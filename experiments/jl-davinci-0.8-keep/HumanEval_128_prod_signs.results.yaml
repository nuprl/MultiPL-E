name: HumanEval_128_prod_signs
language: jl
results:
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    # YOUR CODE HERE\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpus3bizg8.jl:20\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: nothing == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpus3bizg8.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpus3bizg8.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpus3bizg8.jl:21\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ nothing == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpus3bizg8.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpus3bizg8.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpus3bizg8.jl:22\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: nothing == -10\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpus3bizg8.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpus3bizg8.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpus3bizg8.jl:24\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: nothing == 20\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpus3bizg8.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpus3bizg8.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpus3bizg8.jl:25\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: nothing == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/juli"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpus3bizg8.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    arr = [Int(sign(x))\
    \ for x in arr]\n    prod = prod(abs.(arr))\n    if prod == 0 return None end\n\
    \    return prod * prod(arr)\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpn0r7n42q.jl:23\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  UndefVarError:\
    \ prod not defined\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n\
    \     @ Main /tmp/tmpn0r7n42q.jl:14\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpn0r7n42q.jl:23 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpn0r7n42q.jl:22\\ntest set:\
    \ Error During Test at /tmp/tmpn0r7n42q.jl:24\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  UndefVarError: prod not defined\\n  Stacktrace:\\\
    n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpn0r7n42q.jl:14\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpn0r7n42q.jl:24 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpn0r7n42q.jl:22\\ntest set:\
    \ Error During Test at /tmp/tmpn0r7n42q.jl:25\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  UndefVarError: prod not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpn0r7n42q.jl:14\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpn0r7n42q.jl:25 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpn0r7n42q.jl:22\\ntest set:\
    \ Error During Test at /tmp/tmpn0r7n42q.jl:26\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == nothing\\n  UndefVarError: prod not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/t"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    sign_prod = product(abs.(arr))\n    magnitude_sum\
    \ = sum(abs.(arr))\n    return sign_prod * magnitude_sum\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp9ea04b94.jl:25\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  UndefVarError:\
    \ product not defined\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp9ea04b94.jl:16\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp9ea04b94.jl:25 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp9ea04b94.jl:24\\ntest set:\
    \ Error During Test at /tmp/tmp9ea04b94.jl:26\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  UndefVarError: product not defined\\n  Stacktrace:\\\
    n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmp9ea04b94.jl:16\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp9ea04b94.jl:26 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp9ea04b94.jl:24\\ntest set:\
    \ Error During Test at /tmp/tmp9ea04b94.jl:27\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  UndefVarError: product not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmp9ea04b94.jl:16\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp9ea04b94.jl:27 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp9ea04b94.jl:24\\ntest set:\
    \ Error During Test at /tmp/tmp9ea04b94.jl:29\\n  Test threw exception\\n  Expression:\
    \ candidate([2, 4, 1, 2, -1, -1, 9]) == 20\\n  UndefVarError: product not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     "
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    p = 1\n    s = 0\n    for x in arr\n\
    \        if x < 0\n            p *= -1\n        elseif x > 0\n            s +=\
    \ x\n        end\n    end\n    return p * s\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpg1_ypzin.jl:32\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: -5 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg1_ypzin.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg1_ypzin.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpg1_ypzin.jl:33\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg1_ypzin.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg1_ypzin.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpg1_ypzin.jl:34\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: -9 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpg1_ypzin.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg1_ypzin.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpg1_ypzin.jl:36\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: 18 == 20\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg1_ypzin.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg1_ypzin.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpg1_ypzin.jl:37\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: 2 == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg1_ypzin.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    sum = 0\n    product\
    \ = 1\n    for i in arr\n        if i != 0\n            sum += abs(i)\n      \
    \      product *= sign(i)\n        end\n    end\n    return sum * product\nend\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeur_u9x3.jl:29\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeur_u9x3.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeur_u9x3.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpeur_u9x3.jl:31\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeur_u9x3.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeur_u9x3.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpeur_u9x3.jl:35\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeur_u9x3.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeur_u9x3.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    5     3      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeur_u9x3.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    prod = 1\n    sum_mag = 0\n    for i in\
    \ arr\n        if i == 0\n            continue\n        end\n        prod *= sign(i)\n\
    \        sum_mag += abs(i)\n    end\n    return prod * sum_mag\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxurw37r2.jl:33\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxurw37r2.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxurw37r2.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpxurw37r2.jl:39\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxurw37r2.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxurw37r2.jl:31\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxurw37r2.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    r = 1\n    for i = 1:length(arr)\n \
    \       if arr[i] > 0\n            r *= 1\n        elseif arr[i] < 0\n       \
    \     r *= -1\n        else\n            r *= 0\n        end\n    end\n    return\
    \ prod(abs.(arr)) * r\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpficz079s.jl:33\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: -16 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpficz079s.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpficz079s.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpficz079s.jl:35\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: -6 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpficz079s.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpficz079s.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpficz079s.jl:37\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: 144 == 20\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpficz079s.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpficz079s.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpficz079s.jl:38\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: 1 == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpficz079s.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpficz079s.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpficz079s.jl:39\n  Expression: candidate([-1, 1, 1, 1]) ==\
    \ -4\n   Evaluated: -1 == -4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/T"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpficz079s.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    sum_mag, prod_sign\
    \ = 0, 1\n    if isempty(arr)\n        return\n    end\n    for elt in arr\n \
    \       sum_mag += abs(elt)\n        if elt > 0\n            prod_sign *= 1\n\
    \        elseif elt < 0\n            prod_sign *= -1\n        else\n         \
    \   prod_sign *= 0\n        end\n    end\n    return sum_mag * prod_sign\nend\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return\n    end\n    prod = 1\n    for i in arr\n        if i > 0\n \
    \           prod *= 1\n        elseif i < 0\n            prod *= -1\n        else\n\
    \            prod *= 0\n        end\n    end\n    sum = 0\n    for i in arr\n\
    \        sum += abs(i)\n    end\n    sum * prod\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    empty_arr = typeof(arr)\
    \ == Vector{Nothing}\n    if empty_arr\n        return nothing\n    end\n    sum_abs_signs\
    \ = sum(abs.(arr))\n    prod_signs = prod(sign.(arr))\n    sum_abs_signs * prod_signs\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpe5rxtjob.jl:29\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpe5rxtjob.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpe5rxtjob.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe5rxtjob.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    @assert length(arr)\
    \ >= 0\n    if length(arr) == 0\n        return nothing\n    end\n    prod = 1\n\
    \    sum = 0\n    for i in arr\n        if i > 0\n            prod *= 1\n    \
    \    elseif i < 0\n            prod *= -1\n        else\n            prod *= 0\n\
    \        end\n        sum += abs(i)\n    end\n    return prod * sum\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    # your code goes\
    \ here\nend\n \nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfi1lg6k0.jl:21\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: nothing == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfi1lg6k0.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfi1lg6k0.jl:20\ntest set: Test\
    \ Failed at /tmp/tmpfi1lg6k0.jl:22\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ nothing == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfi1lg6k0.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfi1lg6k0.jl:20\ntest set: Test\
    \ Failed at /tmp/tmpfi1lg6k0.jl:23\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: nothing == -10\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfi1lg6k0.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfi1lg6k0.jl:20\ntest set: Test\
    \ Failed at /tmp/tmpfi1lg6k0.jl:25\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: nothing == 20\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfi1lg6k0.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfi1lg6k0.jl:20\ntest set: Test\
    \ Failed at /tmp/tmpfi1lg6k0.jl:26\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: nothing == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/juli"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfi1lg6k0.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    res = sum(abs.(arr))\
    \ * prod(sign.(arr))\n    if res == -0.0 \n        res = 0\n    end\n    return\
    \ res\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnfm5u0g5.jl:27\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnfm5u0g5.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnfm5u0g5.jl:23\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnfm5u0g5.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    sum_of_magnitudes,\
    \ product_of_signs = 0, 1\n    for number in arr\n        sum_of_magnitudes +=\
    \ abs(number)\n        if number > 0\n            product_of_signs *= 1\n    \
    \    elseif number < 0\n            product_of_signs *= -1\n        else\n   \
    \         product_of_signs *= 0\n        end\n    end\n    if sum_of_magnitudes\
    \ > 0\n        return sum_of_magnitudes * product_of_signs\n    else\n       \
    \ return nothing\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    sum_magnitudes = sum(abs.(arr))\n    sum_signs\
    \ = sum(sign.(arr))\n    return sum_magnitudes * sum_signs\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2tocji1q.jl:25\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: 18 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2tocji1q.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2tocji1q.jl:24\ntest set: Test\
    \ Failed at /tmp/tmp2tocji1q.jl:26\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2tocji1q.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2tocji1q.jl:24\ntest set: Test\
    \ Failed at /tmp/tmp2tocji1q.jl:27\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: 50 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2tocji1q.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2tocji1q.jl:24\ntest set: Test\
    \ Failed at /tmp/tmp2tocji1q.jl:29\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: 60 == 20\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2tocji1q.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2tocji1q.jl:24\ntest set: Test\
    \ Failed at /tmp/tmp2tocji1q.jl:30\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2tocji1q.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    n = length(arr)\n\
    \    if n == 0\n        return nothing\n    end\n    signs = [arr[i] > 0 ? 1 :\
    \ (arr[i] < 0 ? -1 : 0) for i in 1:n]\n    return sum(abs.(arr)) * prod(signs)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    \n    # return None\
    \ for empty arr\n    if isempty(arr)\n        return nothing\n    end\n    \n\
    \    # If a negative number is in the array, multiply product by -1\n    product\
    \ = 1\n    for n in arr\n        if n < 0\n            product *= -1\n       \
    \ end\n    end\n    \n    return product * sum(abs.(arr))\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpj1yzgueo.jl:35\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj1yzgueo.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj1yzgueo.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpj1yzgueo.jl:41\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj1yzgueo.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj1yzgueo.jl:33\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj1yzgueo.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    return product(sign.(arr)) * sum(abs.(arr))\n\
    end\n \nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpns3dky6s.jl:24\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  UndefVarError:\
    \ product not defined\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpns3dky6s.jl:16\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpns3dky6s.jl:24 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpns3dky6s.jl:23\\ntest set:\
    \ Error During Test at /tmp/tmpns3dky6s.jl:25\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  UndefVarError: product not defined\\n  Stacktrace:\\\
    n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpns3dky6s.jl:16\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpns3dky6s.jl:25 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpns3dky6s.jl:23\\ntest set:\
    \ Error During Test at /tmp/tmpns3dky6s.jl:26\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  UndefVarError: product not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpns3dky6s.jl:16\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpns3dky6s.jl:26 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpns3dky6s.jl:23\\ntest set:\
    \ Error During Test at /tmp/tmpns3dky6s.jl:28\\n  Test threw exception\\n  Expression:\
    \ candidate([2, 4, 1, 2, -1, -1, 9]) == 20\\n  UndefVarError: product not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     "
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    mags = [abs(x) for x in arr]\n    signs\
    \ = [sign(x) for x in arr]\n    return sum(mags) * prod(signs)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return\n    end\n    acc = 1\n    for i in arr\n        acc *= i <=>\
    \ 0\n    end\n    sum(abs.(arr)) * acc\nend\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \">\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr1h4cz_q.jl:18\nin expression starting at\
    \ /tmp/tmpr1h4cz_q.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    len = length(arr)\n\
    \    if len == 0\n        return nothing\n    end\n    sum = 0\n    prod = 1\n\
    \    for elem in arr\n        prod *= sign(elem)\n        sum += abs(elem)\n \
    \   end\n    return sum * prod\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if arr == []\n \
    \       return nothing\n    end\n    s::Int64 = 1\n    for x in arr\n        s\
    \ *= sign(x)\n    end\n    for x in arr\n        s *= abs(x)\n    end\n    return\
    \ s\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3lqryyyb.jl:30\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: -16 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3lqryyyb.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3lqryyyb.jl:29\ntest set: Test\
    \ Failed at /tmp/tmp3lqryyyb.jl:32\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: -6 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp3lqryyyb.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3lqryyyb.jl:29\ntest set: Test\
    \ Failed at /tmp/tmp3lqryyyb.jl:34\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: 144 == 20\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp3lqryyyb.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3lqryyyb.jl:29\ntest set: Test\
    \ Failed at /tmp/tmp3lqryyyb.jl:35\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: 1 == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3lqryyyb.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3lqryyyb.jl:29\ntest set: Test\
    \ Failed at /tmp/tmp3lqryyyb.jl:36\n  Expression: candidate([-1, 1, 1, 1]) ==\
    \ -4\n   Evaluated: -1 == -4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/T"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3lqryyyb.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    signs = [sgn(x)\
    \ for x in arr]\n    return prod(signs) * sum(abs.(arr))\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpyvr13j7f.jl:21\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  UndefVarError:\
    \ sgn not defined\\n  Stacktrace:\\n   [1] (::var\"#1#2\")(x::Int64)\\n     @\
    \ Main ./none:0\\n   [2] iterate\\n     @ ./generator.jl:47 [inlined]\\n   [3]\
    \ collect(itr::Base.Generator{Vector{Int64}, var\"#1#2\"})\\n     @ Base ./array.jl:724\\\
    n   [4] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpyvr13j7f.jl:13\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [6] macro expansion\\n     @ /tmp/tmpyvr13j7f.jl:21 [inlined]\\\
    n   [7] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [8] top-level scope\\n     @ /tmp/tmpyvr13j7f.jl:20\\ntest set:\
    \ Error During Test at /tmp/tmpyvr13j7f.jl:22\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  UndefVarError: sgn not defined\\n  Stacktrace:\\\
    n   [1] (::var\"#1#2\")(x::Int64)\\n     @ Main ./none:0\\n   [2] iterate\\n \
    \    @ ./generator.jl:47 [inlined]\\n   [3] collect(itr::Base.Generator{Vector{Int64},\
    \ var\"#1#2\"})\\n     @ Base ./array.jl:724\\n   [4] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpyvr13j7f.jl:13\\n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [6] macro expansion\\n     @ /tmp/tmpyvr13j7f.jl:22 [inlined]\\\
    n   [7] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [8] top-level scope\\n     @ /tmp/tmpyvr13j7f.jl:20\\ntest set:\
    \ Error During Test at /tmp/tmpyvr13j7f.jl:23\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  UndefVarError: sgn not defined\\\
    n  Stacktrace:\\n   [1] (::var\"#1#2\")(x::Int64)\\n     @ Main ./none:0\\n  \
    \ [2] iterate\\n     @ ./generator.jl:47 [inlined]\\n   [3] collect(itr::Base.Generator{Vector{Int64},\
    \ var\"#1#2\"})\\n     @ Base ./array.jl:724\\n   [4] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpyvr13j7f.jl:13\\n   ["
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    len = length(arr)\n\
    \    if len > 0\n        prod = 1\n        sum = 0\n        for i in 1:len\n \
    \           prod *= sign(arr[i])\n            sum += abs(arr[i])\n        end\n\
    \        return sum * prod\n    else\n        return nothing\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    sign_arr = sign.(arr)\n\
    \    mag_arr = abs.(arr)\n    if length(arr) == 0\n        return nothing\n  \
    \  else\n        prod_of_signs = prod(sign_arr)\n        sums_of_mags = sum(mag_arr)\n\
    \        return sums_of_mags * prod_of_signs\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    return  none(arr)\
    \ ? nothing : prod(sign(arr)) * sum(abs.(arr))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpt0jwmz_x.jl:20\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  UndefVarError:\
    \ none not defined\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n\
    \     @ Main /tmp/tmpt0jwmz_x.jl:13\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpt0jwmz_x.jl:20 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpt0jwmz_x.jl:19\\ntest set:\
    \ Error During Test at /tmp/tmpt0jwmz_x.jl:21\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  UndefVarError: none not defined\\n  Stacktrace:\\\
    n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpt0jwmz_x.jl:13\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpt0jwmz_x.jl:21 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpt0jwmz_x.jl:19\\ntest set:\
    \ Error During Test at /tmp/tmpt0jwmz_x.jl:22\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  UndefVarError: none not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpt0jwmz_x.jl:13\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpt0jwmz_x.jl:22 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpt0jwmz_x.jl:19\\ntest set:\
    \ Error During Test at /tmp/tmpt0jwmz_x.jl:23\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == nothing\\n  UndefVarError: none not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/t"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    for x in arr\n \
    \       if x < 0\n            @show x\n        end\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "x = -4\ntest set: Test Failed at /tmp/tmp8gpztuuh.jl:24\n  Expression:\
    \ candidate([1, 2, 2, -4]) == -9\n   Evaluated: nothing == -9\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8gpztuuh.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8gpztuuh.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp8gpztuuh.jl:25\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ nothing == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8gpztuuh.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8gpztuuh.jl:23\nx = -1\ntest set:\
    \ Test Failed at /tmp/tmp8gpztuuh.jl:26\n  Expression: candidate([1, 1, 1, 2,\
    \ 3, -1, 1]) == -10\n   Evaluated: nothing == -10\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8gpztuuh.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8gpztuuh.jl:23\nx = -1\nx = -1\n\
    test set: Test Failed at /tmp/tmp8gpztuuh.jl:28\n  Expression: candidate([2, 4,\
    \ 1, 2, -1, -1, 9]) == 20\n   Evaluated: nothing == 20\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8gpztuuh.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8gpztuuh.jl:23\nx = -1\nx = -1\n\
    test set: Test Failed at /tmp/tmp8gpztuuh.jl:29\n  Expression: candidate([-1,\
    \ 1, -1, 1]) == 4\n   Evaluated: nothing == 4\nStacktrace:\n [1] macro expansion\n\
    \ "
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8gpztuuh.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    n = length(arr)\n\
    \    prod_of_signs = 1\n    sum_of_magnitudes = 0\n    if n != 0\n        for\
    \ i in 1:n\n            if arr[i] != 0\n                prod_of_signs *= sign(arr[i])\n\
    \                sum_of_magnitudes += abs(arr[i])\n            end\n        end\n\
    \        prod_of_signs * sum_of_magnitudes\n    else\n        nothing\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppuy7wf3_.jl:34\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppuy7wf3_.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppuy7wf3_.jl:32\ntest set: Test\
    \ Failed at /tmp/tmppuy7wf3_.jl:40\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppuy7wf3_.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppuy7wf3_.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppuy7wf3_.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    sign_prod = 1\n    for x in arr\n      \
    \  if x == 0\n            return 0\n        end\n        sign_prod *= sign(x)\n\
    \    end\n    prod_mag = prod(abs.(arr))\n    prod_mag * sign_prod\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpli452h_h.jl:31\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: -16 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpli452h_h.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpli452h_h.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpli452h_h.jl:33\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: -6 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpli452h_h.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpli452h_h.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpli452h_h.jl:35\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: 144 == 20\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpli452h_h.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpli452h_h.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpli452h_h.jl:36\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: 1 == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpli452h_h.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpli452h_h.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpli452h_h.jl:37\n  Expression: candidate([-1, 1, 1, 1]) ==\
    \ -4\n   Evaluated: -1 == -4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/T"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpli452h_h.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    prod = 1\n    ret_val = 0\n    for num in\
    \ arr\n        if num == 0\n            ret_val += 0\n        elseif num > 0\n\
    \            prod *= 1\n            ret_val += num\n        elseif num < 0\n \
    \           prod *= -1\n            ret_val += abs(num)\n        end\n    end\n\
    \    ret_val * prod\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplang1v8g.jl:37\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplang1v8g.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplang1v8g.jl:35\ntest set: Test\
    \ Failed at /tmp/tmplang1v8g.jl:43\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplang1v8g.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplang1v8g.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplang1v8g.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    prod = 1\n    for x in arr\n        prod\
    \ *= sign(x)\n    end\n    sum = 0\n    for x in arr\n        sum += abs(x)\n\
    \    end\n    return prod * sum\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    n = length(arr)\n\
    \    if n == 0\n        return nothing\n    end\n    if n == 1\n        return\
    \ abs(arr[1])\n    end\n    res = 1\n    for i in 1:n\n        if arr[i] == 0\n\
    \            return 0\n        end\n        if arr[i] < 0\n            res *=\
    \ -1\n        end\n        res *= abs(arr[i])\n    end\n    return res\nend\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpa4d6zvsi.jl:37\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: -16 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa4d6zvsi.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa4d6zvsi.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpa4d6zvsi.jl:39\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: -6 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpa4d6zvsi.jl:39 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa4d6zvsi.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpa4d6zvsi.jl:41\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: 144 == 20\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpa4d6zvsi.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa4d6zvsi.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpa4d6zvsi.jl:42\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: 1 == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa4d6zvsi.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa4d6zvsi.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpa4d6zvsi.jl:43\n  Expression: candidate([-1, 1, 1, 1]) ==\
    \ -4\n   Evaluated: -1 == -4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/T"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa4d6zvsi.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    abs_sum = sum(abs.(arr))\n    zero_count\
    \ = count(x -> x == 0, arr)\n    if zero_count > 0 \n        return zero_count\
    \ * abs_sum\n    end\n    return reduce(*, map(x -> x < 0 ? -1 : 1, arr)) * abs_sum\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjniwpsiz.jl:29\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjniwpsiz.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjniwpsiz.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpjniwpsiz.jl:35\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: 3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjniwpsiz.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjniwpsiz.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjniwpsiz.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    pos = 0\n    neg\
    \ = 0\n    for x in arr\n        if x > 0\n            pos += x\n        elseif\
    \ x < 0\n            neg += x\n        end\n    end\n    if pos == 0 && neg ==\
    \ 0\n        return 0\n    elseif neg == 0\n        return pos\n    elseif pos\
    \ == 0\n        return neg\n    else\n        return pos * neg\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdxgu46s2.jl:37\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: -20 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdxgu46s2.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdxgu46s2.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpdxgu46s2.jl:38\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdxgu46s2.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdxgu46s2.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpdxgu46s2.jl:39\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: -9 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdxgu46s2.jl:39 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdxgu46s2.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpdxgu46s2.jl:40\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdxgu46s2.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdxgu46s2.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpdxgu46s2.jl:41\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: -36 == 20\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdxgu46s2.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    signs = 1\n    for i in arr\n      \
    \  if i == 0\n            return 0\n        elseif i < 0\n            signs *=\
    \ -1\n        end\n    end\n    return sum(abs.(arr)) * signs\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    prod = 1\n    for i in arr\n       \
    \ if i != 0\n            prod *= sign(i)\n        end\n    end\n    return sum(abs.(arr))\
    \ * prod\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0dgqx2oi.jl:30\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0dgqx2oi.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0dgqx2oi.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp0dgqx2oi.jl:36\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0dgqx2oi.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0dgqx2oi.jl:28\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0dgqx2oi.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    \n    #your code\
    \ goes here\n    if length(arr) == 0\n        return nothing\n    end\n    prod_signs\
    \ = 1\n    for sign in arr\n        if sign == 0\n            prod_signs = 0\n\
    \            break\n        elseif sign > 0\n            prod_signs *= 1\n   \
    \     else\n            prod_signs *= -1\n        end\n    end\n    prod_signs\
    \ * sum(abs.(arr))\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    sum = 0\n    prod\
    \ = 1\n    if length(arr) > 0\n        for x in arr\n            sum += abs(x)\n\
    \            prod *= sign(x)\n        end\n        return sum * prod\n    else\n\
    \        return nothing\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    return prod(sign.(arr)) * sum(abs.(arr))\n\
    end\nprod_signs([1, 2, 2, -4]) == -9\nprod_signs([0, 1]) == 0\nprod_signs([])\
    \ == nothing\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: None
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    signs = [sign(el) for el in arr]\n    prod\
    \ = prod(signs)\n    sum = sum(abs.(arr))\n    sum * prod\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpq51l03dz.jl:26\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  UndefVarError:\
    \ prod not defined\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n\
    \     @ Main /tmp/tmpq51l03dz.jl:17\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpq51l03dz.jl:26 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpq51l03dz.jl:25\\ntest set:\
    \ Error During Test at /tmp/tmpq51l03dz.jl:27\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  UndefVarError: prod not defined\\n  Stacktrace:\\\
    n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpq51l03dz.jl:17\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpq51l03dz.jl:27 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpq51l03dz.jl:25\\ntest set:\
    \ Error During Test at /tmp/tmpq51l03dz.jl:28\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  UndefVarError: prod not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpq51l03dz.jl:17\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpq51l03dz.jl:28 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpq51l03dz.jl:25\\ntest set:\
    \ Error During Test at /tmp/tmpq51l03dz.jl:30\\n  Test threw exception\\n  Expression:\
    \ candidate([2, 4, 1, 2, -1, -1, 9]) == 20\\n  UndefVarError: prod not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    prod = 1\n    sum_ = 0\n    for i = 1:length(arr)\n\
    \        prod *= sign(arr[i])\n        sum_ += abs(arr[i])\n    end\n    return\
    \ prod * sum_\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    n = size(arr)[1]\n\
    \    if n == 0\n        return nothing\n    end\n    total = 0\n    prod = 1\n\
    \    for i in 1:n\n        if arr[i] > 0\n            total += arr[i]\n      \
    \      prod *= 1\n        elseif arr[i] < 0\n            total += -arr[i]\n  \
    \          prod *= -1\n        end\n    end\n    return total * prod\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpf9ikwi0x.jl:36\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf9ikwi0x.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf9ikwi0x.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpf9ikwi0x.jl:42\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf9ikwi0x.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf9ikwi0x.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf9ikwi0x.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n  prod = 1\n  sum =\
    \ 0\n  for i in arr\n    prod *= (i>0 ? 1 : (i<0 ? -1 : 0))\n    sum += (i>0 ?\
    \ i : (i<0 ? -i : 0))\n  end\n  return prod*sum\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2p4n6h80.jl:29\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2p4n6h80.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2p4n6h80.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2p4n6h80.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    s = Array{Int64}(undef,\
    \ 0)\n    for i in arr\n        if i > 0\n            push!(s, 1)\n        elseif\
    \ i < 0\n            push!(s, -1)\n        else\n            push!(s, 0)\n   \
    \     end\n    end\n    if length(s) == 0\n        return nothing\n    else\n\
    \        return sum(abs.(arr)) * prod(s)\n    end\nend\nprod_signs([1, 2, 2, -4])\
    \ == -9\nprod_signs([0, 1]) == 0\nprod_signs([]) == nothing\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: None
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    all_signs = prod(sign.(arr))\n    magnitudes\
    \ = map(abs, arr)\n    return sum(magnitudes) * all_signs\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    a = []\n    for num in arr\n        if num\
    \ > 0\n            push!(a, 1)\n        elseif num < 0\n            push!(a, -1)\n\
    \        else\n            push!(a, 0)\n        end\n    end\n    s = prod(a)\n\
    \    n = []\n    for num in arr\n        if num > 0\n            push!(n, num)\n\
    \        elseif num < 0\n            push!(n, -num)\n        else\n          \
    \  push!(n, 0)\n        end\n    end\n    return sum(n) * s\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    magnitude = 0.0\n    magnitude = map(abs,arr)\
    \ |> sum\n    signs = 0.0\n    signs = map(sign,arr) |> prod\n    return(magnitude*signs)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return\n    end\n    return prod(abs.(arr)) * prod(sign.(arr))\n\
    end\n@testset \"Example Tests\" begin\n    @test prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    @test prod_signs([0, 1]) == 0\n    @test prod_signs([]) == nothing\n\
    end\n \nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @testset not defined\nin expression starting\
    \ at /tmp/tmp0_wztm8l.jl:18\nin expression starting at /tmp/tmp0_wztm8l.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\
    \ return nothing end\n    return prod(sign.(arr)) * sum(abs.(arr))\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    prod = 1\n    for i in arr\n       \
    \ if i == 0\n            continue\n        end\n        prod *= sign(i)\n    end\n\
    \    return prod * sum(abs.(arr))\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbpwy57gb.jl:31\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbpwy57gb.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbpwy57gb.jl:29\ntest set: Test\
    \ Failed at /tmp/tmpbpwy57gb.jl:37\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbpwy57gb.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbpwy57gb.jl:29\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbpwy57gb.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    mult = -1\n    s = 0\n    for a in arr\n\
    \        if a != 0\n            mult *= sign(a)\n            s += abs(a)\n   \
    \     end\n    end\n    return s * mult\nend\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpr6wzdimc.jl:31\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: 9 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr6wzdimc.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr6wzdimc.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpr6wzdimc.jl:32\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ -1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr6wzdimc.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr6wzdimc.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpr6wzdimc.jl:33\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: 10 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpr6wzdimc.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr6wzdimc.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpr6wzdimc.jl:35\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: -20 == 20\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpr6wzdimc.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr6wzdimc.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpr6wzdimc.jl:36\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: -4 == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Te"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr6wzdimc.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    size = length(arr)\n\
    \    if size == 0\n        return \n    end\n    s = 0\n    signs = 1\n    for\
    \ i in 1:size\n        if arr[i] == 0\n            continue\n        end\n   \
    \     s += abs(arr[i])\n        if arr[i] > 0\n            signs *= 1\n      \
    \  else\n            signs *= -1\n        end\n    end\n    return s * signs\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpz2z2njkv.jl:38\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz2z2njkv.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz2z2njkv.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpz2z2njkv.jl:44\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz2z2njkv.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz2z2njkv.jl:36\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz2z2njkv.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    prod = 1\n    sum = 0\n    for i in\
    \ arr\n        if i == 0\n            prod *= 0\n        elseif i > 0\n      \
    \      prod *= 1\n        else\n            prod *= -1\n        end\n        sum\
    \ += abs(i)\n    end\n    return prod * sum\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    return prod(sign.(arr)) * sum(abs.(arr))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return\n    end\n    return sum(abs.(arr)) * prod(sign.(arr))\nend\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    prod = prod(sign.(arr))\n    sum = sum(abs.(arr))\n\
    \    return prod * sum\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpgnj7d9qc.jl:25\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  UndefVarError:\
    \ prod not defined\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n\
    \     @ Main /tmp/tmpgnj7d9qc.jl:16\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpgnj7d9qc.jl:25 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpgnj7d9qc.jl:24\\ntest set:\
    \ Error During Test at /tmp/tmpgnj7d9qc.jl:26\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  UndefVarError: prod not defined\\n  Stacktrace:\\\
    n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpgnj7d9qc.jl:16\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpgnj7d9qc.jl:26 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpgnj7d9qc.jl:24\\ntest set:\
    \ Error During Test at /tmp/tmpgnj7d9qc.jl:27\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  UndefVarError: prod not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpgnj7d9qc.jl:16\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpgnj7d9qc.jl:27 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpgnj7d9qc.jl:24\\ntest set:\
    \ Error During Test at /tmp/tmpgnj7d9qc.jl:29\\n  Test threw exception\\n  Expression:\
    \ candidate([2, 4, 1, 2, -1, -1, 9]) == 20\\n  UndefVarError: prod not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    signs = [sign(x)\
    \ for x in arr]\n    sign_prod = prod(signs)\n    sum_magn = sum([abs(x) for x\
    \ in arr])\n    return sign_prod * sum_magn\nend\n \nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpoh5e3q_l.jl:27\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpoh5e3q_l.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpoh5e3q_l.jl:23\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoh5e3q_l.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    for i in arr\n \
    \       if i == 0\n            return 0\n        end\n    end\n    v = [abs(arr[i])\
    \ for i in 1:length(arr)]\n    if length(arr) == 0\n        return\n    elseif\
    \ isempty(arr)\n        return\n    elseif length(arr) == 1\n        return abs(arr[1])\n\
    \    else\n        v_sum = sum(v)\n        return v_sum * prod(sign.(arr))\n \
    \   end\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\
    \ return nothing end\n    prod_signs = 1\n    sum_magnitudes = 0\n    for i in\
    \ arr\n        if i != 0\n            prod_signs *= sign(i)\n            sum_magnitudes\
    \ += abs(i)\n        end\n    end\n    return prod_signs * sum_magnitudes\nend\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeeup158o.jl:30\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeeup158o.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeeup158o.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpeeup158o.jl:36\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeeup158o.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeeup158o.jl:28\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeeup158o.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) >\
    \ 0\n        prod_signs = prod(sign.(arr))\n        signs_mag = sum(abs.(arr))\n\
    \        signs_mag * prod_signs\n    else\n        return\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    @assert all(in.(arr, [-1, 0, 1]))\n    abs_prod\
    \ = prod(abs.(arr))\n    signs_prod = prod(arr)\n    abs_prod * signs_prod\nend\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpi9drawgp.jl:26\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  DimensionMismatch(\"\
    arrays could not be broadcast to a common size; got a dimension with lengths 4\
    \ and 3\")\\n  Stacktrace:\\n    [1] _bcs1\\n      @ ./broadcast.jl:516 [inlined]\\\
    n    [2] _bcs\\n      @ ./broadcast.jl:510 [inlined]\\n    [3] broadcast_shape\\\
    n      @ ./broadcast.jl:504 [inlined]\\n    [4] combine_axes\\n      @ ./broadcast.jl:499\
    \ [inlined]\\n    [5] instantiate\\n      @ ./broadcast.jl:281 [inlined]\\n  \
    \  [6] materialize\\n      @ ./broadcast.jl:860 [inlined]\\n    [7] prod_signs(arr::Vector{Int64})\\\
    n      @ Main /tmp/tmpi9drawgp.jl:16\\n    [8] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n    [9] macro expansion\\n      @ /tmp/tmpi9drawgp.jl:26 [inlined]\\\
    n   [10] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [11] top-level scope\\n      @ /tmp/tmpi9drawgp.jl:25\\ntest\
    \ set: Error During Test at /tmp/tmpi9drawgp.jl:27\\n  Test threw exception\\\
    n  Expression: candidate([0, 1]) == 0\\n  DimensionMismatch(\"arrays could not\
    \ be broadcast to a common size; got a dimension with lengths 2 and 3\")\\n  Stacktrace:\\\
    n    [1] _bcs1\\n      @ ./broadcast.jl:516 [inlined]\\n    [2] _bcs\\n      @\
    \ ./broadcast.jl:510 [inlined]\\n    [3] broadcast_shape\\n      @ ./broadcast.jl:504\
    \ [inlined]\\n    [4] combine_axes\\n      @ ./broadcast.jl:499 [inlined]\\n \
    \   [5] instantiate\\n      @ ./broadcast.jl:281 [inlined]\\n    [6] materialize\\\
    n      @ ./broadcast.jl:860 [inlined]\\n    [7] prod_signs(arr::Vector{Int64})\\\
    n      @ Main /tmp/tmpi9drawgp.jl:16\\n    [8] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n    [9] macro expansion\\n      @ /tmp/tmpi9drawgp.jl:27 [inlined]\\\
    n   [10] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [11] top-level scope\\n      @ /tmp/tmpi9drawgp"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    n = length(arr)\n\
    \    if n == 0\n        return nothing\n    end\n    result = 0\n    for i in\
    \ 1:n\n        result += abs(arr[i]) * sign(arr[i])\n    end\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgli08qjy.jl:28\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: 1 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgli08qjy.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgli08qjy.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpgli08qjy.jl:29\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgli08qjy.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgli08qjy.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpgli08qjy.jl:30\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: 8 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpgli08qjy.jl:30 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgli08qjy.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpgli08qjy.jl:32\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: 16 == 20\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgli08qjy.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgli08qjy.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpgli08qjy.jl:33\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.j"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgli08qjy.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    res = 1\n    for\
    \ x in arr\n        res *= Int64(sign(x))\n    end\n    return res == 0 ? res\
    \ : res * sum(abs.(arr))\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpky7r0_k0.jl:27\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpky7r0_k0.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpky7r0_k0.jl:23\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpky7r0_k0.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    n = length(arr)\n\
    \    pos = 0\n    neg = 0\n    zer = 0\n    sum_el = 0\n    for i = 1:n\n    \
    \    sum_el += abs(arr[i])\n        if arr[i] > 0\n            pos += 1\n    \
    \    elseif arr[i] < 0\n            neg += 1\n        else\n            zer +=\
    \ 1\n        end\n    end\n    if zer > 0\n        return nothing\n    end\n \
    \   return (pos - neg) * sum_el\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpo0466pdz.jl:38\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: 18 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo0466pdz.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo0466pdz.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpo0466pdz.jl:39\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ nothing == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo0466pdz.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo0466pdz.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpo0466pdz.jl:40\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: 50 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpo0466pdz.jl:40 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo0466pdz.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpo0466pdz.jl:41\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo0466pdz.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo0466pdz.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpo0466pdz.jl:42\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: 60 == 20\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdl"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo0466pdz.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    sgns = [sign(i)\
    \ for i in arr]\n    mgns = [abs(i) for i in arr]\n    return prod(sgns) * sum(mgns)\n\
    end\n@testset \"Example Tests\" begin\n    @test prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    @test prod_signs([0, 1]) == 0\n    @test prod_signs([]) == nothing\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @testset not defined\nin expression starting\
    \ at /tmp/tmpkb72_ylq.jl:17\nin expression starting at /tmp/tmpkb72_ylq.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    prod = 1\n    sum\
    \ = 0\n    for i in arr\n        prod *= sign(i)\n        sum += abs(i)\n    end\n\
    \    prod * sum\nend\n    \nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7jie3rle.jl:30\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7jie3rle.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7jie3rle.jl:26\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7jie3rle.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    return sign(prod(arr)) * sum(abs.(arr))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return\n    end\n    signs = filter(x -> x != 0, map(x -> copysign(1,\
    \ x), arr))\n    return prod(signs) * sum(abs.(arr))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp75ed24jj.jl:25\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp75ed24jj.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp75ed24jj.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp75ed24jj.jl:31\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp75ed24jj.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp75ed24jj.jl:23\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp75ed24jj.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return\n    end\n    s = 1\n    m = 0\n    for i in arr\n        if i\
    \ == 0\n            continue\n        end\n        s *= sign(i)\n        m +=\
    \ abs(i)\n    end\n    return s * m\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpt1tltqgd.jl:33\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpt1tltqgd.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt1tltqgd.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpt1tltqgd.jl:39\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpt1tltqgd.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt1tltqgd.jl:31\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt1tltqgd.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    prod = 1\n    for x in arr\n        if x\
    \ < 0\n            prod *= -1\n        elseif x > 0\n            prod *= 1\n \
    \       else\n            prod *= 0\n        end\n    end\n    return prod * sum(abs.(arr))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    signprod = 1\n    magprod = 0\n    for i\
    \ in arr\n        magprod += abs(i)\n        if i == 0\n            signprod *=\
    \ 0\n        elseif i < 0\n            signprod *= -1\n        end\n    end\n\
    \    signprod * magprod\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    signs = [x == 0 ? 0 : x < 0 ? -1 : 1 for\
    \ x in arr]\n    return prod(signs) * sum(abs.(arr))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    return prod(sign.(arr))\
    \ * sum(abs.(arr))\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdwgdyhfz.jl:23\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdwgdyhfz.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdwgdyhfz.jl:19\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdwgdyhfz.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    prod_signs = 1\n    sum_magn = 0\n \
    \   for n in arr\n        if n < 0\n            prod_signs *= -1\n        elseif\
    \ n == 0\n            prod_signs *= 0\n        end\n        sum_magn += abs(n)\n\
    \    end\n    return prod_signs * sum_magn\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    # product of signs:\n    signs = [if\
    \ x > 0; 1; elseif x < 0; -1; else; 0; end for x in arr]\n    # sign_prod = reduce(*,\
    \ signs)\n    sign_prod = prod(signs)\n    # sum of magnitudes:\n    abs_arr =\
    \ abs.(arr)\n    # abs_sum = reduce(+, abs_arr)\n    abs_sum = sum(abs_arr)\n\
    \    return abs_sum * sign_prod\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    signs = Array{Int64}(length(arr))\n\
    \    for i in 1:length(arr)\n        if arr[i] == 0\n            signs[i] = 0\n\
    \        elseif arr[i] > 0\n            signs[i] = 1\n        else\n         \
    \   signs[i] = -1\n        end\n    end\n    prod = prod(signs)\n    if length(arr)\
    \ == 0\n        return nothing\n    else\n        return abs.(arr) * prod\n  \
    \  end\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpfx7cu1b9.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  MethodError: no\
    \ method matching (Array{Int64})(::Int64)\\n  Closest candidates are:\\n    (Array{T})(!Matched::LinearAlgebra.AbstractQ)\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/qr.jl:563\\\
    n    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Tuple{Int64,\
    \ Int64}) where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:494\\\
    n    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Integer, !Matched::Integer)\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:495\\\
    n    ...\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main\
    \ /tmp/tmpfx7cu1b9.jl:13\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpfx7cu1b9.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpfx7cu1b9.jl:34\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    # Your code here.\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmyz72ha3.jl:20\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: nothing == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmyz72ha3.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmyz72ha3.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpmyz72ha3.jl:21\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ nothing == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmyz72ha3.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmyz72ha3.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpmyz72ha3.jl:22\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: nothing == -10\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmyz72ha3.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmyz72ha3.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpmyz72ha3.jl:24\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: nothing == 20\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmyz72ha3.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmyz72ha3.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpmyz72ha3.jl:25\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: nothing == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/juli"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmyz72ha3.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    \n    function multiply(arr::Vector{Int64})::Int64\n\
    \        value = 1\n        for i in arr\n            value *= i\n        end\n\
    \        return value\n    end\n    \n    total = 0\n    if length(arr) > 0\n\
    \        for i in arr\n            if i > 0\n                total += i\n    \
    \        elseif i < 0\n                total -= i\n            end\n        end\n\
    \        return total * multiply(sign.(arr))\n    else\n        return nothing\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    signs = map(x -> ifelse(x > 0, 1, ifelse(x\
    \ < 0, -1, 0)), arr)\n    product(signs) * sum(abs.(arr))\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpn81k08h0.jl:24\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  UndefVarError:\
    \ product not defined\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpn81k08h0.jl:17\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpn81k08h0.jl:24 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpn81k08h0.jl:23\\ntest set:\
    \ Error During Test at /tmp/tmpn81k08h0.jl:25\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  UndefVarError: product not defined\\n  Stacktrace:\\\
    n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpn81k08h0.jl:17\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpn81k08h0.jl:25 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpn81k08h0.jl:23\\ntest set:\
    \ Error During Test at /tmp/tmpn81k08h0.jl:26\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  UndefVarError: product not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpn81k08h0.jl:17\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpn81k08h0.jl:26 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpn81k08h0.jl:23\\ntest set:\
    \ Error During Test at /tmp/tmpn81k08h0.jl:28\\n  Test threw exception\\n  Expression:\
    \ candidate([2, 4, 1, 2, -1, -1, 9]) == 20\\n  UndefVarError: product not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     "
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    return prod(sign.(arr))\
    \ * sum(abs.(arr))\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpv8jqw7if.jl:23\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv8jqw7if.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv8jqw7if.jl:19\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv8jqw7if.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    # your code here\n\
    end\n@timeit prod_signs\ntest_prod_signs(prod_signs)\n \n \n\"\"\"\n    Given\
    \ an array of numbers and a number c, find the count of\n    triples that have\
    \ indices i, j, k such that i < j < k and\n    arr[i] + arr[j] + arr[k] < c.\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @timeit not defined\nin expression starting\
    \ at /tmp/tmp_h6q4lb3.jl:15\nin expression starting at /tmp/tmp_h6q4lb3.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    # your code goes\
    \ here\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzutkepy5.jl:20\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: nothing == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzutkepy5.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzutkepy5.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpzutkepy5.jl:21\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ nothing == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzutkepy5.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzutkepy5.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpzutkepy5.jl:22\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: nothing == -10\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzutkepy5.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzutkepy5.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpzutkepy5.jl:24\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: nothing == 20\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzutkepy5.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzutkepy5.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpzutkepy5.jl:25\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: nothing == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/juli"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzutkepy5.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    if issubset(arr, ([0]))\n        return\
    \ 0\n    end\n    prod(x -> ifelse(x > 0, 1, ifelse(x < 0, -1, 0)), arr) * sum(abs.(arr))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return\n    end\n    prod = 1\n    sum = 0\n    for i in arr\n  \
    \      if i == 0\n            prod *= 1\n        elseif i > 0\n            prod\
    \ *= 1\n        else\n            prod *= -1\n        end\n        sum += abs(i)\n\
    \    end\n    return sum * prod\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnd3adg0o.jl:36\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnd3adg0o.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnd3adg0o.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpnd3adg0o.jl:42\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnd3adg0o.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnd3adg0o.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnd3adg0o.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    product = 1\n    magnitude = 0\n    for\
    \ i in arr\n        product *= sign(i)\n        magnitude += abs(i)\n    end\n\
    \    return product * magnitude\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    sign_prod = 1\n\
    \    sum_abs = 0\n    for num in arr\n        sign_prod *= sign(num)\n       \
    \ sum_abs += abs(num)\n    end\n    return nothing if isempty(arr)\n    return\
    \ sign_prod * sum_abs\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmpm6w5qq5r.jl:12 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpm6w5qq5r.jl:19\n\
    in expression starting at /tmp/tmpm6w5qq5r.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return\n    end\n    sm = 0\n    prod = 1\n    for n in arr\n       \
    \ sm += abs(n)\n        if n > 0\n            prod *= 1\n        elseif n < 0\n\
    \            prod *= -1\n        else\n            prod *= 0\n        end\n  \
    \  end\n    return sm * prod\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    products = 1\n    for num in arr\n     \
    \   if num > 0\n            products *= 1\n        elseif num < 0\n          \
    \  products *= -1\n        else\n            products *= 0\n        end\n    end\n\
    \    magnitudes = 0\n    for num in arr\n        magnitudes += abs(num)\n    end\n\
    \    return magnitudes * products\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    nums = magnitude.(arr)\n\
    \    signs = sign.(arr)\n    prod = prod(signs)\n    if prod == 1 || prod == -1\n\
    \        return sum(nums) * prod\n    else\n        return nothing\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp8qr28jff.jl:27\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  UndefVarError:\
    \ magnitude not defined\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp8qr28jff.jl:13\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp8qr28jff.jl:27 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp8qr28jff.jl:26\\ntest set:\
    \ Error During Test at /tmp/tmp8qr28jff.jl:28\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  UndefVarError: magnitude not defined\\n  Stacktrace:\\\
    n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmp8qr28jff.jl:13\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp8qr28jff.jl:28 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp8qr28jff.jl:26\\ntest set:\
    \ Error During Test at /tmp/tmp8qr28jff.jl:29\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  UndefVarError: magnitude not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmp8qr28jff.jl:13\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp8qr28jff.jl:29 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp8qr28jff.jl:26\\ntest set:\
    \ Error During Test at /tmp/tmp8qr28jff.jl:30\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == nothing\\n  UndefVarError: magnitude not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    n = length(arr)\n\
    \    if n == 0\n        return nothing\n    end\n    s = 1\n    sum = 0\n    for\
    \ i = 1:n\n        if arr[i] > 0\n            sum += arr[i]\n        elseif arr[i]\
    \ < 0\n            sum += -arr[i]\n            s *= -1\n        end\n    end\n\
    \    return s * sum\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbks55mtp.jl:35\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbks55mtp.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbks55mtp.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpbks55mtp.jl:41\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbks55mtp.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbks55mtp.jl:33\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbks55mtp.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    prod = 1\n    sum = 0\n    for i = 1:length(arr)\n\
    \        if arr[i] > 0\n            prod *= 1\n        elseif arr[i] < 0\n   \
    \         prod *= -1\n        else\n            prod *= 0\n        end\n     \
    \   sum += abs(arr[i])\n    end\n    return sum * prod\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    # Your code goes\
    \ here.\n    sum = 0\n    prod = 1\n    for i in arr\n        sum += abs(i)\n\
    \        prod *= sign(i)\n    end\n    return sum * prod\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphknkr6la.jl:30\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphknkr6la.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphknkr6la.jl:26\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphknkr6la.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    sign_prod = prod(sgn.(arr))\n    return\
    \ sign_prod * sum(abs.(arr))\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpc2_7ixtv.jl:24\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  UndefVarError:\
    \ sgn not defined\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n \
    \    @ Main /tmp/tmpc2_7ixtv.jl:16\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpc2_7ixtv.jl:24 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpc2_7ixtv.jl:23\\ntest set:\
    \ Error During Test at /tmp/tmpc2_7ixtv.jl:25\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  UndefVarError: sgn not defined\\n  Stacktrace:\\\
    n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpc2_7ixtv.jl:16\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpc2_7ixtv.jl:25 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpc2_7ixtv.jl:23\\ntest set:\
    \ Error During Test at /tmp/tmpc2_7ixtv.jl:26\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  UndefVarError: sgn not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpc2_7ixtv.jl:16\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpc2_7ixtv.jl:26 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpc2_7ixtv.jl:23\\ntest set:\
    \ Error During Test at /tmp/tmpc2_7ixtv.jl:28\\n  Test threw exception\\n  Expression:\
    \ candidate([2, 4, 1, 2, -1, -1, 9]) == 20\\n  UndefVarError: sgn not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpc"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    try\n        return\
    \ prod(sign.(arr)) * sum(abs.(arr))\n    catch\n        return nothing\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2rs0vqd0.jl:27\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2rs0vqd0.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2rs0vqd0.jl:23\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2rs0vqd0.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    return prod(sign.(arr)) * sum(abs.(arr))\n\
    end\n@testset \"prod_signs\" begin\n    @test prod_signs([1, 2, 2, -4]) == -9\n\
    \    @test prod_signs([0, 1]) == 0\n    @test prod_signs([]) == nothing\nend\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @testset not defined\nin expression starting\
    \ at /tmp/tmp5yjr8uhz.jl:18\nin expression starting at /tmp/tmp5yjr8uhz.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    s = 1\n    for i in arr\n        s *=\
    \ sign(i)\n    end\n    return s * sum(abs.(arr))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    function prod_signs_rec(i::Int64, prod::Int64)::Int64\n\
    \        if i == length(arr) + 1\n            return prod\n        end\n     \
    \   if arr[i] == 0\n            return prod_signs_rec(i + 1, 0)\n        end\n\
    \        if arr[i] > 0\n            return prod_signs_rec(i + 1, abs(arr[i]) *\
    \ prod)\n        end\n        return prod_signs_rec(i + 1, -1 * abs(arr[i]) *\
    \ prod)\n    end\n    return prod_signs_rec(1, 1)\nend\n \nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpravjo_zj.jl:36\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: -16 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpravjo_zj.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpravjo_zj.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpravjo_zj.jl:38\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: -6 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpravjo_zj.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpravjo_zj.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpravjo_zj.jl:40\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: 144 == 20\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpravjo_zj.jl:40 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpravjo_zj.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpravjo_zj.jl:41\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: 1 == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpravjo_zj.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpravjo_zj.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpravjo_zj.jl:42\n  Expression: candidate([-1, 1, 1, 1]) ==\
    \ -4\n   Evaluated: -1 == -4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/T"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpravjo_zj.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    sum(signs(arr) .*\
    \ abs.(arr))\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp3mfk3toi.jl:20\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  UndefVarError:\
    \ signs not defined\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp3mfk3toi.jl:13\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp3mfk3toi.jl:20 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp3mfk3toi.jl:19\\ntest set:\
    \ Error During Test at /tmp/tmp3mfk3toi.jl:21\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  UndefVarError: signs not defined\\n  Stacktrace:\\\
    n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmp3mfk3toi.jl:13\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp3mfk3toi.jl:21 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp3mfk3toi.jl:19\\ntest set:\
    \ Error During Test at /tmp/tmp3mfk3toi.jl:22\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  UndefVarError: signs not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmp3mfk3toi.jl:13\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp3mfk3toi.jl:22 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp3mfk3toi.jl:19\\ntest set:\
    \ Error During Test at /tmp/tmp3mfk3toi.jl:23\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == nothing\\n  UndefVarError: signs not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /t"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    return None\nend\n\
    \ \nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpajrnnjbp.jl:21\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  UndefVarError:\
    \ None not defined\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n\
    \     @ Main /tmp/tmpajrnnjbp.jl:13\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpajrnnjbp.jl:21 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpajrnnjbp.jl:20\\ntest set:\
    \ Error During Test at /tmp/tmpajrnnjbp.jl:22\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  UndefVarError: None not defined\\n  Stacktrace:\\\
    n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpajrnnjbp.jl:13\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpajrnnjbp.jl:22 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpajrnnjbp.jl:20\\ntest set:\
    \ Error During Test at /tmp/tmpajrnnjbp.jl:23\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  UndefVarError: None not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpajrnnjbp.jl:13\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpajrnnjbp.jl:23 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpajrnnjbp.jl:20\\ntest set:\
    \ Error During Test at /tmp/tmpajrnnjbp.jl:24\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == nothing\\n  UndefVarError: None not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/t"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    return prod(sign.(arr)) * sum(abs.(arr))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    return prod(sign.(arr)) * sum(abs.(arr))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    signs = Float64[]\n    mags = Int64[]\n\
    \    for i = 1:length(arr)\n        if arr[i] == 0\n            push!(signs, 0)\n\
    \        elseif arr[i] > 0\n            push!(signs, 1)\n        elseif arr[i]\
    \ < 0\n            push!(signs, -1)\n        end\n        push!(mags, abs(arr[i]))\n\
    \    end\n    return prod(signs) * sum(mags)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    # ADD CODE HERE\n\
    end\n@testset \"prod_signs\" begin\n    @test prod_signs([1, 2, 2, -4]) == -9\n\
    \    @test prod_signs([0, 1]) == 0\n    @test prod_signs([]) == nothing\nend\n\
    prod_signs([1, 2, 2, -4])\n \n# Input and output\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @testset not defined\nin expression starting\
    \ at /tmp/tmp3cm5ndo1.jl:15\nin expression starting at /tmp/tmp3cm5ndo1.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if arr == nothing\n\
    \        return nothing\n    end\n    signs = zeros(Int64, length(arr))\n    for\
    \ i in 1:length(arr)\n        if arr[i] > 0\n            signs[i] = 1\n      \
    \  elseif arr[i] < 0\n            signs[i] = -1\n        else\n            signs[i]\
    \ = 0\n        end\n    end\n    return prod(signs) * sum(abs.(arr))\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpx9k7uhg2.jl:36\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpx9k7uhg2.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpx9k7uhg2.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpx9k7uhg2.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    return nothing\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp33r_5oml.jl:20\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: nothing == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp33r_5oml.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp33r_5oml.jl:19\ntest set: Test\
    \ Failed at /tmp/tmp33r_5oml.jl:21\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ nothing == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp33r_5oml.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp33r_5oml.jl:19\ntest set: Test\
    \ Failed at /tmp/tmp33r_5oml.jl:22\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: nothing == -10\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp33r_5oml.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp33r_5oml.jl:19\ntest set: Test\
    \ Failed at /tmp/tmp33r_5oml.jl:24\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: nothing == 20\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp33r_5oml.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp33r_5oml.jl:19\ntest set: Test\
    \ Failed at /tmp/tmp33r_5oml.jl:25\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: nothing == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/juli"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp33r_5oml.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    res = 0\n    for\
    \ i in arr\n        if i > 0 \n            res += i\n        elseif i < 0\n  \
    \          res -= i\n        end\n    end\n    return res == 0 ? nothing : res\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmph7otr6rr.jl:28\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: 9 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph7otr6rr.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph7otr6rr.jl:27\ntest set: Test\
    \ Failed at /tmp/tmph7otr6rr.jl:29\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph7otr6rr.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph7otr6rr.jl:27\ntest set: Test\
    \ Failed at /tmp/tmph7otr6rr.jl:30\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: 10 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmph7otr6rr.jl:30 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph7otr6rr.jl:27\ntest set: Test\
    \ Failed at /tmp/tmph7otr6rr.jl:34\n  Expression: candidate([-1, 1, 1, 1]) ==\
    \ -4\n   Evaluated: 4 == -4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph7otr6rr.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph7otr6rr.jl:27\ntest set: Test\
    \ Failed at /tmp/tmph7otr6rr.jl:35\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: 3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph7otr6rr.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    sign_prod = 1\n\
    \    magnitude_sum = 0\n    for num in arr\n        if num == 0\n            sign_prod\
    \ *= 0\n        elseif num > 0\n            sign_prod *= 1\n        elseif num\
    \ < 0\n            sign_prod *= -1\n        end\n        magnitude_sum += abs(num)\n\
    \    end\n    if isempty(arr)\n        return nothing\n    else\n        return\
    \ sign_prod * magnitude_sum\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    array_sgns = sgn.(arr)\n    if (all(x\
    \ -> x == 0, array_sgns))\n        return 0\n    end\n    return sum(abs.(arr))\
    \ * prod(array_sgns)\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp0uqavlwy.jl:27\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  UndefVarError:\
    \ sgn not defined\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n \
    \    @ Main /tmp/tmp0uqavlwy.jl:16\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp0uqavlwy.jl:27 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp0uqavlwy.jl:26\\ntest set:\
    \ Error During Test at /tmp/tmp0uqavlwy.jl:28\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  UndefVarError: sgn not defined\\n  Stacktrace:\\\
    n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmp0uqavlwy.jl:16\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp0uqavlwy.jl:28 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp0uqavlwy.jl:26\\ntest set:\
    \ Error During Test at /tmp/tmp0uqavlwy.jl:29\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  UndefVarError: sgn not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmp0uqavlwy.jl:16\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp0uqavlwy.jl:29 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp0uqavlwy.jl:26\\ntest set:\
    \ Error During Test at /tmp/tmp0uqavlwy.jl:31\\n  Test threw exception\\n  Expression:\
    \ candidate([2, 4, 1, 2, -1, -1, 9]) == 20\\n  UndefVarError: sgn not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmp0"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return nothing\n    end\n    sum_magnitudes = sum(abs.(arr))\n \
    \   product_signs = reduce(*, [sign(element) for element in arr])\n    return\
    \ sum_magnitudes * product_signs\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    s = 1\n    if !isempty(arr)\n\
    \        for x in arr\n            s = s * sign(x)\n        end\n        return\
    \ Int64(sum(abs.(arr)) * s)\n    else\n        return nothing\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    arr = filter(x ->\
    \ x != 0, arr)\n    prod([sign(x) for x in arr]) * sum([abs(x) for x in arr])\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnmciopfm.jl:22\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnmciopfm.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnmciopfm.jl:20\ntest set: Test\
    \ Failed at /tmp/tmpnmciopfm.jl:24\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnmciopfm.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnmciopfm.jl:20\ntest set: Test\
    \ Failed at /tmp/tmpnmciopfm.jl:28\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnmciopfm.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnmciopfm.jl:20\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    5     3      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnmciopfm.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    signs = map(x ->\
    \ x < 0 ? -1 : x > 0 ? 1 : 0, arr)\n    return isempty(arr) ? nothing : prod(signs)\
    \ * sum(abs.(arr))\nend\n# tests\n@test prod_signs([1, 2, 2, -4]) == -9\n@test\
    \ prod_signs([0, 1]) == 0\n@test prod_signs([]) == nothing;\n@testset \"Checking\
    \ prod_signs\" begin\n    @test prod_signs([1, 2, 2, -4]) == -9\n    @test prod_signs([0,\
    \ 1]) == 0\n    @test prod_signs([]) == nothing\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @test not defined\nin expression starting\
    \ at /tmp/tmp8e81ptus.jl:17\nin expression starting at /tmp/tmp8e81ptus.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if arr == []\n \
    \       return\n    end\n    prod = 1\n    sum = 0\n    for i = 1:length(arr)\n\
    \        if arr[i] != 0\n            prod *= sign(arr[i])\n            sum +=\
    \ abs(arr[i])\n        end\n    end\n    return prod * sum\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfqviq7ua.jl:32\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfqviq7ua.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfqviq7ua.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpfqviq7ua.jl:38\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfqviq7ua.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfqviq7ua.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfqviq7ua.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    N = length(arr)\n\
    \    if N == 0\n        return nothing\n    end\n    product = 1\n    result =\
    \ 0\n    for i in 1:N\n        if arr[i] > 0\n            product *= 1\n     \
    \   elseif arr[i] < 0\n            product *= -1\n        else\n            product\
    \ *= 0\n        end\n        result += abs(arr[i])\n    end\n    return result\
    \ * product\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t\
    @test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    if length(arr) == 1\n        return arr[1]\n\
    \    end\n    prod_signs = 1\n    sum_magn = 0\n    for (i, e) in enumerate(arr)\n\
    \        if e > 0\n            prod_signs *= 1\n        elseif e < 0\n       \
    \     prod_signs *= -1\n        elseif e == 0\n            prod_signs *= 0\n \
    \       end\n        sum_magn += abs(e)\n    end\n    return prod_signs * sum_magn\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    prod_sign = 1\n    sum_magn = 0\n    for\
    \ (i, v) in enumerate(arr)\n        if v == 0\n            return 0\n        elseif\
    \ v > 0\n            prod_sign *= 1\n        else\n            prod_sign *= -1\n\
    \        end\n        sum_magn += abs(v)\n    end\n    return prod_sign * sum_magn\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\
    \ return nothing end\n    return prod(abs.(arr)) * prod(sign.(arr))\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpf0i3x2c1.jl:21\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: -16 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0i3x2c1.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0i3x2c1.jl:20\ntest set: Test\
    \ Failed at /tmp/tmpf0i3x2c1.jl:23\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: -6 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf0i3x2c1.jl:23 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0i3x2c1.jl:20\ntest set: Test\
    \ Failed at /tmp/tmpf0i3x2c1.jl:25\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: 144 == 20\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf0i3x2c1.jl:25 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0i3x2c1.jl:20\ntest set: Test\
    \ Failed at /tmp/tmpf0i3x2c1.jl:26\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: 1 == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0i3x2c1.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0i3x2c1.jl:20\ntest set: Test\
    \ Failed at /tmp/tmpf0i3x2c1.jl:27\n  Expression: candidate([-1, 1, 1, 1]) ==\
    \ -4\n   Evaluated: -1 == -4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/T"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf0i3x2c1.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    prod_signs = 1\n    for i in arr\n     \
    \   if i == 0\n            prod_signs = 0\n            break\n        elseif i\
    \ > 0\n            prod_signs *= 1\n        else\n            prod_signs *= -1\n\
    \        end\n    end\n    return sum(abs.(arr)) * prod_signs\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    prod_of_signs = 1\n    prod_of_magnitudes\
    \ = 1\n    for number in arr\n        if number > 0\n            prod_of_signs\
    \ *= 1\n            prod_of_magnitudes *= number\n        elseif number < 0\n\
    \            prod_of_signs *= -1\n            prod_of_magnitudes *= abs(number)\n\
    \        else\n            prod_of_signs *= 0\n        end\n    end\n    return\
    \ prod_of_signs * prod_of_magnitudes\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpv0pwq9ql.jl:36\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: -16 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv0pwq9ql.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv0pwq9ql.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpv0pwq9ql.jl:38\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: -6 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpv0pwq9ql.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv0pwq9ql.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpv0pwq9ql.jl:40\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: 144 == 20\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpv0pwq9ql.jl:40 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv0pwq9ql.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpv0pwq9ql.jl:41\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: 1 == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv0pwq9ql.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv0pwq9ql.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpv0pwq9ql.jl:42\n  Expression: candidate([-1, 1, 1, 1]) ==\
    \ -4\n   Evaluated: -1 == -4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/T"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv0pwq9ql.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    signs = map(sign,\
    \ arr)\n    if all(x -> x == 0, signs)\n        return 0\n    elseif any(x ->\
    \ x == 0, signs)\n        return nothing\n    else\n        prod = prod(signs)\n\
    \        return sum(abs.(arr)) * prod\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmps97kay6f.jl:28\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  UndefVarError:\
    \ prod not defined\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n\
    \     @ Main /tmp/tmps97kay6f.jl:19\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmps97kay6f.jl:28 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmps97kay6f.jl:27\\ntest set:\
    \ Test Failed at /tmp/tmps97kay6f.jl:29\\n  Expression: candidate([0, 1]) == 0\\\
    n   Evaluated: nothing == 0'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    signs = 1\n    magnitudes = 0\n    for num\
    \ in arr\n        if num == 0\n            continue\n        end\n        if num\
    \ > 0\n            signs *= 1\n        else\n            signs *= -1\n       \
    \ end\n        magnitudes += abs(num)\n    end\n    return signs * magnitudes\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpq2vyrdd2.jl:37\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpq2vyrdd2.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq2vyrdd2.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpq2vyrdd2.jl:43\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpq2vyrdd2.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq2vyrdd2.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq2vyrdd2.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    prod = 1\n    total = 0\n    for i in\
    \ arr\n        prod *= sign(i)\n        total += abs(i)\n    end\n    return total\
    \ * prod\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    return sum(abs.(arr)) * prod(sign.(arr))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    mul = 0\n    for i in arr\n        if i\
    \ == 0\n            mul *= 0\n        elseif i > 0\n            mul *= 1\n   \
    \     else\n            mul *= -1\n        end\n    end\n    ret = 0\n    for\
    \ i in arr\n        ret += abs(i)\n    end\n    return ret * mul\nend\n\"\"\"\n\
    \    You are given an array arr of integers and you need to return\n    sum of\
    \ magnitudes of integers multiplied by product of all signs\n    of each number\
    \ in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpeghh0vi6.jl:32\nin expression starting at\
    \ /tmp/tmpeghh0vi6.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return\n    end\n    sign_prod = prod(sign.(arr))\n    sum_magnitude\
    \ = sum(abs.(arr))\n    sum_magnitude * sign_prod\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if !isempty(arr)\n\
    \        product(sign.(arr)) * sum(abs.(arr))\n    else\n        nothing\n   \
    \ end\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpq_k31ys8.jl:24\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  UndefVarError:\
    \ product not defined\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpq_k31ys8.jl:14\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpq_k31ys8.jl:24 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpq_k31ys8.jl:23\\ntest set:\
    \ Error During Test at /tmp/tmpq_k31ys8.jl:25\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  UndefVarError: product not defined\\n  Stacktrace:\\\
    n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpq_k31ys8.jl:14\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpq_k31ys8.jl:25 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpq_k31ys8.jl:23\\ntest set:\
    \ Error During Test at /tmp/tmpq_k31ys8.jl:26\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  UndefVarError: product not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpq_k31ys8.jl:14\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpq_k31ys8.jl:26 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpq_k31ys8.jl:23\\ntest set:\
    \ Error During Test at /tmp/tmpq_k31ys8.jl:28\\n  Test threw exception\\n  Expression:\
    \ candidate([2, 4, 1, 2, -1, -1, 9]) == 20\\n  UndefVarError: product not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     "
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    sum_magnitude = sum(abs.(arr))\n    product_signs\
    \ = prod(sign.(arr))\n    return sum_magnitude * product_signs\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    prd, sm = 1, 0\n    for x in arr\n     \
    \   sm += abs(x)\n        prd *= sign(x)\n    end\n    return sm * prd\nend\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return\n    end\n    product = reduce(*, map(x -> sign(x), arr))\n  \
    \  sum = reduce(+, map(x -> abs(x), arr))\n    return product * sum\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    s = 0\n    prod = 1\n    for i = 1:length(arr)\n\
    \        s += abs(arr[i])\n        prod *= sign(arr[i])\n    end\n    return s\
    \ * prod\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    signs = [sgn(x) for x in arr]\n    return\
    \ prod(signs) * sum(abs.(arr))\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp9k8sabyi.jl:24\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  UndefVarError:\
    \ sgn not defined\\n  Stacktrace:\\n   [1] (::var\"#1#2\")(x::Int64)\\n     @\
    \ Main ./none:0\\n   [2] iterate\\n     @ ./generator.jl:47 [inlined]\\n   [3]\
    \ collect(itr::Base.Generator{Vector{Int64}, var\"#1#2\"})\\n     @ Base ./array.jl:724\\\
    n   [4] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmp9k8sabyi.jl:16\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [6] macro expansion\\n     @ /tmp/tmp9k8sabyi.jl:24 [inlined]\\\
    n   [7] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [8] top-level scope\\n     @ /tmp/tmp9k8sabyi.jl:23\\ntest set:\
    \ Error During Test at /tmp/tmp9k8sabyi.jl:25\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  UndefVarError: sgn not defined\\n  Stacktrace:\\\
    n   [1] (::var\"#1#2\")(x::Int64)\\n     @ Main ./none:0\\n   [2] iterate\\n \
    \    @ ./generator.jl:47 [inlined]\\n   [3] collect(itr::Base.Generator{Vector{Int64},\
    \ var\"#1#2\"})\\n     @ Base ./array.jl:724\\n   [4] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp9k8sabyi.jl:16\\n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [6] macro expansion\\n     @ /tmp/tmp9k8sabyi.jl:25 [inlined]\\\
    n   [7] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [8] top-level scope\\n     @ /tmp/tmp9k8sabyi.jl:23\\ntest set:\
    \ Error During Test at /tmp/tmp9k8sabyi.jl:26\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  UndefVarError: sgn not defined\\\
    n  Stacktrace:\\n   [1] (::var\"#1#2\")(x::Int64)\\n     @ Main ./none:0\\n  \
    \ [2] iterate\\n     @ ./generator.jl:47 [inlined]\\n   [3] collect(itr::Base.Generator{Vector{Int64},\
    \ var\"#1#2\"})\\n     @ Base ./array.jl:724\\n   [4] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp9k8sabyi.jl:16\\n   ["
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    arr_signed = [sign(num)\
    \ for num in arr]\n    prod_signs = prod(arr_signed)\n    sum_magnitudes = sum([abs(num)\
    \ for num in arr])\n    return prod_signs * sum_magnitudes\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpf7iua3w8.jl:26\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf7iua3w8.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf7iua3w8.jl:22\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf7iua3w8.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    sign = 1\n    mag = 0\n    for a in arr\n\
    \        if a != 0\n            sign *= sign(a)\n            mag += abs(a)\n \
    \       end\n    end\n    return sign * mag\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpwltiaqbp.jl:31\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  MethodError: objects\
    \ of type Int64 are not callable\\n  Maybe you forgot to use an operator such\
    \ as *, ^, %, / etc. ?\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpwltiaqbp.jl:20\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpwltiaqbp.jl:31 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpwltiaqbp.jl:30\\ntest set:\
    \ Error During Test at /tmp/tmpwltiaqbp.jl:32\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  MethodError: objects of type Int64 are not callable\\\
    n  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\\n  Stacktrace:\\\
    n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpwltiaqbp.jl:20\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpwltiaqbp.jl:32 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpwltiaqbp.jl:30\\ntest set:\
    \ Error During Test at /tmp/tmpwltiaqbp.jl:33\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  MethodError: objects of type Int64\
    \ are not callable\\n  Maybe you forgot to use an operator such as *, ^, %, /\
    \ etc. ?\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main\
    \ /tmp/tmpwltiaqbp.jl:20\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpwltiaqbp.jl:33 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpwl"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return\n    end\n    arr = abs.(arr)\n    arr = Array{Int64}(arr)\n\
    \    # use boolean indexing to distinguish between\n    # negative and non-negative\
    \ numbers\n    # and sum up their magnitudes\n    pos = arr[arr .> 0]\n    neg\
    \ = arr[arr .< 0]\n    pos = sum(pos)\n    neg = sum(neg)\n    # if there are\
    \ any negative number, product of their signs\n    # is -1, else 1\n    sign =\
    \ ifelse(sum(neg) > 0, -1, 1)\n    return sign * (pos + neg)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpd1rm7yti.jl:35\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: 9 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd1rm7yti.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd1rm7yti.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpd1rm7yti.jl:36\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd1rm7yti.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd1rm7yti.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpd1rm7yti.jl:37\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: 10 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpd1rm7yti.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd1rm7yti.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpd1rm7yti.jl:41\n  Expression: candidate([-1, 1, 1, 1]) ==\
    \ -4\n   Evaluated: 4 == -4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd1rm7yti.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd1rm7yti.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpd1rm7yti.jl:42\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: 3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd1rm7yti.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    sign = 1\n    prod = 1\n    for x in arr\n\
    \        if x < 0\n            sign *= -1\n        end\n        prod *= abs(x)\n\
    \    end\n    return sign * prod\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpntmk1yhe.jl:31\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: -16 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpntmk1yhe.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpntmk1yhe.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpntmk1yhe.jl:33\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: -6 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpntmk1yhe.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpntmk1yhe.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpntmk1yhe.jl:35\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: 144 == 20\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpntmk1yhe.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpntmk1yhe.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpntmk1yhe.jl:36\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: 1 == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpntmk1yhe.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpntmk1yhe.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpntmk1yhe.jl:37\n  Expression: candidate([-1, 1, 1, 1]) ==\
    \ -4\n   Evaluated: -1 == -4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/T"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpntmk1yhe.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    prod = 1\n    for x in arr\n        prod\
    \ *= sign(x)\n    end\n    sum = 0\n    for x in arr\n        sum += abs(x)\n\
    \    end\n    return prod * sum\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    prod = 1\n    sum = 0\n    for i in arr\n\
    \        if i > 0\n            prod *= 1\n        elseif i < 0\n            prod\
    \ *= -1\n        else\n            prod *= 0\n        end\n        sum += abs(i)\n\
    \    end\n    return sum * prod\nend\n    \n    \nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    n = length(arr)\n\
    \    if n == 0\n        return nothing\n    end\n    prod = 1\n    sum = 0\n \
    \   for x in arr\n        if x > 0\n            prod *= 1\n        elseif x <\
    \ 0\n            prod *= -1\n        else\n            prod *= 0\n        end\n\
    \        sum += abs(x)\n    end\n    return sum * prod\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    ret = 1\n    for\
    \ num in arr\n        ret *= sign(num)\n    end\n    if ret == 0\n        return\
    \ 0\n    end\n    return ret * sum(abs.(arr))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppz2ghw7i.jl:30\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppz2ghw7i.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppz2ghw7i.jl:26\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppz2ghw7i.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    arr_signs = sign.(arr)\n\
    \    is_not_zero = (arr_signs .!= 0)\n    if sum(is_not_zero) == 0\n        return\
    \ nothing\n    end\n    prod = prod(arr_signs[is_not_zero])\n    sum_abs = sum(abs.(arr[is_not_zero]))\n\
    \    return prod * sum_abs\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpfymfa58_.jl:27\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  UndefVarError:\
    \ prod not defined\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n\
    \     @ Main /tmp/tmpfymfa58_.jl:18\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpfymfa58_.jl:27 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpfymfa58_.jl:26\\ntest set:\
    \ Error During Test at /tmp/tmpfymfa58_.jl:28\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  UndefVarError: prod not defined\\n  Stacktrace:\\\
    n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpfymfa58_.jl:18\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpfymfa58_.jl:28 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpfymfa58_.jl:26\\ntest set:\
    \ Error During Test at /tmp/tmpfymfa58_.jl:29\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  UndefVarError: prod not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpfymfa58_.jl:18\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpfymfa58_.jl:29 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpfymfa58_.jl:26\\ntest set:\
    \ Error During Test at /tmp/tmpfymfa58_.jl:31\\n  Test threw exception\\n  Expression:\
    \ candidate([2, 4, 1, 2, -1, -1, 9]) == 20\\n  UndefVarError: prod not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    N = length(arr)\n\
    \    if N == 0\n        return nothing\n    end\n    res = 1\n    for i = 1:N\n\
    \        res *= sign(arr[i])\n    end\n    if res == 0\n        return 0\n   \
    \ end\n    sum = 0\n    for i = 1:N\n        sum += abs(arr[i])\n    end\n   \
    \ return res * sum\nend\n    \n    \nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    # your code goes\
    \ here\n    return nothing\nend\n \n# end::prod_signs[]\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbsh8ksad.jl:23\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: nothing == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbsh8ksad.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbsh8ksad.jl:22\ntest set: Test\
    \ Failed at /tmp/tmpbsh8ksad.jl:24\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ nothing == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbsh8ksad.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbsh8ksad.jl:22\ntest set: Test\
    \ Failed at /tmp/tmpbsh8ksad.jl:25\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: nothing == -10\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbsh8ksad.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbsh8ksad.jl:22\ntest set: Test\
    \ Failed at /tmp/tmpbsh8ksad.jl:27\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: nothing == 20\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbsh8ksad.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbsh8ksad.jl:22\ntest set: Test\
    \ Failed at /tmp/tmpbsh8ksad.jl:28\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: nothing == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/juli"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbsh8ksad.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    n = length(arr)\n\
    \    if n == 0\n        return nothing\n    end\n    prod_signs = 1\n    sum_magnitudes\
    \ = 0\n    for i in 1:n\n        if arr[i] > 0\n            prod_signs *= 1\n\
    \        elseif arr[i] < 0\n            prod_signs *= -1\n        else\n     \
    \       prod_signs *= 0\n        end\n        sum_magnitudes += abs(arr[i])\n\
    \    end\n    return prod_signs * sum_magnitudes\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    arr = abs.(arr)\n    arr[arr .== 0] = 1\n\
    \    prod = prod(arr)\n    sum = 0\n    for i in arr\n        sum += abs(i)\n\
    \    end\n    prod * sum\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpclhm42od.jl:30\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  ArgumentError:\
    \ indexed assignment with a single value to possibly many locations is not supported;\
    \ perhaps use broadcasting `.=` instead?\\n  Stacktrace:\\n   [1] setindex_shape_check(::Int64,\
    \ ::Int64)\\n     @ Base ./indices.jl:261\\n   [2] _unsafe_setindex!(#unused#::IndexLinear,\
    \ A::Vector{Int64}, x::Int64, I::Base.LogicalIndex{Int64, BitVector})\\n     @\
    \ Base ./multidimensional.jl:903\\n   [3] _setindex!\\n     @ ./multidimensional.jl:894\
    \ [inlined]\\n   [4] setindex!\\n     @ ./abstractarray.jl:1315 [inlined]\\n \
    \  [5] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpclhm42od.jl:17\\n\
    \   [6] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [7] macro expansion\\n     @ /tmp/tmpclhm42od.jl:30 [inlined]\\\
    n   [8] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [9] top-level scope\\n     @ /tmp/tmpclhm42od.jl:29\\ntest set:\
    \ Error During Test at /tmp/tmpclhm42od.jl:31\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  ArgumentError: indexed assignment with a single value\
    \ to possibly many locations is not supported; perhaps use broadcasting `.=` instead?\\\
    n  Stacktrace:\\n   [1] setindex_shape_check(::Int64, ::Int64)\\n     @ Base ./indices.jl:261\\\
    n   [2] _unsafe_setindex!(#unused#::IndexLinear, A::Vector{Int64}, x::Int64, I::Base.LogicalIndex{Int64,\
    \ BitVector})\\n     @ Base ./multidimensional.jl:903\\n   [3] _setindex!\\n \
    \    @ ./multidimensional.jl:894 [inlined]\\n   [4] setindex!\\n     @ ./abstractarray.jl:1315\
    \ [inlined]\\n   [5] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpclhm42od.jl:17\\\
    n   [6] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [7] macro expansion\\n     @ /tmp/tmpclhm42od.jl:31 [inlined]\\\
    n   [8] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    prod = 1\n    mags\
    \ = 0\n    for el in arr\n        if el == 0\n            prod = 0\n        elseif\
    \ el < 0\n            prod *= -1\n        end\n        mags += abs(el)\n    end\n\
    \    mags * prod\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsu8o3cdp.jl:33\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsu8o3cdp.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsu8o3cdp.jl:29\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsu8o3cdp.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    # Get the signs of each number\n   \
    \ sign_arr = sign.(arr)\n    # Get the magnitude of each number\n    abs_arr =\
    \ abs.(arr)\n    # Multiply the signs and get the absolute value of the result.\n\
    \    return abs(prod(sign_arr)) * sum(abs_arr)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp45f2f0b1.jl:28\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: 9 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp45f2f0b1.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp45f2f0b1.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp45f2f0b1.jl:30\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: 10 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp45f2f0b1.jl:30 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp45f2f0b1.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp45f2f0b1.jl:34\n  Expression: candidate([-1, 1, 1, 1]) ==\
    \ -4\n   Evaluated: 4 == -4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp45f2f0b1.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp45f2f0b1.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    5     3      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp45f2f0b1.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    # the list of products\n\
    \    # you can also just multiply everything in a loop\n    # and then take the\
    \ sign of the product\n    return reduce(*, map(sign, arr)) * sum(abs.(arr))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmnunskcg.jl:26\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmnunskcg.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmnunskcg.jl:22\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmnunskcg.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    signs = Vector{Int64}(undef, length(arr))\n\
    \    magnitudes = zeros(Int64, length(arr))\n    for (i, val) in enumerate(arr)\n\
    \        if val == 0\n            signs[i] = 0\n            magnitudes[i] = 0\n\
    \        elseif val > 0\n            signs[i] = 1\n            magnitudes[i] =\
    \ val\n        else\n            signs[i] = -1\n            magnitudes[i] = -val\n\
    \        end\n    end\n    return sum(magnitudes) * prod(signs)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    signprod = 1\n \
    \   sumprod = 0\n    for n in arr\n        if n > 0\n            signprod *= 1\n\
    \        elseif n < 0\n            signprod *= -1\n        else\n            signprod\
    \ *= 0\n        end\n        sumprod += abs(n)\n    end\n    if signprod == 0\n\
    \        return 0\n    else\n        return signprod * sumprod\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplzqupt9x.jl:39\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplzqupt9x.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplzqupt9x.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplzqupt9x.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    prod_signs = 1\n    total_sum = 0\n    for\
    \ i in arr\n        prod_signs *= sign(i)\n        total_sum += abs(i)\n    end\n\
    \    total_sum * prod_signs\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    empty!(arr) == nothing\n\
    \    if nothing\n        return nothing\n    else\n    magnitudes = abs.(arr)\n\
    \    signs = map(x -> ifelse(x == 0, 0, sign(x)), arr)\n    sum(magnitudes) *\
    \ prod(signs)\n    end\nend\n@assert prod_signs([1, 2, 2, -4]) == -9\n@assert\
    \ prod_signs([0, 1]) == 0\n@assert prod_signs([]) == nothing\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: TypeError: non-boolean (Nothing) used in boolean context\n\
    Stacktrace:\n [1] prod_signs(arr::Vector{Int64})\n   @ Main /tmp/tmp3uejh3ik.jl:14\n\
    \ [2] top-level scope\n   @ /tmp/tmp3uejh3ik.jl:22\nin expression starting at\
    \ /tmp/tmp3uejh3ik.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return\n    end\n    prod_signs = 1\n    prod_magnitude = 0\n   \
    \ for i in arr\n        if i == 0\n            continue\n        end\n       \
    \ prod_signs *= sign(i)\n        prod_magnitude += abs(i)\n    end\n    return\
    \ prod_signs * prod_magnitude\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcjt3sm0z.jl:33\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcjt3sm0z.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcjt3sm0z.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpcjt3sm0z.jl:39\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcjt3sm0z.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcjt3sm0z.jl:31\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcjt3sm0z.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    return prod(sign.(arr))\
    \ * sum(abs.(arr))\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpazo8cf1d.jl:23\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpazo8cf1d.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpazo8cf1d.jl:19\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpazo8cf1d.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    return Nothing::Union{Int64,\
    \ Nothing}\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp47360yrg.jl:20\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  TypeError: in typeassert,\
    \ expected Union{Nothing, Int64}, got Type{Nothing}\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp47360yrg.jl:13\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp47360yrg.jl:20 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp47360yrg.jl:19\\ntest set:\
    \ Error During Test at /tmp/tmp47360yrg.jl:21\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  TypeError: in typeassert, expected Union{Nothing,\
    \ Int64}, got Type{Nothing}\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp47360yrg.jl:13\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp47360yrg.jl:21 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp47360yrg.jl:19\\ntest set:\
    \ Error During Test at /tmp/tmp47360yrg.jl:22\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  TypeError: in typeassert, expected\
    \ Union{Nothing, Int64}, got Type{Nothing}\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp47360yrg.jl:13\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp47360yrg.jl:22 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp47360yrg.jl:19\\ntest set:\
    \ Error During Test at /tmp/tmp47360yrg.jl:23\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n   \n    signs = [ sign(x) for x in arr ]\n\
    \    magnitudes = [ abs(x) for x in arr ]\n    return sum(magnitudes) * prod(signs)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    (sum(abs.(arr))\
    \ * prod(sign.(arr)) == 0) ? 0 : sum(abs.(arr)) * prod(sign.(arr))\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2x5bd_fw.jl:23\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2x5bd_fw.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2x5bd_fw.jl:19\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2x5bd_fw.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    s = 1\n    for i in arr\n        if\
    \ i != 0\n            s *= sign(i)\n        end\n    end\n    return sum(abs.(arr))\
    \ * s\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2zxcv8y6.jl:30\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2zxcv8y6.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2zxcv8y6.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp2zxcv8y6.jl:36\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2zxcv8y6.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2zxcv8y6.jl:28\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2zxcv8y6.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    prods = 1\n    summ = 0\n    for i in arr\n\
    \        if i > 0\n            prods *= 1\n        elseif i < 0\n            prods\
    \ *= -1\n        else\n            prods *= 0\n        end\n        summ += abs(i)\n\
    \    end\n    return summ * prods\nend\n\"\"\"\n    You are given an array arr\
    \ of integers. Return maximum number\n    of elements that are non-decreasing,\
    \ i.e. are in format\n    [x1, x2] or [x1, x2, x3] or [x1, x2, x3, x4] ... such\
    \ that\n    x1 <= x2 <= x3 <= x4 ... respectively.\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqur21nqm.jl:30\nin expression starting at\
    \ /tmp/tmpqur21nqm.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    sum = 0\n    sign\
    \ = 1\n    if isempty(arr)\n        return\n    end\n    for num in arr\n    \
    \    sign *= sign(num)\n        sum += abs(num)\n    end\n    return sum * sign\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpkhxwgjyo.jl:29\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  MethodError: objects\
    \ of type Int64 are not callable\\n  Maybe you forgot to use an operator such\
    \ as *, ^, %, / etc. ?\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpkhxwgjyo.jl:19\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpkhxwgjyo.jl:29 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpkhxwgjyo.jl:28\\ntest set:\
    \ Error During Test at /tmp/tmpkhxwgjyo.jl:30\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  MethodError: objects of type Int64 are not callable\\\
    n  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\\n  Stacktrace:\\\
    n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmpkhxwgjyo.jl:19\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpkhxwgjyo.jl:30 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpkhxwgjyo.jl:28\\ntest set:\
    \ Error During Test at /tmp/tmpkhxwgjyo.jl:31\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  MethodError: objects of type Int64\
    \ are not callable\\n  Maybe you forgot to use an operator such as *, ^, %, /\
    \ etc. ?\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main\
    \ /tmp/tmpkhxwgjyo.jl:19\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpkhxwgjyo.jl:31 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpkh"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    prod_signs = 0\n    total_signs = 1\n  \
    \  for i in arr\n        prod_signs += abs(i)\n        if i == 0\n           \
    \ continue\n        end\n        total_signs *= i\n    end\n    return prod_signs\
    \ * total_signs\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgj4zv5_q.jl:32\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: -144 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgj4zv5_q.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgj4zv5_q.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpgj4zv5_q.jl:33\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgj4zv5_q.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgj4zv5_q.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpgj4zv5_q.jl:34\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: -60 == -10\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpgj4zv5_q.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgj4zv5_q.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpgj4zv5_q.jl:36\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: 2880 == 20\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpgj4zv5_q.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgj4zv5_q.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpgj4zv5_q.jl:39\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgj4zv5_q.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    return prod(sign.(arr)) * sum(abs.(arr))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    \"\"\"\n    You\
    \ are given an array arr of integers and you need to return\n    sum of magnitudes\
    \ of integers multiplied by product of all signs\n    of each number in the array,\
    \ represented by 1, -1 or 0.\n    Note: return None for empty arr.\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp3uhb2tp.jl:1\nin expression starting at /tmp/tmpp3uhb2tp.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    res = 1\n    for e in arr\n        if e\
    \ == 0\n            res = 0\n            break\n        elseif e > 0\n       \
    \     res *= 1\n        else\n            res *= -1\n        end\n    end\n  \
    \  return sum(abs.(arr)) * res\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    n = length(arr)\n\
    \    if n == 0\n        return nothing\n    end\n    res = 0\n    prod = 1\n \
    \   for i in 1:n\n        if arr[i] == 0\n            prod = prod * 1\n      \
    \  elseif arr[i] > 0\n            prod = prod * 1\n            res = res + arr[i]\n\
    \        elseif arr[i] < 0\n            prod = prod * -1\n            res = res\
    \ + abs(arr[i])\n        end\n    end\n    res * prod\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkzthfs9_.jl:38\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkzthfs9_.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkzthfs9_.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpkzthfs9_.jl:44\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkzthfs9_.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkzthfs9_.jl:36\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkzthfs9_.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    n = prod(sign.(arr))\n\
    \    if n != 0\n        return sum(abs.(arr)) * n\n    else\n        return\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqxx5e9np.jl:26\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: nothing == 0\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqxx5e9np.jl:26 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqxx5e9np.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpqxx5e9np.jl:28\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqxx5e9np.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqxx5e9np.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpqxx5e9np.jl:32\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: nothing == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqxx5e9np.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqxx5e9np.jl:24\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    5     3      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqxx5e9np.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    return prod(sign.(arr))\
    \ * sum(abs.(arr))\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpor3_df00.jl:23\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpor3_df00.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpor3_df00.jl:19\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpor3_df00.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    sign_prod = reduce(*,\
    \ map(Int64,arr .>= 0))\n    magnitude_sum = sum(abs.(arr))\n    sign_prod * magnitude_sum\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp24t319db.jl:22\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: 0 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp24t319db.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp24t319db.jl:21\ntest set: Test\
    \ Failed at /tmp/tmp24t319db.jl:23\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp24t319db.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp24t319db.jl:21\ntest set: Test\
    \ Failed at /tmp/tmp24t319db.jl:24\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: 0 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp24t319db.jl:24 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp24t319db.jl:21\ntest set: Test\
    \ Failed at /tmp/tmp24t319db.jl:25\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp24t319db.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp24t319db.jl:21\ntest set: Test\
    \ Failed at /tmp/tmp24t319db.jl:26\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: 0 == 20\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/T"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp24t319db.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    return product(sign.(arr)) * sum(abs.(arr))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmph_2qbtv4.jl:23\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  UndefVarError:\
    \ product not defined\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmph_2qbtv4.jl:16\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmph_2qbtv4.jl:23 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmph_2qbtv4.jl:22\\ntest set:\
    \ Error During Test at /tmp/tmph_2qbtv4.jl:24\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  UndefVarError: product not defined\\n  Stacktrace:\\\
    n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmph_2qbtv4.jl:16\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmph_2qbtv4.jl:24 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmph_2qbtv4.jl:22\\ntest set:\
    \ Error During Test at /tmp/tmph_2qbtv4.jl:25\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\\n  UndefVarError: product not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main /tmp/tmph_2qbtv4.jl:16\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmph_2qbtv4.jl:25 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmph_2qbtv4.jl:22\\ntest set:\
    \ Error During Test at /tmp/tmph_2qbtv4.jl:27\\n  Test threw exception\\n  Expression:\
    \ candidate([2, 4, 1, 2, -1, -1, 9]) == 20\\n  UndefVarError: product not defined\\\
    n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     "
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    \n    if isempty(arr)\n\
    \        return nothing\n    end\n    mult = 1\n    for i in arr\n        if i\
    \ > 0\n            mult *= 1\n        elseif i < 0\n            mult *= -1\n \
    \       else\n            mult *= 0\n        end\n    end\n    sum(abs.(arr))\
    \ * mult\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n  if isempty(arr)\n\
    \    return nothing\n  end\n  prod = reduce((x, y) -> x * y, map(x -> ifelse(x\
    \ == 0, 1, sign(x)), arr))\n  if prod == 0\n    prod = 1\n  end\n  return sum(abs.(arr))\
    \ * prod\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpov6gw1s6.jl:28\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpov6gw1s6.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpov6gw1s6.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpov6gw1s6.jl:34\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpov6gw1s6.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpov6gw1s6.jl:26\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpov6gw1s6.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    res = 0\n    product = 1\n    for i\
    \ in arr\n        res += abs(i)\n        if i > 0\n            product *= 1\n\
    \        elseif i < 0\n            product *= -1\n        else\n            product\
    \ *= 0\n        end\n    end\n    res * product\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    prod_signs = 1\n    sum_abs = 0\n  \
    \  for i in arr\n        if i == 0\n            continue\n        end\n      \
    \  prod_signs *= sign(i)\n        sum_abs += abs(i)\n    end\n    prod_signs *\
    \ sum_abs\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbg6c9oy2.jl:33\n  Expression: candidate([0,\
    \ 1]) == 0\n   Evaluated: 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbg6c9oy2.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbg6c9oy2.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpbg6c9oy2.jl:39\n  Expression: candidate([-1, 1, 1, 0]) ==\
    \ 0\n   Evaluated: -3 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbg6c9oy2.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbg6c9oy2.jl:31\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbg6c9oy2.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    l = length(arr)\n\
    \    prod = 1\n    sum = 0\n    if l == 0\n        return nothing\n    end\n \
    \   for i in 1:l\n        num = arr[i]\n        if num > 0\n            prod *=\
    \ 1\n        elseif num < 0\n            prod *= -1\n        else\n          \
    \  prod *= 0\n        end\n        if num != 0\n            sum += abs(num)\n\
    \        end\n    end\n    return sum * prod\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    magnitudes = map(abs, arr)\n    prod_signs\
    \ = reduce(*, map(sign, arr))\n    return sum(magnitudes) * prod_signs\nend\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    @assert length(arr)\
    \ > 0\n    if length(arr) == 0 \n        return nothing\n    end\n    # replace\
    \ each element in the array with the sign of that element\n    sign_arr = map(abs(arr)\
    \ -> -1, arr)\n    # multiply each element in the array with the sign of that\
    \ element\n    sign_prod = reduce(*, 1, sign_arr)\n    # return the sum of the\
    \ absolute value of each element in the array multiplied by the sign of the product\n\
    \    return sum(abs.(arr)) * sign_prod\nend\nprod_signs([1, 2, 2, -4]) == -9\n\
    prod_signs([0, 1]) == 0\nprod_signs([]) == nothing\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"abs(arr)\" is not a valid function argument\
    \ name around /tmp/tmpv2n4s48g.jl:18\nStacktrace:\n [1] top-level scope\n   @\
    \ /tmp/tmpv2n4s48g.jl:1\nin expression starting at /tmp/tmpv2n4s48g.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0 \n        return\n    end\n    prod = reduce(*, [sign(x) for x in arr])\n\
    \    if prod != 0\n        return prod * sum([abs(x) for x in arr])\n    else\n\
    \        return 0\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    # your code here\n\
    end\n\"\"\"\n    We are given array of integers and we need to put all 0s at the\
    \ end\n    of array without changing the order of non-zero elements.\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwbk6h48d.jl:15\nin expression starting at\
    \ /tmp/tmpwbk6h48d.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return\n    end\n    arr_signs = sign.(arr)\n    prod(arr_signs) * sum(abs.(arr))\n\
    end\nprod_signs([1, 2, 2, -4]) == -9\nprod_signs([0, 1]) == 0\nprod_signs([])\
    \ == nothing\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: None
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    \n    prod_signs(arr::Vector{Int64})\
    \ = \n    if length(arr) == 0\n        return\n    elseif length(arr) == 1\n \
    \       return abs(arr[1])\n    else\n        prod_signs(arr[1:end-1]) * abs(arr[end])\
    \ * sign(arr[end])\nend\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpli604c8m.jl:28\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  MethodError: Cannot\
    \ `convert` an object of type var\"#prod_signs#1\" to an object of type Int64\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:Number\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:6\\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:7\\\
    n    convert(::Type{T}, !Matched::Base.TwicePrecision) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/twiceprecision.jl:262\\\
    n    ...\\n  Stacktrace:\\n   [1] convert(#unused#::Type{Union{Nothing, Int64}},\
    \ x::Function)\\n     @ Base ./some.jl:36\\n   [2] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpli604c8m.jl:14\\n   [3] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmpli604c8m.jl:28 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmpli604c8m.jl:27\\ntest set:\
    \ Error During Test at /tmp/tmpli604c8m.jl:29\\n  Test threw exception\\n  Expression:\
    \ candidate([0, 1]) == 0\\n  MethodError: Cannot `convert` an object of type var\"\
    #prod_signs#1\" to an object of type Int64\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:7\\\
    n    convert(::Type{T}, !Matched::Base.TwicePrecision) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/twiceprecision.jl:262\\\
    n    ...\\n  Stacktrace:\\n   [1] convert(#unused#::Type{Union{Nothing, Int64}},\
    \ x::Function)\\n     @ Base ./some.jl:36\\n   [2] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpli604c8m.jl:14\\n   [3] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdl"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    iszero(a::Int64)\
    \ = a == 0\n    sign(a::Int64) = sign(a <=> 0)\n    magnitude(a::Int64) = abs(a)\n\
    \    arr_signs = map(sign, arr)\n    arr_magnitudes = map(magnitude, arr)\n  \
    \  if length(arr) > 0\n        return prod(arr_signs) * sum(arr_magnitudes)\n\
    \    else\n        return nothing\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \">\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpo9dj6uix.jl:14\nin expression starting at\
    \ /tmp/tmpo9dj6uix.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    return sum(abs.(arr)) * prod(sign.(arr))\n\
    end\n@testset \"tests\" begin\n    @test prod_signs([1, 2, 2, -4]) == -9\n   \
    \ @test prod_signs([0, 1]) == 0\n    @test prod_signs([]) == nothing\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2,\
    \ 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1,\
    \ 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t\
    @test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @testset not defined\nin expression starting\
    \ at /tmp/tmpr7q18eum.jl:18\nin expression starting at /tmp/tmpr7q18eum.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    prod = 1\n    mags = 0\n    for i =\
    \ 1:length(arr)\n        if arr[i] > 0\n            prod *= 1\n        elseif\
    \ arr[i] < 0\n            prod *= -1\n        else\n            prod *= 0\n  \
    \      end\n        mags += abs(arr[i])\n    end\n    return mags * prod\nend\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return \n    end\n    prod = 1\n    sum = 0\n    for i in arr\n \
    \       prod *= sign(i)\n        sum += abs(i)\n    end\n    return prod * sum\n\
    end\n@testset \"prod_signs\" begin\n    @test prod_signs([1, 2, 2, -4]) == -9\n\
    \    @test prod_signs([0, 1]) == 0\n    @test prod_signs([]) == nothing\nend\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @testset not defined\nin expression starting\
    \ at /tmp/tmpeq36vb5z.jl:24\nin expression starting at /tmp/tmpeq36vb5z.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if arr == Int64[]\
    \ \n        return nothing\n    end\n    prod_signs = 1\n    sum_mag = 0\n   \
    \ for x in arr\n        sum_mag += abs(x)\n        if x > 0\n            prod_signs\
    \ *= 1\n        elseif x < 0\n            prod_signs *= -1\n        else\n   \
    \         prod_signs *= 0\n        end\n    end\n    return sum_mag * prod_signs\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    arr_length = length(arr)\n\
    \    if arr_length == 0\n        return nothing\n    end\n    prod = 0\n    magnitude\
    \ = 0\n    for i in 1:arr_length\n        if arr[i] > 0\n            prod += 1\n\
    \        elseif arr[i] < 0\n            prod -= 1\n        end\n        magnitude\
    \ += abs(arr[i])\n    end\n    return prod * magnitude\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2ydr5j1e.jl:34\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: 18 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2ydr5j1e.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2ydr5j1e.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp2ydr5j1e.jl:35\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ 1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2ydr5j1e.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2ydr5j1e.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp2ydr5j1e.jl:36\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: 50 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2ydr5j1e.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2ydr5j1e.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp2ydr5j1e.jl:38\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: 60 == 20\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2ydr5j1e.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2ydr5j1e.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp2ydr5j1e.jl:39\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: 0 == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2ydr5j1e.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    signs = map(x ->\
    \ ifelse(x > 0, 1, ifelse(x < 0, -1, 0)), arr)\n    magnitude = map(abs, arr)\n\
    \    return prod(signs) * sum(magnitude)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpenewrdd0.jl:25\n  Expression: candidate(Vector{Int64}([]))\
    \ == nothing\n   Evaluated: 0 == nothing\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpenewrdd0.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpenewrdd0.jl:21\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    7     1      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpenewrdd0.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    all_signs = [1,\
    \ -1, 0]\n    total = 0\n    empty_arr = []\n    if isempty(arr)\n        return\
    \ Nothing\n    end\n    for i in arr\n        for j in all_signs\n           \
    \ total += abs(i) * j\n        end\n    end\n    return total\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpeu3dh20j.jl:31\\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\\n   Evaluated: 0 == -9\\nStacktrace:\\n [1] macro expansion\\\
    n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpeu3dh20j.jl:31 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpeu3dh20j.jl:30\\ntest set: Test\
    \ Failed at /tmp/tmpeu3dh20j.jl:33\\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\\n   Evaluated: 0 == -10\\nStacktrace:\\n [1] macro expansion\\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpeu3dh20j.jl:33 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpeu3dh20j.jl:30\\ntest set: Error\
    \ During Test at /tmp/tmpeu3dh20j.jl:34\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == nothing\\n  MethodError: Cannot `convert` an\
    \ object of type Type{Nothing} to an object of type Int64\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:7\\\
    n    convert(::Type{T}, !Matched::Base.TwicePrecision) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/twiceprecision.jl:262\\\
    n    ...\\n  Stacktrace:\\n   [1] convert(#unused#::Type{Union{Nothing, Int64}},\
    \ x::Type)\\n     @ Base ./some.jl:36\\n   [2] prod_signs(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpeu3dh20j.jl:17\\n   [3] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmpeu3dh20j.jl:34 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inl"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    sum_magn = 0\n \
    \   prod_sign = 1\n    for v in arr\n        if v > 0\n            sum_magn +=\
    \ v\n            prod_sign *= 1\n        elseif v < 0\n            sum_magn +=\
    \ -v\n            prod_sign *= -1\n        else\n            prod_sign *= 0\n\
    \        end\n    end\n    if sum_magn == 0\n        return nothing\n    else\n\
    \        return sum_magn * prod_sign\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    # TODO: write your\
    \ code here\n    return nothing\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0,\
    \ 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([]))\
    \ == nothing)\n\t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1,\
    \ 1, -1, 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1,\
    \ 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpc1q0utg2.jl:21\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: nothing == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc1q0utg2.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc1q0utg2.jl:20\ntest set: Test\
    \ Failed at /tmp/tmpc1q0utg2.jl:22\n  Expression: candidate([0, 1]) == 0\n   Evaluated:\
    \ nothing == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc1q0utg2.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc1q0utg2.jl:20\ntest set: Test\
    \ Failed at /tmp/tmpc1q0utg2.jl:23\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: nothing == -10\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc1q0utg2.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc1q0utg2.jl:20\ntest set: Test\
    \ Failed at /tmp/tmpc1q0utg2.jl:25\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: nothing == 20\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc1q0utg2.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc1q0utg2.jl:20\ntest set: Test\
    \ Failed at /tmp/tmpc1q0utg2.jl:26\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: nothing == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/juli"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpc1q0utg2.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    product = 1\n    sum = 0\n    for n\
    \ in arr\n        if n == 0\n            product *= 0\n        elseif n < 0\n\
    \            product *= -1\n        end\n        sum += abs(n)\n    end\n    product\
    \ * sum\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    m = 1\n    s = 1\n    for i in arr\n   \
    \     m *= abs(i)\n        s *= sign(i)\n    end\n    m * s\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9ffdvvr1.jl:29\n  Expression: candidate([1,\
    \ 2, 2, -4]) == -9\n   Evaluated: -16 == -9\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9ffdvvr1.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9ffdvvr1.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp9ffdvvr1.jl:31\n  Expression: candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10\n   Evaluated: -6 == -10\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9ffdvvr1.jl:31 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9ffdvvr1.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp9ffdvvr1.jl:33\n  Expression: candidate([2, 4, 1, 2, -1, -1,\
    \ 9]) == 20\n   Evaluated: 144 == 20\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9ffdvvr1.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9ffdvvr1.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp9ffdvvr1.jl:34\n  Expression: candidate([-1, 1, -1, 1]) ==\
    \ 4\n   Evaluated: 1 == 4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9ffdvvr1.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9ffdvvr1.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp9ffdvvr1.jl:35\n  Expression: candidate([-1, 1, 1, 1]) ==\
    \ -4\n   Evaluated: -1 == -4\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/T"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9ffdvvr1.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    \"\"\"\n    You\
    \ are given an array arr of integers and you need to return\n    sum of magnitudes\
    \ of integers multiplied by product of all signs\n    of each number in the array,\
    \ represented by 1, -1 or 0.\n    Note: return None for empty arr.\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp2lw744n.jl:1\nin expression starting at /tmp/tmpp2lw744n.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    signs = map(x ->\
    \ x > 0 ? 1 : (x < 0 ? -1 : 0), arr)\n    if !isempty(arr)\n        return prod(signs)\
    \ * sum(abs.(arr))\n    else\n        return nothing\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    signs = ones(length(arr))\n    for i in\
    \ 1:length(arr)\n        if arr[i] < 0\n            signs[i] = -1\n        elseif\
    \ arr[i] == 0\n            signs[i] = 0\n        end\n    end\n    return prod(signs)\
    \ * sum(abs.(arr))\nend\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\
    \t@test(candidate([1, 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1,\
    \ 1, 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    len = length(arr)\n\
    \    if len == 0 return nothing end\n    if len == 1 return abs(arr[1]) end\n\
    \    product = 1\n    for i in 1:len\n        product *= sign(arr[i])\n    end\n\
    \    sum_mag = 0\n    for i in 1:len\n        sum_mag += abs(arr[i])\n    end\n\
    \    return sum_mag * product\nend\n# Test Cases\nprod_signs([1, 2, 2, -4]) ==\
    \ -9\nprod_signs([0, 1]) == 0\nprod_signs([]) == nothing\nusing Test\n\n@testset\
    \ begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) == -9)\n\t\
    @test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1, 1]) == -10)\n\
    \t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2, 4, 1,\
    \ 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: MethodError: no method matching prod_signs(::Vector{Any})\n\
    Closest candidates are:\n  prod_signs(!Matched::Vector{Int64}) at /tmp/tmpizltfjwj.jl:12\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpizltfjwj.jl:29\nin expression\
    \ starting at /tmp/tmpizltfjwj.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    prod = 1\n    sums\
    \ = 0\n    for i in arr\n        if i > 0\n            prod *= 1\n           \
    \ sums += i\n        elseif i < 0\n            prod *= -1\n            sums +=\
    \ -i\n        else\n            prod *= 0\n        end\n    end\n    if sums ==\
    \ 0\n        return nothing\n    else\n        return prod * sums\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    signs = [-1, 1, 0]\n    arr2 = map(abs,\
    \ arr)\n    sum_mag = sum(arr2)\n    product = 1\n    for sign in signs\n    \
    \    sum_mag *= sign * arr2[findall(arr .== sign)]\n    end\n    return sum_mag\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpms532kec.jl:30\\n  Test threw\
    \ exception\\n  Expression: candidate([1, 2, 2, -4]) == -9\\n  MethodError: no\
    \ method matching *(::Vector{Int64}, ::Vector{Int64})\\n  Closest candidates are:\\\
    n    *(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\\\
    n    *(!Matched::StridedMatrix{T}, ::StridedVector{S}) where {T<:Union{Float32,\
    \ Float64, ComplexF32, ComplexF64}, S<:Real} at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/matmul.jl:44\\\
    n    *(::StridedVecOrMat, !Matched::LinearAlgebra.Adjoint{<:Any, <:LinearAlgebra.LQPackedQ})\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/lq.jl:266\\\
    n    ...\\n  Stacktrace:\\n   [1] prod_signs(arr::Vector{Int64})\\n     @ Main\
    \ /tmp/tmpms532kec.jl:21\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpms532kec.jl:30 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpms532kec.jl:29\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if isempty(arr)\n\
    \        return nothing\n    end\n    # if (sum(abs.(arr)) == 0) & (prod(arr .==\
    \ 0) == 0)\n    #     return 0\n    # end\n    # return sum(abs.(arr)) * prod(arr\
    \ .== 0) * prod(arr .!= 0)\n    return sum(abs.(arr)) * prod(sign.(arr))\nend\n\
    using Test\n\n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1,\
    \ 2, 2, -4]) == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\
    \t@test(candidate([2, 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1,\
    \ 1]) == 4)\n\t@test(candidate([-1, 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1,\
    \ 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    i, num_zeros, prod_signs,\
    \ sum_magnitudes = 0, 0, 1, 0\n    while i < length(arr)\n        if arr[i] >\
    \ 0\n            prod_signs *= 1\n            sum_magnitudes += arr[i]\n     \
    \   elseif arr[i] < 0\n            prod_signs *= -1\n            sum_magnitudes\
    \ += -arr[i]\n        else\n            num_zeros += 1\n        end\n        i\
    \ += 1\n    end\n    if num_zeros == length(arr)\n        return nothing\n   \
    \ else\n        return prod_signs * sum_magnitudes\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4])\
    \ == -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqsu8km4x.jl:37\n  Test threw exception\n\
    \  Expression: candidate([1, 2, 2, -4]) == -9\n  BoundsError: attempt to access\
    \ 4-element Vector{Int64} at index [0]\n  Stacktrace:\n   [1] getindex\n     @\
    \ ./array.jl:861 [inlined]\n   [2] prod_signs(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpqsu8km4x.jl:15\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpqsu8km4x.jl:37 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpqsu8km4x.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpqsu8km4x.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([0, 1]) == 0\n  BoundsError: attempt to access 2-element Vector{Int64}\
    \ at index [0]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861 [inlined]\n\
    \   [2] prod_signs(arr::Vector{Int64})\n     @ Main /tmp/tmpqsu8km4x.jl:15\n \
    \  [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpqsu8km4x.jl:38 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpqsu8km4x.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpqsu8km4x.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n  BoundsError: attempt to access 7-element\
    \ Vector{Int64} at index [0]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861\
    \ [inlined]\n   [2] prod_signs(arr::Vector{Int64})\n     @ Main /tmp/tmpqsu8km4x.jl:15\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpqsu8km4x.jl:39 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpqsu8km4x.jl:36\ntest set:\
    \ Error During Test at /tmp/"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqsu8km4x.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given an array arr of integers and you need to return\n\
    \    sum of magnitudes of integers multiplied by product of all signs\n    of\
    \ each number in the array, represented by 1, -1 or 0.\n    Note: return None\
    \ for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n  \
    \  >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\nfunction\
    \ prod_signs(arr::Vector{Int64})::Union{Int64, Nothing} \n    if length(arr) ==\
    \ 0\n        return nothing\n    end\n    product = 1\n    sum = 0\n    for x\
    \ in arr\n        if x > 0\n            product *= 1\n        elseif x < 0\n \
    \           product *= -1\n        else\n            product *= 0\n        end\n\
    \        sum += abs(x)\n    end\n    return sum * product\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = prod_signs;\n\t@test(candidate([1, 2, 2, -4]) ==\
    \ -9)\n\t@test(candidate([0, 1]) == 0)\n\t@test(candidate([1, 1, 1, 2, 3, -1,\
    \ 1]) == -10)\n\t@test(candidate(Vector{Int64}([])) == nothing)\n\t@test(candidate([2,\
    \ 4, 1, 2, -1, -1, 9]) == 20)\n\t@test(candidate([-1, 1, -1, 1]) == 4)\n\t@test(candidate([-1,\
    \ 1, 1, 1]) == -4)\n\t@test(candidate([-1, 1, 1, 0]) == 0)\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    8      8\n"
  exit_code: 0
  status: OK
