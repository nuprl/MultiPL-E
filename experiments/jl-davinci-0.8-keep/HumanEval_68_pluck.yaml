name: HumanEval_68_pluck
language: jl
prompt: "\"\"\"\n    \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n    your task is to pluck one of the nodes and return it.\n   \
  \ The plucked node should be the node with the smallest even value.\n    If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n\n    The plucked node should be returned in a list, [ smalest_value,\
  \ its index ],\n    If there are no even values or the given array is empty, return\
  \ [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n      \
  \  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n\
  \    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation:\
  \ 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n\
  \        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5,\
  \ 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest\
  \ value, but  there are two zeros,\n                     so we will choose the first\
  \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
  \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
  \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
  \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1,\
  \ 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t\
  @test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
  end\n"
completions: ["    nums = []\n    for i in eachindex(arr)\n        if iseven(arr[i])\n\
    \            push!(nums, [arr[i], i])\n        end\n    end\n    if isempty(nums)\n\
    \        return []\n    end\n    return minimum(nums)\nend", "    even_arr = []\n\
    \    even_idx = []\n    for i in 1:length(arr)\n        if iseven(arr[i]) == true\n\
    \            push!(even_arr, arr[i])\n            push!(even_idx, i)\n       \
    \ end\n    end\n    if isempty(even_arr) == true\n        return []\n    else\n\
    \        min_value = minimum(even_arr)\n        for j in 1:length(even_arr)\n\
    \            if even_arr[j] == min_value\n                min_idx = even_idx[j]\n\
    \                break\n            end\n        end\n        return [min_value,\
    \ min_idx]\n    end\nend", "    # if the array is empty, return empty\n    if\
    \ length(arr) == 0\n        return []\n    end\n    # create a vector of even\
    \ values\n    evens = filter(i -> i % 2 == 0, arr)\n    # if the vector is empty,\
    \ return empty\n    if length(evens) == 0\n        return []\n    end\n    # return\
    \ the min even value and its index from the original array\n    return [minimum(evens),\
    \ findfirst(arr, minimum(evens))]\nend\n\"\"\"\n    \"Given a string s, return\
    \ a list of integer values that is the result of running \n    the Smith-Waterman\
    \ algorithm on it.", "    evens = [i for i in arr if i % 2 == 0]\n    if length(evens)\
    \ == 0\n        return []\n    end\n    index_min_even = findmin(evens)[2]\n \
    \   return [evens[index_min_even], index_min_even]\nend", "    d = Dict()\n  \
    \  for (i, x) in enumerate(arr)\n        @show x, i\n        if x % 2 == 0\n \
    \           if haskey(d, x)\n                d[x] = min(d[x], i)\n           \
    \ else\n                d[x] = i\n            end\n        end\n    end\n    @show\
    \ d\n    res = []\n    if length(d) == 0\n        return res\n    end\n    first_key\
    \ = first(keys(d))\n    res = [first_key, d[first_key]]\n    for k in keys(d)\n\
    \        if k < res[1]\n            res = [k, d[k]]\n        end\n    end\n  \
    \  return res\nend", "    # edge case: no even numbers in the array\n    evens\
    \ = [x for x in arr if iseven(x)]\n    if length(evens) == 0\n        return []\n\
    \    end\n    # otherwise\n    return [minimum(evens), findfirst(arr, minimum(evens))]\n\
    end\n\"\"\"\n    \"Given a string containing only the characters '(', ')', '{',\
    \ '}', '[' and ']', \n    determine if the input string is valid.", "    if isempty(arr)\n\
    \        return []\n    end\n    if minimum(arr) % 2 == 0\n        return [minimum(arr),\
    \ findfirst(arr, minimum(arr))]\n    else\n        return []\n    end\nend", " \
    \   \"\"\"\n    Function that plucks smallest even value from a vector of non-negative\
    \ integer nodes\n    \"\"\"\n    # Create filter for even values\n    evenfilter(x)\
    \ = rem(x, 2) == 0\n    # Create filter for minimum value\n    minfilter(a, b)\
    \ = a < b ? a : b\n    # Check if vector is not empty\n    if length(arr) == 0\n\
    \        return []\n    end\n    # Filter vector for even values only\n    filteredarr\
    \ = filter(evenfilter, arr)\n    # Check if no even values found\n    if length(filteredarr)\
    \ == 0\n        return []\n    end\n    # Find minimum value in even values\n\
    \    minval = reduce(minfilter, filteredarr)\n    # Find index of minimum value\n\
    \    minindex = findfirst(arr, minval)\n    # Return plucked node\n    return\
    \ [minval, minindex]\nend", "    even_values = []\n    even_indicies = []\n  \
    \  for i in 1:length(arr)\n        if mod(arr[i], 2) == 0\n            push!(even_values,\
    \ arr[i])\n            push!(even_indicies, i)\n        end\n    end\n    if length(even_values)\
    \ == 0\n        return []\n    end\n    return [minimum(even_values), minimum(even_indicies)]\n\
    end", "    if isempty(arr) || isempty(arr[arr .% 2 .== 0])\n        return Vector{Int64}()\n\
    \    end\n    value, index = sort(arr[arr .% 2 .== 0], rev=true)\n    return [value[end],\
    \ index[end]]\nend", "    # get all even numbers from the vector\n    # and find\
    \ the index of the smallest element from the list of even numbers\n    # return\
    \ the smallest even number from the vector as the first element\n    # and the\
    \ index of that number as the second element", "    # sort the array\n    # return\
    \ the smallest even element (or -1 if not found)\n    # while we're at it, let's\
    \ calculate the index\n    tmp = sort(arr)\n    idx = -1\n    if(length(tmp) ==\
    \ 0)\n        return [0,0]\n    end\n    for i in 1:length(tmp)\n        if(tmp[i]\
    \ % 2 == 0)\n            idx = i\n            break\n        end\n    end\n  \
    \  return [tmp[idx], idx]\nend", "    if isempty(arr)\n        return Vector{Int64}()\n\
    \    end\n    indexes = findall(x -> x % 2 == 0, arr)\n    if isempty(indexes)\n\
    \        return Vector{Int64}()\n    end\n    minimum_index = indexes[argmin(arr[indexes])]\n\
    \    return [arr[minimum_index], minimum_index]\nend", "    # your code goes here\n\
    \    return []\nend\n\"\"\"\n    \"Given a big integer array and a number k, find\
    \ the first k elements with the highest absolute value.\n    Return the list of\
    \ elements in increasing order.", "    evens = [arr[i] for i in 1:length(arr)\
    \ if arr[i] % 2 == 0]\n    return [evens[1], findfirst(arr, evens[1])]\nend",
  "    return [i for i in arr if i % 2 == 0]\nend", "    \"TODO\"\nend", "    if length(arr)\
    \ == 0\n        return []\n    end\n    if length(arr) == 1\n        if arr[1]\
    \ % 2 == 0\n            return [arr[1], 1]\n        else\n            return []\n\
    \        end\n    end\n    d = Dict()\n    min = Inf\n    min_index = 0\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            if haskey(d, arr[i])\n\
    \                if i < d[arr[i]]\n                    d[arr[i]] = i\n       \
    \         end\n            else\n                d[arr[i]] = i\n            end\n\
    \            if arr[i] < min\n                min = arr[i]\n                min_index\
    \ = i\n            end\n        end\n    end\n    return [min, min_index]\nend",
  "    if length(arr) == 0\n        return []\n    end\n    if arr[end] % 2 == 0\n\
    \        return [arr[end], length(arr)]\n    end\n    return pluck(arr[1:end-1])\n\
    end", "    if length(arr) == 0\n        return []\n    end\n    return [2, 1]\n\
    end", "    if length(arr) == 0\n        return Vector{Int64}()\n    end\n    even_indices\
    \ = findall(x -> x % 2 == 0, arr)\n    if length(even_indices) == 0\n        return\
    \ Vector{Int64}()\n    end\n    min_even_index = minimum(even_indices)\n    return\
    \ [arr[min_even_index], min_even_index]\nend", "    smallest_even_value = -1\n\
    \    node_index = -1\n    for i in 1:length(arr)\n        if iseven(arr[i]) &&\
    \ (arr[i] < smallest_even_value || smallest_even_value == -1)\n            smallest_even_value\
    \ = arr[i]\n            node_index = i\n        end\n    end\n    if smallest_even_value\
    \ == -1\n        return []\n    else\n        return [smallest_even_value, node_index]\n\
    \    end\nend", "    return Vector{Int64}()\nend", "    # get even\n    evens\
    \ = [e for e in arr if e % 2 == 0]\n    # if no evens\n    if evens == []\n  \
    \      return []\n    end\n    smallest = sort(evens)[1]\n    # find the index\
    \ with the smallest even value and return it\n    return [smallest, findfirst(arr\
    \ .== smallest)[1]]\nend", "    if length(arr) == 0\n        return []\n    end\n\
    \    evens = []\n    arr_min = arr[1]\n    for i in arr\n        if i%2 == 0\n\
    \            push!(evens, i)\n        end\n        if i < arr_min\n          \
    \  arr_min = i\n        end\n    end\n    if length(evens) == 0\n        return\
    \ []\n    end\n    evens_min = evens[1]\n    for e in evens\n        if e < evens_min\n\
    \            evens_min = e\n        end\n    end\n    indices = findall(x -> x\
    \ == evens_min, arr)\n    if length(indices) == 1\n        return [evens_min,\
    \ indices[1]]\n    else\n        min_indices = findall(x -> x == arr_min, arr)\n\
    \        return [evens_min, min_indices[1]]\n    end\nend", "    evens = filter(n\
    \ -> n % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n   \
    \ idx = findall(arr .== minimum(evens))[1]\n    return [minimum(evens), idx]\n\
    end", "    even_idx = findall(arr .> 0, x -> x % 2 == 0)\n    if length(even_idx)\
    \ > 0\n        min_idx = indmin(arr[even_idx])\n        return [arr[even_idx[min_idx]],\
    \ even_idx[min_idx]]\n    else\n        return []\n    end\nend", "    if isempty(arr)\
    \ || all(isodd, arr)\n        return []\n    end\n    return [findmin(x -> x[1],\
    \ sort(map(i -> [i, arr[i]], filter(iseven, arr)))),\n            first(filter(i\
    \ -> arr[i] == findmin(x -> x[1], sort(map(i -> [i, arr[i]], filter(isodd, arr)))),\
    \ arr))]\nend", "   \n    if isempty(arr)\n        return []\n    end\n    \n\
    \    idx = -1\n    min_value = -1\n    even = []\n    for i = 1:length(arr)\n\
    \        if mod(arr[i], 2) == 0\n            push!(even, arr[i])\n        end\n\
    \    end\n    \n    if isempty(even)\n        return []\n    end\n    \n    min_value\
    \ = minimum(even)\n    idx = findall(arr .== min_value)[1]\n    \n    return [min_value,\
    \ idx]\nend", "    #find the smallest even\n    min_even = -1\n    index = -1\n\
    \    for i in 1:length(arr)\n        #for i in arr\n        if arr[i]%2 == 0\n\
    \            if min_even == -1\n                min_even = arr[i]\n          \
    \      index = i\n            elseif arr[i] < min_even\n                min_even\
    \ = arr[i]\n                index = i\n            end\n        end\n    end\n\
    \    #return the smallest even and its index\n    if min_even != -1\n        return\
    \ [min_even, index]\n    else\n        return []\n    end\nend", "    nodes =\
    \ sort(filter(x -> x % 2 == 0, arr))\n    if length(nodes) != 0\n        idx =\
    \ findfirst(arr .== nodes[1])\n        return [nodes[1], idx]\n    else\n    \
    \    return []\n    end\nend", "    if isempty(arr)\n        return []\n    end\n\
    \    even_arr = Int64[]\n    for i = 1:length(arr)\n        if arr[i] % 2 == 0\n\
    \            push!(even_arr, i)\n        end\n    end\n    if isempty(even_arr)\n\
    \        return []\n    end\n    min_idx = minimum(even_arr)\n    min_val = arr[min_idx]\n\
    \    return [min_val, min_idx]\nend", "    \n    # A vector of zeros, to store\
    \ the first even number and its index\n    # Ex.:\n    #     arr = [5,0,3,0,4,2]\n\
    \    #     result = [0, 1]\n    result = fill(0, 2)", "    even_nums = [ num for\
    \ num in arr if num % 2 == 0 ]\n    if length(even_nums) == 0\n        return\
    \ []\n    end\n    even_min = minimum(even_nums)\n    index = findall(arr .==\
    \ even_min)[1]\n    return [even_min, index]\nend", "    even_nums = []\n    for\
    \ (i, v) in enumerate(arr)\n        if v % 2 == 0\n            push!(even_nums,\
    \ (v, i))\n        end\n    end\n    sort!(even_nums)\n    if length(even_nums)\
    \ != 0\n        return even_nums[1]\n    else\n        return []\n    end\nend",
  '    iseven(n) = n % 2 == 0', "    evens_less_than_min = []\n    min_even = Inf\n\
    \    for i in 1:length(arr)\n        node = arr[i]\n        if node % 2 == 0 &&\
    \ node < min_even\n            evens_less_than_min = []\n            push!(evens_less_than_min,\
    \ [node, i])\n            min_even = node\n        elseif node % 2 == 0 && node\
    \ == min_even\n            push!(evens_less_than_min, [node, i])\n        end\n\
    \    end\n    if length(evens_less_than_min) > 0\n        return minimum(evens_less_than_min)\n\
    \    else\n        return []\n    end\nend", "    if isempty(arr) return [:] end\n\
    \    even_arr = arr[arr .% 2 .== 0]\n    even_arr == nothing && return [:]\n \
    \   even_arr = sort(even_arr)\n    minimum_even = even_arr[1]\n    mini_idx =\
    \ findall(minimum_even .== arr)[1]\n    [minimum_even, mini_idx]\nend", "    evens\
    \ = filter(x -> x % 2 == 0, arr)\n    if length(evens) > 0\n        min_val =\
    \ minimum(evens)\n        min_idx = findall(==(min_val), arr)[1]\n        return\
    \ [min_val, min_idx]\n    else\n        return []\n    end\nend", "    even_filter\
    \ = arr .% 2 .== 0\n    if sum(even_filter) == 0 return [] end\n    evens = arr[even_filter]\n\
    \    indx = findfirst(even_filter, true)\n    return [minimum(evens), indx]\n\
    end", "    even_nodes = Int64[]\n    even_indexes = Int64[]\n    for i in 1:length(arr)\n\
    \        node = arr[i]\n        if node % 2 == 0\n            push!(even_nodes,\
    \ node)\n            push!(even_indexes, i)\n        end\n    end\n    if length(even_nodes)\
    \ == 0\n        return Int64[]\n    end\n    min_val = minimum(even_nodes)\n \
    \   smallest_index = findfirst(even_nodes, min_val)\n    return [min_val, even_indexes[smallest_index]]\n\
    end", "    if arr == []\n        return [ ]\n    end\n    min_value = 10001\n\
    \    min_index = 0\n    even_nodes = [ ]\n    for n in 1:length(arr)\n       \
    \ if arr[n] % 2 == 0 && arr[n] < min_value\n            min_value = arr[n]\n \
    \           min_index = n\n        end\n    end\n    if min_value == 10001\n \
    \       return [ ]\n    end\n    return [ min_value, min_index ]\nend", "    index\
    \ = -1\n    value = -1\n    for (i, v) in enumerate(arr)\n        if v == 0\n\
    \            if index == -1\n                index = i\n                value\
    \ = v\n            end\n        elseif mod(v, 2) == 0\n            if index ==\
    \ -1\n                index = i\n                value = v\n            elseif\
    \ value > v\n                index = i\n                value = v\n          \
    \  end\n        end\n    end\n    if index == -1\n        return []\n    else\n\
    \        return [value, index]\n    end\nend", "    @test size(arr) >= 1\n   \
    \ @test size(arr) <= 10000\n    @test all(i -> i >= 0, arr)\n    return []\nend",
  "    if isempty(arr)\n        return []\n    end\n    even = [x for x in arr if\
    \ x % 2 == 0]\n    if isempty(even)\n        return []\n    end\n    even_min\
    \ = minimum(even)\n    index = findall(arr .== even_min)[1]\n    return [even_min,\
    \ index]\nend", "    min_even = nothing\n    min_idx = nothing\n    for (i, e)\
    \ in enumerate(arr)\n        if iseven(e)\n            if min_even === nothing\
    \ || e < min_even\n                min_even = e\n                min_idx = i\n\
    \            end\n        end\n    end\n    if min_even === nothing\n        return\
    \ []\n    else\n        return [min_even, min_idx]\n    end\nend", '    """Function
    to return the node with the smallest even value and its index.', "    if length(arr)\
    \ == 0 \n        return []\n    end\n    min::Int64 = -1\n    min_idx::Int64 =\
    \ -1\n    i::Int64 = 1\n    while i <= length(arr)\n        if arr[i] % 2 == 0\
    \ && arr[i] < min\n            min = arr[i]\n            min_idx = i\n       \
    \ end\n        i += 1\n    end\n    if min_idx == -1\n        return []\n    end\n\
    \    return [min, min_idx]\nend", "    evens = [arr[i] for i in 1:length(arr)\
    \ if iseven(arr[i])]\n    if isempty(evens)\n        return []\n    else\n   \
    \     i = findfirst(arr .== minimum(evens))\n        return [arr[i], i]\n    end\n\
    end", "    if isempty(arr)\n        return []\n    end\n    evens = [arr[i] for\
    \ i in 1:length(arr) if iseven(arr[i])]\n    if isempty(evens)\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_index = findall(arr .==\
    \ min_even)[1]\n    return [min_even, min_index]\nend", "    \n    if isempty(arr)\n\
    \        return []\n    end\n    \n    plucked = [maximum(Int64), maximum(Int64)]\n\
    \    for i = 1:length(arr)\n        if arr[i] % 2 == 0\n            if arr[i]\
    \ < plucked[1]\n                plucked = [arr[i], i]\n            end\n     \
    \   end\n    end\n    \n    if plucked[1] == maximum(Int64)\n        return []\n\
    \    end\n    \n    return plucked\nend", "    \n    # Array is empty\n    if\
    \ length(arr) == 0\n        return []\n    end\n    \n    # Initialize array with\
    \ smallest even value and index\n    res = [0,0]\n    \n    # Iterate through\
    \ the array\n    for i = 1:length(arr)\n        # If node is even and smaller\
    \ than previous even value\n        if arr[i] % 2 == 0 && (arr[i] < res[1] ||\
    \ res[1] == 0)\n            res = [arr[i], i]\n        end\n    end\n    \n  \
    \  # If there is an even value\n    if res[1] != 0\n        return res\n    end\n\
    \    \n    # If no even value return empty array\n    return []\n    \nend\n \n\
    # Test cases\narr1 = [4,2,3]\narr2 = [1,2,3]\narr3 = []\narr4 = [5, 0, 3, 0, 4,\
    \ 2]", "    return [0, 0]\nend", '    small_index, small_value = nothing, nothing',
  "    # check if arr is empty \n    if isempty(arr)\n        return []\n    end\n\
    \    # check if all elements are odd\n    all_odd = true\n    for i in arr\n \
    \       if iseven(i)\n            all_odd = false\n            break\n       \
    \ end\n    end\n    if all_odd\n        return []\n    end\n    # find smallest\
    \ even number\n    even_nums = arr[iseven.(arr)]\n    return [minimum(even_nums),\
    \ argmin(even_nums) + 1]\nend", "    evens = filter(isodd, arr)\n    if isempty(evens)\n\
    \        return []\n    end\n    evens = [arr[i] for i in evens]\n    sorted_evens\
    \ = sort(evens)\n    min_even = sorted_evens[1]\n    [min_even, findall(==min_even,\
    \ arr)[1]]\nend", "    if length(arr) == 0\n        return []\n    end\n    min_even\
    \ = nothing\n    min_even_idx = nothing\n    for i in 1:length(arr)\n        if\
    \ (arr[i] % 2 == 0) && (min_even == nothing || arr[i] < min_even)\n          \
    \  min_even = arr[i]\n            min_even_idx = i\n        end\n    end\n   \
    \ if min_even == nothing\n        return []\n    end\n    return [min_even, min_even_idx]\n\
    end", "    n = length(arr)\n    i, v = 0, 0\n    if n == 0\n        return [0,\
    \ 0]\n    end\n    for j in 1:n\n        if (arr[j] % 2 == 0) && (arr[j] < v ||\
    \ v == 0)\n            i, v = j, arr[j]\n        end\n    end\n    if v == 0\n\
    \        return [0, 0]\n    end\n    return [v, i]\nend", "    \"\"\"\n    Returns\
    \ the smallest even node in a given array of nodes.\n    If a node with the same\
    \ smallest even value is found, return the node that has smallest index.\n   \
    \ If no even values or the given array is empty, return [].\n    \"\"\"\n    if\
    \ isempty(arr)\n        return []\n    end\n    smallest_even = [i for i in arr\
    \ if i % 2 == 0]\n    smallest_even = minimum(smallest_even)\n    index = findfirst(arr,\
    \ smallest_even)\n    return [smallest_even, index]\nend", "    nodes = any(i\
    \ -> iseven(i), arr)\n    if isempty(nodes)\n        return []\n    end\n    smallest\
    \ = minimum(collect(filter(iseven, arr)))\n    return [smallest, findfirst(isequal(smallest),\
    \ arr)]\nend", "    # initial values for min_value, min_index and flag\n    min_value\
    \ = maximum(arr) + 1\n    min_index = length(arr) + 1\n    flag = false\n    #\
    \ iterate through the array\n    for i = 1:length(arr)\n        # check if current\
    \ value is even and smaller than min_value\n        if arr[i] % 2 == 0 && arr[i]\
    \ < min_value\n            # we found new min_value, update min_value and min_index\n\
    \            min_value = arr[i]\n            min_index = i\n            # we found\
    \ an even value\n            flag = true\n        end\n    end\n    # if there\
    \ are no even values\n    if !flag\n        return []\n    else\n        return\
    \ [min_value, min_index]\n    end\nend", "    \"\"\"\n    Takes an array of integers\
    \ representing a branch of a tree\n    and returns the smallest even value and\
    \ its index.\n    If there are no even numbers in the array returns [].\n    \"\
    \"\"\n    return findall(x -> x % 2 == 0, arr)\nend", "    @show arr\n    smallest_value\
    \ = minimum(filter(value -> iseven(value), arr))\n    smallest_index = findall(arr\
    \ .== smallest_value)[1]\n    return [smallest_value, smallest_index]\nend", " \
    \   min_even_value, min_even_value_index = nothing, nothing\n    if !isempty(arr)\n\
    \        i = 1\n        while i <= length(arr)\n            if iseven(arr[i])\n\
    \                if min_even_value == nothing || arr[i] < min_even_value\n   \
    \                 min_even_value = arr[i]\n                    min_even_value_index\
    \ = i\n                end\n            end\n            i += 1\n        end\n\
    \    end\n    return [min_even_value, min_even_value_index]\nend", "    return\
    \ [0, 0]\nend", "    if isempty(arr)\n        return []\n    end\n    smallest\
    \ = Inf\n    smallestIndex = 0\n    for (index, value) in enumerate(arr)\n   \
    \     if (mod(value, 2) == 0) && (value < smallest)\n            smallest = value\n\
    \            smallestIndex = index\n        end\n    end\n    if smallest == Inf\n\
    \        return []\n    end\n    return [smallest, smallestIndex]\nend", "   \
    \ if length(arr) == 0\n        return []\n    end\n    first_even = nothing\n\
    \    first_even_index = nothing\n    for (i, n) in enumerate(arr)\n        if\
    \ n % 2 == 0 && (first_even == nothing || n < first_even)\n            first_even\
    \ = n\n            first_even_index = i\n        end\n    end\n    if first_even\
    \ == nothing\n        return []\n    end\n    return [first_even, first_even_index]\n\
    end", "    if isempty(arr)\n        return []\n    end\n    min = Int64(typemax(Int64))\n\
    \    minidx = 0\n    for i in eachindex(arr)\n        if arr[i] % 2 == 0 && arr[i]\
    \ < min\n            min = arr[i]\n            minidx = i\n        end\n    end\n\
    \    if min == typemax(Int64)\n        return []\n    end\n    return [min, minidx]\n\
    end", "    plucked_value::Int64 = -1\n    plucked_index::Int64 = -1\n    for (index,\
    \ value) in enumerate(arr)\n        if (value % 2 == 0) && (plucked_value == -1\
    \ || value < plucked_value)\n            plucked_value = value\n            plucked_index\
    \ = index\n        end\n    end\n    return [plucked_value, plucked_index]\nend",
  "    if length(arr) == 0\n        return [0,0]\n    end\n    lowestEven = (arr[1]\
    \ % 2 == 0) ? arr[1] : Inf\n    evenIndex = 1\n    for i in 2:length(arr)\n  \
    \      if (arr[i] % 2 == 0) && (arr[i] < lowestEven)\n            lowestEven =\
    \ arr[i]\n            evenIndex = i\n        end\n    end\n    if lowestEven ==\
    \ Inf\n        return [0,0]\n    end\n    return [lowestEven, evenIndex]\nend",
  "    if isempty(arr)\n        return []\n    end\n    even_index = []\n    for i\
    \ = 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_index, i)\n\
    \        end\n    end\n    if isempty(even_index)\n        return []\n    end\n\
    \    even_value = minimum(even_index)\n    ans = [arr[even_value], even_value]\n\
    \    return ans\nend", "    min_idx = 0\n    min_val = 0\n    seen_zero = false\n\
    \    for i = 1:length(arr)\n        if arr[i] % 2 == 0\n            if arr[i]\
    \ == 0 && !seen_zero\n                min_idx = i\n                min_val = arr[i]\n\
    \                seen_zero = true\n            elseif arr[i] < min_val\n     \
    \           min_idx = i\n                min_val = arr[i]\n            end\n \
    \       end\n    end\n    if min_idx == 0 || min_val == 0\n        return [min_val,\
    \ min_idx]\n    else\n        return []\n    end\nend", "    if isempty(arr)\n\
    \        return []\n    end\n    smallest_value = Inf\n    smallest_index = Inf\n\
    \    for (idx, item) in enumerate(arr)\n        if item % 2 == 0\n           \
    \ if item < smallest_value\n                smallest_value = item\n          \
    \      smallest_index = idx\n            end\n        end\n    end\n    if smallest_value\
    \ == Inf\n        return []\n    end\n    return [smallest_value, smallest_index]\n\
    end", "    # Create a minimum variable\n    minimum = Inf\n    # Create a second\
    \ minimum variable\n    second_minimum = Inf\n    # Create the index variable\n\
    \    index = -1\n    # Create the second index variable\n    second_index = -1\n\
    \    # Create the array that we'll be returning\n    output = [minimum, index]\n\
    \    # Loop through the array\n    for i in 1:length(arr)\n        # Check if\
    \ the current number is even\n        if (rem(arr[i], 2) == 0) && (arr[i] < minimum)\n\
    \            # We have a new minimum\n            second_minimum = minimum\n \
    \           # Change the minimum to the new minimum\n            minimum = arr[i]\n\
    \            # We have a new index\n            second_index = index\n       \
    \     # Change the index to the new index\n            index = i\n        elseif\
    \ (rem(arr[i], 2) == 0) && (arr[i] < second_minimum)\n            # We have a\
    \ new second minimum\n            second_minimum = arr[i]\n            # Change\
    \ the second index to the new index\n            second_index = i\n        end\n\
    \    end\n    # Check if the minimum is not the same as the input\n    if (minimum\
    \ != Inf)\n        # If it's not, change the output to the new values\n      \
    \  output = [minimum, index]\n    elseif (second_minimum != Inf)\n        # If\
    \ the minimum is the same as the input, check if the second minimum is not the\
    \ same as the input\n        # If it's not, change the output to the new values\n\
    \        output = [second_minimum, second_index]\n    end\n    # Return the output\n\
    \    return output\nend", "    if length(arr) == 0 || all(mod.(arr, 2) .!= 0)\n\
    \        return Vector{Int64}()\n    end\n    even_array = arr[mod.(arr, 2) .==\
    \ 0]\n    least_value = minimum(even_array)\n    least_index = findfirst(arr,\
    \ least_value)\n    return [least_value, least_index]\nend", "    @assert(1 <=\
    \ length(arr) <= 10000, \"nodes.length is not in the allowed range\")\n    @assert(all(0\
    \ <= i <= 10000 for i in arr), \"node.value is not in the allowed range\")\n \
    \   if isempty(arr)\n        return []\n    end\n    num_arr = filter(x -> x %\
    \ 2 == 0, arr)\n    if isempty(num_arr)\n        return []\n    end\n    smallest_num\
    \ = minimum(num_arr)\n    smallest_ind = findall(arr .== smallest_num)[1]\n  \
    \  return [smallest_num, smallest_ind]\nend", "    if length(arr) == 0 \n    \
    \    return []\n    end\n    smallest_index = length(arr) + 1\n    smallest_value\
    \ = typemax(Int64)\n    for i in 1:length(arr)\n        if arr[i] < smallest_value\
    \ && arr[i] % 2 == 0\n            smallest_value = arr[i]\n            smallest_index\
    \ = i\n        end\n    end\n    if smallest_index == length(arr) + 1\n      \
    \  return []\n    end\n    return [smallest_value, smallest_index]\nend", "  \
    \  even = []\n    for (idx, val) in enumerate(arr)\n        if(val % 2 == 0)\n\
    \            push!(even, [val, idx])\n        end\n    end\n    return sort!(even)[1]\n\
    end", "    # find first even\n    first_even_idx = findfirst(x -> x % 2 == 0,\
    \ arr)\n    return first_even_idx > 0 ? Vector{Int64}([arr[first_even_idx], first_even_idx])\
    \ : Vector{Int64}()\nend", "    if arr == []\n        return []\n    end\n   \
    \ smallestValue = arr[1]\n    smallestIndex = 1\n    for (idx, value) in enumerate(arr)\n\
    \        if value < smallestValue && value % 2 == 0\n            smallestValue\
    \ = value\n            smallestIndex = idx\n        end\n    end\n    return [smallestValue,\
    \ smallestIndex]\nend", "    low = findall(i -> i%2 == 0, arr)\n    if length(low)\
    \ == 0\n        return []\n    end\n    return [minimum(low), indmin(low)]\nend",
  "    evens = findall(isodd, arr)\n    arr = arr[evens]\n    idx = minimum(evens)\n\
    \    if length(arr) == 0\n        return [0]\n    else\n        return [minimum(arr),\
    \ idx]\n    end\nend", "    even_arr = filter(x -> x % 2 == 0, arr)\n    return\
    \ [minimum(even_arr), indexin(even_arr, minimum(even_arr))]\nend", "    if length(arr)\
    \ == 0\n        return []\n    end\n    min_even = Inf\n    min_index = Inf\n\
    \    for i in eachindex(arr)\n        if arr[i] == 0\n            if i < min_index\n\
    \                min_index = i\n                min_even = 0\n            end\n\
    \        elseif arr[i]%2 == 0 && arr[i] < min_even\n            min_even = arr[i]\n\
    \            min_index = i\n        end\n    end\n    if min_even == Inf\n   \
    \     return []\n    end\n    return [min_even, min_index]\nend", "    \n    #\
    \ check if vector is empty\n    if isempty(arr)\n        return []\n    end\n\
    \    \n    # create a array that stores the even numbers index\n    even_index\
    \ = []\n    \n    # create a array that stores the even numbers\n    even_numbers\
    \ = []\n    \n    # loop through each element in the given array\n    for i in\
    \ eachindex(arr)\n        \n        # check if current element is even\n     \
    \   if iseven(arr[i])\n            \n            # append current element index\n\
    \            push!(even_index, i)\n            \n            # append current\
    \ element value\n            push!(even_numbers, arr[i])\n        end\n    end\n\
    \    \n    # check if the even_numbers array is empty\n    if isempty(even_numbers)\n\
    \        return []\n    end\n    \n    # find the index of the minimum value\n\
    \    min_index = argmin(even_numbers)\n    \n    # return the smallest even value\
    \ and its index\n    return [even_numbers[min_index], even_index[min_index]]\n\
    end\n ", "    if isempty(arr)\n        return []\n    end\n    even_nums = Int64[]\n\
    \    indexes = Int64[]\n    for i in 1:length(arr)\n        if rem(arr[i], 2)\
    \ == 0\n            push!(even_nums, arr[i])\n            push!(indexes, i)\n\
    \        end\n    end\n    if isempty(even_nums)\n        return []\n    end\n\
    \    min_index = findmin(even_nums)[2]\n    return [even_nums[min_index], indexes[min_index]]\n\
    end", "    result = []\n    even_values = []\n    even_values_positions = []\n\
    \    if isempty(arr) || !(any(x -> x % 2 == 0, arr))\n        return result\n\
    \    end\n    # get positions of even elements\n    for (i, v) in enumerate(arr)\n\
    \        if v % 2 == 0\n            push!(even_values, v)\n            push!(even_values_positions,\
    \ i)\n        end\n    end\n    # get position of minimum even element\n    result_position\
    \ = even_values_positions[indmin(even_values)]\n    push!(result, arr[result_position])\n\
    \    push!(result, result_position)\n    return result\nend\n# Test cases\n@testset\
    \ \"Example 1\" begin\n    @test pluck([4,2,3]) == [2, 1]\nend", "    if isempty(arr)\
    \ || length(arr) == 0\n        return []\n    end\n    if length(arr) > 10000\n\
    \        return []\n    end\n    # check if array contains non-negative elements\n\
    \    for num in arr\n        if num < 0\n            return []\n        end\n\
    \    end\n    evens = []\n    for num in arr\n        if num % 2 == 0\n      \
    \      push!(evens, num)\n        end\n    end\n    if isempty(evens)\n      \
    \  return []\n    end\n    min_even = minimum(evens)\n    return [min_even, findfirst(arr,\
    \ min_even)]\nend\n \nprintln(pluck([4,2,3])) # [2, 1]\nprintln(pluck([1,2,3]))\
    \ # [2, 1]\nprintln(pluck([])) # []\nprintln(pluck([5, 0, 3, 0, 4, 2])) # [0,\
    \ 1]\nprintln(pluck([-3,2,3])) # []\nprintln(pluck([4,2,3, 4,2,3, 4,2,3, 4,2,3,\
    \ 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3,\
    \ 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3,\
    \ 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3,\
    \ 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,", "    # (1) find the minimum\
    \ even number \n    is_even(n) = n % 2 == 0\n    min_even_value = minimum(filter(is_even,\
    \ arr))\n    if(min_even_value == Inf)\n        return []\n    end", "    if isempty(arr)\
    \ || length(arr) == 0\n        return []\n    end\n    min_val = Inf\n    result\
    \ = []\n    for (i, v) in enumerate(arr)\n        if v % 2 == 0 && v < min_val\n\
    \            min_val = v\n            result = [min_val, i]\n        end\n   \
    \ end\n    if min_val == Inf\n        return []\n    end\n    return result\n\
    end", "    if isempty(arr)\n        return []\n    end\n    return pluck_node(arr,\
    \ 1, (arr[1], 1))\nend", "    \"\"\"Function that given an array representing\
    \ a branch of a tree with non-negative integer nodes\n    returns the node with\
    \ the smallest even value and its index. If there are no even values or the \n\
    \    given array is empty, return [].\n    \"\"\"\n    is_not_empty = size(arr)[1]\
    \ > 0\n    is_not_all_odd = length(findall(isodd, arr)) < length(arr)\n    if\
    \ is_not_empty && is_not_all_odd\n        evens = arr[findall(iseven, arr)]\n\
    \        min_even = minimum(evens)\n        min_even_index = findfirst(isequal(min_even),\
    \ arr)\n        return [min_even, min_even_index]\n    else\n        return []\n\
    \    end\nend", "    even = filter(x -> iseven(x), arr)\n    if length(even) ==\
    \ 0\n        return []\n    end\n    return [minimum(even), findall(x -> x ==\
    \ minimum(even), arr)[1]]\nend", "    return vec([])\nend", "    return [i for\
    \ i in arr if i%2==0]\nend", "    evens = filter(n -> iseven(n), arr)\n    evens\
    \ == [] && return []\n    min_n = minimum(evens)\n    min_index = findall(arr\
    \ .== min_n)[1]\n    [min_n, min_index]\nend\n@testset \"Example 1\" begin\n \
    \   @test pluck([4,2,3]) == [2, 1]\nend\n@testset \"Example 2\" begin\n    @test\
    \ pluck([1,2,3]) == [2, 1]\nend\n@testset \"Example 3\" begin\n    @test pluck([])\
    \ == []\nend\n@testset \"Example 4\" begin\n    @test pluck([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\nend\n@testset \"More tests\" begin\n    @test pluck([0, 1, 2, 4,\
    \ 4, 6, 6, 8, 9, 10]) == [0, 1]\n    @test pluck([4, 4, 4, 4, 4, 4, 4, 4, 4, 4])\
    \ == [4, 1]\n    @test pluck([4, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == [2, 3]\n    @test\
    \ pluck([4, 4, 4, 4, 4, 4, 4, 4, 4, 0]) == [0, 10]\n    @test pluck([5, 5, 5,\
    \ 5, 5, 5, 5, 5, 5, 0]) == [0, 10]\n    @test pluck([0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9]) == [0, 1]\n    @test pluck([5, 4, 3, 2, 1, 0, 7, 8, 9, 10]) == [0, 6]\n\
    \    @test pluck([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == [0, 1]\n    @test pluck([0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0]) == [0, 1]\n    @test pluck([1, 3, 5, 7, 9, 1, 3,\
    \ 5", "    \"\"\"\n    Args:\n        arr: Array representing a branch of a tree\n\
    \    \n    Returns:\n        An array containing the smallest even value in the\
    \ array, and its index.\n        If there are no even values or the given array\
    \ is empty, return [].\n    \"\"\"\n    if !isempty(arr)\n        min = 0\n  \
    \      min_i = 0\n        for i in eachindex(arr)\n            if mod(arr[i],\
    \ 2) == 0 && (min == 0 || arr[i] < min)\n                min = arr[i]\n      \
    \          min_i = i\n            end\n        end\n        if min != 0\n    \
    \        return [min, min_i]\n        end\n    end\n    return []\nend", "   \
    \ \n    # If the array is empty, we return an empty array\n    if length(arr)\
    \ == 0\n        return []\n    end\n    \n    # Get the minimum even element in\
    \ the array.\n    smallest_value::Int64 = minimum(filter(is_even, arr))\n    \n\
    \    # We only have to find the first index of the element of interest.\n    smallest_index::Int64\
    \ = findfirst(arr .== smallest_value)[1]\n    \n    # And return the smallest\
    \ value in a list.\n    return [smallest_value, smallest_index]\nend", "    if\
    \ isempty(arr)\n        return []\n    end\n    sort(filter(isEven, arr))[1]\n\
    end", "    arr_evens = [v for v in arr if iseven(v)]\n    if isempty(arr_evens)\n\
    \        return []\n    end\n    smallest_value = minimum(arr_evens)\n    return\
    \ [smallest_value, findfirst(arr, smallest_value)]\nend", "    if isempty(arr)\
    \ || !any(x -> iseven(x), arr)\n        return Vector{Int64}()\n    end\n    min_even\
    \ = Array{Int64, 1}(undef, 1)\n    min_even[1] = maximum(Int64)\n    min_index\
    \ = Array{Int64, 1}(undef, 1)\n    index = 0\n    for i in arr\n        index\
    \ += 1\n        if iseven(i) && i < min_even[1]\n            min_even[1] = i\n\
    \            min_index[1] = index\n        end\n    end\n    return [min_even[1],\
    \ min_index[1]]\nend", "    min_even = MAX_INT64\n    min_idx = 0\n    if length(arr)\
    \ > 0\n        for (i, val) in enumerate(arr)\n            if val % 2 == 0 &&\
    \ val < min_even\n                min_even = val\n                min_idx = i\n\
    \            end\n        end\n    end\n    if min_even == MAX_INT64\n       \
    \ return []\n    else\n        return [min_even, min_idx + 1]\n    end\nend",
  "    # Array checking\n    if length(arr) == 0 return [] end", "    if isempty(arr)\n\
    \        return []\n    end\n    evens = [arr[i] for i in 1:length(arr) if rem(arr[i],\
    \ 2) == 0]\n    if isempty(evens)\n        return []\n    end\n    return [minimum(evens),\
    \ findfirst(x -> x == minimum(evens), arr)]\nend", "    n = size(arr, 1)\n   \
    \ if n == 0\n        return []\n    end\n    mins = Int64[]\n    for i in 1:n\n\
    \        if rem(arr[i], 2) == 0\n            push!(mins, arr[i])\n        end\n\
    \    end\n    for i in 1:n\n        if (rem(arr[i], 2) == 0) && (arr[i] == minimum(mins))\n\
    \            return [arr[i], i]\n        end\n    end\n    return []\nend", " \
    \   i = 0\n    min_even = 10000\n    min_even_index = 0\n    while i <= length(arr)\n\
    \        if arr[i] < min_even && arr[i] % 2 == 0\n            min_even = arr[i]\n\
    \            min_even_index = i\n        end\n        i += 1\n    end\n    if\
    \ min_even != 10000\n        return [min_even, min_even_index]\n    else\n   \
    \     return []\n    end\nend", "    if isempty(arr) || (isempty(findall(arr->arr\
    \ % 2 == 0, arr)))\n        return []\n    end\n    evens = findall(arr->arr %\
    \ 2 == 0, arr)\n    min_even = minimum(evens)\n    idx = findfirst(arr, min_even)\n\
    \    return [min_even, idx]\nend", "    # remove all odd numbers\n    arr_evens\
    \ = arr[ arr .% 2 .== 0 ]\n    return [minimum(arr_evens), findall(x -> x == minimum(arr_evens),\
    \ arr)[1]]\nend", "    if isempty(arr)\n        return []\n    end\n    min_val,\
    \ min_idx = Int64(0), Int64(0)\n    min_idx = 0\n    for i in eachindex(arr)\n\
    \        if iseven(arr[i])\n            if arr[i] < min_val\n                min_val\
    \ = arr[i]\n                min_idx = i\n            end\n        end\n    end\n\
    \    if min_val == 0\n        return []\n    end\n    return [min_val, min_idx]\n\
    end\n@testset \"Example Tests\" begin\n    @test pluck([4,2,3]) == [2, 1]\n  \
    \  @test pluck([1,2,3]) == [2, 1]\n    @test pluck([]) == []\n    @test pluck([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\nend\n@testset \"Test 1\" begin\n    @test pluck([1,2,3,4,5,6,7,8,9,10])\
    \ == [2, 1]\nend\n@testset \"Test 2\" begin\n    @test pluck([1,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,",
  "    if isempty(arr)\n        return []\n    end\n    even_nums = []\n    for index\
    \ in 1:length(arr)\n        if (arr[index] % 2 == 0)\n            push!(even_nums,\
    \ [arr[index], index])\n        end\n    end\n    if isempty(even_nums)\n    \
    \    return []\n    end\n    lowest_even = even_nums[1]\n    for index in 2:length(even_nums)\n\
    \        if even_nums[index][1] < lowest_even[1]\n            lowest_even = even_nums[index]\n\
    \        end\n    end\n    return lowest_even\nend", "    if length(arr) == 0\n\
    \        return []\n    end\n    if length(arr) == 1\n        if arr[1] % 2 ==\
    \ 0\n            return [arr[1], 1]\n        else\n            return []\n   \
    \     end\n    end\n    even_nums = Int64[]\n    for i in arr\n        if i %\
    \ 2 == 0\n            push!(even_nums, i)\n        end\n    end\n    if length(even_nums)\
    \ == 0\n        return []\n    end\n    smallest_even = minimum(even_nums)\n \
    \   idx = argmin(even_nums)\n    return [smallest_even, idx]\nend", "    min_value\
    \ = nothing\n    min_index = nothing\n    for i = 1:length(arr)\n        if (arr[i]\
    \ % 2 == 0) & (min_value isa Nothing)\n            min_value = arr[i]\n      \
    \      min_index = i\n        elseif (arr[i] % 2 == 0) & (arr[i] < min_value)\n\
    \            min_value = arr[i]\n            min_index = i\n        end\n    end\n\
    \    if min_value isa Nothing\n        return []\n    else\n        return [min_value,\
    \ min_index]\n    end\nend", "    if length(arr) == 0\n        return []\n   \
    \ end\n    even_vals = filter(x -> x % 2 == 0, arr)\n    if length(even_vals)\
    \ == 0\n        return []\n    end\n    min_even = minimum(even_vals)\n    min_idx\
    \ = findfirst(x -> x == min_even, arr)\n    return [min_even, min_idx]\nend\n\
    @testset \"Example 1\" begin\n    @test pluck([4,2,3]) == [2, 1]\nend\n@testset\
    \ \"Example 2\" begin\n    @test pluck([1,2,3]) == [2, 1]\nend\n@testset \"Example\
    \ 3\" begin\n    @test pluck([]) == []\nend\n@testset \"Example 4\" begin\n  \
    \  @test pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\nend", "    even_val = 0\n    index\
    \ = 0\n    min_val = 0", "    \"\"\"\n    Returns the plucked node as [even_value,\
    \ index]\n    \"\"\"\n    if isempty(arr)\n        return []\n    end\n    # Find\
    \ min even, and its index\n    smallest_even = Inf\n    smallest_even_index =\
    \ 0\n    for (i, node) in enumerate(arr)\n        if node % 2 == 0 && node < smallest_even\n\
    \            smallest_even = node\n            smallest_even_index = i\n     \
    \   end\n    end\n    #return nothing if there is no even number\n    if smallest_even\
    \ == Inf\n        return []\n    end\n    return [smallest_even, smallest_even_index]\n\
    end", "    smallest = zero(Int64)\n    index = zero(Int64)\n    for (i, element)\
    \ in enumerate(arr)\n        isEven = element % 2 == 0\n        isSmaller = element\
    \ < smallest\n        isFirst = smallest == zero(Int64)\n        if (isEven &&\
    \ (isSmaller || isFirst))\n            smallest = element\n            index =\
    \ i\n        end\n    end\n    if (smallest == zero(Int64))\n        return []\n\
    \    end\n    return [smallest, index]\nend", "    n = length(arr)\n    @inbounds\
    \ for i in 1:n\n        if arr[i] % 2 == 0\n            return [arr[i], i]\n \
    \       end\n    end\n    return []\nend", "    if arr == []\n        return []\n\
    \    end\n    min_index = -1\n    min_value = -1\n    for i = 1:length(arr)\n\
    \        if (arr[i] % 2 == 0) && (min_value == -1 || arr[i] < min_value)\n   \
    \         min_value = arr[i]\n            min_index = i\n        end\n    end\n\
    \    if min_index == -1\n        return []\n    end\n    return [min_value, min_index]\n\
    end", "    # Your code here\nend\n\"\"\"\n    \"Given an array representing a\
    \ tree that has non-negative integer nodes\n    your task is to find the largest\
    \ value in the array and return it.\n    If there are multiple values with the\
    \ same largest value return the value that has the smallest index.", "    evens\
    \ = filter(x -> x % 2 == 0, arr)\n    if isempty(evens)\n        return []\n \
    \   end\n    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend", "    \n    # Split all nodes into\
    \ even and odd (1-3, 5-7, ...)\n    even_nodes = [node for node in arr if node\
    \ % 2 == 0]\n    odd_nodes = [node for node in arr if node % 2 != 0]\n    \n \
    \   if(!isempty(even_nodes))\n        # Find minimum number and location of that\
    \ number\n        min_even_node = minimum(even_nodes)\n        min_even_node_index\
    \ = findfirst(arr .== min_even_node)\n        \n        # If there is a duplicate\
    \ of minimum number,\n        # choose the index where minimum number is located\
    \ at in the\n        # original array\n        for i in 2:length(even_nodes)\n\
    \            if(even_nodes[i] == min_even_node)\n                min_even_node_index\
    \ = findfirst(arr .== min_even_node)\n            end\n        end\n    else\n\
    \        return []\n    end\n    \n    return [min_even_node, min_even_node_index]\n\
    end\n\"\"\"\n    \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    your task is to pluck one of the nodes and return it.\n \
    \   The plucked node should be the node with the smallest even value.\n    If\
    \ multiple nodes with the same smallest even value are found return the node that\
    \ has smallest index.", "    smallest_even = nothing\n    smallest_even_idx =\
    \ nothing\n    for (i, n) in enumerate(arr)\n        if iseven(n)\n          \
    \  if !haskey(smallest_even, 1)\n                smallest_even = n\n         \
    \       smallest_even_idx = i\n            elseif n < smallest_even\n        \
    \        smallest_even = n\n                smallest_even_idx = i\n          \
    \  end\n        end\n    end\n    return isempty(smallest_even) ? [] : [smallest_even,\
    \ smallest_even_idx + 1]\nend", "    smallest_index = 0\n    smallest_value =\
    \ 0\n    for (index, value) in enumerate(arr)\n        if value % 2 == 0\n   \
    \         if smallest_value == 0 || value < smallest_value\n                smallest_value\
    \ = value\n                smallest_index = index\n            end\n        end\n\
    \    end\n    return [smallest_value, smallest_index]\nend", "    if isempty(arr)\n\
    \        return []\n    end\n    evens = filter(i -> i % 2 == 0, arr)\n    if\
    \ isempty(evens)\n        return []\n    end\n    min_even = minimum(evens)\n\
    \    return [min_even, findfirst(i -> i == min_even, arr)]\nend", "    # your\
    \ code here \nend", "    return [x for x in arr if iseven(x)]\nend", "    length(arr)\
    \ == 0 && return []\n    min_index, min_val = size(arr)[1], maximum(arr)\n   \
    \ for i in 1:length(arr)\n        val = arr[i]\n        if val % 2 == 0 && val\
    \ < min_val\n            min_index, min_val = i, val\n        end\n    end\n \
    \   if min_val == maximum(arr)\n        return []\n    else\n        return [min_val,\
    \ min_index]\n    end\nend", "    arr_evens = filter(x -> iseven(x), arr)\n  \
    \  if length(arr_evens) == 0\n        return []\n    end\n    return [minimum(arr_evens),\
    \ findfirst(arr, minimum(arr_evens))]\nend", "    values = filter(x -> x % 2 ==\
    \ 0, arr)\n    if length(values) == 0\n        return []\n    end\n    values\
    \ = sort(values)\n    indexes = findall(arr -> arr == values[1], arr)\n    return\
    \ [values[1], indexes[1]]\nend", "    i = 1\n    val = 0\n    for j = 1:length(arr)\n\
    \        if mod(arr[j], 2) == 0\n            if (arr[j] < val) || (val == 0)\n\
    \                val = arr[j]\n                i = j\n            end\n      \
    \  end\n    end\n    return [val, i]\nend", "    # Write your solution here\n\
    end\n \n \n@testset \"Test Cases\" begin\n    @test pluck([]) == []\n    @test\
    \ pluck([1,2,3]) == [2, 1]\n    @test pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\n  \
    \  @test pluck([4,2,3]) == [2, 1]\nend\n\"\"\"\n    Plotting the function:\n \
    \   f(x,y) = x^2 + 2*y^2 - 1", "    if length(arr) == 0\n        return []\n \
    \   end\n    even_arr = [x for x in arr if x % 2 == 0]\n    if length(even_arr)\
    \ == 0\n        return []\n    end\n    min_even = minimum(even_arr)\n    return\
    \ [min_even, findall(arr, min_even)[1]]\nend", "    minimum(filter(n -> rem(n,\
    \ 2) == 0, arr))\nend", "    smallest = [findall(x -> x % 2 == 0, arr)]\n    if\
    \ !isempty(smallest)\n        [findmin(smallest[1]), findall(x -> x == findmin(smallest[1]),\
    \ arr)[1]]\n    else\n        [0,0]\n    end\nend", "    even_index = Int[]\n\
    \    even_value = Int[]\n    #exception\n    if length(arr) == 0\n        return\
    \ []\n    end\n    #get even index and value\n    for i = 1:length(arr)\n    \
    \    if (arr[i] % 2 == 0) && (arr[i] != 0)\n            push!(even_index, i)\n\
    \            push!(even_value, arr[i])\n        end\n    end\n    #exception\n\
    \    if length(even_index) == 0\n        return []\n    end\n    #get index and\
    \ value of the smallest even number\n    min_value = even_value[1]\n    min_index\
    \ = even_index[1]\n    for i = 2:length(even_value)\n        if even_value[i]\
    \ < min_value\n            min_value = even_value[i]\n            min_index =\
    \ even_index[i]\n        end\n    end\n    return [min_value, min_index]\nend",
  "    if length(arr) == 0\n        return []\n    end\n    idx_min, val_min = findmin(arr)\n\
    \    if (val_min % 2 == 0)\n        return [val_min, idx_min]\n    end\n    return\
    \ pluck(deleteat!(arr, idx_min))\nend", "    evens = findall(x -> (x % 2 == 0),\
    \ arr)\n    if length(evens) == 0\n        return []\n    end\n    min_even =\
    \ minimum(evens)\n    return [min_even, findall(x -> (x == min_even), arr)[1]]\n\
    end", "    if length(arr) == 0\n        return []\n    end\n    result = []\n\
    \    min = Inf\n    index = 0\n    for i in 1:length(arr)\n        if arr[i] %\
    \ 2 == 0 && arr[i] < min\n            min = arr[i]\n            index = i\n  \
    \      end\n    end\n    if length(result) == 0\n        return []\n    end\n\
    \    return [min, index]\nend", "    min_even = (Int64, 0) # (min_even_value,\
    \ min_even_index)\n    arr_size = length(arr)\n    for index in 1:arr_size\n \
    \       if iseven(arr[index])\n            if min_even[1] == 0 || arr[index] <\
    \ min_even[1]\n                min_even = (arr[index], index)\n            end\n\
    \        end\n    end\n    return min_even\nend", "    l = length(arr)\n    if\
    \ l == 0\n        return []\n    end\n    minimum = 1e6\n    idx = 0\n    for\
    \ i = 1:l\n        if arr[i] < minimum && mod(arr[i], 2) == 0\n            minimum\
    \ = arr[i]\n            idx = i\n        end\n    end\n    if idx == 0\n     \
    \   return []\n    end\n    return [minimum, idx]\nend", "    \"\"\"\n    Solve\
    \ a given equation and return the value of x in the form of string \"x=#value\"\
    .\n    The equation contains only '+', '-' operation, the variable x and its coefficient.",
  "    N = length(arr)\n    even_idx = [ idx for idx in 1:N if arr[idx] % 2 == 0 ]\n\
    \    if length(even_idx) == 0\n        return [0, 0]\n    end\n    min_idx = even_idx[\
    \ argmin( arr[ even_idx ] ) ]\n    return [ arr[min_idx], min_idx ]\nend", " \
    \   if isempty(arr)\n        return []\n    end\n    evenArr = filter(x -> x %\
    \ 2 == 0, arr)\n    if isempty(evenArr)\n        return []\n    end\n    val =\
    \ minimum(evenArr)\n    for i in 1:length(arr)\n        if arr[i] == val\n   \
    \         return [val, i]\n        end\n    end\nend", "    length(arr) < 1 &&\
    \ return []\n    arr[arr .% 2 .== 0] == minimum(arr[arr .% 2 .== 0]) ?\n     \
    \   [minimum(arr[arr .% 2 .== 0]), findall(arr .== minimum(arr[arr .% 2 .== 0]))[1]]\
    \ :\n        []\nend", "    \n    # Find the minimum even value\n    min_even\
    \ = minimum(filter(n -> iseven(n), arr))", "    if length(arr) == 0\n        return\
    \ []\n    end\n    even = filter(x -> x%2 == 0, arr)\n    min_even = minimum(even)\n\
    \    if min_even == Inf\n        return []\n    end\n    idx = findall(arr .==\
    \ min_even)[1]\n    return [min_even, idx]\nend", "    min_even_value = 0\n  \
    \  min_even_value_idx = 0\n    for (idx, value) in enumerate(arr)\n        if\
    \ value < min_even_value && value % 2 == 0\n            min_even_value = value\n\
    \            min_even_value_idx = idx\n        end\n    end\n    return [min_even_value,\
    \ min_even_value_idx]\nend\n ", "    even = []\n    for i = 1:length(arr)\n  \
    \      if arr[i] % 2 == 0\n            push!(even, i)\n        end\n    end\n\
    \    if length(even) == 0\n        return []\n    end\n    return [arr[indmin(even)],\
    \ indmin(even)]\nend", "    if !any(arr .% 2 .== 0)\n        return []\n    end\n\
    \    arr_evens = arr[arr .% 2 .== 0]\n    minimum_value = minimum(arr_evens)\n\
    \    position = searchsortedlast(arr, minimum_value)\n    return [minimum_value,\
    \ position]\nend\n\"\"\"\n    Run tests:\n        julia test.jl\n\"\"\"", "  \
    \  @assert length(arr) >= 1\n    @assert all(isodd, arr)", "    evens = []\n \
    \   positions = []\n    for (index, val) in enumerate(arr)\n        if val % 2\
    \ == 0\n            push!(evens, val)\n            push!(positions, index)\n \
    \       end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min = evens[1]\n    min_index = positions[1]\n    min_index_pos = 1\n   \
    \ for (index, val) in enumerate(evens)\n        if val < min\n            min\
    \ = val\n            min_index = positions[index]\n            min_index_pos =\
    \ index\n        end\n    end\n    return [min, min_index]\nend", "    empty_list\
    \ = []\n    if isempty(arr)\n        return empty_list\n    end\n    smallest_even\
    \ = Inf\n    smallest_even_index = Inf\n    for node in eachindex(arr)\n     \
    \   if arr[node] % 2 == 0 && arr[node] < smallest_even\n            smallest_even\
    \ = arr[node]\n            smallest_even_index = node\n        end\n    end\n\
    \    if smallest_even == Inf\n        return empty_list\n    end\n    return [smallest_even,\
    \ smallest_even_index]\nend", "    even_nums = []\n    for (i, el) in enumerate(arr)\n\
    \        if el % 2 == 0\n            push!(even_nums, (el, i))\n        end\n\
    \    end\n    if length(even_nums) == 0\n        return []\n    end\n    return\
    \ sort!(even_nums)[1]\nend", "    even_values = filter(x -> x % 2 == 0, arr)\n\
    \    if isempty(even_values)\n        return []\n    end\n    minimal_even_value\
    \ = even_values[1]\n    for value in even_values\n        if value < minimal_even_value\n\
    \            minimal_even_value = value\n        end\n    end\n    for (i, element)\
    \ in enumerate(arr)\n        if element == minimal_even_value\n            return\
    \ [element, i]\n        end\n    end\nend", "    # do something\nend", "    result\
    \ = []\n    for i = 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(result,\
    \ i)\n        end\n    end\n    sort!(result)\n    isempty(result) ? [] : [arr[result[1]],\
    \ result[1]]\nend", "    \n    # check empty array\n    if length(arr) == 0\n\
    \        return []\n    end\n    \n    # keep track of the smallest even value\n\
    \    sm_even = Inf\n    \n    # keep track of first index of smallest even value\n\
    \    sm_index = -1\n    \n    # go through array and if number is even and less\
    \ than sm_even\n    # update sm_even and sm_index\n    for i in 1:length(arr)\n\
    \        if arr[i] % 2 == 0 && arr[i] < sm_even\n            sm_even = arr[i]\n\
    \            sm_index = i\n        end\n    end\n    \n    # if sm_even is still\
    \ Inf, then no even numbers, so return empty array\n    if sm_even == Inf\n  \
    \      return []\n    end\n    \n    # return list containing the smallest even\
    \ value and its index\n    return [sm_even, sm_index]\nend", "    if length(arr)\
    \ == 0\n        return []\n    end\n    even_idx = Int64[]\n    even_arr = Int64[]\n\
    \    for i in 1:length(arr)\n        if iseven(arr[i])\n            push!(even_idx,\
    \ i)\n            push!(even_arr, arr[i])\n        end\n    end\n    if length(even_arr)\
    \ == 0\n        return []\n    end\n    min_idx = even_idx[argmin(even_arr)]\n\
    \    return [arr[min_idx], min_idx]\nend", "    least:Int64 = 0\n    index:Int64\
    \ = 0\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            if\
    \ (least == 0) || (arr[i] < least)\n                least = arr[i]\n         \
    \       index = i\n            end\n        end\n    end\n    if least == 0\n\
    \        return []\n    else\n        return [least, index]\n    end\nend\n@testset\
    \ \"Basic tests\" begin\n    @test pluck([4,2,3]) == [2, 1]\n    @test pluck([1,2,3])\
    \ == [2, 1]\n    @test pluck([]) == []\n    @test pluck([5, 0, 3, 0, 4, 2]) ==\
    \ [0, 1]\nend\n@testset \"Random tests\" begin\n    @testset \"Run 25 random tests\"\
    \ begin\n        for i in 1:25\n            s = rand(1:10000)\n            l =\
    \ [rand(0:10000) for i in 1:s]\n            p = pluck(l)\n            if !isempty(p)\n\
    \                @test 0 <= p[1] <= 10000\n                @test p[2] in 1:length(l)\n\
    \                @test 2p[1] == l[p[2]]\n            else\n                @test\
    \ all(x -> x % 2 != 0, l)\n            end\n        end\n    end\nend\n \nend\n\
    \ \n \n \n\"\"\"\n    Given a string of characters, return the character that\
    \ appears the most often.", "    if length(arr) == 0\n        return []\n    end\n\
    \    ans = findall(arr .== minimum(arr[arr .== 0]));\n    if length(ans) == 0\n\
    \        return []\n    end\n    return [arr[ans[1]], ans[1]]\nend", "    # Your\
    \ solution here\nend", "    evens = findall(x -> x % 2 == 0, arr)\n    if isempty(evens)\n\
    \        return Vector{Int64}()\n    end\n    return [minimum(evens), findfirst(arr\
    \ .== minimum(evens))]\nend", "    min_value = nothing\n    min_index = nothing\n\
    \    for (index, value) in enumerate(arr)\n        if value % 2 == 0\n       \
    \     if isnothing(min_value) || value < min_value\n                min_value\
    \ = value\n                min_index = index\n            end\n        end\n \
    \   end\n    return isnothing(min_value) ? [] : [min_value, min_index]\nend",
  "    if isempty(arr)\n        return []\n    end\n    ret = []\n    minval = 9999999\n\
    \    minidx = 9999999\n    for (idx, val) in enumerate(arr)\n        if mod(val,\
    \ 2) == 0 && val < minval\n            minval = val\n            minidx = idx\n\
    \        end\n    end\n    if minval != 9999999\n        return [minval, minidx\
    \ + 1]\n    else\n        return []\n    end\nend", "    evens = [arr[i] for i\
    \ in 1:length(arr) if rem(arr[i], 2) == 0]\n    if isempty(evens)\n        return\
    \ []\n    else\n        smallest = minimum(evens)\n        return [smallest, findall(arr\
    \ .== smallest)[1]]\n    end\nend", "    index = -1\n    value = -1\n   \n   \
    \ for i in 1:length(arr)\n        if rem(arr[i], 2) == 0\n            if value\
    \ == -1\n                value = arr[i]\n                index = i\n         \
    \   elseif arr[i] < value\n                value = arr[i]\n                index\
    \ = i\n            end\n        end\n    end\n    if index == -1\n        return\
    \ Vector{Int64}()\n    end\n    return [value, index]\nend", "    # filter and\
    \ reduce to find lowest even number, if any, and its index in the input array\n\
    \    return reduce(findmin, [(i, arr[i]) for i in 1:length(arr) if iseven(arr[i])],\
    \ (NaN, NaN))[1] # this is a poor man's form of pattern matching, but it works!\n\
    end", "    zero_values = findall(x -> x == 0, arr) # Gets all the zero values'\
    \ index\n    if isempty(zero_values)\n        zero_values = 0\n    end\n    even_values\
    \ = findall(x -> x % 2 == 0, arr) # Gets all the even values' index\n    if isempty(even_values)\n\
    \        even_values = 0\n    end\n    if isempty(zero_values) && isempty(even_values)\n\
    \        return []\n    end\n    if length(zero_values) >= length(even_values)\n\
    \        return [0, zero_values[1]]\n    else\n        return [arr[even_values[1]],\
    \ even_values[1]]\n    end\nend", "    \n    # Find all the even elements\n  \
    \  even_elements = findall(x -> x % 2 == 0, arr)\n    \n    # If there are no\
    \ even elements, return empty Vector.\n    if length(even_elements) == 0\n   \
    \     return []\n    end\n    \n    # Find the index of the smallest even element\n\
    \    even_index = findfirst(arr .== minimum(even_elements))\n    \n    # Return\
    \ a Vector with the smallest even element and its index.\n    return [arr[even_index],\
    \ even_index]\nend", "    evenNodes = filter(x -> x % 2 == 0, arr)\n    if length(evenNodes)\
    \ == 0\n        return []\n    end\n    values = map(x -> [x, findfirst(==(x),\
    \ arr)], evenNodes)\n    min(values, by = x -> x[1])[1]\nend", "    r = []\n \
    \   idx = 0\n    for (i,v) in enumerate(arr)\n        if v % 2 == 0 && v < r[1]\n\
    \            r = [v, i]\n        end\n    end\n    return r\nend", "    # base\
    \ cases\n    if length(arr) == 0 return [] end", "    values = []\n    indexes\
    \ = []\n    for (i, v) in enumerate(arr)\n        if v % 2 == 0\n            push!(values,\
    \ v)\n            push!(indexes, i)\n        end\n    end\n    if isempty(values)\n\
    \        return []\n    end\n    min_v = minimum(values)\n    min_i = minimum(indexes[values\
    \ .== min_v])\n    return [min_v, min_i]\nend", "    # 1) find even elements\n\
    \    even_elements = [x for x in arr if mod(x, 2) == 0]\n    # 2) find minumum\n\
    \    min_even = minimum(even_elements)\n    # 3) find index of minimum\n    min_even_index\
    \ = indmin(even_elements)\n    return [min_even, min_even_index]\nend", "    min\
    \ = 10000\n    min_index = -1\n    for (index, element) in enumerate(arr)\n  \
    \      if element < min && element % 2 == 0\n            min = element\n     \
    \       min_index = index\n        end\n    end\n    if min == 10000\n       \
    \ return []\n    end\n    return [min, min_index]\nend", "    # declarations\n\
    \    if arr == []\n        return []\n    end\n    index = 0\n    evens = []\n\
    \    for i in 1:length(arr)\n        if iseven(arr[i])\n            index = i\n\
    \            push!(evens, arr[i])\n        end\n    end\n    if evens == []\n\
    \        return []\n    end\n    # sort evens \n    evens = sort(evens)\n    #\
    \ find index of evens[1]\n    for i in 1:length(arr)\n        if arr[i] == evens[1]\n\
    \            index = i\n            break\n        end\n    end\n    return [evens[1],\
    \ index]\nend\n# test vectors\na1 = [4,2,3]\na2 = [1,2,3]\na3 = []\na4 = [5, 0,\
    \ 3, 0, 4, 2]", "    if length(arr) == 0\n        return []\n    end\n    even_entries\
    \ = []\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_entries,\
    \ arr[i])\n        end\n    end\n    if length(even_entries) == 0\n        return\
    \ []\n    end\n    min_even = minimum(even_entries)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_even\n            return [min_even, i]\n        end\n\
    \    end\nend", "    min_even = minimum(filter(x -> iseven(x), arr))\n    min_idx\
    \ = findfirst(arr, min_even)\n    return [min_even, min_idx]\nend", "    # your\
    \ code here\nend\n\"\"\"\n    Bonus Points:\n    Rewrite the same function that\
    \ it runs faster, but with a time complexity of O(n).", "    if length(arr) ==\
    \ 0\n        return []\n    end\n    # filter all the even numbers\n    filtered_even_numbers\
    \ = filter(x -> x % 2 == 0, arr)\n    # get the smallest number\n    minimum_even_number\
    \ = minimum(filtered_even_numbers)\n    # get the index of minimum even number\n\
    \    index_of_minimum_even_number = findall(arr .== minimum_even_number)[1]",
  "    even = []\n    for(i,a) in enumerate(arr)\n        if(a % 2 == 0)\n       \
    \     push!(even, a)\n        end\n    end\n    if(isempty(even))\n        return\
    \ []\n    end\n    index = findall(x -> x == minimum(even), even)[1]\n    return\
    \ [arr[index], index]\nend", "    if isempty(arr)\n        return Vector{Int64}([])\n\
    \    end\n    min = 10001\n    min_ind = -1\n    for i in 1:length(arr)\n    \
    \    if arr[i]%2 == 0\n            if arr[i] < min\n                min = arr[i]\n\
    \                min_ind = i\n            end\n        end\n    end\n    if min\
    \ == 10001\n        return Vector{Int64}([])\n    end\n    return Vector{Int64}([min,\
    \ min_ind])\nend", "    \"\"\"\"\n    Time: O(n)\n    Space: O(1)\n    \"\"\"\n\
    \    # Find the smallest even value\n    min_even = nothing\n    min_even_idx\
    \ = nothing\n    for (i, item) in enumerate(arr)\n        if iseven(item)\n  \
    \          if min_even == nothing || item < min_even\n                min_even\
    \ = item\n                min_even_idx = i\n            end\n        end\n   \
    \ end\n    if min_even == nothing\n        return []\n    end\n    return [min_even,\
    \ min_even_idx]\nend", "    even_arr = arr[findall(x -> iseven(x), arr)]\n   \
    \ min_even = minimum(even_arr)\n    indices = findall(arr .== min_even)\n    return\
    \ [min_even, minimum(indices)]\nend\npluck([4,2,3])", "    # Your code here\n\
    end\n\"\"\"\n    \"Given an array of integers, return an array of the same length\
    \ and with\n    each element equal to the product of all elements of the array\
    \ EXCEPT the element at that index.\n    Your solution must be able to handle\
    \ zeros properly.", "    if length(arr) == 0\n        return []\n    end\n   \
    \ res_val = 0\n    res_index = 0\n    for (i, val) in enumerate(arr)\n       \
    \ if val % 2 == 0\n            if res_val == 0\n                res_val = val\n\
    \                res_index = i\n            elseif val < res_val\n           \
    \     res_val = val\n                res_index = i\n            end\n        end\n\
    \    end\n    if res_val == 0\n        return []\n    end\n    return [res_val,\
    \ res_index]\nend", "    for (index, item) in enumerate(arr)\n        if iseven(item)\
    \ && index == 1\n            return [item, index]\n        elseif iseven(item)\
    \ && item < arr[1]\n            return [item, index]\n        end\n    end\n \
    \   \n    return []\nend", "    min_even_value, min_even_index = 0, 0\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            if min_even_value\
    \ == 0 || arr[i] < min_even_value\n                min_even_value = arr[i]\n \
    \               min_even_index = i\n            end\n        end\n    end\n  \
    \  if min_even_value == 0\n        return Vector{Int64}(undef,0)\n    else\n \
    \       return [min_even_value, min_even_index]\n    end\nend", "    min_even\
    \ = [0, 0]\n    for i in 1:length(arr)\n        if (isodd(arr[i]) == false) &\
    \ (min_even[1] == 0)\n            min_even = [arr[i], i]\n        elseif (isodd(arr[i])\
    \ == false) & (arr[i] < min_even[1])\n            min_even = [arr[i], i]\n   \
    \     end\n    end\n    return min_even\nend", "    if isempty(arr)\n        return\
    \ []\n    end\n    min_even = 0\n    for i in arr\n        if i%2 == 0 && (min_even\
    \ == 0 || i < min_even)\n            min_even = i\n        end\n    end\n    if\
    \ min_even == 0\n        return []\n    end\n    return [min_even, findfirst(arr\
    \ .== min_even)[1]]\nend", "    # TODO: complete function pluck and pass the tests\n\
    end", "    isempty(arr) && return Vector{Int64}()\n    evens = filter(x -> x %\
    \ 2 == 0, arr)\n    minimum(evens) == maximum(evens) && return Vector{Int64}()\n\
    \    val, idx = minimum(evens), findfirst(arr, minimum(evens))\n    [val, idx]\n\
    end", "    if length(arr) == 0\n        return []\n    end\n    min = 10001\n\
    \    idx = 0\n    for i in 1:length(arr)\n        if arr[i] == 0 && idx == 0\n\
    \            idx = i\n        end\n        if arr[i] > 0 && arr[i] < min && mod(arr[i],\
    \ 2) == 0\n            min = arr[i]\n            idx = i\n        end\n    end\n\
    \    if idx == 0\n        return []\n    end\n    return [min, idx]\nend", " \
    \   \"\"\"\n    Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    your task is to pluck one of the nodes and return it.\n \
    \   The plucked node should be the node with the smallest even value.\n    If\
    \ multiple nodes with the same smallest even value are found return the node that\
    \ has smallest index.", "    min_idx = -1\n    min_val = maximum(arr)\n    for\
    \ (i, n) in enumerate(arr)\n        if n %% 2 == 0 && n < min_val\n          \
    \  min_idx = i\n            min_val = n\n        end\n    end\n    return (min_idx\
    \ != -1) ? [min_val, min_idx] : []\nend", "    res = find_smallest_even(arr)\n\
    \    return res == nothing ? Vector{Int64}() : [res, findfirst(arr, res)[1]]\n\
    end", "    if all(!iseven, arr) || length(arr) == 0\n        return []\n    end\n\
    \    return [minimum(filter(iseven, arr)), findfirst(arr, minimum(filter(iseven,\
    \ arr)))]\nend", "    if isempty(arr)\n        return Vector{Int64}()\n    end\n\
    \    result = [arr[1], 1]\n    for i in 2:length(arr)\n        if iseven(arr[i])\n\
    \            if result[1] == 0 || arr[i] < result[1]\n                result =\
    \ [arr[i], i]\n            end\n        end\n    end\n    if result[1] == 0\n\
    \        return Vector{Int64}()\n    end\n    return result\nend", "    # making\
    \ a vector of all the evens and getting the minimum value of that list.\n    possible_answers\
    \ = findall(x -> x % 2 == 0, arr) \n    if !isempty(possible_answers)\n      \
    \  smallest_even = minimum(possible_answers) \n        # finding the index of\
    \ the first occurance of the smallest_even.\n        index = findfirst(arr .==\
    \ smallest_even)\n        return [smallest_even, index]\n    else\n        return\
    \ []\n    end\nend\n@testset \"Example 1\" begin\n    @test pluck([4,2,3]) ==\
    \ [2, 1]\nend\n@testset \"Example 2\" begin\n    @test pluck([1,2,3]) == [2, 1]\n\
    end\n@testset \"Example 3\" begin\n    @test pluck([]) == []\nend\n@testset \"\
    Example 4\" begin\n    @test pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\nend\n@testset\
    \ \"bunch of tests\" begin\n    @test pluck([]) == []\n    @test pluck([1]) ==\
    \ []\n    @test pluck([0]) == [0, 1]\n    @test pluck([2]) == [2, 1]\n    @test\
    \ pluck([0,2]) == [0, 1]\n    @test pluck([0,1,1,1,1,0]) == [0, 1]\n    @test\
    \ pluck([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,",
  "    first_even = nothing\n    first_even_idx = nothing\n    for (idx, item) in\
    \ enumerate(arr)\n        if item % 2 == 0\n            if first_even == nothing\n\
    \                first_even = item\n                first_even_idx = idx\n   \
    \         else\n                if item < first_even\n                    first_even\
    \ = item\n                    first_even_idx = idx\n                end\n    \
    \        end\n        end\n    end\n    if first_even == nothing\n        return\
    \ []\n    else\n        return [first_even, first_even_idx]\n    end\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
