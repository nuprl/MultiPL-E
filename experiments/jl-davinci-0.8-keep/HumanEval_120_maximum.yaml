name: HumanEval_120_maximum
language: jl
prompt: "\"\"\"\n    Given an array arr of integers and a positive integer k, return\
  \ a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example\
  \ 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n\
  \    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\
  \n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n     \
  \   Output: [2]\n\n    Note:\n        1. The length of the array will be in the\
  \ range of [1, 1000].\n        2. The elements in the array will be in the range\
  \ of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\nfunction maximum(arr::Vector{Int64},\
  \ k::Int64)::Vector{Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = maximum;\n\t@test(candidate([-3,\
  \ -4, 5], 3) == [-4, -3, 5])\n\t@test(candidate([4, -4, 4], 2) == [4, 4])\n\t@test(candidate([-3,\
  \ 2, 1, 2, -1, -2, 1], 1) == [2])\n\t@test(candidate([123, -123, 20, 0, 1, 2, -3],\
  \ 3) == [2, 20, 123])\n\t@test(candidate([-123, 20, 0, 1, 2, -3], 4) == [0, 1, 2,\
  \ 20])\n\t@test(candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5,\
  \ 15])\n\t@test(candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5])\n\t@test(candidate([1,\
  \ 0, 5, -7], 1) == [5])\n\t@test(candidate([4, -4], 2) == [-4, 4])\n\t@test(candidate([-10,\
  \ 10], 2) == [-10, 10])\n\t@test(candidate([1, 2, 3, -23, 243, -400, 0], 0) == Vector{Int64}([]))\n\
  end\n"
completions: ["    n = length(arr)\n    i = 1\n    maxs = Vector{Int64}(k)\n    while\
    \ i <= k\n        maxs[i] = -Inf64\n        i += 1\n    end\n    for i = 1:n\n\
    \        j = k\n        while j >= 1\n            if arr[i] > maxs[j]\n      \
    \          j -= 1\n            else\n                break\n            end\n\
    \        end\n        for c in (j+1):(k-1)\n            maxs[c] = maxs[c+1]\n\
    \        end\n        maxs[k] = arr[i]\n    end\n    return maxs\nend", "    function\
    \ append(arr::Vector{Int64}, x::Int64)\n        size = length(arr)\n        new_arr\
    \ = zeros(Int64, size + 1)\n        new_arr[1:size] = arr\n        new_arr[size\
    \ + 1] = x\n        return new_arr\n    end\n    heap = [arr[1]]\n    for i in\
    \ 2:length(arr)\n        if (length(heap) < k) || (arr[i] > heap[1])\n       \
    \     heap = append(heap, arr[i])\n            heap = HeapTools.pushheap!(heap)\n\
    \        end\n        if length(heap) > k\n            heap = HeapTools.popheap!(heap)\n\
    \        end\n    end\n    heap = HeapTools.heapsort!(heap)\n    return heap\n\
    end", "    n = length(arr)\n    p = @threads for i = 1:n\n        push!(arr[i],\
    \ arr[i])\n    end\n    return sort(arr[1:k], rev=true)\nend", "    @assert k\
    \ <= length(arr)\n    return sort(arr)[end-k+1:end]\nend", "    #  this function\
    \ mutates the vector\n    if k == length(arr)\n        return sort(arr)\n    end\n\
    \    for i in k:length(arr)\n        for j in i:k:-1\n            if arr[j] <\
    \ arr[j-1]\n                temp = arr[j]\n                arr[j] = arr[j-1]\n\
    \                arr[j-1] = temp\n            end\n        end\n    end\n    arr[1:k]\n\
    end\narr = [-3, -4, 5]\nk = 3\n# arr = [4, -4, 4]\n# k = 2\n# arr = [-3, 2, 1,\
    \ 2, -1, -2, 1]\n# k = 1\nmaximum(arr, k)", "    \n    top_k = Vector{Int64}()",
  "    where {T}\n    max = []\n    for i = 1:k\n        maximum = -1001\n       \
    \ max_index = -1\n        for j = 1:length(arr)\n            if arr[j] > maximum\n\
    \                maximum = arr[j]\n                max_index = j\n           \
    \ end\n        end\n        push!(max, arr[max_index])\n        deleteat!(arr,\
    \ max_index)\n    end\n    return max\nend", "    \"\"\"\n    Sorts the first\
    \ k elements in an array and returns them as an array. \n    \"\"\"\n    s = sort(arr[1:k])\n\
    \    for i in k+1:length(arr)\n        if arr[i] >= s[1]\n            s[1] = arr[i]\n\
    \            s = sort(s)\n        end\n    end\n    return s\nend", "    \n  \
    \  return sort(arr)[end-k+1:end]\nend", "    heap = Heap(arr)\n    res = Vector{Int64}(undef,\
    \ k)\n    for i in 1:k\n        res[i] = pop!(heap)\n    end\n    return res\n\
    end", "    n = length(arr)\n    push!(arr, maximum(arr) + 1)", "    \"\"\"\n \
    \   max_list = []\n    for i in 1:k\n        max_list.append(max(arr))\n     \
    \   arr.remove(max(arr))\n    end\n    return sort(max_list)\n    \"\"\"\n   \
    \ q = PriorityQueue()\n    sorted_list = []\n    for i in arr\n        q.push(i)\n\
    \    end\n    for i in 1:k\n        sorted_list.append(q.pop())\n    end\n   \
    \ return sorted_list\nend", "    # initialize empty vector to store output in\n\
    \    out = Int64[]\n    # loop through the first k elements\n    for i in 1:k\n\
    \        # store the index of the element with the smallest value in the array\n\
    \        # that is larger than the current largest element in out\n        ind\
    \ = get_index(out, arr)\n        # push the value of the current largest element\
    \ to out\n        push!(out, arr[ind])\n    end\n    # return the sorted output\
    \ vector\n    sort(out)\nend", "    n = length(arr)\n    if n == k\n        return\
    \ sort(arr)\n    end\n    sort(arr)[n-k+1:n]\nend", "    arr[sortperm(arr)[end-k+1:end]]\n\
    end", "    arr_length = length(arr)\n    assert(k <= arr_length)\n    if k < 1\n\
    \        return []\n    end\n    if k == 1\n        return [maximum(arr)]\n  \
    \  end\n    result = Vector{Int64}(undef, k)\n    for i in 1:k\n        result[i]\
    \ = arr[i]\n    end\n    # make sure that the first k elements can be treated\
    \ as a heap.\n    build_max_heap(result)\n    for i in k+1:arr_length\n      \
    \  if arr[i] > result[1]\n            result[1] = arr[i]\n            max_heapify(result,\
    \ 1)\n        end\n    end\n    return result\nend", "    heap = MaxHeap(arr)\n\
    \    return peek(heap, k)\nend", "    if length(arr) <= k\n        return sort(arr,\
    \ rev=true)\n    end\n    heap = MaxHeap()\n    for i in 1:k\n        push!(heap,\
    \ arr[i])\n    end\n    for i in k+1:length(arr)\n        if arr[i] > heap.arr[1]\n\
    \            pop!(heap)\n            push!(heap, arr[i])\n        end\n    end\n\
    \    return sort(heap.arr, rev=true)\nend", "    length(arr) > k ? filter(x ->\
    \ x >= maximum(setdiff(arr, minimum(arr, k))), arr) : arr\nend", "    N = length(arr)\n\
    \    p = 1\n    q = N\n    while p <= q\n        pivot = arr[rand(p:q)]\n    \
    \    i = p\n        j = q\n        while i <= j\n            while arr[i] > pivot\n\
    \                i += 1\n            end\n            while arr[j] < pivot\n \
    \               j -= 1\n            end\n            if i <= j\n             \
    \   arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n                j\
    \ -= 1\n            end\n        end\n        if j - p + 1 >= k\n            q\
    \ = j\n        else\n            k -= j - p + 1\n            p = i\n        end\n\
    \    end\n    return arr[p:p+k-1]\nend\nusing Test\n@testset \"Single Value\"\
    \ begin\n    @test maximum([-3, -4, 5], 3) == [-4, -3, 5]\n    @test maximum([4,\
    \ -4, 4], 2) == [4, 4]\n    @test maximum([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n\
    end", "    arr[sortperm(arr)[end-k+1:end]]\nend", "    \"\"\"\n    Find the highest\
    \ K numbers in the vector and return them in sorted order\n    \"\"\"\n    # sort\
    \ the array\n    sorted_array = sort(arr, rev=true)\n    return sorted_array[1:k]\n\
    end", "    # initialize\n    store = Vector{Int64}()\n    max = 0\n    # iterate\
    \ through the array, inserting the new number where it is larger than\n    # the\
    \ currently stored numbers. Also, pop the element with the minimum value \n  \
    \  # when the length of the store exceeds k.\n    for i in arr\n        if length(store)\
    \ == 0\n            push!(store, i)\n        elseif length(store) < k\n      \
    \      for i in 1:length(store)\n                if i == 1 && i == length(store)\n\
    \                    push!(store, i)\n                elseif i == 1\n        \
    \            if i < store[i+1]\n                        push!(store, i)\n    \
    \                else\n                        push!(store, i)\n             \
    \           push!(store, store[i+1])\n                    end\n              \
    \  elseif i == length(store)\n                    if i > store[i-1]\n        \
    \                push!(store, i)\n                    else\n                 \
    \       push!(store, store[i-1])\n                        push!(store, i)\n  \
    \                  end\n                else\n                    if i > store[i-1]\
    \ && i < store[i+1]\n                        push!(store, i)\n               \
    \     elseif i > store[i-1] && i > store[i+1]\n                        push!(store,\
    \ store[i-1])\n                        push!(store, i)\n                     \
    \   push!(store, store[i+1])\n                    elseif i < store[i-1] && i <\
    \ store[i+1]\n                        push!(store, i)\n                      \
    \  push!(store, store[i-1])\n                        push!(store, store[i+1])\n\
    \                    else\n                        push!(store, store[i-1])\n\
    \                        push!(store, i)\n                    end\n          \
    \      end\n            end\n        else\n            for i in 1:length(store)\n\
    \                if i == 1 && i == length(store)\n                    push!(store,\
    \ i)\n                    pop!(store)\n                elseif i == 1\n       \
    \             if i < store[i+1]\n                        push!(store, i)\n   \
    \                     pop!(store)\n                    else\n                \
    \        push!(store,", "    \"\"\"\n    Function that returns a sorted list of\
    \ length k with the maximum k numbers in arr.\n    \"\"\"\n    tmp = []\n    for\
    \ i in arr\n        push!(tmp, i)\n    end\n    sort!(tmp)\n    output = []\n\
    \    for i in 1:k\n        push!(output, tmp[end - i + 1])\n    end\n    return\
    \ output\nend\nprintln(maximum([-3, -4, 5], 3))\nprintln(maximum([4, -4, 4], 2))\n\
    println(maximum([-3, 2, 1, 2, -1, -2, 1], 1))", "    \n    n = length(arr)\n \
    \   if k == 0\n        return Vector{Int64}()\n    end\n    if k == n\n      \
    \  return arr\n    end\n    \n    val, _ = partition(arr, 1, n)\n    if k == n\
    \ - val + 1\n        return arr[(val):end]\n    elseif k < n - val + 1\n     \
    \   return maximum(arr[(val + 1):end], k)\n    else\n        return vcat(maximum(arr[1:val],\
    \ k - (n - val + 1)), [arr[val]])\n    end\nend", "    max_stack = Vector{Int64}()\n\
    \    for i in arr\n        push!(max_stack, i)\n        if length(max_stack) >\
    \ k\n            popfirst!(max_stack)\n        end\n    end\n    sort(max_stack)\n\
    end", "    #initialize empty vector\n    b = []\n    #for loop that iterates over\
    \ each element in the vector\n    for i in 1:k\n        #push maximum value of\
    \ the array into the array\n        push!(b, maximum(arr))\n        #delete the\
    \ value once pushed\n        deleteat!(arr, arr == maximum(arr))\n    end\n  \
    \  #return the array in ascending order\n    sort(b)\nend", "    \"\"\" \"\"\"\
    \n    arr_len = length(arr)\n    tmp = []\n    if k > arr_len\n        return\
    \ arr\n    end\n    for i = 1:arr_len\n        push!(tmp, arr[i])\n        if\
    \ length(tmp) > k\n            k = sortperm(tmp)[1]\n            pop!(tmp, k)\n\
    \        end\n    end\n    return sort(tmp)\nend", "    # only sort the first\
    \ k items\n    return sort(arr)[1:k]\nend", "    \"\"\"\n    Selects the k maximum\
    \ values from the array arr.\n    \"\"\"\n    newarr = []\n    for i in 1:length(arr)\n\
    \        if length(newarr) >= k && arr[i] > newarr[1]\n            popfirst!(newarr)\n\
    \            push!(newarr, arr[i])\n        elseif length(newarr) < k\n      \
    \      push!(newarr, arr[i])\n        end\n    end\n    return sort(newarr)\n\
    end", "    heap = MaxHeap(arr)\n    kmax = zeros(Int64, k)\n    for i in 1:k\n\
    \        kmax[i] = heap.pop()\n    end\n    return kmax\nend", "    \"\"\"Finds\
    \ the maximum k numbers in arr\n    \"\"\"\n    heap = BinaryHeap{Int64}()\n \
    \   n = length(arr)\n    if k >= n\n        return sort(arr)\n    end\n    for\
    \ i in 1:k\n        push!(heap, arr[i])\n    end\n    for i in k+1:n\n       \
    \ if arr[i] > peek(heap)\n            pop!(heap)\n            push!(heap, arr[i])\n\
    \        end\n    end\n    return sort(collect(heap))\nend", "    if k == 0\n\
    \        return []\n    end\n    pivot = find_pivot(arr)\n    if pivot == -1\n\
    \        return []\n    end\n    pivot = arr[pivot]\n    left = [arr[i] for i\
    \ in 1:length(arr) if arr[i] < pivot]\n    right = [arr[i] for i in 1:length(arr)\
    \ if arr[i] > pivot]\n    n_left = length(left)\n    n_right = length(right)\n\
    \    if n_left == k - 1\n        return sort(insert!(left, pivot))\n    elseif\
    \ n_left >= k\n        return maximum(left, k)\n    else\n        return maximum(right,\
    \ k - n_left - 1)\n    end\nend", "    n = length(arr)\n    if k >= n\n      \
    \  return sort(arr, rev=true)\n    end\n    pq = PriorityQueue()\n    # insert\
    \ first k elements into the pq\n    for i in 1:k\n        push!(pq, arr[i])\n\
    \    end\n    # compare the remaining elements with the smallest element in the\
    \ pq\n    for i in k+1:n\n        if isempty(pq)\n            push!(pq, arr[i])\n\
    \        elseif arr[i] > peek(pq)\n            pop!(pq)\n            push!(pq,\
    \ arr[i])\n        end\n    end\n    sort(collect(pq), rev=true)\nend", "    k_arr\
    \ = []\n    for i in 1:k\n        k_arr = push!(k_arr, arr[i])\n    end\n    k_arr\
    \ = sort(k_arr)\n    for i in k:length(arr)\n        if arr[i] > k_arr[1]\n  \
    \          k_arr[1] = arr[i]\n            k_arr = sort(k_arr)\n        end\n \
    \   end\n    return k_arr\nend\n    \narr = [-3, -4, 5]\nk = 3\nmaximum(arr, k)",
  "    max = arr[1]\n    for i in 2:length(arr)\n        if arr[i] > max\n       \
    \     max = arr[i]\n        end\n    end\n    return [max for i in 1:k]\nend\n\
    arr1 = [-3, -4, 5]\narr2 = [4, -4, 4]\narr3 = [-3, 2, 1, 2, -1, -2, 1]\n@test\
    \ maximum(arr1, 3) == [-4, -3, 5]\n@test maximum(arr2, 2) == [4, 4]\n@test maximum(arr3,\
    \ 1) == [2]", "    import Base.sort\n    if k == 0\n        return []\n    end\n\
    \    sort!(arr)\n    arr[end-k+1:end]\nend", "    res = zeros(Int64, k)\n    idx\
    \ = 1\n    while idx <= k\n        max = -1\n        max_idx = -1\n        for\
    \ i in 1:length(arr)\n            if arr[i] > max\n                max = arr[i]\n\
    \                max_idx = i\n            end\n        end\n        res[idx] =\
    \ max\n        arr[max_idx] = -10001\n        idx += 1\n    end\n    return res\n\
    end\narr1 = [-3, -4, 5]\narr2 = [4, -4, 4]\narr3 = [-3, 2, 1, 2, -1, -2, 1]\n\
    @testset \"maximum\" begin\n    @test maximum(arr1, 3) == [-4, -3, 5]\n    @test\
    \ maximum(arr2, 2) == [4, 4]\n    @test maximum(arr3, 1) == [2]\nend", "    N\
    \ = length(arr)\n    k = min(k, N)\n    res = zeros(Int64, k)\n    for i = 1:k\n\
    \        max_idx = 1\n        for j = 2:N-k+i\n            if arr[j] > arr[max_idx]\n\
    \                max_idx = j\n            end\n        end\n        res[i] = arr[max_idx]\n\
    \        arr[max_idx] = arr[N-k+i]\n    end\n    return res\nend", "    heap =\
    \ MaxHeap(arr[1:k])\n    push!(heap, arr[k+1:end])\n    return collect(heap)\n\
    end", "    # Maximum heap\n    h = MaxHeap()\n    # While the size of the heap\
    \ is less than k \n    # Push all the elements in the heap\n    for i = 1:k\n\
    \        push!(h, arr[i])\n    end\n    # While the size of the heap is greater\
    \ than k\n    # Pop the max and push in the next element\n    for i = k+1:length(arr)\n\
    \        if arr[i] > h.data[1]\n            pop!(h)\n            push!(h, arr[i])\n\
    \        end\n    end\n    # Return the sorted heap data\n    return sort(h.data)\n\
    end", "    sorted_arr = sort(arr)\n    return sorted_arr[end-k+1:end]\nend", " \
    \   # sort the array in descending order\n    sortedarr = sort(arr, rev=true)\n\
    \    # return the first k elements\n    return sortedarr[1:k]\nend", '    n =
    length(arr)', "    n = length(arr)\n    if k == n\n        return sort(arr)\n\
    \    end\n    new_arr = zeros(Int64, n-k+1)\n    for i in 1:n-k+1\n        new_arr[i]\
    \ = arr[i:i+k-1] |> sort |> last\n    end\n    sort(new_arr)\nend", "    length(arr)\
    \ == k ? sort(arr) : sort(arr)[end-k+1:end]\nend", "    n = length(arr)\n    i\
    \ = 1\n    j = 1\n    while i < k\n        while j < n\n            if arr[i]\
    \ < arr[j]\n                arr[i], arr[j] = arr[j], arr[i]\n            end\n\
    \            j += 1\n        end\n        i += 1\n        j = i + 1\n    end\n\
    \    return arr[1:k]\nend", '    heap = PriorityQueue()', "    # sort the array,\
    \ then return the last k elements\n    sortedarr = sort(arr)\n    return sortedarr[end-k+1:end]\n\
    end\nmaximum([-3, -4, 5], 3)", "    n = length(arr)\n    return sort(arr)[end\
    \ - k + 1:end]\nend", "    nums = []\n    sizeh = 0\n    sizet = 0\n    while\
    \ sizet < length(arr)\n        push!(nums, arr[sizet])\n        sizet += 1\n \
    \       sizeh += 1\n        if sizeh > k\n            popfirst!(nums)\n      \
    \      sizeh -= 1\n        end\n    end\n    while length(nums) > k\n        popfirst!(nums)\n\
    \    end\n    return sort(nums)\nend", "    sort(arr, by=x->(-x))[1:k]\nend",
  "    lens = length(arr)\n    if lens == k\n        return arr\n    end\n    left\
    \ = 1\n    right = k\n    while right < lens\n        j = right\n        while\
    \ j >= left && arr[j] >= arr[j-1]\n            j -= 1\n        end\n        for\
    \ i in reverse(left:j-1)\n            if arr[i] >= arr[right]\n              \
    \  arr[i+1:right] = arr[i:right-1]\n                arr[i] = arr[right]\n    \
    \            break\n            end\n        end\n        left += 1\n        right\
    \ += 1\n    end\n    return arr[1:k]\nend", "    return sort(arr)[end - k + 1:end]\n\
    end", "    return sort(arr)[end-k+1:end]\nend", "    if k == 0\n        return\
    \ [0]\n    end\n    n = length(arr)\n    if k >= n\n        return sort(arr)\n\
    \    end\n    return sort(arr)[n-k+1:n]\nend", "    # Remove all negative numbers\
    \ and sort\n    # remove negative numbers\n    arr = arr[arr .> 0]\n    # sort\n\
    \    @time sort!(arr)\n    # remove the last element if number of elements is\
    \ greater than k\n    while length(arr) > k\n        deleteat!(arr,end)\n    end\n\
    \    # return the result\n    return arr\nend", "    l = length(arr)\n    if l\
    \ == 0 || k == 0\n        return []\n    end\n    if k == 1\n        return [maximum(arr)]\n\
    \    end\n    if k == l\n        return sort(arr)\n    end\n    if k > l\n   \
    \     return \"k can't be greater than length of arr\"\n    end\n    # Partition\
    \ arr around pivot: \n    # pivot is the first element of the array\n    # all\
    \ element < pivot are before pivot and\n    # all elements > pivot are after pivot\n\
    \    function partition(arr::Vector{Int64}, pivot::Int64)::Int64\n        i =\
    \ pivot + 1\n        j = length(arr)\n        while i <= j\n            while\
    \ i <= length(arr) && arr[i] >= arr[pivot]\n                i += 1\n         \
    \   end\n            while j >= pivot + 1 && arr[j] < arr[pivot]\n           \
    \     j -= 1\n            end\n            if i < j\n                arr[i], arr[j]\
    \ = arr[j], arr[i]\n            end\n        end\n        arr[pivot], arr[j] =\
    \ arr[j], arr[pivot]\n        return j\n    end\n    # return index of the kth\
    \ smallest element in arr\n    function kth_smallest(arr::Vector{Int64}, k::Int64)::Int64\n\
    \        if k > length(arr)\n            return \"k can't be greater than length\
    \ of arr\"\n        end\n        pivot = rand(1:length(arr))\n        pivot =\
    \ partition(arr, pivot)\n        if pivot == k - 1\n            return pivot\n\
    \        elseif pivot > k - 1\n            return kth_smallest(arr[1:pivot], k)\n\
    \        else\n            return kth_smallest(arr[pivot + 1:end], k - pivot -\
    \ 1)\n        end\n    end\n    i = kth_smallest(arr, k)\n    return sort(arr[i\
    \ + 1:end])\nend", "    n = length(arr)\n    if k == n\n        return sort(arr)\n\
    \    end\n    if k == 1\n        max = arr[1]\n        for i in 2:n\n        \
    \    if arr[i] > max\n                max = arr[i]\n            end\n        end\n\
    \        return [max]\n    end\n    if k == 0\n        return []\n    end\n  \
    \  indices = Vector{Int64}()\n    indices = [i for i in 1:k]\n    max = maximum(arr,\
    \ 1)[1]\n    for i in k+1:n\n        if arr[i] > max\n            push!(indices,\
    \ i)\n            max = arr[i]\n        end\n    end\n    partial = sort(arr[indices])\n\
    \    return partial\nend", "    push!(arr, maximum(arr))\n    arr\nend", "   \
    \ out = Array{Int64}(undef, k)\n    for i in 1:k\n        m_idx = 1\n        for\
    \ j in 2:length(arr)\n            if arr[j] > arr[m_idx]\n                m_idx\
    \ = j\n            end\n        end\n        out[i] = arr[m_idx]\n        arr[m_idx]\
    \ = -Inf\n    end\n    return out\nend", "    top_k_indices = findmax(arr, k)[2]\n\
    \    sort(arr[top_k_indices])\nend", "    if k == 1\n        return [maximum(arr)]\n\
    \    end\n    s = []\n    for i in arr\n        push!(s, i)\n    end\n    sort!(s)\n\
    \    return s[end - k + 1:end]\nend", "    return sort(arr, rev=true)[1:k]\nend",
  "    \"\"\"\n    Find the maximum k numbers from arr.\n    \"\"\"\n    heap = MaxHeap()\n\
    \    for i in 1:k\n        push!(heap, arr[i])\n    end\n    for i in k+1:length(arr)\n\
    \        if arr[i] > top(heap)\n            pop!(heap)\n            push!(heap,\
    \ arr[i])\n        end\n    end\n    maximum = Array{Int64}(k)\n    for i in 1:k\n\
    \        maximum[i] = pop!(heap)\n    end\n    return maximum\nend", "    pq =\
    \ PriorityQueue()\n    for i in 1:length(arr)\n        enqueue!(pq, (arr[i], i))\n\
    \    end\n    j = 1\n    result = []\n    while j <= k\n        popped = pop!(pq)\n\
    \        if popped[2] != i\n            push!(result, popped[1])\n           \
    \ j += 1\n        end\n    end\n    return result\nend\nmaximum([-3, -4, 5], 3)",
  "    n = length(arr)\n    arr_maxk = sort(arr)[n-k+1:n]\n    return arr_maxk\nend",
  "    n = length(arr)\n    if k == n\n        return sort(arr)\n    end\n    @assert\
    \ k <= n", "    # Some Input Checking\n    @assert 1 <= k <= length(arr) \"k must\
    \ be greater than 0 and less than or equal to length of arr\"\n    return sort(arr)[end-k+1:end]\n\
    end", "    len = length(arr)\n    max_k = zeros(Int64, k)\n    @inbounds for i\
    \ in 1:k\n        max_k[i] = i\n    end\n    @inbounds for i in k+1:len\n    \
    \    if arr[i] > arr[max_k[1]]\n            max_k[1] = i\n            @inbounds\
    \ for j in 2:k\n                if arr[max_k[j]] < arr[max_k[j-1]]\n         \
    \           tmp = max_k[j]\n                    max_k[j] = max_k[j-1]\n      \
    \              max_k[j-1] = tmp\n                else\n                    break\n\
    \                end\n            end\n        end\n    end\n    sorted = zeros(Int64,\
    \ k)\n    @inbounds for i in 1:k\n        sorted[i] = arr[max_k[i]]\n    end\n\
    \    return sorted\nend", "    # sort!(arr)\n    # reverse!(arr)\n    # return\
    \ take(arr, k)\n    max_k_array = Vector{Int64}()\n    for i in 1:k\n        push!(max_k_array,\
    \ -Inf)\n    end\n    for i in 1:length(arr)\n        if arr[i] > max_k_array[1]\n\
    \            max_k_array[1] = arr[i]\n            sort!(max_k_array)\n       \
    \ end\n    end\n    return max_k_array\nend", "    partition_at_k(arr, k)\n  \
    \  arr[1:k]\nend", '    n = length(arr)', "    \"\"\"\"\n    Sorts the vector\
    \ with the largest k elements.\n    \"\"\"\n    if k == 0\n        return Vector{Int64}()\n\
    \    end\n    sort!(arr, rev=true)\n    return arr[1:k]\nend", "    \n    output\
    \ = Vector{Int64}()\n    push!(output, -Inf)", "    # filter out the maximum k\
    \ elements\n    filter(x -> x >= maximum(arr[:k]), arr)\nend", "    sort(arr)[end-k+1:end]\n\
    end\nmaximum([-3, -4, 5], 3)\nmaximum([4, -4, 4], 2)\nmaximum([-3, 2, 1, 2, -1,\
    \ -2, 1], 1)", "    l = length(arr)\n    if k > l\n        error(\"k must be less\
    \ than or equal to the length of the input.\")\n    end\n    i = 1\n    j = k\n\
    \    while i < j\n        arr[i], arr[j] = arr[j], arr[i]\n        i += 1\n  \
    \      j -= 1\n    end\n    arr[1:k]\nend", "    n = length(arr)\n    if k >=\
    \ n\n        return sort(arr, rev=true)\n    end\n    heap = MaxHeap()\n    for\
    \ i in 1:k\n        push!(heap, arr[i])\n    end\n    for i in k+1:n\n       \
    \ top = top!(heap)\n        if arr[i] > top\n            pop!(heap)\n        \
    \    push!(heap, arr[i])\n        end\n    end\n    res = sort(collect(heap),\
    \ rev=true)\n    return res\nend", "    function partition(arr::Vector{Int64},\
    \ low::Int64, high::Int64) -> Int64\n        pivot = arr[high]\n        i = low\
    \ - 1\n        for j in low:high\n            if arr[j] <= pivot\n           \
    \     i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n            end\n\
    \        end\n        arr[i+1], arr[high] = arr[high], arr[i+1]\n        return\
    \ i + 1\n    end", "    # Initialize a max heap\n    maximum_heap = MaxHeap(k)",
  "    arr[partialsortperm(arr, k)[1:k]]\nend", "    heap = Base.heapify(MaxHeap{Int64},\
    \ arr[1:k])\n    heap = merge!(heap, Maximum(arr[k+1:end]))\n    return collect(heap)\n\
    end", "    # @show arr, k\n    n = length(arr)\n    if k == n\n        return\
    \ sort(arr, rev=true)\n    end\n    pivot = arr[rand(1:n)]\n    # @show pivot\n\
    \    left = [i for i in arr if i > pivot]\n    middle = [i for i in arr if i ==\
    \ pivot]\n    right = [i for i in arr if i < pivot]\n    # @show left, middle,\
    \ right\n    if k <= length(left)\n        return maximum(left, k)\n    elseif\
    \ k <= length(left) + length(middle)\n        return sort(concatenate((left, middle)),\
    \ rev=true)\n    else\n        return sort(concatenate((left, middle, maximum(right,\
    \ k - length(left) - length(middle)))), rev=true)\n    end\nend", "    b = Array{Int64}(length(arr))\n\
    \    for i = 1:length(arr)\n        b[i] = i\n    end\n    for i = 1:length(arr)\n\
    \        for j = 1:length(arr)\n            if arr[b[i]] > arr[b[j]]\n       \
    \         t = b[i]\n                b[i] = b[j]\n                b[j] = t\n  \
    \          end\n        end\n    end\n    @show arr[b[1:k]]\nend", "    # 1. Sort\
    \ the array (use Arrays.sort!)\n    sort!(arr)\n    # 2. Slice it to get the last\
    \ k element\n    arr[end-k+1:end]\nend", "    n = length(arr)\n    if n == k\n\
    \        return sort(arr, rev=true)\n    end\n    heap = BHeap{Int64}()\n    for\
    \ i in 1:k\n        heap.push(arr[i])\n    end\n    for i in k+1:n\n        if\
    \ arr[i] > heap.peek()\n            heap.pop()\n            heap.push(arr[i])\n\
    \        end\n    end\n    return sort(heap.data, rev=true)\nend", "    len =\
    \ length(arr)\n    res = []\n    for i in 1:k\n        val, ind = findmax(arr)\n\
    \        push!(res, val)\n        deleteat!(arr, ind)\n    end\n    res\nend",
  "    len = length(arr)\n    if len == k\n        return sort(arr)\n    end\n   \
    \ if k == 1\n        return sort(arr)[end]\n    end\n    i = 1\n    if len <=\
    \ k\n        return sort(arr)\n    end\n    while i <= k\n        j = i + 1\n\
    \        while j <= len\n            if arr[i] < arr[j]\n                arr[i],\
    \ arr[j] = arr[j], arr[i]\n            end\n            j += 1\n        end\n\
    \        i += 1\n    end\n    return sort(arr[1:k])\nend", "    max_heap = MaxHeap(Int64)\n\
    \    for i in 1:k\n        push!(max_heap, arr[i])\n    end\n    for i in k+1:length(arr)\n\
    \        if arr[i] > max_heap.root\n            pop!(max_heap)\n            push!(max_heap,\
    \ arr[i])\n        end\n    end\n    return to_array(max_heap)\nend", "    n =\
    \ length(arr)\n    # Create a priority queue and insert the first k values \n\
    \    # into the queue.\n    pq = PriorityQueue(lt=lt, init=[arr[i] for i = 1:k])\n\
    \    # For each element x in the array that we haven't looked \n    # at yet,\
    \ add x to the priority queue if x is larger than \n    # the root of the priority\
    \ queue, and then remove the root \n    # element.\n    for i = k+1:n\n      \
    \  x = arr[i]\n        root = pop!(pq)\n        if x > root\n            push!(pq,\
    \ x)\n        else\n            push!(pq, root)\n        end\n    end\n    # Return\
    \ the sorted k values.\n    sort(collect(pq))\nend", "    \"\"\"\n    This function\
    \ takes an array of integers and an integer k and returns a \n    vector of size\
    \ k with the maximum k numbers in the array.", "    \"\"\"\n    Returns a sorted\
    \ vector of the maximum k numbers in arr\n    \"\"\"\n    @assert k <= length(arr)\n\
    \    arr_new = copy(arr)\n    indices = sortperm(arr_new)[end-k+1:end]\n    return\
    \ sort(arr_new[indices])\nend", "    n = length(arr)\n    # Initialize a PriorityQueue\
    \ with size k and a descending sort\n    q = PriorityQueue(k, true)\n    for i\
    \ in 1:n\n        # if queue is not full, push the element into the queue\n  \
    \      if !isfull(q)\n            enqueue!(q, arr[i])\n        else\n        \
    \    # peek the first (largest) element in the queue\n            max = peek(q)\n\
    \            # if arr[i] is smaller than max, replace max in the queue with arr[i]\n\
    \            if max > arr[i]\n                replace!(q, arr[i])\n          \
    \  end\n        end\n    end\n    # Convert the heap into a sorted array \n  \
    \  return sort!(Array(q))\nend", "    n = length(arr)\n    @assert n >= k >= 0\n\
    \    maxk = zeros(Int64, k)", "    pq = PriorityQueue()\n    for i \u2208 1:k\
    \ \n        push!(pq, arr[i])\n    end\n    for i \u2208 k+1:length(arr)\n   \
    \     if arr[i] > top!(pq)\n            pop!(pq)\n            push!(pq, arr[i])\n\
    \        end\n    end\n    out = []\n    while !isempty(pq)\n        push!(out,\
    \ top!(pq))\n        pop!(pq)\n    end\n    return reverse(out)\nend", "    #\
    \ create a heap\n    heap = Heap()\n    # check if the length of the array is\
    \ less than k\n    if length(arr) < k\n        # do nothing since the solution\
    \ is the whole array\n        sol = arr\n    elseif length(arr) == k\n       \
    \ # arrange the array in ascending order and return the reversed array\n     \
    \   sol = reverse(sort(arr))\n    else\n        # initialize solution vector with\
    \ the first k elements in the array\n        sol = arr[1:k]\n        # we will\
    \ now arrange them in ascending order using a heap\n        for element in sol\n\
    \            heap.push(element)\n        end\n        # we will use a for loop\
    \ to compare the last k elements from the array to the elements in the heap\n\
    \        for i = k+1:length(arr)\n            # if the current element is less\
    \ than the top element in the heap, pop it and insert it\n            if arr[i]\
    \ < heap.peek()\n                heap.pop()\n                heap.push(arr[i])\n\
    \            end\n        end\n        # we have obtained the k minimum elements\
    \ in the array\n        # we will pop them to obtain the descending order\n  \
    \      for i = 1:k\n            sol[i] = heap.pop()\n        end\n    end\n  \
    \  # return the solution\n    return sol\nend", "    @assert k <= length(arr)\n\
    \    for index in 1:k\n        for j = index:length(arr)\n            if arr[index]\
    \ < arr[j]\n                arr[index], arr[j] = arr[j], arr[index]\n        \
    \    end\n        end\n    end\n    return arr[1:k]\nend", "    arr_size = length(arr)\n\
    \    if arr_size < k\n        return arr\n    end\n    # Get kth largest element\
    \ \n    kth = maximum(arr, k, 1, arr_size) \n    # Find all elements which are\
    \ greater than kth largest element \n    # And sort these elements \n    return\
    \ maximum(arr, k, 1, arr_size, kth) \nend", "    n = length(arr)\n    if n ==\
    \ k\n        return sort(arr)\n    end\n    for i in n - k + 1:n\n        for\
    \ j in 1:i - 1\n            if arr[j] > arr[i]\n                arr[j], arr[i]\
    \ = arr[i], arr[j]\n            end\n        end\n    end\n    return arr[n -\
    \ k + 1:n]\nend", "    # quickselect algorithm\n    return sort(maximum(arr, k,\
    \ 1, length(arr)))\nend", "    h = Dict{Int64,Int64}()\n    for val in arr\n \
    \       if !haskey(h, val)\n            h[val] = 1\n        else\n           \
    \ h[val] += 1\n        end\n    end\n    heap = []\n    for (key,value) in h\n\
    \        push!(heap, (key,value))\n    end\n    build_max_heap!(heap)\n    out\
    \ = []\n    while k > 0\n        (key,value) = pop!(heap)\n        if value ==\
    \ 1\n            push!(out, key)\n            k -= 1\n        else\n         \
    \   value -= 1\n            push!(heap, (key,value))\n        end\n    end\n \
    \   return out\nend", "    i = maximum_k_index(arr, 1, length(arr), k)\n    return\
    \ view(arr, 1:i)\nend", "    # Initialize a vector with zeros with length k\n\
    \    result = zeros(Int64, k)", "    sorted = sort(arr)\n    for i in 1:length(sorted)\n\
    \        if i == k\n            return sorted[(i-k+1):i]\n        end\n    end\n\
    end", "    ans = []\n    for i in 1:k\n        maximum = 0\n        index = 0\n\
    \        for j in 1:length(arr)\n            if j in ans\n                continue\n\
    \            end\n            if arr[j] > maximum\n                maximum = arr[j]\n\
    \                index = j\n            end\n        end\n        push!(ans, index)\n\
    \    end\n    ans = [arr[i] for i in ans]\n    return ans\nend", "    heap = MaxHeap()\n\
    \    for (i, v) in enumerate(arr)\n        push!(heap, v)\n        if i > k\n\
    \            pop!(heap)\n        end\n    end\n    return reverse!(heap)\nend",
  "    ans = zeros(Int64, k)\n    @inbounds for i in 1:k\n        ans[i] = arr[i]\n\
    \    end\n    for i in k+1:length(arr)\n        idx = minimum_index(ans)\n   \
    \     if ans[idx] < arr[i]\n            ans[idx] = arr[i]\n        end\n    end\n\
    \    return sort(ans)\nend", "    # 1. sorting arr\n    # 2. pick up first k\n\
    \    # 3. reverse it \n    sortedarr = sort(arr)\n    reversedarr = reverse(sortedarr)\n\
    \    return reversedarr[1:k]\nend", "    # @assert 0 <= k <= length(arr) \n  \
    \  # @assert k > 0 \n    # ______________\n    # check array size:\n    len =\
    \ length(arr) \n    if len == k \n        return arr \n    end \n    # ______________\n\
    \    # sort the array:\n    # sort(arr, rev=true) \n    # ______________\n   \
    \ # build a max-heap:\n    max_heap = build_max_heap(arr) \n    # ______________\n\
    \    # sort in descending order:\n    for i = len:-1:len-k+1 \n        # swap\
    \ values:\n        max_heap[1], max_heap[i] = max_heap[i], max_heap[1] \n    \
    \    # heapify:\n        heapify(max_heap, 1, i-1) \n    end \n    # ______________\n\
    \    # return the top k elements:\n    return max_heap[end-k+1:end] \nend ", " \
    \   n = length(arr)\n    if k > n\n        k = n\n    end\n    q = BoundedPriorityQueue{Int64,\
    \ ReverseLessThan, Int64}(k)\n    for i = 1:n\n        push!(q, arr[i])\n    end\n\
    \    res = Vector{Int64}(undef, k)\n    for i = 1:k\n        res[i] = pop!(q)\n\
    \    end\n    return res\nend", "    \"\"\"\n    Get the maximum `k` of an array\
    \ `arr` (Vector{Int64}).\n    \"\"\"\n    n = length(arr)\n    left = 1\n    right\
    \ = n\n    i = div(left + right, 2)", "    left = 0\n    right = length(arr) -\
    \ 1\n    pivot = arr[left]\n    x = left + 1\n    y = right\n    while x <= y\n\
    \        while x <= y && arr[x] >= pivot\n            x += 1\n        end\n  \
    \      while x <= y && arr[y] <= pivot\n            y -= 1\n        end\n    \
    \    if x < y\n            arr[x], arr[y] = arr[y], arr[x]\n        end\n    end\n\
    \    arr[left], arr[y] = arr[y], arr[left]\n    if y == k - 1\n        return\
    \ arr[1:k]\n    elseif y > k - 1\n        return maximum(arr[1:y], k)\n    else\n\
    \        return maximum(arr[y + 1:end], k - y - 1)\n    end\nend", "    sortedArr\
    \ = sort(arr)\n    nums = Vector{Int64}(undef, k)\n    nums[1:k] = sortedArr[end-k+1:end]\n\
    \    return nums\nend", "    heap = Array{Int64}(undef, k)\n    fill!(heap, 1000)\n\
    \    heapify!(heap)\n    for i in arr \n        if i < maximum(heap)\n       \
    \     push!(heap, i)\n            sort!(heap)\n            pop!(heap)\n      \
    \  end\n    end\n    return heap\nend\narr = [-3, -4, 5]\nk = 3\nmaximum(arr,\
    \ k)", "    if length(arr) == k\n        return sort(arr, rev=true)\n    end\n\
    \    if length(arr) == k + 1\n        return sort(arr, rev=true)[1:k]\n    end\n\
    \    arr = sort(arr, rev=true)\n    return arr[1:k]\nend", "    if k == 0\n  \
    \      return []\n    end\n    pivot = arr[1]\n    left = [x for x in arr if x\
    \ > pivot]\n    right = [x for x in arr if x <= pivot]\n    if length(left) ==\
    \ k\n        return left\n    elseif length(left) > k\n        return maximum(left,\
    \ k)\n    else\n        return maximum(right, k - length(left))\n    end\nend\n\
    @show maximum([-3, -4, 5], 3)\n@show maximum([4, -4, 4], 2)\n@show maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1)\n@show maximum([-3, 2, 1, 2, -1, -2, 1], 2)\n@show maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 4)\n@show maximum([-3, 2, 1, 2, -1, -2, 1], 7)\n@show maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 8)\n@show maximum([-3, 2, 1, 2, -1, -2, 1], 0)", "    \"\
    \"\"\n    Returns a sorted list of length k with the maximum k numbers in arr\n\
    \    \"\"\"\n    maxes = Vector{Int64}(undef, k)\n    maxes[1] = arr[1]\n    k_copy\
    \ = k\n    for i in arr[2:end]\n        if i < maxes[k_copy]\n            continue\n\
    \        else\n            j = k_copy\n            while j > 1 && i > maxes[j-1]\n\
    \                maxes[j] = maxes[j-1]\n                j -= 1\n            end\n\
    \            maxes[j] = i\n        end\n    end\n    return maxes\nend", "   \
    \ k_max = maximum_k(arr, k)\n    return sort(k_max)\nend", "    # sort the array\
    \ first\n    sorted_arr = sort(arr)\n    # make a new vector with last k elements\n\
    \    final_arr = Vector{Int64}(undef, k)\n    for i in 1:k\n        final_arr[i]\
    \ = sorted_arr[length(sorted_arr) - k + i]\n    end\n    return final_arr\nend",
  "    # We will only use the first k elements of the array to avoid setting up another\
    \ \n    # sortable array.\n    heap = arr[1:k]\n    heap_size = k\n    build_max_heap!(heap,\
    \ heap_size)\n    for i = k+1:length(arr)\n        if arr[i] > heap[1]\n     \
    \       heap[1] = arr[i]\n            max_heapify!(heap, 1, heap_size)\n     \
    \   end\n    end\n    sort!(heap)\n    return heap\nend", "    @assert k <= length(arr)\n\
    \    sorted_array = sort(arr)\n    sorted_array[end-k+1:end]\nend", "    n = length(arr)\n\
    \    pq = BHeap{Int64}()\n    for i in 1:k\n        push!(pq, arr[i])\n    end\n\
    \    for i in k+1:n\n        x = pop!(pq)\n        if arr[i] > x\n           \
    \ push!(pq, arr[i])\n        else\n            push!(pq, x)\n        end\n   \
    \ end\n    return sort(collect(pq), rev=true)\nend", "    n = length(arr)\n  \
    \  first = 1\n    last = n\n    k = min(k, n)\n    k = max(k, 1)\n    sorted =\
    \ Array{Int64}(undef, k)\n    for i = 1:k\n        max_idx = first\n        for\
    \ j = first:last\n            if arr[j] > arr[max_idx]\n                max_idx\
    \ = j\n            end\n        end\n        sorted[i] = arr[max_idx]\n      \
    \  arr[max_idx] = arr[last]\n        last -= 1\n    end\n    return sorted\nend",
  "    arr = sort(arr)\n    arr[end:-1:end-k+1]\nend", "    \"\"\"\n    Compute the\
    \ maximum of k values in arr\n    \"\"\"\n    # Verify inputs\n    @assert length(arr)\
    \ >= k >= 0", "    values = []\n    for i = 1:k\n        idx = argmax(arr)\n \
    \       push!(values, arr[idx])\n        arr = [arr[i] for i in 1:length(arr)\
    \ if i != idx]\n    end\n    return values\nend", "    sorted = sort(arr, rev=true)\n\
    \    return sorted[1:k]\nend", "    sorted_arr = sort(arr, rev=true)\n    return(sorted_arr[1:k])\n\
    end", "    quick_select(arr, k)\nend", "    if k == 0\n        return []\n   \
    \ end\n    if k >= length(arr)\n        return sort(arr)\n    end\n    if k ==\
    \ 1\n        return [maximum(arr)]\n    end\n    return sort(maximum(arr[1:k],\
    \ k), maximum(arr[(k+1):end], k))\nend", "    @assert 1 <= k <= length(arr)\n\
    \    return sort(arr)[end-k+1:end]\nend", "    if k == 0 return [] end\n    @assert\
    \ k <= length(arr)\n    x = []\n    for i in 1:k\n        insert!(x, arr[i])\n\
    \    end\n    for i in k+1:length(arr)\n        insert!(x, arr[i])\n        sort!(x)\n\
    \        deleteat!(x, 1)\n    end\n    sort!(x)\n    return x\nend", "    \n \
    \   # Sort the given array\n    sorted_arr = sort(arr)\n    \n    # Reverse the\
    \ sorted array\n    sorted_arr = reverse(sorted_arr)\n    \n    # If k == length(arr)\
    \ then return the sorted array\n    if k == length(arr)\n        return sorted_arr\n\
    \    end\n    \n    # Create a new vector to store the maximum k numbers\n   \
    \ maximum_k_vector = Vector{Int64}(undef, k)\n    \n    # Add the maximum k numbers\
    \ to the vector\n    for i in 1:k\n        push!(maximum_k_vector, sorted_arr[i])\n\
    \    end\n    \n    # Return the vector\n    return maximum_k_vector\nend", " \
    \   max_arr = Vector{Int64}()\n    for i in arr\n        if length(max_arr) <\
    \ k\n            push!(max_arr, i)\n        else\n            if maximum(max_arr)\
    \ < i\n                max_arr[1] = i\n            end\n        end\n        max_arr\
    \ = sort(max_arr, rev=true)\n    end\n    return max_arr\nend", "    if k == length(arr)\n\
    \        return sort(arr)\n    end\n    m = maximum(arr)\n    l = zeros(Int64,\
    \ k)\n    l[1] = m\n    for i = 2:k\n        m = maximum(filter(x -> x < m, arr))\n\
    \        l[i] = m\n    end\n    sort(l)\nend", "    # get k maximum values from\
    \ an array\n    return sort(arr, rev=true)[1:k]\nend", "    curr_max = 0\n   \
    \ max_list = zeros(Int64, k)\n    for i in 1:length(arr)\n        if i <= k\n\
    \            max_list[i] = arr[i]\n            curr_max = maximum(max_list)\n\
    \        elseif arr[i] > curr_max\n            ind = find(max_list .== curr_max)\n\
    \            max_list[ind[1]] = arr[i]\n            curr_max = maximum(max_list)\n\
    \        end\n    end\n    return sort(max_list, rev=true)\nend\nmaximum([-3,\
    \ -4, 5], 3)\nmaximum([4, -4, 4], 2)\nmaximum([-3, 2, 1, 2, -1, -2, 1], 1)\n \n\
    # Problem 4", "    left, right = 1, length(arr)\n    while left <= right\n   \
    \     mid = div(left + right, 2)\n        if sum(max.(arr[1:mid], arr[mid+1:end]))\
    \ <= k\n            left = mid + 1\n        else\n            right = mid - 1\n\
    \        end\n    end\n    return sort(vcat(arr[1:left-1], arr[left:end]), rev=true)[1:k]\n\
    end\narr = [-3, -4, 5]\nk = 3\n@show maximum(arr, k)", "    mx = maximum(arr)\n\
    \    for i in 1:k\n        @inbounds for j in 1:length(arr)\n            if mx\
    \ < arr[j]\n                mx = arr[j]\n            end\n        end\n      \
    \  push!(res, mx)\n        mx = minimum(arr)\n    end\n    res\nend", "    # if\
    \ k = 1 then return maximum of array\n    if k == 1\n        return maximum(arr)\n\
    \    end\n    result = []\n    for i = 1:k\n        push!(result, pop!(arr))\n\
    \    end\n    result = sort(result)\n    for i = k+1:length(arr)\n        curr\
    \ = arr[i]\n        is_inserted = false\n        for j = 1:k\n            # if\
    \ current element is greater than an element in the result\n            # then\
    \ replace that element with the current element and sort\n            if curr\
    \ > result[j]\n                result[j] = curr\n                is_inserted =\
    \ true\n                result = sort(result)\n                break\n       \
    \     end\n        end\n        # if no element in the result is smaller than\
    \ the current element\n        # then leave the result as it is\n        if !is_inserted\n\
    \            continue\n        end\n    end\n    return result\nend", "    # initialize\
    \ max heap\n    heap = initialize(arr)\n    # initialize result\n    result =\
    \ Vector{Int64}(undef, k)\n    i = 1\n    while i <= k\n        result[i] = heap[1]\n\
    \        heap[1] = heap[end]\n        heap = heap[1:end-1]\n        heap = maxHeapify(heap,\
    \ i)\n        i += 1\n    end\n    return result\nend", "    quickselect(arr,\
    \ k)\nend", "    if length(arr) <= k\n        return sort(arr, rev=true)\n   \
    \ end\n    ret = sort(arr[1:k], rev=true)\n    for x in arr[k+1:end]\n       \
    \ i = findfirst(ret .< x)\n        if i != nothing\n            ret[i:end-1] =\
    \ ret[i+1:end]\n            ret[end] = x\n        end\n    end\n    return ret\n\
    end", "    println(\"----------------------------------------------------------------------\"\
    )\n    println(\"for [$(join(', ', arr))] -> maximum([$(join(', ', arr))], $k)\"\
    )\n    println(\"----------------------------------------------------------------------\"\
    )\n    ret = zeros(Int64, k)\n    for i in 1:k\n        ret[i] = maximum(arr)\n\
    \        arr = filter(x -> x != maximum(arr), arr)\n    end\n    return ret\n\
    end", "    sorted_arr = sort(arr)\n    return sorted_arr[end - k + 1:end]\nend",
  "    \n    n = length(arr)\n    # Create a new array to store the result\n    res\
    \ = Array{Int64}(undef, k)\n    # Initialize first k elements of the result\n\
    \    for i = 1:k\n        res[i] = arr[i]\n    end\n    # Sort the result\n  \
    \  sort!(res)\n    # Start from k+1 element and insert in the appropriate index\
    \ to maintain \n    # the sorted order \n    for i = k+1:n\n        res = insert(res,\
    \ arr[i])\n    end\n    return res\nend", "    heap = BinaryHeap()\n    # push\
    \ first k element onto heap\n    for i in 1:k\n        push!(heap, arr[i])\n \
    \   end\n    # push remaining elements onto heap\n    for i in k+1:length(arr)\n\
    \        push!(heap, arr[i])\n        shift!(heap)\n    end\n    return(heap.data)\n\
    end", "    return sort(arr)[end-k+1:end]\nend", "    arr_len = length(arr)\n \
    \   if k >= arr_len\n        return sort(arr)\n    end\n    m::Int64 = 0\n   \
    \ for i::Int64 in 1:k\n        m = i\n        for j::Int64 in i+1:arr_len\n  \
    \          if arr[j] > arr[m]\n                m = j\n            end\n      \
    \  end\n        if m != i\n            arr[i], arr[m] = arr[m], arr[i]\n     \
    \   end\n    end\n    return sort(arr[1:k])\nend", "    return sort(arr, by=i->-i)[1:k]\n\
    end", "    max_heap = MaxHeap()\n    for (i, item) in enumerate(arr)\n       \
    \ if i < k\n            push!(max_heap, item)\n        else\n            peek!(max_heap)\
    \ > item && pop!(max_heap)\n            push!(max_heap, item)\n        end\n \
    \   end\n    return max_heap.data\nend", "    length(arr) >= k ? sort(arr)[end\
    \ - k + 1:end] : throw(ArgumentError(\"k should be smaller than the length of\
    \ the array\"))\nend\n\"\"\"\n    Given a matrix of size m x n, you need to swap\
    \ its first and last column. \n    Your task is to swap the first and last column\
    \ and return the modified matrix.", "    \"\"\"\n    Find the maximum k numbers\
    \ in arr.", "    max_indices = zeros(Int64, k)\n    for i in 1:k\n        max_indices[i]\
    \ = i\n    end\n    for i in k+1:length(arr)\n        max_indices[1] = i\n   \
    \     for j in 2:k\n            if arr[max_indices[j]] > arr[max_indices[j-1]]\n\
    \                temp = max_indices[j]\n                max_indices[j] = max_indices[j-1]\n\
    \                max_indices[j-1] = temp\n            end\n        end\n    end\n\
    \    sort!(arr[max_indices])\nend", "    arr = sort(arr)\n    return arr[end -\
    \ k + 1:end]\nend", "    start, finish = k-1, length(arr)\n    result = []\n \
    \   for i in start:finish\n        current_max = arr[i]\n        for j in i-k+1:i\n\
    \            if arr[j] > current_max\n                current_max = arr[j]\n \
    \           end\n        end\n        push!(result, current_max)\n    end\n  \
    \  return result\nend", "    heap = BinaryHeap(max)\n    for i in 1:k\n      \
    \  push!(heap, arr[i])\n    end\n    for i in k+1:length(arr)\n        if arr[i]\
    \ > peek(heap)\n            pop!(heap)\n            push!(heap, arr[i])\n    \
    \    end\n    end\n    return sort(collect(heap), rev=true)\nend", "    i = 1\n\
    \    while k > 0\n        i = 2 * i\n        k -= 1\n    end\n    heapify(arr,\
    \ i)\n    i = (length(arr) - 1) * 2\n    while i >= 2\n        arr[1], arr[i]\
    \ = arr[i], arr[1]\n        sift_down(arr, i, 1)\n        i -= 2\n    end\n  \
    \  return arr[1:k]\nend", "    arr = sort(arr, rev=true)\n    return arr[1:k]\n\
    end", "    \n    if k == length(arr)\n        return sort(arr)\n    end", "  \
    \  maximums = zeros(Int64, k)\n    for x in arr\n        if x > maximums[1]\n\
    \            minimums[1] = x\n            maximums = sort(maximums)\n        end\n\
    \    end\n    return maximums\nend", "    maxs = []\n    i = 1\n    while i \u2264\
    \ k\n        max = Int64(arr[i])\n        for j in i:length(arr)\n           \
    \ if max < arr[j]\n                max = arr[j]\n            end\n        end\n\
    \        push!(maxs, max)\n        arr = filter(x -> x != max, arr)\n        i\
    \ += 1\n    end\n    return maxs\nend", "    heap = Vector{Int64}()\n    for a\
    \ in arr\n        push!(heap, a)\n        if length(heap) > k\n            pop!(heap)\n\
    \        end\n    end\n    return reverse(sort(heap))\nend", "    n = length(arr)\n\
    \    cmp_func(x::Int64, y::Int64) = x > y\n    quick_select(arr, 1, n, k, cmp_func)\n\
    end", "    for i in 1:k \n        for j in i+1:length(arr) \n            if arr[i]\
    \ < arr[j] \n                temp = arr[i] \n                arr[i] = arr[j] \n\
    \                arr[j] = temp \n            end \n        end \n    end \n  \
    \  return arr[1:k] \nend ", "    n = length(arr)\n    if k > n\n        return\
    \ arr\n    end\n    @inbounds for i in 1:k\n        @inbounds for j in i+1:n\n\
    \            if arr[i] < arr[j]\n                t = arr[i]\n                arr[i]\
    \ = arr[j]\n                arr[j] = t\n            end\n        end\n    end\n\
    \    return arr[1:k]\nend", "    arr_sort = sort(arr)\n    return arr_sort[end-k+1:end]\n\
    end\nmaximum([-3, -4, 5], 3)", "    \n    arr = sort(arr)\n    k_max = []\n  \
    \  \n    for i in 1:k\n        push!(k_max, arr[end-i+1])\n    end\n    \n   \
    \ return k_max\nend", "    n = length(arr)\n    arr = sort(arr)\n    for i in\
    \ 1:n-k+1\n        if (arr[i] < 0 && arr[i+k-1] < 0) || (arr[i] > 0 && arr[i+k-1]\
    \ > 0)\n            return arr[i:i+k-1]\n        end\n    end\n    return arr[n-k+1:n]\n\
    end", "    arr_len = length(arr)\n    if k > arr_len\n        @printf(\"k > length(arr)\"\
    )\n        return -1\n    end\n    if k == arr_len\n        return sort(arr, rev=true)\n\
    \    end\n    push!(arr, typemax(Int64))\n    max_heap = Vector{Int64}(undef,\
    \ k+1)\n    max_heap[1] = typemax(Int64)\n    max_heap[2:k+1] = sort(arr[1:k],\
    \ rev=true)\n    max_heapify(max_heap, k)\n    @printf(\"max_heap = %s\\n\", max_heap)\n\
    \    for i in (k+1):arr_len\n        elem = arr[i]\n        if elem < max_heap[1]\n\
    \            max_heap[1] = elem\n            max_heapify(max_heap, k)\n      \
    \  end\n    end\n    max_heap[1:k]\nend", "    return sort(arr)[end-k+1:end]\n\
    end", "    index = zeros(Int64, 0)\n    maxValue = zeros(Int64, 0)\n    length\
    \ = size(arr)[1]\n    if length < k\n        return arr\n    end\n    for i =\
    \ 1:k\n        maxValue = push!(maxValue, arr[i])\n        index = push!(index,\
    \ i)\n    end\n    for i = k + 1:length\n        check = 0\n        for j = 1:k\n\
    \            if arr[i] > maxValue[j]\n                maxValue[j] = arr[i]\n \
    \               index[j] = i\n                check = 1\n                break\n\
    \            end\n        end\n        if check == 0\n            minimum = maxValue[1]\n\
    \            for j = 1:k\n                if maxValue[j] < minimum\n         \
    \           minimum = maxValue[j]\n                end\n            end\n    \
    \        for j = 1:k\n                if maxValue[j] == minimum\n            \
    \        maxValue[j] = arr[i]\n                    index[j] = i\n            \
    \        break\n                end\n            end\n        end\n    end\n \
    \   sorted = sort!(maxValue)\n    return sorted\nend\n\"\"\"\n    Given an array\
    \ arr of integers and a positive integer k, return a sorted list \n    of length\
    \ k with the maximum k numbers in arr.", "    n = length(arr)\n    if k > n\n\
    \        return -1\n    end\n    max_list = []\n    list_index = 1\n    for num\
    \ in arr\n        if list_index > k\n            list_index = 1\n        end\n\
    \        if list_index == 1\n            max_list = [num]\n        else\n    \
    \        if num > max_list[1]\n                max_list = [num]\n            elseif\
    \ num == max_list[1]\n                push!(max_list, num)\n            end\n\
    \        end\n        list_index += 1\n    end\n    return max_list\nend", " \
    \   heap = BinaryHeap(Int64)\n    for x in arr\n        if length(heap) < k\n\
    \            push!(heap, x)\n        elseif heap[1] < x\n            pop!(heap)\n\
    \            push!(heap, x)\n        end\n    end\n    return sort(collect(heap))\n\
    end", "    N = length(arr)\n    max_arr = zeros(Int64, k)\n    for i in 1:k\n\
    \        max_arr[i] = arr[i]\n    end\n    min_num = min(max_arr)\n    for i in\
    \ (k+1):N\n        if arr[i] > min_num\n            for j in 1:k\n           \
    \     if max_arr[j] == min_num\n                    max_arr[j] = arr[i]\n    \
    \                break\n                end\n            end\n            min_num\
    \ = min(max_arr)\n        end\n    end\n    return sort(max_arr, rev=true)\nend",
  "    # base cases\n    if length(arr) == 0 return Int64[] end\n    if k == 0 return\
    \ Int64[] end\n    if k == 1 return [maximum(arr)] end\n    if k == length(arr)\
    \ return sort(arr) end\n    \n    # define maxes\n    maxes = Vector{Int64}(k)\n\
    \    idx = ones(Int64, k)\n    maxes[1] = arr[1]\n    \n    # loop through array,\
    \ finding k largest values\n    for i in 2:length(arr)\n        # if arr[i] is\
    \ larger than maxes[1], append to maxes\n        if arr[i] > maxes[1]\n      \
    \      push!(maxes, arr[i])\n            push!(idx, i)\n            sort!(maxes,\
    \ rev=true)\n            sort!(idx, rev=true)\n        end\n    end\n    \n  \
    \  # return maxes and sort\n    sort!(maxes, rev=true)\n    return maxes\nend",
  "    return sort(arr, rev=true)[1:k]\nend", "    # We create an array of the first\
    \ K elements, this array is sorted. \n    # Then we iterate over the rest of the\
    \ array. Each time we encounter an \n    # element that is higher than the smallest\
    \ element in the K-length array \n    # we insert it and remove the smallest element.\
    \ \n    k_length_arr = sort(arr[1:k])\n    for i in k+1:length(arr)\n        if\
    \ arr[i] > k_length_arr[1]\n            k_length_arr[1] = arr[i]\n           \
    \ k_length_arr = sort(k_length_arr)\n        end\n    end\n    return k_length_arr\n\
    end\n\"\"\"\n    Given a matrix of size n x m, and an array arr of length n.\n\
    \    Return the maximum of all the elements of array arr after multiplying each\
    \ \n    element by the largest number in its corresponding row in the matrix.",
  "    n = length(arr)\n    \"\"\"\n    [2, -2, 0, -1, 1, 3, -3, 4, -4]\n    \"\"\"\
    \n    if n == k\n        return sort(arr, rev=true)\n    end\n    left, right\
    \ = 1, k\n    while right <= n\n        println(left, \" \", right)\n        if\
    \ arr[left] >= arr[right]\n            left += 1\n            right += 1\n   \
    \     else\n            left = right\n            right += 1\n        end\n  \
    \  end\n    left = min(left, n - k + 1)\n    right = left + k - 1\n    return\
    \ sort(arr[left:right], rev=true)\nend", "    if k == length(arr)\n        return\
    \ sort(arr)\n    end\n    left = 1\n    right = k\n    max_idx = findmax(arr[left:right])[2]\n\
    \    arr[left:right], arr[left+max_idx-1] = arr[left+max_idx-1], arr[left]\n \
    \   i = left + 1\n    j = right + 1\n    while j <= length(arr)\n        if arr[i]\
    \ < arr[j]\n            arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n\
    \        end\n        j += 1\n    end\n    return maximum(arr, k)\nend", "   \
    \ # create a vector of size k\n    result = zeros(Int64, k)\n    # iterate through\
    \ arr\n    for (idx, val) in enumerate(arr)\n        # if value is less than the\
    \ smallest value in the result vector\n        if val < result[1]\n          \
    \  # skip to the next element\n            continue\n        end\n        # change\
    \ the smallest value in the result vector to the current value\n        result[1]\
    \ = val\n        # sort the result vector in place\n        sort!(result)\n  \
    \  end\n    # return the result vector\n    return result\nend\n\"\"\"\n    Time\
    \ Complexity: O(n * log(k))\n    Space Complexity: O(k)\n\"\"\"", "    \n    n\
    \ = length(arr)\n    pq = PriorityQueue{Int64, Tuple{Int64, Int64}}()\n    push!(pq,\
    \ arr[1], (n, 1))", "    \n    # sort the array\n    arr_sort = sort(arr, rev=true)\n\
    \    \n    # new array of size k\n    arr_k = zeros(Int64, k)\n    \n    # store\
    \ the first k elements\n    for i in 1:k\n        arr_k[i] = arr_sort[i]\n   \
    \ end\n    \n    return arr_k\nend", "    arr_sorted = sort(arr)\n    return [arr_sorted[end\
    \ - i + 1] for i in 1:k]\nend", "    \n    # Sorts the array in ascending order\n\
    \    sort!(arr)\n    \n    # Reverses the order of the sorted array\n    reverse!(arr)\n\
    \    \n    # Returns the maximum k numbers\n    return arr[1:k]\n    \nend\nmaximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1)", "    if k == 0\n        return []\n    end\n    heap\
    \ = MinHeap()\n    for i in 1:length(arr)\n        if length(heap) < k\n     \
    \       push!(heap, arr[i])\n        elseif arr[i] > peek(heap)\n            pop!(heap)\n\
    \            push!(heap, arr[i])\n        end\n    end\n    return sort(heap)\n\
    end", "    # I: Ascending sorted array\n    # O: Descending sorted array\n   \
    \ # C:\n    # E:\n    # This function is O(n) linear time because it is being\
    \ done k times.\n    arr_length = length(arr)\n    for i = 1:k\n        for j\
    \ = 1:arr_length - 1\n            if arr[j] < arr[j + 1]\n                temp\
    \ = arr[j]\n                arr[j] = arr[j + 1]\n                arr[j + 1] =\
    \ temp\n            end\n        end\n    end\n    return arr[1:k]\nend", "  \
    \  \"\"\"\n    Returns the maximum k integers of an array `arr` using the heapsort\
    \ algorithm.\n    \"\"\"\n    heap = Heap.new()\n    for i = 1:k\n        push!(heap,\
    \ arr[i])\n    end\n    for i = k+1:length(arr)\n        push!(heap, arr[i])\n\
    \        pop!(heap)\n    end\n    return sort(collect(heap))\nend", "    @assert\
    \ k in 1:length(arr) \n    return sort(arr)[end - k + 1:end]\nend", "    \n  \
    \  if k > length(arr)\n        return arr\n    end\n    \n    if k == length(arr)\n\
    \        return sort(arr)\n    end\n    \n    max_arr = Vector{Int64}(k)\n   \
    \ max_arr[1] = arr[1]\n    \n    for i in 1:(k-1)\n        if arr[i] > max_arr[1]\n\
    \            max_arr[1] = arr[i]\n        end\n    end\n    \n    for i in k:length(arr)\n\
    \        if arr[i] > max_arr[1]\n            max_arr[1] = arr[i]\n        end\n\
    \        \n        j = 1\n        while j < k\n            if max_arr[j] > max_arr[j+1]\n\
    \                temp = max_arr[j]\n                max_arr[j] = max_arr[j+1]\n\
    \                max_arr[j+1] = temp\n            end\n            j += 1\n  \
    \      end\n    end\n    \n    return max_arr\nend", "    return sort(arr)[end-k+1:end]\n\
    end", "    \"\"\"\n    Returns the maximum k elements from arr\n    \"\"\"\n \
    \   arr = copy(arr)\n    sort!(arr)\n    arr[end-k+1:end]\nend", "    \"\"\"\n\
    \    Find the maximum k elements in arr.", "    ret = []\n    # work backwards\n\
    \    j = length(arr)\n    while k > 0\n        # find the largest value in the\
    \ remaining array\n        i = 1\n        for m = 2:j\n            if arr[m] >\
    \ arr[i]\n                i = m\n            end\n        end\n        push!(ret,\
    \ arr[i])\n        # remove that value from the array\n        deleteat!(arr,\
    \ i)\n        j -= 1\n        k -= 1\n    end\n    return sort(ret)\nend", " \
    \   n = length(arr)\n    if n == k \n        return arr\n    end\n    arr[1:k]\
    \ = sort!(arr[1:k])\n    for i in k+1:n\n        # println(arr[1:k])\n       \
    \ if arr[i] > arr[1]\n            arr[1] = arr[i]\n            arr[1:k] = sort!(arr[1:k])\n\
    \        end\n    end\n    return arr[1:k]\nend\narr = [-3, -4, 5]\nk = 3\n@test\
    \ maximum(arr, k) == [-4, -3, 5]\narr = [4, -4, 4]\nk = 2\n@test maximum(arr,\
    \ k) == [4, 4]\narr = [-3, 2, 1, 2, -1, -2, 1]\nk = 1\n@test maximum(arr, k) ==\
    \ [2]", "    heap = Heap{Int64}(arr[1:k])\n    for i in k+1:length(arr)\n    \
    \    if arr[i] > heap.top\n            heap.pop()\n            heap.push(arr[i])\n\
    \        end\n    end\n    sort(collect(heap), rev=true)\nend", "    indices =\
    \ Vector{Int64}()\n    for i in 1:k\n        _, index = findmax(arr)\n       \
    \ push!(indices, index)\n        deleteat!(arr, index)\n    end\n    return sort(indices)\n\
    end\narr = [-3, -4, 5]\nk = 3\nmaximum(arr, k)", "    \"\"\"\n    Return a sorted\
    \ list of length k with the maximum k numbers in arr.", "    N = length(arr)\n\
    \    if N <= k \n        return sort(arr)\n    end\n    mid = maximum(arr[1:ceil(Int64,\
    \ N/2)], k)\n    res = maximum(arr[ceil(Int64, N/2)+1:end], k)\n    for i in 1:k\n\
    \        if mid[i] <= res[k]\n            return mid\n        elseif res[i] <=\
    \ mid[k]\n            return res\n        end\n    end\n    return [max(mid[i],\
    \ res[i]) for i in 1:k]\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
