name: HumanEval_1_separate_paren_groups
language: jl
results:
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    curr_paren = []\n    paren_list = []\n    for letter in paren_string\n\
    \        if letter == '('\n            push!(curr_paren,letter)\n        elseif\
    \ letter == ')'\n            push!(curr_paren,letter)\n            push!(paren_list,\
    \ join(curr_paren))\n            curr_paren = []\n        end\n    end\n    return\
    \ paren_list\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp029t1t9o.jl:27\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"()\", \")\", \"((()\", \")\", \")\", \"()\", \"((()\"\
    , \")\", \"()\", \"()\", \")\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp029t1t9o.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp029t1t9o.jl:26\ntest set: Test\
    \ Failed at /tmp/tmp029t1t9o.jl:28\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(()\"\
    , \")\", \"((()\", \")\", \")\", \"(((()\", \")\", \")\", \")\"] == [\"()\", \"\
    (())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp029t1t9o.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp029t1t9o.jl:26\ntest set: Test\
    \ Failed at /tmp/tmp029t1t9o.jl:29\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"(()\", \")\", \"((()\", \"\
    )\", \")\", \")\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp029t1t9o.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp029t1t9o.jl:26\ntest set: Test\
    \ Failed at /tmp/tmp029t1t9o.jl:30\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()\", \"(()\", \"\
    )\", \"(()\", \"()\", \")\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp029t1t9o.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # look for the outermost paren pair\n    # when you find it, take it out\
    \ and recurse on the rest\n    \n    \"\"\" This is a helper function to count\
    \ the number of open braces\n        >>> count_paren(\"(()\")\n        1\n   \
    \     >>> count_paren(\"(())\")\n        0\n        >>> count_paren(\"()(()(()))\"\
    )\n        -2\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp7idwlb_d.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp7idwlb_d.jl:1\n\
    in expression starting at /tmp/tmp7idwlb_d.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Use a stack to keep track of braces and stack position\n    closing_braces\
    \ = findall(r\"\\)\", paren_string)\n    open_braces = findall(r\"\\(\", paren_string)\n\
    \    # 3. Find the index position of the closing braces and calculate the distance\
    \ between braces that close\n    n_open_braces = length(open_braces)\n    n_closing_braces\
    \ = length(closing_braces)\n    if n_open_braces != n_closing_braces\n       \
    \ return -1\n    end\n    distances = Int[]\n    for i in 1:n_closing_braces\n\
    \        push!(distances, open_braces[i] - closing_braces[i])\n    end\n    #\
    \ 4. For each unique distance, find the corresponding open/close braces and create\
    \ substrings\n    return_strings = String[]\n    unique_distances = unique(distances)\n\
    \    for i in 1:length(unique_distances)\n        indices = findall(x -> x ==\
    \ unique_distances[i], distances)\n        string_start = open_braces[indices[1]]\n\
    \        string_end = closing_braces[indices[end]]\n        push!(return_strings,\
    \ string(paren_string[string_start:string_end]))\n    end\n    return return_strings\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # You can use Julia's findfirst() function to find the index of the first\
    \ occurance of a character\n    # You can use the replace() function to replace\
    \ a character with another\n    # You can use the count() function to find the\
    \ number of ocurrances of a character\n    # You can use the splice() function\
    \ to remove items from an array by index\n    # You can use Julia's split() function\
    \ to split a string by a character\n    \n    # You can use the find_matching_paren()\
    \ function you created above to find a closing parenthesis\n    # that matches\
    \ a given opening parenthesis.\n    # In fact, you should use it in this function!\n\
    \    \n    # You can use Julia's push!() function to add a new element to the\
    \ end of an array\n    # You can use Julia's append!() function to add a new element\
    \ to the end of an array\n    \n    # The push!() and append!() functions are\
    \ \"in place\" - they change an array you already have\n    # and don't create\
    \ a new one.\n    # In general, if the name of a function ends with a !, it probably\
    \ changes the argument you pass in.\n    \n    ## Your code here\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmppwq1ezl0.jl:33\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{String}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmppwq1ezl0.jl:27\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmppwq1ezl0.jl:33 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmppwq1ezl0.jl:32\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_list = []\n    s = \"\"\n    open_parens = 0\n    for char in paren_string\n\
    \        if char == '('\n            open_parens += 1\n        elseif char ==\
    \ ')'\n            open_parens -= 1\n        end\n        if char != ' '\n   \
    \         s = string(s, char)\n        end\n        if open_parens == 0\n    \
    \        push!(paren_list, s)\n            s = \"\"\n        end\n    end\n  \
    \  return paren_list\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpi_a8e2z1.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \"\", \"((()))\", \"\", \"()\", \"\", \"((())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi_a8e2z1.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi_a8e2z1.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpi_a8e2z1.jl:34\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"\"\
    , \"(())\", \"\", \"((()))\", \"\", \"(((())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi_a8e2z1.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi_a8e2z1.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpi_a8e2z1.jl:36\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()\", \"\", \"(())\"\
    , \"\", \"(()())\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi_a8e2z1.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi_a8e2z1.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi_a8e2z1.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    group_of_string = []\n    open_count = 0\n    close_count = 0\n    new_string\
    \ = \"\"\n    for i = 1:length(paren_string)\n        if paren_string[i] == '('\n\
    \            open_count += 1\n            new_string = new_string * paren_string[i]\n\
    \        elseif paren_string[i] == ')'\n            close_count += 1\n       \
    \     new_string = new_string * paren_string[i]\n        end\n        if open_count\
    \ == close_count && open_count != 0\n            push!(group_of_string, new_string)\n\
    \            open_count = 0\n            close_count = 0\n            new_string\
    \ = \"\"\n        end\n    end\n    return group_of_string\nend\nprintln(separate_paren_groups('(\
    \ ) (( )) (( )( ))'))\nprintln(separate_paren_groups('((())(()))'))\nprintln(separate_paren_groups('(())(())(())(())'))\n\
    println(separate_paren_groups('((())()()())'))\nprintln(separate_paren_groups('(()()()()())'))\n\
    println(separate_paren_groups('((()()(()))())'))\nprintln(separate_paren_groups('(((()(()()))()()))'))\n\
    println(separate_paren_groups('(())))((()))'))\nprintln(separate_paren_groups('(()))((()))'))\n\
    println(separate_paren_groups(')))()((()))'))\nprintln(separate_paren_groups('()()()()()()(()()())()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpcoxx_38w.jl:30\nin expression\
    \ starting at /tmp/tmpcoxx_38w.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Separate into a vector of strings delimited by space\n    paren_groups\
    \ = split(paren_string)\n    # Delete any empty strings\n    deleteat!(paren_groups,\
    \ find(paren_groups .== \"\"))\n    return paren_groups\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpi34iyyly.jl:20\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  UndefVarError: find not defined\\\
    n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\n     @ Main\
    \ /tmp/tmpi34iyyly.jl:12\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpi34iyyly.jl:20 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpi34iyyly.jl:19\\ntest set:\
    \ Error During Test at /tmp/tmpi34iyyly.jl:21\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  UndefVarError: find not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpi34iyyly.jl:12\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpi34iyyly.jl:21 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpi34iyyly.jl:19\\ntest set:\
    \ Error During Test at /tmp/tmpi34iyyly.jl:22\\n  Test threw exception\\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n  UndefVarError: find\
    \ not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpi34iyyly.jl:12\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpi34iyyly.jl:22 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpi34iyyly.jl:19\\ntest set:\
    \ Error During Test at /tmp/tmpi34iyyly.jl:23\\n  Test threw exception\\n  Expr"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # check_balanced(paren_string)\n    paren_string = replace(paren_string,\
    \ \" \" => \"\")\n    paren_groups = []\n    num_paren = 0\n    paren_i = []\n\
    \    for i = 1:length(paren_string)\n        c = paren_string[i]\n        if c\
    \ == '('\n            push!(paren_i, i)\n            num_paren += 1\n        elseif\
    \ c == ')'\n            if num_paren == 0\n                error(\"Unbalanced\
    \ parentheses\")\n            end\n            push!(paren_groups, paren_string[paren_i[end]+1:i-1])\n\
    \            pop!(paren_i)\n            num_paren -= 1\n        end\n    end\n\
    \    if num_paren != 0\n        error(\"Unbalanced parentheses\")\n    end\n \
    \   return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfys3ei_k.jl:38\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"\", \"\", \"()()\", \"\", \"()\", \"(())\", \"\", \"\", \"\
    ()\", \"\", \"\", \"(())()()\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfys3ei_k.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfys3ei_k.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpfys3ei_k.jl:39\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"\", \"\",\
    \ \"()\", \"\", \"()\", \"(())\", \"\", \"()\", \"(())\", \"((()))\"] == [\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpfys3ei_k.jl:39 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfys3ei_k.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpfys3ei_k.jl:40\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"\", \"\", \"()\", \"\", \"()\", \"\
    (())\", \"()(())((()))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfys3ei_k.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfys3ei_k.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpfys3ei_k.jl:41\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"\", \"\", \"()\",\
    \ \"\", \"\", \"()()\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfys3ei_k.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = filter(x -> x != ' ', paren_string) #remove spaces\n  \
    \  paren_string = filter(x -> x != ' ', paren_string) #remove spaces\n    group_starts\
    \ = findall(x -> x == '(', paren_string) #find opening parens\n    group_ends\
    \ = findall(x -> x == ')', paren_string) #find closing parens\n    group_starts\
    \ = [idx for idx in group_starts if paren_string[idx:idx+1] != \"()\"] #remove\
    \ empty groups\n    group_ends = [idx for idx in group_ends if paren_string[idx-1:idx]\
    \ != \"()\"] #remove empty groups\n    groups = []\n    for i = 1:length(group_starts)\n\
    \        groups = [groups; paren_string[group_starts[i]:group_ends[i]]]\n    end\n\
    \    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmppj03h101.jl:26\\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\\n   Evaluated: [\"(()())\", \"((())\", \"(()))\", \"((())\", \"(())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\\nStacktrace:\\n [1] macro\
    \ expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmppj03h101.jl:26 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmppj03h101.jl:25\\ntest set: Test\
    \ Failed at /tmp/tmppj03h101.jl:27\\n  Expression: candidate(\"() (()) ((()))\
    \ (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\\n   Evaluated:\
    \ [\"(())\", \"((())\", \"(()))\", \"(((())\", \"((()))\", \"(())))\"] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\\nStacktrace:\\n [1] macro expansion\\\
    n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmppj03h101.jl:27 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmppj03h101.jl:25\\ntest set: Test\
    \ Failed at /tmp/tmppj03h101.jl:28\\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\\n   Evaluated: [\"(()(())\", \"(())((())\", \"((()))\"\
    , \"(())))\"] == [\"(()(())((())))\"]\\nStacktrace:\\n [1] macro expansion\\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmppj03h101.jl:28 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmppj03h101.jl:25\\ntest set: Test\
    \ Failed at /tmp/tmppj03h101.jl:29\\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\\n   Evaluated: [\"(())\", \"(()())\"\
    ] == [\"()\", \"(())\", \"(()())\"]\\nStacktrace:\\n [1] macro expansion\\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    clean_string = replace(paren_string, \" \" => \"\")\n    start = 1\n \
    \   end = 1\n    paren_groups = Vector{String}()\n    while end < length(clean_string)\n\
    \        while clean_string[end] != ')'\n            end += 1\n        end +=\
    \ 1\n        push!(paren_groups, clean_string[start:end-1])\n        start = end\n\
    \    end\n    return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid assignment location \"function separate_paren_groups(paren_string::String)::Vector{String}\n\
    \    # /tmp/tmpvdp46zqw.jl, line 8\n    # /tmp/tmpvdp46zqw.jl, line 9\n    clean_string\
    \ = replace(paren_string, (\" \" => \"\"))\n    # /tmp/tmpvdp46zqw.jl, line 10\n\
    \    start = 1\nend\" around /tmp/tmpvdp46zqw.jl:1\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpvdp46zqw.jl:1\nin expression starting at /tmp/tmpvdp46zqw.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    groups = Vector{String}([])\n    group = \"\"\n    balance = 0\n    for\
    \ char in paren_string\n        if char == '('\n            balance += 1\n   \
    \     elseif char == ')'\n            balance -= 1\n        end\n        if balance\
    \ == 0 && char != ' '\n            push!(groups, group)\n            group = \"\
    \"\n        elseif char != ' '\n            group = group * char\n        end\n\
    \    end\n    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnenjhiz7.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()()\", \"((())\", \"(\", \"((())()()\"] == [\"(()())\",\
    \ \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnenjhiz7.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnenjhiz7.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpnenjhiz7.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"(\", \"(()\"\
    , \"((())\", \"(((()))\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnenjhiz7.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnenjhiz7.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpnenjhiz7.jl:34\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()(())((()))\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnenjhiz7.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnenjhiz7.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpnenjhiz7.jl:35\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"(\", \"(()\", \"(()()\"\
    ] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnenjhiz7.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shar"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnenjhiz7.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Code here\nend\n@test separate_paren_groups(\"( ) (( )) (( )( ))\")\
    \ == [\"()\", \"(())\", \"(()())\"]\n@test separate_paren_groups(\"(( ))( ( ))((\
    \ ))( ( ))\") == [\"(())\", \"(())\", \"(())\", \"(())\"]\n@test separate_paren_groups(\"\
    (((( ))))\") == [\"(((())))\"]\n@test separate_paren_groups(\"((()()))\") == [\"\
    ((()()))\"]\n \nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @test not defined\nin expression starting\
    \ at /tmp/tmpeh7_v05e.jl:11\nin expression starting at /tmp/tmpeh7_v05e.jl:11\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # ====================== TYPE YOUR CODE HERE =========================\n\
    \    # instructions\n    # 1) initialize the output stack\n    # 2) for each character\
    \ in the input string\n    #    a) if the character is an open parenthesis then\
    \ push an empty string to the output stack\n    #    b) if the character is a\
    \ closed parenthesis then \n    #       i) pop the stack and add the closed parenthesis\
    \ to the string that was popped\n    #       ii) then push the string back to\
    \ the stack\n    #    c) otherwise (i.e. any other character) add the character\
    \ to the first string in the stack\n    # 3) return the output stack (cast to\
    \ a Vector{String})\n    #\n    # Hint: you may find using the 'push!' and 'pop!'\
    \ functions convenient\n    #       for this exercise. See the help for these\
    \ functions.\n    # =============================================================\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpbnipjj8w.jl:29\\n  Test threw\
    \ exception\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    i, j = 1, 1\n    open_paren = 0\n    output = []\n    while i<=length(paren_string)\n\
    \        if paren_string[i]=='('\n            open_paren += 1\n        elseif\
    \ paren_string[i]==')'\n            open_paren -= 1\n        end\n        if open_paren==0\
    \ && i!=length(paren_string)\n            if paren_string[i]==')'\n          \
    \      i += 1\n            end\n            push!(output, strip(paren_string[j:i]))\n\
    \            j = i+1\n        end\n        i += 1\n    end\n    return output\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_3d150_a.jl:34\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \"((()))\", \"()\"] == [\"(()())\", \"((()))\",\
    \ \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_3d150_a.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_3d150_a.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp_3d150_a.jl:35\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(())\"\
    , \"((()))\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_3d150_a.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_3d150_a.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp_3d150_a.jl:36\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_3d150_a.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_3d150_a.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp_3d150_a.jl:37\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \"(( ))\"]\
    \ == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_3d150_a.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/jul"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_3d150_a.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    split_s = split(paren_string, \" \")\n    # Remove all empty strings\n\
    \    split_s = split_s[split_s .!= \"\"]\n    paren_groups = Vector{String}()\n\
    \    if length(split_s) > 0\n        open_paren = 0\n        curr_paren_string\
    \ = \"\"\n        for s in split_s\n            open_paren += length(findall(s,\
    \ '\\\\('))\n            open_paren -= length(findall(s, '\\\\)'))\n         \
    \   curr_paren_string *= s\n            if open_paren == 0\n                push!(paren_groups,\
    \ curr_paren_string)\n                curr_paren_string = \"\"\n            end\n\
    \        end\n    end\n    return paren_groups\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpd3gchsis.jl:17\nin expression\
    \ starting at /tmp/tmpd3gchsis.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    stack = []\n    group = \"\"\n    result = []\n    for c in paren_string\n\
    \        if c != ' '\n            push!(stack, c)\n        end\n    end\n    while\
    \ length(stack) > 0\n        current = pop!(stack)\n        if current == ')'\n\
    \            if length(stack) > 0\n                if stack[end] == '('\n    \
    \                pop!(stack)\n                    push!(result, group)\n     \
    \               group = \"\"\n                else\n                    group\
    \ = current * group\n                end\n            else\n                group\
    \ = current * group\n                push!(result, group)\n                group\
    \ = \"\"\n            end\n        else\n            group = current * group\n\
    \        end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwse86evv.jl:44\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\")\", \"\", \")\", \"((\", \"))\", \")((\", \"\"] == [\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpwse86evv.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwse86evv.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpwse86evv.jl:45\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\")))\", \"\
    ))(((\", \")((\", \"(\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwse86evv.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwse86evv.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpwse86evv.jl:46\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\")))\", \")((\", \"(\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwse86evv.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwse86evv.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpwse86evv.jl:47\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\")\", \"\", \")(\"\
    , \"(\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwse86evv.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwse86evv.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    groups = []\n\
    \    current_group = \"\"\n    level = 0\n    for c in paren_string\n        if\
    \ c == '('\n            level += 1\n        elseif c == ')'\n            level\
    \ -= 1\n        end\n        current_group *= c\n        if level == 0\n     \
    \       push!(groups, current_group)\n            current_group = \"\"\n     \
    \   end\n    end\n    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_paren_locs = findall(x -> x == '(' , paren_string)\n    close_paren_locs\
    \ = findall(x -> x == ')' , paren_string)\n    group_lengths = close_paren_locs\
    \ - open_paren_locs\n    groups = []\n    for i in eachindex(group_lengths)\n\
    \        start_idx = open_paren_locs[i]\n        end_idx = close_paren_locs[i]\n\
    \        group = paren_string[start_idx:end_idx]\n        push!(groups, group)\n\
    \    end\n    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7f0bc4bj.jl:26\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"()()\", \"())\", \"((()\", \"(())\", \"()))\", \"\
    ()\", \"((()\", \"(())\", \"())()\", \"()()\", \"())\"] == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7f0bc4bj.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7f0bc4bj.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp7f0bc4bj.jl:27\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(()\"\
    , \"())\", \"((()\", \"(())\", \"()))\", \"(((()\", \"((())\", \"(()))\", \"())))\"\
    ] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7f0bc4bj.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7f0bc4bj.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp7f0bc4bj.jl:28\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"()(()\", \"(())\", \"())((()\"\
    , \"((())\", \"(()))\", \"())))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7f0bc4bj.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7f0bc4bj.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp7f0bc4bj.jl:29\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \"(( )\", \"\
    ( ))\", \"(( )\", \"( )( )\", \"( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7f0bc4bj.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_list = []\n    current_list = []\n    current_paren = 1\n    for\
    \ i in paren_string\n        if i == '('\n            current_paren += 1\n   \
    \         push!(current_list, i)\n        elseif i == ')'\n            if current_paren\
    \ == 1\n                push!(paren_list, join(current_list))\n              \
    \  current_list = []\n            else\n                push!(current_list, i)\n\
    \                current_paren -= 1\n            end\n        end\n    end\n \
    \   return paren_list\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphqluhqzi.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphqluhqzi.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphqluhqzi.jl:32\ntest set: Test\
    \ Failed at /tmp/tmphqluhqzi.jl:34\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphqluhqzi.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphqluhqzi.jl:32\ntest set: Test\
    \ Failed at /tmp/tmphqluhqzi.jl:35\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphqluhqzi.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphqluhqzi.jl:32\ntest set: Test\
    \ Failed at /tmp/tmphqluhqzi.jl:36\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphqluhqzi.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphqluhqzi.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = paren_string\n    paren_string = replace(paren_string,\
    \ ' ' => \"\")\n    paren_string_length = length(paren_string)\n    open_paren_indexes\
    \ = Vector{Int}()\n    for i = 1:paren_string_length\n        if paren_string[i]\
    \ == '('\n            push!(open_paren_indexes, i)\n        end\n    end\n   \
    \ closed_paren_indexes = Vector{Int}()\n    for i = 1:paren_string_length\n  \
    \      if paren_string[i] == ')'\n            push!(closed_paren_indexes, i)\n\
    \        end\n    end\n    paren_groups = Vector{String}()\n    for i = 1:length(open_paren_indexes)\n\
    \        start_index = open_paren_indexes[i]\n        end_index = closed_paren_indexes[i]\n\
    \        push!(paren_groups, paren_string[start_index:end_index])\n    end\n \
    \   return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2kon5s95.jl:37\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"()()\", \"())\", \"((()\", \"(())\", \"()))\", \"\
    ()\", \"((()\", \"(())\", \"())()\", \"()()\", \"())\"] == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2kon5s95.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2kon5s95.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp2kon5s95.jl:38\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(()\"\
    , \"())\", \"((()\", \"(())\", \"()))\", \"(((()\", \"((())\", \"(()))\", \"())))\"\
    ] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2kon5s95.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2kon5s95.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp2kon5s95.jl:39\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"()(()\", \"(())\", \"())((()\"\
    , \"((())\", \"(()))\", \"())))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2kon5s95.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2kon5s95.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp2kon5s95.jl:40\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()\", \"(()\", \"\
    ())\", \"(()\", \"()()\", \"())\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /sh"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2kon5s95.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    inside_paren = false \n    paren_groups = Vector{String}()\n    current_string\
    \ = \"\"\n    for i in paren_string\n        if i == '('\n            if inside_paren\
    \ == false\n                inside_paren = true\n            end\n        elseif\
    \ i == ')'\n            if inside_paren == true\n                current_string\
    \ = push!(current_string, i)\n                push!(paren_groups, current_string)\n\
    \                current_string = \"\"\n                inside_paren = false\n\
    \            end\n        elseif inside_paren == true\n            current_string\
    \ = push!(current_string, i)\n        end\n    end\n    return paren_groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp3xnorjuf.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ push!(::String, ::Char)\\n  Closest candidates are:\\n    push!(::Any, ::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2970\\\
    n    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2971\\\
    n    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:605\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmp3xnorjuf.jl:19\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp3xnorjuf.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp3xnorjuf.jl:34\\ntest set:\
    \ Error During Test at /tmp/tmp3xnorjuf.jl:36\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  MethodError: no method matching push!(::String, ::Char)\\n  Closest\
    \ candidates are:\\n    push!(::Any, ::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2970\\\
    n    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2971\\\
    n    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:605\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmp3xnorjuf.jl:19\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp3xnorjuf.jl:36 [inlined]\\\
    n   [4] macro expansion\\n "
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n   \n    # Balance check\n    if !balance_check(paren_string)\n        return\
    \ error(\"Unbalanced string\")\n    end\n    \n    # Remove all spaces\n    paren_string\
    \ = replace(paren_string, r\"\\s+\"=>\"\")\n    \n    # Iterate over input string\n\
    \    new_list = []\n    current_paren = \"\"\n    while length(paren_string) >\
    \ 0\n        char = first(paren_string)\n        next_char = paren_string[2]\n\
    \        if char == '('\n            if next_char == ')'\n                new_list\
    \ = push!(new_list, \"()\")\n                paren_string = paren_string[3:end]\n\
    \            else\n                current_paren = char\n                paren_string\
    \ = paren_string[2:end]\n            end\n        elseif char == ')'\n       \
    \     current_paren = current_paren * char\n            new_list = push!(new_list,\
    \ current_paren)\n            current_paren = \"\"\n            paren_string =\
    \ paren_string[2:end]\n        end\n    end\n    return new_list\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpb_e8bi7u.jl:46\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  UndefVarError: balance_check\
    \ not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpb_e8bi7u.jl:11\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpb_e8bi7u.jl:46 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpb_e8bi7u.jl:45\\ntest set:\
    \ Error During Test at /tmp/tmpb_e8bi7u.jl:47\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  UndefVarError: balance_check not defined\\n  Stacktrace:\\n  \
    \ [1] separate_paren_groups(paren_string::String)\\n     @ Main /tmp/tmpb_e8bi7u.jl:11\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpb_e8bi7u.jl:47 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpb_e8bi7u.jl:45\\ntest set:\
    \ Error During Test at /tmp/tmpb_e8bi7u.jl:48\\n  Test threw exception\\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n  UndefVarError: balance_check\
    \ not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpb_e8bi7u.jl:11\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpb_e8bi7u.jl:48 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpb_e8bi7u.jl:45\\ntest set:\
    \ Error During Test at /tmp/tmpb_e8bi7u.jl:49\\n  T"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    assert(is_balanced(paren_string))\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    open_paren = '('\n    close_paren = ')'\n    group_start_indices\
    \ = findall(open_paren, paren_string)\n    group_end_indices = findall(close_paren,\
    \ paren_string)\n    group_lengths = group_end_indices .- group_start_indices\
    \ .+ 1\n    group_lengths, group_start_indices = sortperm(group_lengths, rev=true)\n\
    \    string_groups = []\n    for i in 1:length(group_lengths)\n        push!(string_groups,\
    \ paren_string[group_start_indices[i]:group_start_indices[i]+group_lengths[i]-1])\n\
    \    end\n    return string_groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmppx1o3h4d.jl:28\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  UndefVarError: is_balanced not\
    \ defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmppx1o3h4d.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmppx1o3h4d.jl:28 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmppx1o3h4d.jl:27\\ntest set:\
    \ Error During Test at /tmp/tmppx1o3h4d.jl:29\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  UndefVarError: is_balanced not defined\\n  Stacktrace:\\n   [1]\
    \ separate_paren_groups(paren_string::String)\\n     @ Main /tmp/tmppx1o3h4d.jl:9\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmppx1o3h4d.jl:29 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmppx1o3h4d.jl:27\\ntest set:\
    \ Error During Test at /tmp/tmppx1o3h4d.jl:30\\n  Test threw exception\\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n  UndefVarError: is_balanced\
    \ not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmppx1o3h4d.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmppx1o3h4d.jl:30 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmppx1o3h4d.jl:27\\ntest set:\
    \ Error During Test at /tmp/tmppx1o3h4d.jl:31\\n  Test threw"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp_756mswh.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{String}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmp_756mswh.jl:10\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp_756mswh.jl:16 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp_756mswh.jl:15\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \"\"\" Use vectors to store the location of open and close parentheses.\
    \ Loop through the string\n        and identify the location of each open and\
    \ close parenthesis. When the open and close \n        parentheses are matched,\
    \ use that location to capture the substring.\n        This approach uses extra\
    \ space in the form of vectors (one to store each type of paren)\n        but\
    \ it has very linear time complexity (loop through the string only once)\n   \
    \ \"\"\"\n    open_parens = Int64[] # store the location of open parentheses\n\
    \    close_parens = Int64[] # store the location of close parentheses\n    for\
    \ i in 1:length(paren_string)\n        if paren_string[i] == '('\n           \
    \ push!(open_parens, i)\n        elseif paren_string[i] == ')'\n            push!(close_parens,\
    \ i)\n        end\n    end\n    # loop through the vectors at the same time to\
    \ capture substrings\n    open_i = 1\n    close_i = 1\n    result = String[]\n\
    \    while open_i <= length(open_parens) && close_i <= length(close_parens)\n\
    \        current_open = open_parens[open_i]\n        current_close = close_parens[close_i]\n\
    \        if current_open < current_close\n            push!(result, string(paren_string[current_open:current_close]))\n\
    \            open_i += 1\n            close_i += 1\n        else\n           \
    \ close_i += 1\n        end\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp20g1kmvs.jl:46\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"()()\", \"())\", \"((()\", \"(())\", \"()))\", \"\
    ()\", \"((()\", \"(())\", \"())()\", \"()()\", \"())\"] == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp20g1kmvs.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp20g1kmvs.jl:45\ntest set: Test\
    \ Failed at /tmp/tmp20g1kmvs.jl:47\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(()\"\
    , \"())\", \"((()\", \"(())\", \"()))\", \"(((()\", \"((())\", \"(()))\", \"())))\"\
    ] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp20g1kmvs.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp20g1kmvs.jl:45\ntest set: Test\
    \ Failed at /tmp/tmp20g1kmvs.jl:48\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"()(()\", \"(())\", \"())((()\"\
    , \"((())\", \"(()))\", \"())))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp20g1kmvs.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp20g1kmvs.jl:45\ntest set: Test\
    \ Failed at /tmp/tmp20g1kmvs.jl:49\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \"(( )\", \"\
    ( ))\", \"(( )\", \"( )( )\", \"( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp20g1kmvs.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_i = [i for (i,c) in enumerate(paren_string) if c == '(']\n    close_i\
    \ = [i for (i,c) in enumerate(paren_string) if c == ')']\n    open_i = unique(sort(open_i))\n\
    \    close_i = unique(sort(close_i))\n    if length(open_i) != length(close_i)\n\
    \        error(\"Uneven number of parentheses\")\n    end\n    seperated_groups\
    \ = String[]\n    num_parens = length(open_i)\n    while num_parens > 0\n    \
    \    open_paren = open_i[1]\n        close_paren = search(paren_string, ')', open_paren)[1]\n\
    \        push!(seperated_groups, paren_string[open_paren:close_paren])\n     \
    \   open_i = open_i[open_i .> close_paren]\n        close_i = close_i[close_i\
    \ .> close_paren]\n        num_parens = length(open_i)\n    end\n    return seperated_groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp673dge7k.jl:33\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  UndefVarError: search not defined\\\
    n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\n     @ Main\
    \ /tmp/tmp673dge7k.jl:20\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp673dge7k.jl:33 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp673dge7k.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmp673dge7k.jl:34\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  UndefVarError: search not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmp673dge7k.jl:20\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp673dge7k.jl:34 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp673dge7k.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmp673dge7k.jl:35\\n  Test threw exception\\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n  UndefVarError: search\
    \ not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmp673dge7k.jl:20\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp673dge7k.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp673dge7k.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmp673dge7k.jl:36\\n  Test threw exception\\n"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    #where the groups are stored\n    groups = []\n    #keeps track of \"\
    (\"\n    track = []\n    #what we will return\n    return_groups = []\n    #what\
    \ we will put in to groups\n    str = \"\"\n    #first we will replace any spaces\
    \ with \"\"\n    paren_string = replace(paren_string, \" \" => \"\")\n    #iterate\
    \ through the string\n    for c in paren_string\n        #if we see \"(\", we\
    \ push it to track\n        if c == \"(\"\n            push!(track,c)\n      \
    \  #if we see \")\", we pop the last \"(\", and if we pop it, we push to the str\
    \ and then push to groups\n        elseif c == \")\"\n            pop!(track)\n\
    \            push!(str,c)\n            push!(groups,str)\n            str = \"\
    \"\n        end\n    end\n    #we will iterate through groups\n    for group in\
    \ groups\n        #if we have seen a group before, we continue\n        if group\
    \ in return_groups\n            continue\n        #if we have not seen a group\
    \ before, we push it to return_groups\n        else\n            push!(return_groups,group)\n\
    \        end\n    end\n    #return the return_groups\n    return return_groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2ixaaqwr.jl:50\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2ixaaqwr.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2ixaaqwr.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp2ixaaqwr.jl:51\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2ixaaqwr.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2ixaaqwr.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp2ixaaqwr.jl:52\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2ixaaqwr.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2ixaaqwr.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp2ixaaqwr.jl:53\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2ixaaqwr.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2ixaaqwr.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\n    # You'll probably want to use a regex to do the\
    \ job\n    # Consider using the following regex:\n    # r = r\"\"\"(?x)      \
    \         # Allow comments, verbose regex\n    #         \\(                 \
    \ # Match the opening parenthesis\n    #         (                   # Start capture\
    \ group\n    #         (?:                 # Start non-capture group\n    #  \
    \       [^()]               # Match anything that is not a parenthesis\n    #\
    \         |                   # or\n    #         \\((?-1)\\)           # Match\
    \ a group inside of a group\n    #         )*                  # Close non-capture\
    \ group\n    #         )                   # Close capture group\n    #      \
    \   \\)                  # Match the closing parenthesis\n    #         \"\"\"\
    \n    # and something like:\n    # match_list = matchall(r, paren_string)\n  \
    \  # to get the matches\n    #\n    # Note that the above regex is from StackOverflow:\n\
    \    # https://stackoverflow.com/questions/15085902/regex-for-properly-nested-parentheses\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmphy18d1ap.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{String}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmphy18d1ap.jl:29\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmphy18d1ap.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmphy18d1ap.jl:34\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    (n::Int) = 0\n    s = split(paren_string, \" \")\n    groups = []\n\
    \    current_paren = \"\"\n    while !isempty(s)\n        x = popfirst!(s)\n \
    \       current_paren = current_paren * x\n        if x == \"(\"\n           \
    \ n += 1\n        elseif x == \")\"\n            n -= 1\n        end\n       \
    \ if n == 0\n            push!(groups, current_paren)\n            current_paren\
    \ = \"\"\n        end\n    end\n    return groups\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_8600qjl.jl:37\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()\"\
    , \"((\", \"))\", \"((\", \")(\", \"))\"] == [\"()\", \"(())\", \"(()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_8600qjl.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_8600qjl.jl:33\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     1      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_8600qjl.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_parens = 0\n    group_count = 0\n    groups = Vector{String}()\n\
    \    paren_string = string(replace(paren_string, \" \" => \"\"))\n    for i =\
    \ 1:length(paren_string)\n        if open_parens == 0 && paren_string[i] == '('\n\
    \            push!(groups, \"\")\n            group_count += 1\n        end\n\
    \        if paren_string[i] == '('\n            open_parens += 1\n        elseif\
    \ paren_string[i] == ')'\n            open_parens -= 1\n        end\n        groups[group_count]\
    \ = string(groups[group_count], paren_string[i])\n    end\n    return groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    groups = []\n    start_index = 0\n    end_index = 0\n    count = 0\n \
    \   for letter in paren_string\n        if letter == '('\n            count +=\
    \ 1\n        elseif letter == ')'\n            count -= 1\n        end\n     \
    \   if count == 0\n            if start_index != end_index\n                push!(groups,\
    \ paren_string[start_index:end_index])\n            end\n            start_index\
    \ = end_index + 1\n        end\n        end_index += 1\n    end\n    groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmps5pgndjy.jl:34\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  BoundsError: attempt to access\
    \ 27-codeunit String at index [0:5]\\n  Stacktrace:\\n   [1] checkbounds\\n  \
    \   @ ./strings/basic.jl:216 [inlined]\\n   [2] getindex\\n     @ ./strings/string.jl:261\
    \ [inlined]\\n   [3] separate_paren_groups(paren_string::String)\\n     @ Main\
    \ /tmp/tmps5pgndjy.jl:21\\n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [5] macro expansion\\n     @ /tmp/tmps5pgndjy.jl:34 [inlined]\\\
    n   [6] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [7] top-level scope\\n     @ /tmp/tmps5pgndjy.jl:33\\ntest set:\
    \ Error During Test at /tmp/tmps5pgndjy.jl:35\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  BoundsError: attempt to access 23-codeunit String at index [0:1]\\\
    n  Stacktrace:\\n   [1] checkbounds\\n     @ ./strings/basic.jl:216 [inlined]\\\
    n   [2] getindex\\n     @ ./strings/string.jl:261 [inlined]\\n   [3] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmps5pgndjy.jl:21\\n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [5] macro expansion\\n     @ /tmp/tmps5pgndjy.jl:35 [inlined]\\\
    n   [6] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [7] top-level scope\\n     @ /tmp/tmps5pgndjy.jl:33\\ntest set:\
    \ Error During Test at /tmp/tmps5pgndjy.jl:36\\n  Test threw exception\\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n  BoundsError: attempt\
    \ to access 14-codeunit String at index [0:13]\\n  Stacktrace:\\n   [1] checkbounds\\\
    n     @ ./strings/basic.jl:216 [inlined]\\n   [2] getindex\\n     @ ./strings/string.jl:261\
    \ [inlined]\\n   [3] separate_paren_groups(paren_string::String)\\n     @ Main "
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # First, let's separate out all of the parentheses.\n    # There may be\
    \ some extra spaces so we need to ignore those\n    paren_list = filter(x -> x\
    \ != ' ', string(paren_string))\n    # Now, we are going to make a new list that\
    \ contains all of the separate groups\n    paren_group_list = Vector{String}()\n\
    \    # Every time we find a '(' we need to look for the next ')' and then add\
    \ the substring in between them to the list\n    i = 1\n    while i <= length(paren_list)\n\
    \        # First we need to find the first open '('\n        while i <= length(paren_list)\
    \ && paren_list[i] != '('\n            i += 1\n        end\n        # Now we need\
    \ to find the matching close ')'\n        j = i + 1\n        stack = 0\n     \
    \   while j <= length(paren_list)\n            if paren_list[j] == '('\n     \
    \           stack += 1\n            elseif paren_list[j] == ')'\n            \
    \    if stack == 0\n                    break\n                else\n        \
    \            stack -= 1\n                end\n            end\n            j +=\
    \ 1\n        end\n        # Now that we have found all of the matching parentheses,\
    \ add them to the list\n        append!(paren_group_list, join(paren_list[i:(j-1)],\
    \ \"\"))\n        i = j\n    end\n    return paren_group_list\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Keep in mind that you can use the `find` function to find all instances\
    \ of a given character.\n    paren_groups = Vector{String}()\n    open_index,\
    \ close_index = 0, 0\n    for i = 1:length(paren_string)\n        if paren_string[i]\
    \ == '('\n            open_index = i\n        elseif paren_string[i] == ')'\n\
    \            close_index = i\n            push!(paren_groups, paren_string[open_index:close_index])\n\
    \        end\n    end\n    return paren_groups\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsrpfgvk4.jl:27\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"()\", \"()\", \"())\", \"()\", \"())\", \"()))\", \"()\",\
    \ \"()\", \"())\", \"()\", \"()\", \"())\"] == [\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsrpfgvk4.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsrpfgvk4.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpsrpfgvk4.jl:28\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"()\"\
    , \"())\", \"()\", \"())\", \"()))\", \"()\", \"())\", \"()))\", \"())))\"] ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsrpfgvk4.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsrpfgvk4.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpsrpfgvk4.jl:29\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"()\", \"()\", \"())\", \"()\", \"\
    ())\", \"()))\", \"())))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsrpfgvk4.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsrpfgvk4.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpsrpfgvk4.jl:30\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \"( )\", \"\
    ( ))\", \"( )\", \"( )\", \"( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/juli"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsrpfgvk4.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function as described above. Return a vector of\
    \ strings containing the \n    # separated groups.\n    return Vector{String}()\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpr18_b7au.jl:18\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr18_b7au.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr18_b7au.jl:17\ntest set: Test\
    \ Failed at /tmp/tmpr18_b7au.jl:19\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr18_b7au.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr18_b7au.jl:17\ntest set: Test\
    \ Failed at /tmp/tmpr18_b7au.jl:20\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr18_b7au.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr18_b7au.jl:17\ntest set: Test\
    \ Failed at /tmp/tmpr18_b7au.jl:21\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr18_b7au.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr18_b7au.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    let n1, n2 = paren_counts(paren_string)\n    if n1 != n2\n        println(\"\
    Uneven parentheses\")\n        return []\n    end\n    let open_paren_count =\
    \ 0\n    let paren_strings = Vector{String}()\n    let current_string = \"\"\n\
    \    for char in paren_string\n        if char == '('\n            open_paren_count\
    \ += 1\n            current_string *= char\n        elseif char == ')'\n     \
    \       open_paren_count -= 1\n            current_string *= char\n          \
    \  if open_paren_count == 0\n                push!(paren_strings, current_string)\n\
    \                current_string = \"\"\n            end\n        end\n    end\n\
    \    return paren_strings\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"let\" at /tmp/tmpa1jlvr0t.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpa1jlvr0t.jl:1\n\
    in expression starting at /tmp/tmpa1jlvr0t.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    #count the number of open and close parentheses\n    #starting with the\
    \ left-most parantheses, see if there is an equal number of open and close parantheses\n\
    \    #if so, collect those parantheses and move on, if not, move one right\n \
    \   #after each collection, remove the collected parantheses from the original\
    \ string\n    #repeat until string is empty\n    #return the vector of collected\
    \ parantheses\n    #we can use the map function on the split string:\n    str\
    \ = split(paren_string,\"\")\n    open_parens = [x for x in str if x == \"(\"\
    ]\n    close_parens = [x for x in str if x == \")\"]\n    if length(open_parens)\
    \ != length(close_parens)\n        error(\"Number of open parentheses does not\
    \ equal number of close parentheses\")\n    end\n    result = []\n    #remove\
    \ spaces\n    str = [x for x in str if x != \" \"]\n    #remove the open parantheses\n\
    \    str = [x for x in str if x != \"(\"]\n    #remove the close parantheses\n\
    \    str = [x for x in str if x != \")\"]\n    while length(str) != 0\n      \
    \  temp = []\n        #we'll check to see if the first element is an open parantheses,\
    \ if not, then the string is\n        #not a valid parantheses group\n       \
    \ if str[1] == \"(\"\n            #then we know that the first element is an open\
    \ parantheses, so we'll use it as the starting\n            #point to find a group\
    \ of balanced parantheses\n            #now we'll start at the first element and\
    \ move right, counting the number of open parantheses\n            #and close\
    \ parantheses we pass.\n            #if we encounter a close parantheses, we'll\
    \ know that it is the first close parantheses in\n            #the string, so\
    \ we'll know that the number of open parantheses before it will be one less\n\
    \            #than the number of close parantheses before it.\n            #so\
    \ we'll count the number of open and close parantheses and if the number of open\n\
    \            #parantheses ever equals the number of close parantheses, we'll know\
    \ that we have a balanced\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjo5bmhb_.jl:1\nin expression starting at /tmp/tmpjo5bmhb_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    # We will use a stack to keep track of open parens, which will help\
    \ us separate the groups\n    open_parens = []\n    curr_paren_group = \"\" #\
    \ This is the string that will hold the parens\n    groups = [] # This is the\
    \ list that will hold all the separate groups of parens\n    \n    for character\
    \ in paren_string\n        if character == '('\n            push!(open_parens,\
    \ '(')\n            curr_paren_group = curr_paren_group * character\n        elseif\
    \ character == ')'\n            pop!(open_parens)\n            curr_paren_group\
    \ = curr_paren_group * character\n            if length(open_parens) == 0\n  \
    \              push!(groups, curr_paren_group)\n                curr_paren_group\
    \ = \"\"\n            end\n        end\n    end\n    \n    return groups\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = paren_string[findall(r\"\\S\", paren_string)]\n    start\
    \ = 1\n    end = 1\n    paren_list = []\n    string_start = 1\n    for i = 1:length(paren_string)\n\
    \        if paren_string[i] == '('\n            start += 1\n        elseif paren_string[i]\
    \ == ')'\n            end += 1\n        end\n        if start == end\n       \
    \     paren_list = append!(paren_string[string_start:i], paren_list)\n       \
    \     string_start = i + 1\n            start = 1\n            end = 1\n     \
    \   end\n    end\n    return paren_list\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid assignment location \"function separate_paren_groups(paren_string::String)::Vector{String}\n\
    \    # /tmp/tmphowhfo9s.jl, line 8\n    # /tmp/tmphowhfo9s.jl, line 9\n    paren_string\
    \ = paren_string[findall(Base.Regex(pattern=\"\\S\", compile_options=0x040a0002,\
    \ match_options=0x40000000, regex=0x0000000000d04740), paren_string)]\n    # /tmp/tmphowhfo9s.jl,\
    \ line 10\n    start = 1\nend\" around /tmp/tmphowhfo9s.jl:1\nStacktrace:\n [1]\
    \ top-level scope\n   @ /tmp/tmphowhfo9s.jl:1\nin expression starting at /tmp/tmphowhfo9s.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n   \n    open = 0\n    close = 0\n    empty_vec = Vector{String}()\n    for\
    \ i in 1:length(paren_string)\n        # If a open paren \n        if paren_string[i]\
    \ == '('\n            open = open + 1\n        end\n        # If a close paren\n\
    \        if paren_string[i] == ')'\n            close = close + 1\n        end\n\
    \        # If equal closed as opened\n        if open == close\n            #\
    \ push string from paren_string[1:i] and current close paren to empty_vec\n  \
    \          push!(empty_vec, paren_string[1:i]*paren_string[i])\n            #\
    \ remove added part from paren_string\n            paren_string = paren_string[i+1:end]\n\
    \            # reset i\n            i = 0\n            # reset open and close\n\
    \            open = 0\n            close = 0\n        end\n    end\n    return\
    \ empty_vec\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpd28adbm2.jl:42\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  BoundsError: attempt to access\
    \ 1-codeunit String at index [12]\\n  Stacktrace:\\n   [1] checkbounds\\n    \
    \ @ ./strings/basic.jl:216 [inlined]\\n   [2] codeunit\\n     @ ./strings/string.jl:102\
    \ [inlined]\\n   [3] getindex\\n     @ ./strings/string.jl:223 [inlined]\\n  \
    \ [4] separate_paren_groups(paren_string::String)\\n     @ Main /tmp/tmpd28adbm2.jl:15\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [6] macro expansion\\n     @ /tmp/tmpd28adbm2.jl:42 [inlined]\\\
    n   [7] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [8] top-level scope\\n     @ /tmp/tmpd28adbm2.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmpd28adbm2.jl:43\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  BoundsError: attempt to access 3-codeunit String at index [9]\\\
    n  Stacktrace:\\n   [1] checkbounds\\n     @ ./strings/basic.jl:216 [inlined]\\\
    n   [2] codeunit\\n     @ ./strings/string.jl:102 [inlined]\\n   [3] getindex\\\
    n     @ ./strings/string.jl:223 [inlined]\\n   [4] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpd28adbm2.jl:15\\n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [6] macro expansion\\n     @ /tmp/tmpd28adbm2.jl:43 [inlined]\\\
    n   [7] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [8] top-level scope\\n     @ /tmp/tmpd28adbm2.jl:41\\ntest set:\
    \ Test Failed at /tmp/tmpd28adbm2.jl:44\\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\\n   Evaluated: [\"(()(())((()))))\"] == [\"(()(())((())))\"\
    ]'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_parens = 0\n    output = []\n    s = \"\"\n    for i in 1:length(paren_string)\n\
    \        if (paren_string[i] == '(')\n            open_parens += 1\n         \
    \   s = push!(s, paren_string[i])\n        elseif (paren_string[i] == ')')\n \
    \           open_parens -= 1\n            s = push!(s, paren_string[i])\n    \
    \    end\n        if (open_parens == 0)\n            push!(output, s)\n      \
    \      s = \"\"\n        end\n    end\n    return output\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpd4e6ia_n.jl:32\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ push!(::String, ::Char)\\n  Closest candidates are:\\n    push!(::Any, ::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2970\\\
    n    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2971\\\
    n    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:605\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpd4e6ia_n.jl:15\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpd4e6ia_n.jl:32 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpd4e6ia_n.jl:31\\ntest set:\
    \ Error During Test at /tmp/tmpd4e6ia_n.jl:33\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  MethodError: no method matching push!(::String, ::Char)\\n  Closest\
    \ candidates are:\\n    push!(::Any, ::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2970\\\
    n    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2971\\\
    n    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:605\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpd4e6ia_n.jl:15\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpd4e6ia_n.jl:33 [inlined]\\\
    n   [4] macro expansion\\n "
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \"\"\" \n    Function to create a list of balanced paren groups\n    \"\
    \"\"\n    # Remove spaces from input string\n    paren_string = replace(paren_string,\
    \ \" \" => \"\")\n    # Create an empty list to store strings (parentheses group)\n\
    \    paren_list = Vector{String}()\n    paren_stack = []\n    # Iterate through\
    \ the characters in the string\n    for c in paren_string\n        # If the character\
    \ is a left parenthesis, push it onto the stack\n        if c == '('\n       \
    \     push!(paren_stack, c)\n        # If the character is a right parenthesis,\
    \ pop the last paren in the stack\n        elseif c == ')'\n            pop!(paren_stack)\n\
    \        end\n        # If there is no left parenthesis in the stack,\n      \
    \  # it means that the right parenthesis just popped is the closing one\n    \
    \    # for that group, so we will add the current stack to the list of groups\n\
    \        if isempty(paren_stack)\n            push!(paren_list, join(paren_stack))\n\
    \        end\n    end\n    return paren_list\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplmgxraf4.jl:40\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"\", \"\", \"\", \"\"] == [\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplmgxraf4.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplmgxraf4.jl:39\ntest set: Test\
    \ Failed at /tmp/tmplmgxraf4.jl:41\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"\", \"\",\
    \ \"\", \"\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplmgxraf4.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplmgxraf4.jl:39\ntest set: Test\
    \ Failed at /tmp/tmplmgxraf4.jl:42\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"\"] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplmgxraf4.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplmgxraf4.jl:39\ntest set: Test\
    \ Failed at /tmp/tmplmgxraf4.jl:43\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"\", \"\", \"\"] ==\
    \ [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplmgxraf4.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Te"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplmgxraf4.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    group = \"\"\n    group_count = 0\n    group_list = []\n    for i in paren_string\n\
    \        if i == '('\n            group = group * i\n            group_count +=\
    \ 1\n        elseif i == ')'\n            group = group * i\n            group_count\
    \ -= 1\n            if group_count == 0\n                push!(group_list, group)\n\
    \                group = \"\"\n            end\n        end\n    end\n    return\
    \ group_list\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # This will be a list of every separate parenthesis group\n    paren_groups\
    \ = Vector{String}()\n    # Remove spaces\n    paren_string = replace(paren_string,\
    \ \" \" => \"\")\n    # Iterate through all chars in the string\n    i = 1\n \
    \   while i <= length(paren_string)\n        char = paren_string[i]\n        #\
    \ If a '(' is found, we need to determine where the closing ')' is\n        if\
    \ char == '('\n            paren_counter = 1\n            # j will iterate through\
    \ each char after the opening '('\n            j = i + 1\n            while j\
    \ <= length(paren_string)\n                # If a '(' is found, add 1 to paren_counter\n\
    \                if paren_string[j] == '('\n                    paren_counter\
    \ += 1\n                # If a ')' is found, subtract 1 from paren_counter\n \
    \               elseif paren_string[j] == ')'\n                    paren_counter\
    \ -= 1\n                end\n                # If paren_counter is 0, we have\
    \ found the end of the nested parens\n                if paren_counter == 0\n\
    \                    push!(paren_groups, paren_string[i:j])\n                \
    \    i = j\n                    break\n                end\n                j\
    \ += 1\n            end\n        end\n        i += 1\n    end\n    return paren_groups\n\
    end\n \nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t\
    @test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    # create vector to store each seperated string in\n    seperated_strings\
    \ = Vector{String}()\n    \n    # create index to keep track of starting of each\
    \ seperated string\n    index = 1\n    \n    # loop through paren_string\n   \
    \ for i in 1:length(paren_string)\n        \n        # if encounter open paren,\
    \ increment index, go to next iteration\n        if paren_string[i] == '('\n \
    \           index += 1\n            continue\n        end\n        \n        #\
    \ if encounter closed paren, decrement index, go to next iteration\n        if\
    \ paren_string[i] == ')'\n            index -= 1\n            continue\n     \
    \   end\n        \n        # if encounter space, go to next iteration\n      \
    \  if paren_string[i] == ' '\n            continue\n        end\n        \n  \
    \      # if encounter anything else, error\n        error(\"Invalid character\
    \ in string\")\n    end\n    \n    # if index is not 0, error, string not properly\
    \ closed\n    if index != 0\n        error(\"String not properly closed\")\n \
    \   end\n    \n    # index will be 0 if string properly closed\n    # now we proceed\
    \ to seperate groups\n    \n    # index to keep track of starting of each seperated\
    \ string\n    index = 1\n    \n    # loop through paren_string\n    for i in 1:length(paren_string)\n\
    \        \n        # if encounter closed paren,\n        if paren_string[i] ==\
    \ ')'\n            \n            # push substring from index to i into seperated_strings\n\
    \            push!(seperated_strings, paren_string[index:i])\n            \n \
    \           # increment index, go to next iteration\n            index = i + 1\n\
    \            continue\n        end\n        \n        # if encounter anything\
    \ else, go to next iteration\n        continue\n    end\n    \n    # return seperated_strings\n\
    \    return seperated_strings\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpxcnh46x5.jl:77\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  String not properly closed\\\
    n  Stacktrace:\\n   [1] error(s::String)\\n     @ Base ./error.jl:33\\n   [2]\
    \ separate_paren_groups(paren_string::String)\\n     @ Main /tmp/tmpxcnh46x5.jl:42\\\
    n   [3] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmpxcnh46x5.jl:77 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmpxcnh46x5.jl:76\\ntest set:\
    \ Error During Test at /tmp/tmpxcnh46x5.jl:78\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  String not properly closed\\n  Stacktrace:\\n   [1] error(s::String)\\\
    n     @ Base ./error.jl:33\\n   [2] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpxcnh46x5.jl:42\\n   [3] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmpxcnh46x5.jl:78 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmpxcnh46x5.jl:76\\ntest set:\
    \ Error During Test at /tmp/tmpxcnh46x5.jl:79\\n  Test threw exception\\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n  String not properly\
    \ closed\\n  Stacktrace:\\n   [1] error(s::String)\\n     @ Base ./error.jl:33\\\
    n   [2] separate_paren_groups(paren_string::String)\\n     @ Main /tmp/tmpxcnh46x5.jl:42\\\
    n   [3] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmpxcnh46x5.jl:79 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Your code here\n    return Vector()\nend\n \nSeparateGroupsTest\
    \ = @testset \"Separate paren groups\" begin\n    @test separate_paren_groups(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n    @test separate_paren_groups(\"\
    ()((()()()))\") == [\"()\", \"((()()()))\"]\n    @test separate_paren_groups(\"\
    (() ((()(())))())\") == [\"(()\", \"((()(())))())\"]\n    @test separate_paren_groups(\"\
    ( ( ( ( (  )\") == [\"( ( ( ( (  )\"]\n    @test separate_paren_groups(\"\") ==\
    \ Vector{String}()\nend\n \nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @testset not defined\nin expression starting\
    \ at /tmp/tmpwkzml3ne.jl:13\nin expression starting at /tmp/tmpwkzml3ne.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    # Initialize empty vector of strings to store groups of parentheses\n\
    \    groups = Vector{String}()\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpb9vq92s5.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpb9vq92s5.jl:1\n\
    in expression starting at /tmp/tmpb9vq92s5.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # ...\nend\n```\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid \"`\" syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzj_sqkrs.jl:11\nin expression starting at\
    \ /tmp/tmpzj_sqkrs.jl:11\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # ==================================================================================\n\
    \    #   TODO: Complete the function following the task description above    \
    \          \n    # ==================================================================================\n\
    \    # YOUR CODE HERE\n    # raise NotImplementedError()\n    # ==================================================================================\n\
    \    #                       END OF YOUR CODE                                \
    \           \n    # ==================================================================================\n\
    end\n \nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t\
    @test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    count = 0\n    group = \"\"\n    group_list = Vector{String}()\n    for\
    \ i in 1:length(paren_string)\n        if paren_string[i] == '('\n           \
    \ count += 1\n        elseif paren_string[i] == ')'\n            count -= 1\n\
    \        end\n        group = append!(group, paren_string[i])\n        if count\
    \ == 0\n            push!(group_list, group)\n            group = \"\"\n     \
    \   end\n    end\n    return group_list\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp_qx2orn0.jl:31\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ append!(::String, ::Char)\\n  Closest candidates are:\\n    append!(!Matched::BitVector,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:782\\n  \
    \  append!(!Matched::AbstractVector, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1050\\\
    n    append!(!Matched::AbstractVector, ::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1053\\\
    n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\n     @ Main\
    \ /tmp/tmp_qx2orn0.jl:18\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp_qx2orn0.jl:31 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp_qx2orn0.jl:30\\ntest set:\
    \ Error During Test at /tmp/tmp_qx2orn0.jl:32\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  MethodError: no method matching append!(::String, ::Char)\\n \
    \ Closest candidates are:\\n    append!(!Matched::BitVector, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:782\\\
    n    append!(!Matched::AbstractVector, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1050\\\
    n    append!(!Matched::AbstractVector, ::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1053\\\
    n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\n     @ Main\
    \ /tmp/tmp_qx2orn0.jl:18\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp_qx2orn0.jl:32 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level sc"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    return paren_string |>\n           gsub(\"\\\\s\", \"\") |> # remove whitespace\n\
    \           matchall(\"\\\\([^()]*\\\\)\") |> # find all the matches\n       \
    \    replace_matches(\"\", \"\") |> # remove the matchers,\n           collect\
    \ # collect into a vector\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpg1ijos96.jl:20\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  UndefVarError: gsub not defined\\\
    n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\n     @ Main\
    \ /tmp/tmpg1ijos96.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpg1ijos96.jl:20 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpg1ijos96.jl:19\\ntest set:\
    \ Error During Test at /tmp/tmpg1ijos96.jl:21\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  UndefVarError: gsub not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpg1ijos96.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpg1ijos96.jl:21 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpg1ijos96.jl:19\\ntest set:\
    \ Error During Test at /tmp/tmpg1ijos96.jl:22\\n  Test threw exception\\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n  UndefVarError: gsub\
    \ not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpg1ijos96.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpg1ijos96.jl:22 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpg1ijos96.jl:19\\ntest set:\
    \ Error During Test at /tmp/tmpg1ijos96.jl:23\\n  Test threw exception\\n  Express"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    n = length(paren_string)\n    spaces = count(x->x==' ', paren_string)\n\
    \    paren_string = replace(paren_string, ' '=>'')\n    @assert length(paren_string)\
    \ == n - spaces\n    group_strings = []\n    group_accumulator = \"\"\n    left_parens\
    \ = 0\n    right_parens = 0\n    for paren in paren_string\n        if paren ==\
    \ '('\n            left_parens += 1\n        elseif paren == ')'\n           \
    \ right_parens += 1\n        end\n        if left_parens == right_parens\n   \
    \         push!(group_strings, group_accumulator)\n            group_accumulator\
    \ = \"\"\n            left_parens = 0\n            right_parens = 0\n        else\n\
    \            group_accumulator *= paren\n        end\n    end\n    group_strings\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid empty character literal\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2zv0haxg.jl:11\nin expression starting at\
    \ /tmp/tmp2zv0haxg.jl:11\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    ...\n    end\n \nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid identifier name \"...\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2sn337fn.jl:9\nin expression starting at /tmp/tmp2sn337fn.jl:9\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    function is_opening_paren(c::Char)::Bool\n        return c == '('\n  \
    \  end\n    function is_closing_paren(c::Char)::Bool\n        return c == ')'\n\
    \    end\n    function is_spaces(c::Char)::Bool\n        return c == ' '\n   \
    \ end\n    function count_paren(c::Char, count::Int)::Int\n        if is_opening_paren(c)\n\
    \            return count + 1\n        elseif is_closing_paren(c)\n          \
    \  return count - 1\n        else\n            return count\n        end\n   \
    \ end\n    function is_balanced(p::String)::Bool\n        count = 0\n        for\
    \ c in p\n            count = count_paren(c, count)\n            if count < 0\n\
    \                return false\n            end\n        end\n        return count\
    \ == 0\n    end\n    function get_paren_group(s::String)::String\n        count\
    \ = 0\n        for (i, c) in enumerate(s)\n            if is_opening_paren(c)\n\
    \                count += 1\n            elseif is_closing_paren(c)\n        \
    \        count -= 1\n            end\n            if count == 0\n            \
    \    return s[1:i]\n            end\n        end\n        return \"\"\n    end\n\
    \    paren_groups = []\n    while paren_string != \"\"\n        group = get_paren_group(paren_string)\n\
    \        if group != \"\"\n            push!(paren_groups, group)\n        end\n\
    \        paren_string = paren_string[length(group) + 1:end]\n    end\n    return\
    \ filter(is_balanced, paren_groups)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpiu3tcdml.jl:66\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiu3tcdml.jl:66 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiu3tcdml.jl:65\ntest set: Test\
    \ Failed at /tmp/tmpiu3tcdml.jl:67\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \" \"\
    , \"(())\", \" \", \"((()))\", \" \", \"(((())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiu3tcdml.jl:67 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiu3tcdml.jl:65\ntest set: Test\
    \ Failed at /tmp/tmpiu3tcdml.jl:69\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \" \", \"((\
    \ ))\", \" \", \"(( )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiu3tcdml.jl:69 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiu3tcdml.jl:65\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiu3tcdml.jl:63\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    stack = []\n    current_paren = []\n    open_parens = 0\n    output =\
    \ []\n    for i in eachindex(paren_string)\n        if paren_string[i] == '('\
    \ || paren_string[i] == ')'\n            push!(stack, paren_string[i])\n     \
    \   end\n    end\n    for i in eachindex(stack)\n        if stack[i] == '('\n\
    \            push!(current_paren, stack[i])\n            open_parens += 1\n  \
    \      elseif stack[i] == ')'\n            push!(current_paren, stack[i])\n  \
    \          open_parens -= 1\n        end\n        if open_parens == 0\n      \
    \      push!(output, string(current_paren))\n            current_paren = []\n\
    \        end\n    end\n    return output\nend\n \nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp608hi9el.jl:39\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"Any['(', '(', ')', '(', ')', ')']\", \"Any['(', '(', '(',\
    \ ')', ')', ')']\", \"Any['(', ')']\", \"Any['(', '(', '(', ')', ')', '(', ')',\
    \ '(', ')', ')']\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp608hi9el.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp608hi9el.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp608hi9el.jl:40\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"Any['(', ')']\"\
    , \"Any['(', '(', ')', ')']\", \"Any['(', '(', '(', ')', ')', ')']\", \"Any['(',\
    \ '(', '(', '(', ')', ')', ')', ')']\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp608hi9el.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp608hi9el.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp608hi9el.jl:41\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"Any['(', '(', ')', '(', '(', ')',\
    \ ')', '(', '(', '(', ')', ')', ')', ')']\"] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp608hi9el.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp608hi9el.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp608hi9el.jl:42\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Eval"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp608hi9el.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    groups = split(paren_string, ')(')\n    groups = [ groups[1] * ')'\
    \ ] + [ string(substr(g, 2, length(g) - 1)) for g in groups[2:end-1] ] .+ [groups[end]\
    \ * '(']\n    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpv0k72jgr.jl:10\nin expression\
    \ starting at /tmp/tmpv0k72jgr.jl:10\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # This is a simple approach. It will not work if you have nested groups\
    \ \n    # paren_string = string(filter(ch -> (ch != ' '), paren_string))\n   \
    \ # paren_string = string(filter(ch -> (ch != ')'), paren_string))\n    # split(paren_string,\
    \ '(')\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t\
    @test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpg51pz7kq.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpg51pz7kq.jl:1\n\
    in expression starting at /tmp/tmpg51pz7kq.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    groups = Vector{String}()\n\
    \    count = 0\n    for i = 1:length(paren_string)\n        if paren_string[i]\
    \ == '('\n            count += 1\n        elseif paren_string[i] == ')'\n    \
    \        count -= 1\n        end\n        if count == 0\n            push!(groups,\
    \ paren_string[1:i])\n            paren_string = paren_string[i+1:end]\n     \
    \       i = 0\n        end\n    end\n    return groups\nend\nseparate_paren_groups('(\
    \ ) (( )) (( )( ))')\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp1_1ltsfu.jl:26\nin expression\
    \ starting at /tmp/tmp1_1ltsfu.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    i = 1\n    temp_string = \"\"\n    new_list = []\n    while i <= length(paren_string)\n\
    \        if paren_string[i] == ' '\n            i += 1\n        elseif paren_string[i]\
    \ == '('\n            j = 0\n            temp_string = \"\"\n            for k\
    \ in 0:length(paren_string)\n                if paren_string[i + k] == '('\n \
    \                   j += 1\n                elseif paren_string[i + k] == ')'\n\
    \                    j -= 1\n                end\n                if j == 0\n\
    \                    break\n                end\n                temp_string =\
    \ temp_string * paren_string[i + k]\n            end\n            new_list = push!(new_list,\
    \ temp_string)\n            i += length(temp_string)\n        end\n    end\n \
    \   return new_list\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    n = length(paren_string)\n    count = 0\n    group = \"\"\n    group_list\
    \ = Vector{String}()\n    for i in 1:n\n        if paren_string[i] == '('\n  \
    \          group = group * paren_string[i]\n            count += 1\n        elseif\
    \ paren_string[i] == ')'\n            group = group * paren_string[i]\n      \
    \      count -= 1\n        end\n        if count == 0 && group != \"\"\n     \
    \       push!(group_list, group)\n            group = \"\"\n        end\n    end\n\
    \    return group_list\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \"\"\"\n    TODO!\n    \"\"\"\n    return [] # <- REMOVE THIS WHEN YOU'RE\
    \ DONE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdqwnpngb.jl:19\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdqwnpngb.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdqwnpngb.jl:18\ntest set: Test\
    \ Failed at /tmp/tmpdqwnpngb.jl:20\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdqwnpngb.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdqwnpngb.jl:18\ntest set: Test\
    \ Failed at /tmp/tmpdqwnpngb.jl:21\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdqwnpngb.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdqwnpngb.jl:18\ntest set: Test\
    \ Failed at /tmp/tmpdqwnpngb.jl:22\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdqwnpngb.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdqwnpngb.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    openParenCount = 0\n    startIndex = 1\n    for (i, c) in enumerate(paren_string)\n\
    \        if c == '('\n            openParenCount += 1\n        elseif c == ')'\n\
    \            openParenCount -= 1\n        end\n        if openParenCount == 0\n\
    \            push!(ans, paren_string[startIndex:i])\n            startIndex =\
    \ i + 1\n        end\n    end\n    return ans\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpa9wp60pb.jl:29\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  UndefVarError: ans not defined\\\
    n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\n     @ Main\
    \ /tmp/tmpa9wp60pb.jl:18\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpa9wp60pb.jl:29 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpa9wp60pb.jl:28\\ntest set:\
    \ Error During Test at /tmp/tmpa9wp60pb.jl:30\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  UndefVarError: ans not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpa9wp60pb.jl:18\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpa9wp60pb.jl:30 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpa9wp60pb.jl:28\\ntest set:\
    \ Error During Test at /tmp/tmpa9wp60pb.jl:31\\n  Test threw exception\\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n  UndefVarError: ans\
    \ not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpa9wp60pb.jl:18\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpa9wp60pb.jl:31 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpa9wp60pb.jl:28\\ntest set:\
    \ Error During Test at /tmp/tmpa9wp60pb.jl:32\\n  Test threw exception\\n  Express"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # First let's remove any spaces in the string.\n    paren_string = replace(paren_string,\
    \ \" \" => \"\")\n    # Your code goes here\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmps7fhx9mp.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmps7fhx9mp.jl:1\n\
    in expression starting at /tmp/tmps7fhx9mp.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    ...\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid identifier name \"...\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph6ufif96.jl:9\nin expression starting at /tmp/tmph6ufif96.jl:9\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    ################## TODO #############################\n    split_strings\
    \ = []\n    paren_string_no_space = replace(paren_string, r\"\\s+\"=>\"\")\n \
    \   i = 1\n    while i <= length(paren_string_no_space)\n        if paren_string_no_space[i]\
    \ == '('\n            j = i\n            count = 1\n            while j < length(paren_string_no_space)\n\
    \                if paren_string_no_space[j] == '('\n                    count\
    \ += 1\n                elseif paren_string_no_space[j] == ')'\n             \
    \       count -= 1\n                end\n                if count == 0\n     \
    \               break\n                end\n                j += 1\n         \
    \   end\n            push!(split_strings, paren_string_no_space[i:j])\n      \
    \      i = j\n        end\n        i += 1\n    end\n    split_strings\n    #####################################################\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1wi3lji5.jl:41\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())((()))()((())()())\"] == [\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1wi3lji5.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1wi3lji5.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp1wi3lji5.jl:42\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()(())((()))(((())))\"\
    ] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1wi3lji5.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1wi3lji5.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp1wi3lji5.jl:44\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()(())(()())\"] ==\
    \ [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1wi3lji5.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1wi3lji5.jl:40\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1wi3lji5.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \"\"\"\n    Result Vector \n    \"\"\"\n    result_vector = String[]\n\
    \    paren_stack = String[]\n    open_paren_count = 0\n    close_paren_count =\
    \ 0\n   \n    for i in eachindex(paren_string)\n        #println(paren_string[i])\n\
    \        if paren_string[i] == '(' \n            push!(paren_stack, paren_string[i])\n\
    \            open_paren_count += 1\n        elseif paren_string[i] == ')' \n \
    \           pop!(paren_stack)\n            close_paren_count += 1\n        end\n\
    \        \n        if open_paren_count > 0 && open_paren_count == close_paren_count\n\
    \            #println(paren_stack)\n            push!(result_vector, join(paren_stack))\n\
    \            paren_stack = String[]\n            open_paren_count = 0\n      \
    \      close_paren_count = 0\n        end\n    end\n    return result_vector\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # first remove all whitespace\n    paren_string = replace(paren_string,\
    \ r\"\\s\", \"\")\n    # create a vector to store results\n    paren_vector =\
    \ []\n    # construct a regex to match strings with balanced parentheses of any\
    \ length\n    paren_regex = r\"(\\([^\\(\\)]*\\))\"\n    # begin iterating over\
    \ the string\n    paren_iterator = eachmatch(Regex(paren_regex), paren_string)\n\
    \    for paren_match in paren_iterator\n        # the result of each iteration\
    \ is stored in \"paren_match\"\n        push!(paren_vector, paren_match.match)\n\
    \    end\n    return paren_vector\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpte283gce.jl:28\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ replace(::String, ::Regex, ::String)\\n  Closest candidates are:\\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\\\
    n    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\\\
    n    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpte283gce.jl:10\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpte283gce.jl:28 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpte283gce.jl:27\\ntest set:\
    \ Error During Test at /tmp/tmpte283gce.jl:29\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  MethodError: no method matching replace(::String, ::Regex, ::String)\\\
    n  Closest candidates are:\\n    replace(!Matched::Union{Function, Type}, ::Any;\
    \ count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\\n    replace(::String,\
    \ !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\\\
    n    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpte283gce.jl:10\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpte283gce.jl:29 [inlined]\\\
    n   [4"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpp1z__q6i.jl:1\nin expression starting at /tmp/tmpp1z__q6i.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    split_chars = [\" \"]\n    separate_strings = split(paren_string, split_chars)\n\
    \    separate_strings = filter(x -> !(x == \"\"), separate_strings)\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2g__mzyq.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2g__mzyq.jl:1\n\
    in expression starting at /tmp/tmp2g__mzyq.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    group = Vector{String}()\n    i = 1\n    while i <= length(paren_string)\n\
    \        j = i\n        count = 0\n        while j <= length(paren_string)\n \
    \           if paren_string[j] == '('\n                count += 1\n          \
    \  elseif paren_string[j] == ')'\n                count -= 1\n            end\n\
    \            if count == 0\n                push!(group, paren_string[i:j])\n\
    \                i = j + 1\n                break\n            end\n         \
    \   j += 1\n        end\n    end\n    return group\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpm47k0e5e.jl:35\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm47k0e5e.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm47k0e5e.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpm47k0e5e.jl:36\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \" \"\
    , \"(())\", \" \", \"((()))\", \" \", \"(((())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm47k0e5e.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm47k0e5e.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpm47k0e5e.jl:38\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \" \", \"((\
    \ ))\", \" \", \"(( )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm47k0e5e.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm47k0e5e.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm47k0e5e.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    if length(paren_string)==0\n        return []\n    end\n    \n \
    \   level = 0\n    open_paren = 0\n    close_paren = 0\n    paren_index = 0\n\
    \    start_index = 0\n    end_index = 0\n    paren_groups = []\n    \n    for\
    \ i in 1:length(paren_string)\n        if paren_string[i] == '('\n           \
    \ level += 1\n            open_paren += 1\n            paren_index = i\n     \
    \       if paren_index > end_index\n                end_index = paren_index\n\
    \            end\n        elseif paren_string[i] == ')'\n            level -=\
    \ 1\n            close_paren += 1\n            paren_index = i\n            if\
    \ paren_index > end_index\n                end_index = paren_index\n         \
    \   end\n        end\n        \n        if level==0\n            start_index =\
    \ paren_index + 1\n            push!(paren_groups, paren_string[paren_index+1:end_index])\n\
    \            paren_index = 0\n            open_paren = 0\n            close_paren\
    \ = 0\n        end\n        \n    end\n    \n    # remove the extra characters\
    \ and spaces around the parentheses\n    for i in 1:length(paren_groups)\n   \
    \     paren_groups[i] = replace(paren_groups[i], r\"[ ]+\", \"\")\n    end\n \
    \   \n    return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpd7hdic4i.jl:61\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ replace(::String, ::Regex, ::String)\\n  Closest candidates are:\\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\\\
    n    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\\\
    n    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpd7hdic4i.jl:51\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpd7hdic4i.jl:61 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpd7hdic4i.jl:60\\ntest set:\
    \ Error During Test at /tmp/tmpd7hdic4i.jl:62\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  MethodError: no method matching replace(::String, ::Regex, ::String)\\\
    n  Closest candidates are:\\n    replace(!Matched::Union{Function, Type}, ::Any;\
    \ count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\\n    replace(::String,\
    \ !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\\\
    n    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpd7hdic4i.jl:51\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpd7hdic4i.jl:62 [inlined]\\\
    n   [4"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    x = split(paren_string,\")\")\n    y = []\n    for i in x\n        z =\
    \ haskey(i, \"(\" )\n        if z == true\n            y = append!(y,i)\n    \
    \    end\n    end\n    return y\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpid09a2b2.jl:24\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ haskey(::SubString{String}, ::String)\\n  Closest candidates are:\\n    haskey(!Matched::Base.ImmutableDict,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/dict.jl:789\\n    haskey(!Matched::WeakKeyDict{K},\
    \ ::Any) where K at /shared/centos7/julia/1.7.3/share/julia/base/weakkeydict.jl:179\\\
    n    haskey(!Matched::IOContext, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/show.jl:339\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpid09a2b2.jl:12\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpid09a2b2.jl:24 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpid09a2b2.jl:23\\ntest set:\
    \ Error During Test at /tmp/tmpid09a2b2.jl:25\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  MethodError: no method matching haskey(::SubString{String}, ::String)\\\
    n  Closest candidates are:\\n    haskey(!Matched::Base.ImmutableDict, ::Any) at\
    \ /shared/centos7/julia/1.7.3/share/julia/base/dict.jl:789\\n    haskey(!Matched::WeakKeyDict{K},\
    \ ::Any) where K at /shared/centos7/julia/1.7.3/share/julia/base/weakkeydict.jl:179\\\
    n    haskey(!Matched::IOContext, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/show.jl:339\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpid09a2b2.jl:12\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpid09a2b2.jl:25 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpx7dfzwj6.jl:17\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{String}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpx7dfzwj6.jl:10\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpx7dfzwj6.jl:17 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpx7dfzwj6.jl:16\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # We use a stack of open braces to keep track of the number of open braces\
    \ in a group at any given point\n    open_braces = Int[]\n    # This is the list\
    \ of strings which will be returned\n    output = String[]\n    # We also keep\
    \ track of the current string that we are building as we process the input\n \
    \   curr_string = \"\"\n    for paren in paren_string\n        if paren == '('\n\
    \            # if we hit an open brace, push that onto the stack\n           \
    \ push!(open_braces, 1)\n        elseif paren == ')'\n            # if we hit\
    \ a closed brace, pop off the top of the stack\n            # if the stack is\
    \ empty, that means we've closed off the current group\n            # so reset\
    \ the curr_string, and push it to the output list\n            if isempty(open_braces)\n\
    \                push!(output, curr_string)\n                curr_string = \"\"\
    \n            else\n                pop!(open_braces)\n            end\n     \
    \   else\n            # if we hit a character that is not a paren, append it to\
    \ the current string we are building\n            curr_string *= paren\n     \
    \   end\n    end\n    # return the output list\n    return output\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3bl_qask.jl:42\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3bl_qask.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3bl_qask.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp3bl_qask.jl:43\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3bl_qask.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3bl_qask.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp3bl_qask.jl:44\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3bl_qask.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3bl_qask.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp3bl_qask.jl:45\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3bl_qask.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3bl_qask.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_paren_pos = findall(x -> x == '(' , paren_string) # This finds all\
    \ the positions of open parentheses, so we can keep track of where all the open\
    \ parentheses are\n    close_paren_pos = findall(x -> x == ')' , paren_string)\
    \ # This finds all the positions of close parentheses, so we can keep track of\
    \ where all the close parentheses are\n    all_parens = sort([open_paren_pos;\
    \ close_paren_pos]) # This combines the open and close parentheses together, but\
    \ also puts them in order of what position they're in\n    open_paren_index =\
    \ 1 # This keeps track of where we are in the list of open parens.\n    paren_groups\
    \ = Vector{String}() # This is where we will store the separate paren groups\n\
    \    for i in all_parens # This loop goes through each position of each paren\n\
    \        if i == open_paren_pos[open_paren_index] # If it's an open paren\n  \
    \          if open_paren_index == 1 # If it's the first paren group\n        \
    \        push!(paren_groups, paren_string[i]) # we add it to the list\n      \
    \      else # If it's not the first paren group\n                push!(paren_groups,\
    \ paren_string[open_paren_pos[open_paren_index-1]:i]) # We add it to the list,\
    \ but with the previous paren group included in it\n            end\n        \
    \    open_paren_index += 1 # We update our index of where we are in the list of\
    \ open parens.\n        else # If it's a close paren\n            if i == open_paren_pos[end]\
    \ # If it's the last close paren\n                push!(paren_groups, paren_string[open_paren_pos[end]:i])\
    \ # We add it to the list\n            else # If it's not the last close paren\n\
    \                push!(paren_groups, paren_string[open_paren_pos[end]:i]) # We\
    \ add it to the list, but with the last open paren included in it\n          \
    \  end\n        end\n    end\n    return paren_groups # We return the list of\
    \ paren groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    length = lastindex(paren_string)\n\
    \    paren_stack = []\n    start_index = 0\n    end_index = 0\n    paren_groups\
    \ = []\n    for i in 1:length\n        if paren_string[i] == '('\n           \
    \ push!(paren_stack, paren_string[i])\n            start_index = i\n        elseif\
    \ paren_string[i] == ')'\n            pop!(paren_stack)\n            end_index\
    \ = i\n            if paren_stack == []\n                push!(paren_groups, paren_string[start_index:end_index])\n\
    \            end\n        end\n    end\n    return paren_groups\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5kd9aoze.jl:34\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"())\", \"()))\", \"()\", \"())\"] == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kd9aoze.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kd9aoze.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp5kd9aoze.jl:35\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"())\"\
    , \"()))\", \"())))\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kd9aoze.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kd9aoze.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp5kd9aoze.jl:36\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"())))\"] == [\"(()(())((())))\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kd9aoze.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kd9aoze.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp5kd9aoze.jl:37\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()\", \"())\", \"\
    ())\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kd9aoze.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5kd9aoze.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    balance_count::Int = 0\n    result::Vector{String} = Vector{String}()\n\
    \    current_group::String = \"\"\n    for c in paren_string\n        if c ==\
    \ '('\n            balance_count += 1\n        elseif c == ')'\n            balance_count\
    \ -= 1\n        end\n        if balance_count == 0 && current_group != \"\"\n\
    \            push!(result, current_group)\n            current_group = \"\"\n\
    \        elseif balance_count > 0\n            current_group *= c\n        end\n\
    \    end\n    return result\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp35x8rzi8.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()()\", \"((())\", \"(\", \"((())()()\"] == [\"(()())\",\
    \ \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp35x8rzi8.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp35x8rzi8.jl:31\ntest set: Test\
    \ Failed at /tmp/tmp35x8rzi8.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"(\", \"(()\"\
    , \"((())\", \"(((()))\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp35x8rzi8.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp35x8rzi8.jl:31\ntest set: Test\
    \ Failed at /tmp/tmp35x8rzi8.jl:34\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()(())((()))\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp35x8rzi8.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp35x8rzi8.jl:31\ntest set: Test\
    \ Failed at /tmp/tmp35x8rzi8.jl:35\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( \", \"(( )\", \"\
    (( )( )\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp35x8rzi8.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp35x8rzi8.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    str = filter(x -> x != ' ', paren_string)\n    parens = Char[]\n    for\
    \ i in 1:length(str)\n        if str[i] == '('\n            push!(parens, '(')\n\
    \        elseif str[i] == ')'\n            if isempty(parens) || parens[end] !=\
    \ '('\n                return -1\n            else\n                pop!(parens)\n\
    \            end\n        end\n    end\n    return length(parens) == 0 ? true\
    \ : false\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpu0vxyqn7.jl:29\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Bool to an object of type Vector{String}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpu0vxyqn7.jl:22\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpu0vxyqn7.jl:29 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpu0vxyqn7.jl:28\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    n_paren = length(paren_string)\n    i = 1\n    j = 1\n    paren_count\
    \ = 0\n    start_paren = 0\n    end_paren = 0\n    temp_string = \"\"\n    paren_array\
    \ = Array{Char}(undef,1)\n    paren_array = []\n    group_string = []\n    while\
    \ i <= n_paren\n        if paren_string[i] == '('\n            paren_count +=\
    \ 1\n            temp_string += '('\n            if paren_count == 1\n       \
    \         start_paren = i\n            end\n        elseif paren_string[i] ==\
    \ ')'\n            paren_count -= 1\n            temp_string += ')'\n        \
    \    if paren_count == 0\n                end_paren = i\n                push!(group_string,temp_string)\n\
    \                temp_string = \"\"\n            end\n        end\n        i +=\
    \ 1\n    end\n    return group_string\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpagpse3jg.jl:44\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ +(::String, ::Char)\\n  Closest candidates are:\\n    +(::Any, ::Any, !Matched::Any,\
    \ !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\\\
    n    +(!Matched::Integer, ::AbstractChar) at /shared/centos7/julia/1.7.3/share/julia/base/char.jl:247\\\
    n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\n     @ Main\
    \ /tmp/tmpagpse3jg.jl:22\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpagpse3jg.jl:44 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpagpse3jg.jl:43\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # create an array to hold the groups of nested parentheses\n    paren_groups\
    \ = []\n    # create an array to hold the positions of the open and close parentheses\
    \ in the string\n    paren_locations = []\n    # find the location of all the\
    \ parentheses in the string\n    for i in eachindex(paren_string)\n        if\
    \ paren_string[i] == '('\n            push!(paren_locations, i)\n        elseif\
    \ paren_string[i] == ')'\n            push!(paren_locations, i)\n        end\n\
    \    end\n    # split the string at the locations of the parentheses\n    for\
    \ i in eachindex(paren_locations)\n        paren_groups = [paren_string[1:paren_locations[i]-1];\
    \ paren_string[paren_locations[i]+1:end]]\n    end\n    # return the strings containing\
    \ the nested parentheses\n    return paren_groups\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpib90mb7i.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()()) ((())) () ((())()()\", \"\"] == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpib90mb7i.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpib90mb7i.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpib90mb7i.jl:34\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"() (()) ((()))\
    \ (((()))\", \"\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpib90mb7i.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpib90mb7i.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpib90mb7i.jl:35\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()(())((()))\", \"\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpib90mb7i.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpib90mb7i.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpib90mb7i.jl:36\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( ) (( )) (( )( )\"\
    , \"\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpib90mb7i.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpib90mb7i.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_groups = split(paren_string, \")\") # ignores any string that doesn't\
    \ end in )\n    paren_groups = [strip(x, \" \") for x in paren_groups] # remove\
    \ any whitespace\n    paren_groups = [x for x in paren_groups if occursin(\"(\"\
    , x)] # remove anything without ( in it\n    paren_groups = [x[occursin(x, \"\
    (\"):end] for x in paren_groups] # remove anything before the first ( in each\
    \ string\n    return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpefrcx5s7.jl:20\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: objects of type\
    \ SubString{String} are not callable\\n  Stacktrace:\\n    [1] rstrip(f::SubString{String},\
    \ s::String)\\n      @ Base ./strings/util.jl:289\\n    [2] strip\\n      @ ./strings/util.jl:322\
    \ [inlined]\\n    [3] #1\\n      @ ./none:0 [inlined]\\n    [4] iterate\\n   \
    \   @ ./generator.jl:47 [inlined]\\n    [5] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#4\"})\\n      @ Base ./array.jl:724\\n    [6] separate_paren_groups(paren_string::String)\\\
    n      @ Main /tmp/tmpefrcx5s7.jl:10\\n    [7] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n    [8] macro expansion\\n      @ /tmp/tmpefrcx5s7.jl:20 [inlined]\\\
    n    [9] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [10] top-level scope\\n      @ /tmp/tmpefrcx5s7.jl:19\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    groups = []\n\
    \    balance = 0\n    l = length(paren_string)\n    for i = 1:l\n        ch =\
    \ paren_string[i]\n        if ch == '('\n            balance += 1\n        elseif\
    \ ch == ')'\n            balance -= 1\n        end\n        if balance == 0 &&\
    \ i != l\n            push!(groups, paren_string[1:i])\n            paren_string\
    \ = paren_string[i+1:end]\n            l = length(paren_string)\n            i\
    \ = 0\n        end\n    end\n    push!(groups, paren_string)\n    return groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpqsywqvy3.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  BoundsError: attempt to access\
    \ 10-codeunit String at index [11]\\n  Stacktrace:\\n   [1] checkbounds\\n   \
    \  @ ./strings/basic.jl:216 [inlined]\\n   [2] codeunit\\n     @ ./strings/string.jl:102\
    \ [inlined]\\n   [3] getindex\\n     @ ./strings/string.jl:223 [inlined]\\n  \
    \ [4] separate_paren_groups(paren_string::String)\\n     @ Main /tmp/tmpqsywqvy3.jl:14\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [6] macro expansion\\n     @ /tmp/tmpqsywqvy3.jl:35 [inlined]\\\
    n   [7] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [8] top-level scope\\n     @ /tmp/tmpqsywqvy3.jl:34\\ntest set:\
    \ Error During Test at /tmp/tmpqsywqvy3.jl:36\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  BoundsError: attempt to access 2-codeunit String at index [11]\\\
    n  Stacktrace:\\n   [1] checkbounds\\n     @ ./strings/basic.jl:216 [inlined]\\\
    n   [2] codeunit\\n     @ ./strings/string.jl:102 [inlined]\\n   [3] getindex\\\
    n     @ ./strings/string.jl:223 [inlined]\\n   [4] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpqsywqvy3.jl:14\\n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [6] macro expansion\\n     @ /tmp/tmpqsywqvy3.jl:36 [inlined]\\\
    n   [7] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [8] top-level scope\\n     @ /tmp/tmpqsywqvy3.jl:34\\ntest set:\
    \ Error During Test at /tmp/tmpqsywqvy3.jl:38\\n  Test threw exception\\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\\n  BoundsError:\
    \ attempt to access 4-codeunit String at index [7]\\n  Stacktrace:\\n   [1] checkbounds\\\
    n     @ ./strings/basic.jl:216 [inlined]\\n  "
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_paren = 1\n    closed_paren = 0\n    i = 1 \n    count = 0\n    result\
    \ = []\n    temp = \"(\"\n    while i <= length(paren_string)\n        if paren_string[i]\
    \ == '('\n            open_paren += 1\n            count += 1\n            temp\
    \ = temp * string(paren_string[i])\n        elseif paren_string[i] == ')'\n  \
    \          closed_paren += 1\n            count += 1\n            temp = temp\
    \ * string(paren_string[i])\n        elseif (open_paren == closed_paren) && (open_paren\
    \ != 0) && (closed_paren != 0)\n            push!(result, temp)\n            temp\
    \ = \"(\"\n            open_paren = 1\n            closed_paren = 0\n        \
    \    count = 0\n        end\n        i += 1\n    end\n    push!(result, temp)\n\
    \    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpc2irpi86.jl:41\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"((()())((()))()((())()())\"] == [\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc2irpi86.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc2irpi86.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpc2irpi86.jl:42\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"(()(())((()))(((())))\"\
    ] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc2irpi86.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc2irpi86.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpc2irpi86.jl:43\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"((()(())((())))\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc2irpi86.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc2irpi86.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpc2irpi86.jl:44\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"(()(())(()())\"] ==\
    \ [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc2irpi86.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpc2irpi86.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # This is the container where I'll save each individual group of parentheses.\n\
    \    paren_groups = Vector{String}()\n    # This is the index of the next character\
    \ I'm looking at.\n    i = 1\n    # This is the index of the last character I've\
    \ finished with\n    j = 1\n    # This is the number of open parentheses we have\
    \ seen so far.\n    open_parens = 0\n    # This is the total number of parentheses\
    \ that are part of the group we're looking at.\n    group_size = 0\n    # This\
    \ is the number of closed parentheses that are in the group we're looking at.\n\
    \    closed_parens = 0\n    # This is the total number of open parentheses that\
    \ have been found so far.\n    total_open_parens = 0\n    # This is the total\
    \ number of closed parentheses that have been found so far.\n    total_closed_parens\
    \ = 0\n    while i <= length(paren_string)\n        if paren_string[i] == '('\n\
    \            open_parens += 1\n            total_open_parens += 1\n        elseif\
    \ paren_string[i] == ')'\n            closed_parens += 1\n            total_closed_parens\
    \ += 1\n        end\n        group_size += 1\n        if open_parens == closed_parens\n\
    \            push!(paren_groups, String(paren_string[j:i]))\n            j = i\
    \ + 1\n            group_size = 0\n            open_parens = 0\n            closed_parens\
    \ = 0\n        end\n        i += 1\n    end\n    paren_groups\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwcujpr1d.jl:50\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwcujpr1d.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwcujpr1d.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpwcujpr1d.jl:51\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \" \"\
    , \"(())\", \" \", \"((()))\", \" \", \"(((())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwcujpr1d.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwcujpr1d.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpwcujpr1d.jl:53\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \" \", \"((\
    \ ))\", \" \", \"(( )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwcujpr1d.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwcujpr1d.jl:49\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwcujpr1d.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_paren = '('\n    close_paren = ')'\n    counts = Dict{Char,Int}()\n\
    \    push!(counts, open_paren, 0)\n    push!(counts, close_paren, 0)\n    tmp_string\
    \ = \"\"\n    paren_strings = []\n    for c in paren_string\n        if c in counts\n\
    \            counts[c] += 1\n            tmp_string = string(tmp_string, c)\n\
    \        end\n    end\n    if counts[open_paren] != counts[close_paren]\n    \
    \    return \"String error: not balanced\"\n    end\n    i = 1\n    while i <\
    \ length(tmp_string)\n        cur_paren = tmp_string[i]\n        if cur_paren\
    \ == open_paren\n            if cur_paren == tmp_string[i+1]\n               \
    \ tmp_string = string(tmp_string[1:i-1], tmp_string[i+1:end])\n            end\n\
    \        end\n        i += 1\n    end\n    i = 1\n    while i < length(tmp_string)\n\
    \        cur_paren = tmp_string[i]\n        if cur_paren == close_paren\n    \
    \        if cur_paren == tmp_string[i+1]\n                tmp_string = string(tmp_string[1:i-1],\
    \ tmp_string[i+1:end])\n            end\n        end\n        i += 1\n    end\n\
    \    return split(tmp_string, \")(\")\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpqsv6petv.jl:52\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ push!(::Dict{Char, Int64}, ::Char)\\n  Closest candidates are:\\n    push!(::Any,\
    \ ::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2970\\\
    n    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2971\\\
    n    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:605\\\
    n    ...\\n  Stacktrace:\\n   [1] push!(A::Dict{Char, Int64}, a::Char, b::Int64)\\\
    n     @ Base ./abstractarray.jl:2970\\n   [2] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpqsv6petv.jl:12\\n   [3] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmpqsv6petv.jl:52 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmpqsv6petv.jl:51\\ntest set:\
    \ Error During Test at /tmp/tmpqsv6petv.jl:53\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  MethodError: no method matching push!(::Dict{Char, Int64}, ::Char)\\\
    n  Closest candidates are:\\n    push!(::Any, ::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2970\\\
    n    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2971\\\
    n    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:605\\\
    n    ...\\n  Stacktrace:\\n   [1] push!(A::Dict{Char, Int64}, a::Char, b::Int64)\\\
    n     @ Base ./abstractarray.jl:2970\\n   [2] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpqsv6petv.jl:12\\"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_strings = []\n    paren_string = paren_string .* \")\"\n    len_paren_string\
    \ = length(paren_string)\n    paren_counter = 0\n    temp_paren_string = \"\"\n\
    \    for i = 1:len_paren_string\n        if paren_string[i] == \"(\"\n       \
    \     paren_counter += 1\n        elseif paren_string[i] == \")\"\n          \
    \  paren_counter -= 1\n        end\n        temp_paren_string *= paren_string[i]\n\
    \        if paren_counter == 0\n            paren_strings = [paren_strings...,\
    \ temp_paren_string]\n            temp_paren_string = \"\"\n        end\n    end\n\
    \    paren_strings\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyp3x6evd.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(\", \"(\", \")\", \"(\", \")\", \")\", \" \", \"(\", \"(\"\
    , \"(\"  \u2026  \"(\", \"(\", \")\", \")\", \"(\", \")\", \"(\", \")\", \")\"\
    , \")\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyp3x6evd.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyp3x6evd.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpyp3x6evd.jl:34\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"(\", \")\"\
    , \" \", \"(\", \"(\", \")\", \")\", \" \", \"(\", \"(\"  \u2026  \" \", \"(\"\
    , \"(\", \"(\", \"(\", \")\", \")\", \")\", \")\", \")\"] == [\"()\", \"(())\"\
    , \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyp3x6evd.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyp3x6evd.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpyp3x6evd.jl:35\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(\", \"(\", \")\", \"(\", \"(\", \"\
    )\", \")\", \"(\", \"(\", \"(\", \")\", \")\", \")\", \")\", \")\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyp3x6evd.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyp3x6evd.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpyp3x6evd.jl:36\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"(\", \" \", \")\"\
    , \" \", \"(\", \"(\", \" \", \")\", \")\", \" \", \"(\", \"(\", \" \","
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyp3x6evd.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_index = 1\n    start_index = 1\n    prev_char = ' '\n    count =\
    \ 0\n    i = 1\n    groups = Vector{String}()\n    while i <= length(paren_string)\n\
    \        if isequal(paren_string[i], ' ')\n            i += 1\n            continue\n\
    \        end\n        if isequal(paren_string[i], '(') && (prev_char == ' ' ||\
    \ prev_char == '(')\n            start_index = i\n            paren_index = i\n\
    \            count += 1\n        elseif isequal(paren_string[i], ')') && prev_char\
    \ == '('\n            paren_index = i\n            count -= 1\n        elseif\
    \ isequal(paren_string[i], ')') && (prev_char == ' ' || prev_char == ')')\n  \
    \          push!(groups, String(paren_string[start_index:paren_index]))\n    \
    \        paren_index = i\n            start_index = i\n            count -= 1\n\
    \        end\n        if count == 0\n            start_index = i+1\n        end\n\
    \        prev_char = paren_string[i]\n        i += 1\n    end\n    return groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4fpgdauv.jl:46\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"\", \"\", \")\", \"()\", \")()()\"] == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4fpgdauv.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4fpgdauv.jl:45\ntest set: Test\
    \ Failed at /tmp/tmp4fpgdauv.jl:47\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"\", \"\",\
    \ \")\", \"\", \")\", \")\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4fpgdauv.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4fpgdauv.jl:45\ntest set: Test\
    \ Failed at /tmp/tmp4fpgdauv.jl:48\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"()\", \"()\", \"\", \")\"] == [\"\
    (()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4fpgdauv.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4fpgdauv.jl:45\ntest set: Test\
    \ Failed at /tmp/tmp4fpgdauv.jl:49\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"\", \" )( )\"] ==\
    \ [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4fpgdauv.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4fpgdauv.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # ...\n    # TODO: Implement me!\n    # ...\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpf4flt7sw.jl:18\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{String}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpf4flt7sw.jl:12\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpf4flt7sw.jl:18 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpf4flt7sw.jl:17\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    #Initialize\n    open_paren = 0\n    group_index = 1\n    groups\
    \ = []\n    group = \"\"\n    \n    #Loop through the string\n    for i in 1:length(paren_string)\n\
    \        if paren_string[i] == '('\n            open_paren += 1\n        elseif\
    \ paren_string[i] == ')'\n            open_paren -= 1\n        end\n        \n\
    \        #Add to group\n        group *= paren_string[i]\n        \n        #Append\
    \ group when group is complete\n        if open_paren == 0\n            push!(groups,\
    \ group)\n            group = \"\"\n        end\n    end\n    \n    return groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpau5ktsgd.jl:41\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpau5ktsgd.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpau5ktsgd.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpau5ktsgd.jl:42\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \" \"\
    , \"(())\", \" \", \"((()))\", \" \", \"(((())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpau5ktsgd.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpau5ktsgd.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpau5ktsgd.jl:44\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \" \", \"((\
    \ ))\", \" \", \"(( )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpau5ktsgd.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpau5ktsgd.jl:40\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpau5ktsgd.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_list = split(paren_string, \" \")\n    result = []\n    for (i,\
    \ paren) in enumerate(paren_list)\n        if length(paren) > 0\n            push!(result,\
    \ paren)\n        end\n    end\n    return result\nend\nseparate_paren_groups(\"\
    () (( )) (( )( ))\")\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpj9uetx13.jl:27\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"(\"\
    , \")\", \"((\", \"))\", \"((\", \")(\", \"))\"] == [\"()\", \"(())\", \"(()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj9uetx13.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj9uetx13.jl:23\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     1      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj9uetx13.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    return [r\"\\( *\\)\"]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp4w12t3tx.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Regex to an object of type String\\n  Closest candidates are:\\\
    n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\\\
    n    ...\\n  Stacktrace:\\n    [1] setindex!(A::Vector{String}, x::Regex, i1::Int64)\\\
    n      @ Base ./array.jl:903\\n    [2] _unsafe_copyto!(dest::Vector{String}, doffs::Int64,\
    \ src::Vector{Regex}, soffs::Int64, n::Int64)\\n      @ Base ./array.jl:253\\\
    n    [3] unsafe_copyto!\\n      @ ./array.jl:307 [inlined]\\n    [4] _copyto_impl!\\\
    n      @ ./array.jl:331 [inlined]\\n    [5] copyto!\\n      @ ./array.jl:317 [inlined]\\\
    n    [6] copyto!\\n      @ ./array.jl:343 [inlined]\\n    [7] copyto_axcheck!\\\
    n      @ ./abstractarray.jl:1104 [inlined]\\n    [8] Vector{String}(x::Vector{Regex})\\\
    n      @ Base ./array.jl:563\\n    [9] convert\\n      @ ./array.jl:554 [inlined]\\\
    n   [10] separate_paren_groups(paren_string::String)\\n      @ Main /tmp/tmp4w12t3tx.jl:9\\\
    n   [11] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [12] macro expansion\\n      @ /tmp/tmp4w12t3tx.jl:16 [inlined]\\\
    n   [13] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [14] top-level scope\\n      @ /tmp/tmp4w12t3tx.jl:15\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Initialize a vector that will hold each of the separate groups as strings\n\
    \    open_paren = '('\n    close_paren = ')'\n    groups = Vector{String}()\n\
    \    # Initialize a counter to keep track of how many open parentheses are present\
    \ for each group\n    open_count = 0\n    # For each character in the given string\n\
    \    for c in paren_string\n        # Check if the current character is either\
    \ an open or closed parenthesis\n        if c == open_paren\n            # Increment\
    \ the counter\n            open_count += 1\n        elseif c == close_paren\n\
    \            # Decrement the counter\n            open_count -= 1\n        end\n\
    \        # \n        \n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    group = []\n    group_index = 1\n    group[group_index] = \"\"\n    for\
    \ char in paren_string\n        if char != ' '\n            group[group_index]\
    \ *= char\n        end\n        if char == ')'\n            group_index += 1\n\
    \            group[group_index] = \"\"\n        end\n    end\n    group\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpi1imrxt3.jl:28\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  BoundsError: attempt to access\
    \ 0-element Vector{Any} at index [1]\\n  Stacktrace:\\n   [1] setindex!\\n   \
    \  @ ./essentials.jl:479 [inlined]\\n   [2] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpi1imrxt3.jl:11\\n   [3] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmpi1imrxt3.jl:28 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmpi1imrxt3.jl:27\\ntest set:\
    \ Error During Test at /tmp/tmpi1imrxt3.jl:29\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  BoundsError: attempt to access 0-element Vector{Any} at index\
    \ [1]\\n  Stacktrace:\\n   [1] setindex!\\n     @ ./essentials.jl:479 [inlined]\\\
    n   [2] separate_paren_groups(paren_string::String)\\n     @ Main /tmp/tmpi1imrxt3.jl:11\\\
    n   [3] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmpi1imrxt3.jl:29 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmpi1imrxt3.jl:27\\ntest set:\
    \ Error During Test at /tmp/tmpi1imrxt3.jl:30\\n  Test threw exception\\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n  BoundsError: attempt\
    \ to access 0-element Vector{Any} at index [1]\\n  Stacktrace:\\n   [1] setindex!\\\
    n     @ ./essentials.jl:479 [inlined]\\n   [2] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpi1imrxt3.jl:11\\n   [3] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmpi1imrxt3.jl:"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    idx = [1]\n    open = 0\n    close = 0\n    for i in 1:length(paren_string)\n\
    \        if paren_string[i] == '('\n            open += 1\n        elseif paren_string[i]\
    \ == ')'\n            close += 1\n        end\n        if open == close\n    \
    \        push!(idx, i)\n            open = 0\n            close = 0\n        end\n\
    \    end\n    if length(idx) == 1\n        return []\n    end\n    paren_list\
    \ = []\n    for i in 1:length(idx)-1\n        push!(paren_list, paren_string[idx[i]:idx[i+1]])\n\
    \    end\n    return paren_list\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpplt5et_c.jl:38\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \") \", \" ((()))\", \") \", \" ()\", \") \", \"\
    \ ((())()())\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpplt5et_c.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpplt5et_c.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpplt5et_c.jl:39\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \")\
    \ \", \" (())\", \") \", \" ((()))\", \") \", \" (((())))\"] == [\"()\", \"(())\"\
    , \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpplt5et_c.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpplt5et_c.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpplt5et_c.jl:41\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \") \", \"\
    \ (( ))\", \") \", \" (( )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpplt5et_c.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpplt5et_c.jl:37\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpplt5et_c.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp1uyq5oyj.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{String}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmp1uyq5oyj.jl:10\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp1uyq5oyj.jl:16 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp1uyq5oyj.jl:15\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    final_string = \"\"\n    count = 0\n    for i in 1:length(paren_string)\n\
    \        if paren_string[i] == '('\n            count += 1\n        elseif paren_string[i]\
    \ == ')'\n            count -= 1\n        end\n        if count == 0 && i != length(paren_string)\n\
    \            final_string *= \",\"\n        else\n            final_string *=\
    \ paren_string[i]\n        end\n    end\n    return split(strip(replace(replace(final_string,\
    \ \"(\", \" ( \"), \")\", \" ) \")), \", \")\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpnsyqna6o.jl:30\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ replace(::String, ::String, ::String)\\n  Closest candidates are:\\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\\\
    n    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\\\
    n    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpnsyqna6o.jl:23\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpnsyqna6o.jl:30 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpnsyqna6o.jl:29\\ntest set:\
    \ Error During Test at /tmp/tmpnsyqna6o.jl:31\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  MethodError: no method matching replace(::String, ::String, ::String)\\\
    n  Closest candidates are:\\n    replace(!Matched::Union{Function, Type}, ::Any;\
    \ count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\\n    replace(::String,\
    \ !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\\\
    n    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpnsyqna6o.jl:23\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpnsyqna6o.jl:31 [inlined]\\\
    n   "
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    # Identify the first occurrence of '(' and ')'\n    start_ind =\
    \ findfirst(paren_string .== '(')\n    end_ind = findfirst(paren_string .== ')')\n\
    \    \n    # If there is no '(' we have reached the end of the process\n    if\
    \ isempty(start_ind)\n        return []\n    end\n    \n    # Determine the size\
    \ of the paren group by identifying all parens\n    left_parens = count(x -> x\
    \ == '(', paren_string[start_ind:end_ind])\n    right_parens = count(x -> x ==\
    \ ')', paren_string[start_ind:end_ind])\n    \n    # If the number of left and\
    \ right parens is equal then we have a complete group\n    if left_parens == right_parens\n\
    \        return [paren_string[start_ind:end_ind]] .* separate_paren_groups(paren_string[end_ind\
    \ + 1:end])\n    else # If the left and right parens are not equal recursively\
    \ find the right end of the group\n        return separate_paren_groups(paren_string[end_ind\
    \ + 1:end])\n    end\n    \nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpq5afgdr_.jl:36\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ iterate(::Nothing)\\n  Closest candidates are:\\n    iterate(!Matched::Union{LinRange,\
    \ StepRangeLen}) at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:826\\\
    n    iterate(!Matched::Union{LinRange, StepRangeLen}, !Matched::Integer) at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:826\\\
    n    iterate(!Matched::T) where T<:Union{Base.KeySet{<:Any, <:Dict}, Base.ValueIterator{<:Dict}}\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/dict.jl:695\\n    ...\\n  Stacktrace:\\\
    n   [1] isempty(itr::Nothing)\\n     @ Base ./essentials.jl:775\\n   [2] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpq5afgdr_.jl:15\\n   [3] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmpq5afgdr_.jl:36 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmpq5afgdr_.jl:35\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    ...\nend\n@testset \"separate_paren_groups()\" begin\n    @testset \"\
    empty string\" begin\n        @test separate_paren_groups(\"\") == []\n    end\n\
    \    @testset \"2 groups\" begin\n        @test separate_paren_groups(\"() (())\"\
    ) == [\"()\", \"(())\"]\n    end\n    @testset \"multiple groups\" begin\n   \
    \     @test separate_paren_groups(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\"\
    , \"(()())\"]\n    end\n    @testset \"spaces\" begin\n        @test separate_paren_groups(\"\
    \ () (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n        @test separate_paren_groups(\"\
    ( ) (( )) (( )( )) \") == [\"()\", \"(())\", \"(()())\"]\n        @test separate_paren_groups(\"\
    ( )   (( ))   (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n    end\nend\n \n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid identifier name \"...\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpbpqc15j2.jl:9\nin expression starting at /tmp/tmpbpqc15j2.jl:9\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    results = String[]\n    group = String[]\n    count = 0\n    open = '('\n\
    \    close = ')'\n    for s in paren_string\n        if s == open\n          \
    \  count += 1\n        elseif s == close\n            count -= 1\n        end\n\
    \        push!(group, s)\n        if count == 0\n            push!(results, join(group,\
    \ \"\"))\n            group = String[]\n        end\n    end\n    return results\n\
    end\n@test separate_paren_groups(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\"\
    , \"(()())\"]\n@test separate_paren_groups(\"( ) (( )( ))\") == [\"()\", \"(())\"\
    ]\n@test separate_paren_groups(\"(( )) (( )( ))\") == [\"(())\", \"(()())\"]\n\
    @test separate_paren_groups(\"(( )) ( ) (( )( ))\") == [\"(())\", \"()\", \"(())\"\
    ]\n@test separate_paren_groups(\"( ) (( )) (( )( )) ( ( )) ( ( ))\") == [\"()\"\
    , \"(())\", \"(()())\", \"()\", \"()\"]\n@test separate_paren_groups(\"( ( ))\
    \ ( ( ))\") == [\"(())\", \"(())\"]\n@test separate_paren_groups(\"( ( ))\") ==\
    \ [\"(())\"]\n@test separate_paren_groups(\"( ( )\") == []\n \nusing Test\n\n\
    @testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @test not defined\nin expression starting\
    \ at /tmp/tmpge23iw1j.jl:28\nin expression starting at /tmp/tmpge23iw1j.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_group = []\n    open_paren = '('\n    close_paren = ')'\n    groups\
    \ = []\n    open_index = 0\n    # detect if there is an open or close paren in\
    \ the string\n    for i in 1:length(paren_string)\n        current_letter = paren_string[i]\n\
    \        if current_letter == open_paren\n            push!(open_group, current_letter)\n\
    \            open_index = i\n        elseif current_letter == close_paren\n  \
    \          open_group = []\n            push!(groups, paren_string[open_index:i])\n\
    \        end\n    end\n    return groups\nend\nseparate_paren_groups('( ) (( ))\
    \ (( )( ))')\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp_n82nzsj.jl:27\nin expression\
    \ starting at /tmp/tmp_n82nzsj.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Create counter to count open parens\n    open_count = 0\n    # Vector\
    \ of strings to contain our output\n    output = Vector{String}()\n    # Temporary\
    \ string to hold our string while we are creating it\n    temp_string = \"\"\n\
    \    # Iterate through each character in the string\n    for i in 1:length(paren_string)\n\
    \        # Add to the output string if we see a non space character\n        if\
    \ paren_string[i] != ' '\n            temp_string *= paren_string[i]\n       \
    \ end\n        # Increment open count if we see an open parens\n        if paren_string[i]\
    \ == '('\n            open_count += 1\n        end\n        # Decrement open count\
    \ if we see a closed parens\n        if paren_string[i] == ')'\n            open_count\
    \ -= 1\n        end\n        # If we have 0 open parens, we have a complete paren\
    \ group, add it to the output and reset the temp string\n        if open_count\
    \ == 0\n            push!(output, temp_string)\n            temp_string = \"\"\
    \n        end\n    end\n    # This will return our list of properly separated\
    \ paren groups\n    return output\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmuqnqer3.jl:43\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \"\", \"((()))\", \"\", \"()\", \"\", \"((())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmuqnqer3.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmuqnqer3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpmuqnqer3.jl:44\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"\"\
    , \"(())\", \"\", \"((()))\", \"\", \"(((())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmuqnqer3.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmuqnqer3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpmuqnqer3.jl:46\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()\", \"\", \"(())\"\
    , \"\", \"(()())\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmuqnqer3.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmuqnqer3.jl:42\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmuqnqer3.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \"\"\" Need a vector to store the balanced parens\"\"\"\n    balanced_parens\
    \ = Vector{String}()\n    current_string = \"\"\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp10wz8rjw.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp10wz8rjw.jl:1\n\
    in expression starting at /tmp/tmp10wz8rjw.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    i = 1\n    j = 1\n    k = 0\n    l = 0\n    all_groups = []\n    each_group\
    \ = \"\"\n    while i <= length(paren_string)\n        if paren_string[i] == '('\n\
    \            j = i + 1\n            each_group = \"\"\n            while j <=\
    \ length(paren_string)\n                if paren_string[j] == ')'\n          \
    \          k = j + 1\n                    l = 1\n                    while k <=\
    \ length(paren_string)\n                        if paren_string[k] == '('\n  \
    \                          l = l + 1\n                        elseif paren_string[k]\
    \ == ')'\n                            l = l - 1\n                        end\n\
    \                        if l == 0\n                            break\n      \
    \                  end\n                        k = k + 1\n                  \
    \  end\n                    i = k\n                    if k <= length(paren_string)\n\
    \                        push!(all_groups, each_group)\n                    end\n\
    \                    break\n                else\n                    each_group\
    \ = each_group * paren_string[j]\n                end\n                j = j +\
    \ 1\n            end\n        end\n        i = i + 1\n    end\n    return all_groups\n\
    end\n \nparen_string = \"( (a) (b) ((c) (d)) )\"\nseparate_paren_groups(paren_string)\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkqywvfsy.jl:57\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(\", \"((\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkqywvfsy.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkqywvfsy.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpkqywvfsy.jl:58\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkqywvfsy.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkqywvfsy.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpkqywvfsy.jl:59\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(\"] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkqywvfsy.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkqywvfsy.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpkqywvfsy.jl:60\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkqywvfsy.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkqywvfsy.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    opening_parens = [\"(\"]\n    closing_parens = [\")\"]\n    matching_parens\
    \ = Dict(\"(\" => \")\")\n    group = \"\"\n    stack = []\n    groups = []\n\
    \    for i in paren_string\n        if i in opening_parens\n            push!(stack,\
    \ i)\n        elseif i in closing_parens\n            if !isempty(stack) && matching_parens[stack[end]]\
    \ == i\n                pop!(stack)\n                if isempty(stack)\n     \
    \               push!(groups, group)\n                    group = \"\"\n     \
    \           end\n            else\n                push!(stack, i)\n         \
    \   end\n        elseif i != \" \"\n            group = group * i\n        end\n\
    \    end\n    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp29txmx9a.jl:39\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp29txmx9a.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp29txmx9a.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp29txmx9a.jl:40\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp29txmx9a.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp29txmx9a.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp29txmx9a.jl:41\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp29txmx9a.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp29txmx9a.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp29txmx9a.jl:42\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp29txmx9a.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp29txmx9a.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    ret = Vector{String}()\n    curr_word = \"\"\n    open_paren = 0\n   \
    \ for i = 1:length(paren_string)\n        curr_letter = paren_string[i]\n    \
    \    if curr_letter == '('\n            open_paren += 1\n        elseif curr_letter\
    \ == ')'\n            open_paren -= 1\n        end\n        if open_paren == 0\
    \ && i < length(paren_string)\n            push!(ret, curr_word)\n           \
    \ curr_word = \"\"\n        else\n            curr_word = string(curr_word, curr_letter)\n\
    \        end\n    end\n    push!(ret, curr_word)\n    return ret\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw91sbk_z.jl:34\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw91sbk_z.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw91sbk_z.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpw91sbk_z.jl:35\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"(\", \"\"\
    , \"(()\", \"\", \"((())\", \"\", \"(((())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw91sbk_z.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw91sbk_z.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpw91sbk_z.jl:37\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( \", \"\", \"(( )\"\
    , \"\", \"(( )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw91sbk_z.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw91sbk_z.jl:33\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw91sbk_z.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # To be implemented\nend\n \n \nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpap4tk_z_.jl:18\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{String}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpap4tk_z_.jl:10\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpap4tk_z_.jl:18 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpap4tk_z_.jl:17\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # return a list of all groups, ignoring spaces\n    # find:\n    # first\
    \ paren, then find the closing paren,\n    # split into 3 parts, one before, one\
    \ in between, and one after\n    # recursively call on the parts before and after\
    \ (ignore part in between, since it's been handled)\n    # stop when no parens\
    \ are left\n    # return all parts in a vector\n    \n    paren_list = split(paren_string,\
    \ \" \")\n    paren_list = deleteif(x -> x == \"\", paren_list)\n    final_list\
    \ = []\n    for paren in paren_list\n        if haskey(reverse_paren_dict, paren)\n\
    \            push!(final_list, paren)\n        else\n            left_idx = nextind(x\
    \ -> x == '(', paren)\n            right_idx = nextind(x -> x == ')', paren)\n\
    \            new_paren = paren[left_idx:right_idx]\n            left_paren = paren[1:left_idx-1]\n\
    \            right_paren = paren[right_idx+1:end]\n            final_list = [separate_paren_groups(left_paren);\
    \ separate_paren_groups(right_paren); new_paren]\n        end\n    end\n    return\
    \ final_list\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpjbh_wghw.jl:39\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  UndefVarError: deleteif not\
    \ defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpjbh_wghw.jl:18\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpjbh_wghw.jl:39 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpjbh_wghw.jl:38\\ntest set:\
    \ Error During Test at /tmp/tmpjbh_wghw.jl:40\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  UndefVarError: deleteif not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpjbh_wghw.jl:18\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpjbh_wghw.jl:40 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpjbh_wghw.jl:38\\ntest set:\
    \ Error During Test at /tmp/tmpjbh_wghw.jl:41\\n  Test threw exception\\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n  UndefVarError: deleteif\
    \ not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpjbh_wghw.jl:18\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpjbh_wghw.jl:41 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpjbh_wghw.jl:38\\ntest set:\
    \ Error During Test at /tmp/tmpjbh_wghw.jl:42\\n  Test threw excep"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Initialize a Vector to hold results\n    results = Vector{String}()\n\
    \    # loop over each character in the string\n    # and keep track of the depth\
    \ of the open parentheses\n    depth = 0\n    for char in paren_string\n     \
    \   # capture the depth and collect the open parentheses\n        if char == '('\n\
    \            depth += 1\n            results[depth] = char\n        # capture\
    \ the depth and collect the closed parentheses\n        elseif char == ')'\n \
    \           results[depth] *= char\n            depth -= 1\n        end\n    end\n\
    \    return results\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpi4eudw3_.jl:32\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Char to an object of type String\\n  Closest candidates are:\\\
    n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\\\
    n    ...\\n  Stacktrace:\\n   [1] setindex!(A::Vector{String}, x::Char, i1::Int64)\\\
    n     @ Base ./array.jl:903\\n   [2] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpi4eudw3_.jl:18\\n   [3] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmpi4eudw3_.jl:32 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmpi4eudw3_.jl:31\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_stack = ParenStack()\n    group_strings = Vector{String}()\n   \
    \ group_string = \"\"\n    for char in paren_string\n        if char == '('\n\
    \            push!(paren_stack, char)\n        elseif char == ')'\n          \
    \  if isempty(paren_stack)\n                throw(ParenError(\"Too many closing\
    \ parentheses!\"))\n            end\n            pop!(paren_stack)\n         \
    \   if isempty(paren_stack)\n                push!(group_strings, group_string)\n\
    \                group_string = \"\"\n            end\n        elseif char !=\
    \ ' '\n            throw(ParenError(\"Invalid character: $char\"))\n        end\n\
    \    end\n    if !isempty(paren_stack)\n        throw(ParenError(\"Too many opening\
    \ parentheses!\"))\n    end\n    return group_strings\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpbr85u7ww.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  UndefVarError: ParenStack not\
    \ defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpbr85u7ww.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpbr85u7ww.jl:38 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpbr85u7ww.jl:37\\ntest set:\
    \ Error During Test at /tmp/tmpbr85u7ww.jl:39\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  UndefVarError: ParenStack not defined\\n  Stacktrace:\\n   [1]\
    \ separate_paren_groups(paren_string::String)\\n     @ Main /tmp/tmpbr85u7ww.jl:9\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpbr85u7ww.jl:39 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpbr85u7ww.jl:37\\ntest set:\
    \ Error During Test at /tmp/tmpbr85u7ww.jl:40\\n  Test threw exception\\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n  UndefVarError: ParenStack\
    \ not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpbr85u7ww.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpbr85u7ww.jl:40 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpbr85u7ww.jl:37\\ntest set:\
    \ Error During Test at /tmp/tmpbr85u7ww.jl:41\\n  Test threw ex"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    open_braces = 0\n    current_group = \"\"\n    groups = []\n   \
    \ \n    for char in paren_string\n        if char == '('\n            open_braces\
    \ += 1\n            current_group *= string(char)\n        elseif char == ')'\n\
    \            if open_braces == 0\n                error(\"Unbalanced parens\"\
    )\n            end\n            open_braces -= 1\n            current_group *=\
    \ string(char)\n        elseif char == ' '\n            if open_braces == 0\n\
    \                push!(groups, current_group)\n                current_group =\
    \ \"\"\n            end\n        end\n    end\n    \n    if open_braces != 0\n\
    \        error(\"Unbalanced parens\")\n    end\n    \n    push!(groups, current_group)\n\
    \    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp17u1stlj.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{String}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmp17u1stlj.jl:10\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp17u1stlj.jl:16 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp17u1stlj.jl:15\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    ###########\n    ## Your code here\n    ###########\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp3jy0x8s4.jl:18\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    @assert length(paren_string) > 0\n    @assert length(unique(paren_string))\
    \ <= 2 # must only have ( and )\n    @assert paren_string == join(sort(string(paren_string)),\
    \ \"\") # must be sorted\n    \n    if !(String(paren_string) in (\"()\", \"(())\"\
    , \"(()())\", \"((()))\"))\n        error(\"invalid paren string\")\n    end\n\
    \    \n    # some constants\n    OPEN_BRACE = '('\n    CLOSE_BRACE = ')'\n   \
    \ OPEN_BRACE_INDEX = 2\n    CLOSE_BRACE_INDEX = 2\n    \n    # my code\n    num_open_braces\
    \ = 0\n    num_close_braces = 0\n    for (i, char) in enumerate(paren_string)\n\
    \        if char == OPEN_BRACE\n            num_open_braces += 1\n        elseif\
    \ char == CLOSE_BRACE\n            num_close_braces += 1\n        end\n    end\n\
    \    \n    # test that it is balanced\n    @assert num_open_braces == num_close_braces\n\
    \    \n    if num_open_braces > num_close_braces\n        error(\"incorrect paren\
    \ string\")\n    end\n    \n    if num_open_braces < num_close_braces\n      \
    \  error(\"incorrect paren string\")\n    end\n    \n    if num_open_braces ==\
    \ 0 && num_close_braces == 0\n        error(\"incorrect paren string\")\n    end\n\
    \    \n    i = 1\n    output = []\n    for num_braces in collect(1:1:num_open_braces)\n\
    \        if paren_string[i] == OPEN_BRACE\n            if paren_string[i+OPEN_BRACE_INDEX]\
    \ == OPEN_BRACE\n                push!(output, paren_string[i:i+OPEN_BRACE_INDEX])\n\
    \                i += OPEN_BRACE_INDEX\n            elseif paren_string[i+CLOSE_BRACE_INDEX]\
    \ == CLOSE_BRACE\n                push!(output, paren_string[i:i\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjrt1c551.jl:1\nin expression starting at /tmp/tmpjrt1c551.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, r\" \", \"\")\n    paren_groups =\
    \ Vector{String}()\n    buffer = \"\"\n    left_counter = 0\n    right_counter\
    \ = 0\n    for i = 1:length(paren_string)\n        char = paren_string[i]\n  \
    \      if char == '('\n            left_counter += 1\n        elseif char == ')'\n\
    \            right_counter += 1\n        end\n        buffer = string(buffer,\
    \ char)\n        if left_counter == right_counter\n            push!(paren_groups,\
    \ buffer)\n            buffer = \"\"\n            left_counter = 0\n         \
    \   right_counter = 0\n        end\n    end\n    return paren_groups\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpdc0xgk_o.jl:36\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ replace(::String, ::Regex, ::String)\\n  Closest candidates are:\\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\\\
    n    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\\\
    n    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpdc0xgk_o.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpdc0xgk_o.jl:36 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpdc0xgk_o.jl:35\\ntest set:\
    \ Error During Test at /tmp/tmpdc0xgk_o.jl:37\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  MethodError: no method matching replace(::String, ::Regex, ::String)\\\
    n  Closest candidates are:\\n    replace(!Matched::Union{Function, Type}, ::Any;\
    \ count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\\n    replace(::String,\
    \ !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\\\
    n    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpdc0xgk_o.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpdc0xgk_o.jl:37 [inlined]\\\
    n   [4] "
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    start_idx = findfirst(paren_string .== \"(\");\n    tmp_idx = 1;\n   \
    \ output = [];\n    for i in 1:length(start_idx)\n        stack = []\n       \
    \ for j in 1:length(paren_string)\n            if paren_string[j] == \"(\"\n \
    \               push!(stack, j)\n            elseif paren_string[j] == \")\"\n\
    \                pop!(stack)\n            end\n            if isempty(stack)\n\
    \                break\n            end\n        end\n        push!(output, paren_string[start_idx[i]:j])\n\
    \        paren_string = paren_string[j+1:end]\n        tmp_idx = tmp_idx + j\n\
    \        start_idx = findfirst(paren_string .== \"(\") .+ tmp_idx;\n    end\n\
    \    return output\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpxid0ong_.jl:36\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ length(::Nothing)\\n  Closest candidates are:\\n    length(!Matched::Union{Base.KeySet,\
    \ Base.ValueIterator}) at /shared/centos7/julia/1.7.3/share/julia/base/abstractdict.jl:58\\\
    n    length(!Matched::Union{LinearAlgebra.Adjoint{T, S}, LinearAlgebra.Transpose{T,\
    \ S}} where {T, S}) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/adjtrans.jl:171\\\
    n    length(!Matched::Base.InvasiveLinkedListSynchronized) at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:604\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpxid0ong_.jl:12\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpxid0ong_.jl:36 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpxid0ong_.jl:35\\ntest set:\
    \ Error During Test at /tmp/tmpxid0ong_.jl:37\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  MethodError: no method matching length(::Nothing)\\n  Closest\
    \ candidates are:\\n    length(!Matched::Union{Base.KeySet, Base.ValueIterator})\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/abstractdict.jl:58\\n    length(!Matched::Union{LinearAlgebra.Adjoint{T,\
    \ S}, LinearAlgebra.Transpose{T, S}} where {T, S}) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/adjtrans.jl:171\\\
    n    length(!Matched::Base.InvasiveLinkedListSynchronized) at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:604\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpxid0ong_.jl:12\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    group_starts = findall(x -> x == '(' , paren_string)\n    group_ends =\
    \ findall(x -> x == ')' , paren_string)\n    #group_ends[1] = nothing\n    group_starts\
    \ = group_starts[1:end-1]\n    group_ends = group_ends[2:end]\n    groups = Int[]\n\
    \    groups_end = Int[]\n    for i in 1:length(group_starts)\n        if group_starts[i]\
    \ > group_ends[i]\n            push!(groups, group_starts[i])\n            push!(groups_end,\
    \ group_ends[i])\n        end\n    end\n    if length(groups) == 0\n        return\
    \ String[]\n    end\n    groups_string = String[]\n    paren_string = replace(paren_string,\
    \ r\" \"=>\"\")\n    for i in 1:length(groups)\n        push!(groups_string, paren_string[groups[i]:groups_end[i]])\n\
    \    end\n    return groups_string\nend\n \n \nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp266l713b.jl:39\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp266l713b.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp266l713b.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp266l713b.jl:40\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp266l713b.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp266l713b.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp266l713b.jl:41\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp266l713b.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp266l713b.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp266l713b.jl:42\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp266l713b.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp266l713b.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_list = [] #initiailize vector to hold substrings\n    paren_index\
    \ = 1\n    while paren_index <= length(paren_string)\n        open_paren_index\
    \ = paren_index\n        num_parens = 0\n        while open_paren_index <= length(paren_string)\n\
    \            if paren_string[open_paren_index] == '('\n                num_parens\
    \ += 1\n            elseif paren_string[open_paren_index] == ')'\n           \
    \     num_parens -= 1\n            end\n            if num_parens == 0\n     \
    \           paren_list = push!(paren_list,paren_string[paren_index:open_paren_index])\n\
    \                paren_index = open_paren_index + 1\n                break\n \
    \           end\n            open_paren_index += 1\n        end\n    end\n   \
    \ return paren_list\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpl6latbf7.jl:35\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpl6latbf7.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpl6latbf7.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpl6latbf7.jl:36\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \" \"\
    , \"(())\", \" \", \"((()))\", \" \", \"(((())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpl6latbf7.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpl6latbf7.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpl6latbf7.jl:38\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \" \", \"((\
    \ ))\", \" \", \"(( )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpl6latbf7.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpl6latbf7.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl6latbf7.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, r\" \", \"\") # Remove any spaces\n\
    \    open_paren = [] # Stack to store start positions of each open paren\n   \
    \ end_paren = [] # Stack to store end positions of each closed paren\n    pos\
    \ = 1\n    while pos <= length(paren_string)\n        if paren_string[pos] ==\
    \ '('\n            push!(open_paren, pos)\n        else\n            push!(end_paren,\
    \ pos)\n        end\n        pos += 1\n    end\n    #println(open_paren)\n   \
    \ #println(end_paren)\n    res = []\n    while length(open_paren) > 0\n      \
    \  start_paren = pop!(open_paren)\n        end_paren = pop!(end_paren)\n     \
    \   push!(res, paren_string[start_paren:end_paren])\n    end\n    return res\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmph6weybck.jl:36\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ replace(::String, ::Regex, ::String)\\n  Closest candidates are:\\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\\\
    n    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\\\
    n    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmph6weybck.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmph6weybck.jl:36 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmph6weybck.jl:35\\ntest set:\
    \ Error During Test at /tmp/tmph6weybck.jl:37\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  MethodError: no method matching replace(::String, ::Regex, ::String)\\\
    n  Closest candidates are:\\n    replace(!Matched::Union{Function, Type}, ::Any;\
    \ count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\\n    replace(::String,\
    \ !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\\\
    n    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmph6weybck.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmph6weybck.jl:37 [inlined]\\\
    n   [4] "
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # if the input string is empty, return an empty array\n    if isempty(paren_string)\n\
    \        return []\n    end\n    \n    # initialize output\n    # group_list will\
    \ be an array of strings containing balanced groups of parentheses\n    group_list\
    \ = []\n    \n    # counter for number of open brackets\n    open_count = 0\n\
    \    \n    # iterate through the input\n    for (i, char) in enumerate(paren_string)\n\
    \        # if the current character is an open bracket\n        if char == '('\n\
    \            # increment open_count\n            open_count += 1\n           \
    \ # if this is the first open bracket in the string\n            if open_count\
    \ == 1\n                # record its index\n                start_index = i\n\
    \            end\n        # if the current character is a closed bracket\n   \
    \     elseif char == ')'\n            # decrement open_count\n            open_count\
    \ -= 1\n            # if this is the last closed bracket in the string\n     \
    \       if open_count == 0\n                # record its index\n             \
    \   end_index = i\n                # add the substring containing the balanced\
    \ group to group_list\n                push!(group_list, paren_string[start_index:end_index])\n\
    \            end\n        end\n    end\n    \n    # return the list of strings\
    \ containing balanced groups of parentheses\n    return group_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpt0polvx9.jl:54\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  UndefVarError: start_index not\
    \ defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpt0polvx9.jl:41\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpt0polvx9.jl:54 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpt0polvx9.jl:53\\ntest set:\
    \ Error During Test at /tmp/tmpt0polvx9.jl:55\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  UndefVarError: start_index not defined\\n  Stacktrace:\\n   [1]\
    \ separate_paren_groups(paren_string::String)\\n     @ Main /tmp/tmpt0polvx9.jl:41\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpt0polvx9.jl:55 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpt0polvx9.jl:53\\ntest set:\
    \ Error During Test at /tmp/tmpt0polvx9.jl:56\\n  Test threw exception\\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n  UndefVarError: start_index\
    \ not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpt0polvx9.jl:41\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpt0polvx9.jl:56 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpt0polvx9.jl:53\\ntest set:\
    \ Error During Test at /tmp/tmpt0polvx9.jl:57\\n  Test th"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    split_string = split(string, \" \") #Split string into vector of strings,\
    \ by each space\n    paren_groups = Vector{String}()\n    for i in 1:length(split_string)\n\
    \        temp_string = split_string[i]\n        if length(temp_string) > 0 &&\
    \ temp_string[1] == '('\n            j = i\n            for j in j:length(split_string)\n\
    \                temp_string *= \" \" * split_string[j]\n                if length(temp_string)\
    \ > 0 && temp_string[end] == ')'\n                    push!(paren_groups, temp_string)\n\
    \                    break\n                end\n            end\n        end\n\
    \    end\n    return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpjm_y1buf.jl:31\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ split(::typeof(string), ::String)\\n  Closest candidates are:\\n    split(!Matched::T,\
    \ ::Any; limit, keepempty) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:417\\\
    n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\n     @ Main\
    \ /tmp/tmpjm_y1buf.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpjm_y1buf.jl:31 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpjm_y1buf.jl:30\\ntest set:\
    \ Error During Test at /tmp/tmpjm_y1buf.jl:32\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  MethodError: no method matching split(::typeof(string), ::String)\\\
    n  Closest candidates are:\\n    split(!Matched::T, ::Any; limit, keepempty) where\
    \ T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:417\\\
    n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\n     @ Main\
    \ /tmp/tmpjm_y1buf.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpjm_y1buf.jl:32 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpjm_y1buf.jl:30\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    group_count = 0 \n    group_index = 1 \n    groups = Vector{String}(undef,\
    \ 0)\n    current_group = \"\"\n    for char in paren_string\n        if char\
    \ == '('\n            group_count += 1\n            current_group *= group_count\n\
    \        elseif char == ')'\n            group_count -= 1\n            current_group\
    \ *= group_count\n        else\n            current_group *= 1\n        end\n\
    \    end\n    push!(groups, current_group)\n    return groups\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    count = 0\n    list_str = []\n    temp_str = \"\"\n    flag = false\n\
    \    for i in paren_string\n        if i != ' '\n            if i == '(' && count\
    \ == 0\n                flag = true\n            end\n            if flag\n  \
    \              temp_str = temp_str * i\n            end\n            if i == '('\n\
    \                count += 1\n            elseif i == ')'\n                count\
    \ -= 1\n            end\n            if i == ')' && count == 0\n             \
    \   flag = false\n                push!(list_str, temp_str)\n                temp_str\
    \ = \"\"\n            end\n        end\n    end\n    return list_str\nend\n  \
    \  \n \nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t\
    @test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    ...\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid identifier name \"...\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpef1srv9c.jl:9\nin expression starting at /tmp/tmpef1srv9c.jl:9\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Return value\n    return_vector = []\n    \n    # Removing whitespace\
    \ from the string\n    paren_string = replace(paren_string, \" \" => \"\")\n \
    \   \n    # Counting the total number of characters\n    len_paren_string = length(paren_string)\n\
    \    \n    # Counting the total number of open parentheses\n    num_open_paren\
    \ = count(paren_string, '(')\n    \n    # Initializing counters\n    i = 1\n \
    \   j = 1\n    num_substrings = num_open_paren\n    \n    # Looping through all\
    \ the substrings\n    while j <= num_substrings\n        \n        # Initializing\
    \ the substring\n        substring = \"\"\n        \n        # Looping through\
    \ the characters in the string\n        while i <= len_paren_string\n        \
    \    \n            # If the current character is an open parenthesis, then we\
    \ append to the substring\n            if paren_string[i] == '('\n           \
    \     substring = string(substring, paren_string[i])\n            \n         \
    \   # If it is a closed parenthesis, then we append to the substring and check\
    \ if the parenthesis is\n            # balanced. If it is, then the substring\
    \ is added to the list and the counter is updated\n            elseif paren_string[i]\
    \ == ')'\n                substring = string(substring, paren_string[i])\n   \
    \             if balanced_paren(substring)\n                    push!(return_vector,\
    \ substring)\n                    j += 1\n                    break\n        \
    \        end\n            end\n            \n            # Updating the counter\n\
    \            i += 1\n        end\n    end\n    \n    # Return the vector\n   \
    \ return return_vector\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpgyqz8ky3.jl:63\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: objects of type\
    \ String are not callable\\n  Stacktrace:\\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\\n     @ Base ./reduce.jl:1206\\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\\n     @ Base ./reduce.jl:1201\\n   [3] count(f::String,\
    \ itr::Char)\\n     @ Base ./reduce.jl:1201\\n   [4] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpgyqz8ky3.jl:19\\n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [6] macro expansion\\n     @ /tmp/tmpgyqz8ky3.jl:63 [inlined]\\\
    n   [7] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [8] top-level scope\\n     @ /tmp/tmpgyqz8ky3.jl:62\\ntest set:\
    \ Error During Test at /tmp/tmpgyqz8ky3.jl:64\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  MethodError: objects of type String are not callable\\n  Stacktrace:\\\
    n   [1] _simple_count(pred::String, itr::Char, init::Int64)\\n     @ Base ./reduce.jl:1206\\\
    n   [2] count(f::String, itr::Char; init::Int64)\\n     @ Base ./reduce.jl:1201\\\
    n   [3] count(f::String, itr::Char)\\n     @ Base ./reduce.jl:1201\\n   [4] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpgyqz8ky3.jl:19\\n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [6] macro expansion\\n     @ /tmp/tmpgyqz8ky3.jl:64 [inlined]\\\
    n   [7] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [8] top-level scope\\n     @ /tmp/tmpgyqz8ky3.jl:62\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \"\"\" initialize the stack to contain our characters\n    and the vector\
    \ to hold our strings \"\"\"\n    stk = []\n    vec = []\n    for i = 1:length(paren_string)\n\
    \        \"\"\" We push each open parentheses on the stack\n        and any time\
    \ we find a closing parentheses, we pop until we find the\n        corresponding\
    \ open parentheses. \"\"\"\n        if paren_string[i] == '('\n            push!(stk,\
    \ paren_string[i])\n        elseif paren_string[i] == ')'\n            while length(stk)\
    \ != 0\n                if stk[end] == '('\n                    pop!(stk)\n  \
    \                  break\n                else\n                    pop!(stk)\n\
    \                end\n            end\n        end\n    end\n    \"\"\" Now that\
    \ we have our stack, we can check if the string is valid \"\"\"\n    if length(stk)\
    \ == 0\n        \"\"\" If it is, we loop over our string again and push on a string\
    \ to \n        a vector each time we have a '(' and pop it off each time we have\
    \ a ')'\"\"\"\n        for i = 1:length(paren_string)\n            if paren_string[i]\
    \ == '('\n                push!(vec, string(paren_string[i]))\n            elseif\
    \ paren_string[i] == ')'\n                if length(vec) != 0\n              \
    \      vec[end] = vec[end] * string(paren_string[i])\n                end\n  \
    \          end\n        end\n        for i = 1:length(vec)\n            \"\"\"\
    \ We then remove the first and last character of each string in our vector \"\"\
    \"\n            vec[i] = vec[i][2:end-1]\n        end\n        return vec\n  \
    \  else\n        return \"There is an error in your parenthesis.\"\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6d608mh3.jl:57\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"\", \"\", \")\", \"\", \"\", \"))\", \"\", \"\", \"\", \"\
    )\", \"\", \")\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6d608mh3.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6d608mh3.jl:56\ntest set: Test\
    \ Failed at /tmp/tmp6d608mh3.jl:58\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"\", \"\",\
    \ \")\", \"\", \"\", \"))\", \"\", \"\", \"\", \")))\"] == [\"()\", \"(())\",\
    \ \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6d608mh3.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6d608mh3.jl:56\ntest set: Test\
    \ Failed at /tmp/tmp6d608mh3.jl:59\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"\", \"\", \"\", \")\", \"\", \"\"\
    , \")))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6d608mh3.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6d608mh3.jl:56\ntest set: Test\
    \ Failed at /tmp/tmp6d608mh3.jl:60\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"\", \"\", \")\", \"\
    \", \"\", \")\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6d608"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6d608mh3.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    paren_string = replace(paren_string, \" \" => \"\")\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbhzisl_x.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbhzisl_x.jl:1\n\
    in expression starting at /tmp/tmpbhzisl_x.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    result = String[]\n    # TODO: write your code here!\n    s = filter(x\
    \ -> !isspace(x), paren_string)\n    open_num = 0\n    for i in 1:length(s)\n\
    \        if s[i] == '('\n            open_num += 1\n        elseif s[i] == ')'\n\
    \            open_num -= 1\n        end\n    end\n    if open_num == 0\n     \
    \   j = 1\n        open_num = 0\n        for i in 1:length(s)\n            if\
    \ s[i] == '('\n                if open_num == 0\n                    j = i\n \
    \               end\n                open_num += 1\n            elseif s[i] ==\
    \ ')'\n                open_num -= 1\n                if open_num == 0\n     \
    \               push!(result, s[j:i])\n                end\n            end\n\
    \        end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = strip(paren_string)\n    if paren_string[1] != '(' || paren_string[end]\
    \ != ')'\n        return []\n    end\n    if length(paren_string) == 2\n     \
    \   return [paren_string]\n    end\n    # Helper function\n    # find next closing\
    \ bracket\n    function find_next_closing_bracket(i::Int)::Int\n        open_count\
    \ = 0\n        for j in i:length(paren_string)\n            if paren_string[j]\
    \ == '('\n                open_count += 1\n            elseif paren_string[j]\
    \ == ')'\n                open_count -= 1\n            end\n            if open_count\
    \ == 0\n                return j\n            end\n        end\n        return\
    \ -1\n    end\n    # Split recursively by first opening\n    split_point = find_next_closing_bracket(2)\n\
    \    substring = paren_string[2:split_point-1]\n    if substring[1] == '('\n \
    \       all_substrings = separate_paren_groups(substring)\n    else\n        all_substrings\
    \ = [substring]\n    end\n    # Now, recurse on the rest\n    all_substrings =\
    \ append!(all_substrings, separate_paren_groups(paren_string[split_point+1:end-1]))\n\
    \    return all_substrings\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpxcqhlv2i.jl:49\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ separate_paren_groups(::SubString{String})\\n  Closest candidates are:\\n  \
    \  separate_paren_groups(!Matched::String) at /tmp/tmpxcqhlv2i.jl:8\\n  Stacktrace:\\\
    n   [1] separate_paren_groups(paren_string::String)\\n     @ Main /tmp/tmpxcqhlv2i.jl:36\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpxcqhlv2i.jl:49 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpxcqhlv2i.jl:48\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_paren = \"(\"\n    close_paren = \")\"\n    group_string = \"\"\n\
    \    paren_groups = []\n    in_group = false\n    for i in 1:length(paren_string)\n\
    \        if paren_string[i] == open_paren\n            if in_group == false\n\
    \                in_group = true\n            end\n            group_string =\
    \ group_string * paren_string[i]\n        elseif paren_string[i] == close_paren\n\
    \            group_string = group_string * paren_string[i]\n            if in_group\
    \ == true\n                in_group = false\n                push!(paren_groups,\
    \ group_string)\n                group_string = \"\"\n            end\n      \
    \  end\n    end\n    return paren_groups\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpywojaase.jl:36\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpywojaase.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpywojaase.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpywojaase.jl:37\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpywojaase.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpywojaase.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpywojaase.jl:38\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpywojaase.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpywojaase.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpywojaase.jl:39\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpywojaase.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpywojaase.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    open_braces = 0\n    close_braces = 0\n    paren_list = []\n   \
    \ temp_string = \"\"\n    \n    for paren in paren_string\n        if paren ==\
    \ '('\n            open_braces += 1\n        elseif paren == ')'\n           \
    \ close_braces += 1\n        end\n        \n        if open_braces > 0 && open_braces\
    \ == close_braces\n            push!(paren_list, temp_string)\n            temp_string\
    \ = \"\"\n            open_braces = 0\n            close_braces = 0\n        else\n\
    \            temp_string = temp_string * paren\n        end\n    end\n    \n \
    \   return paren_list\nend\nseparate_paren_groups('( ) (( )) (( )( ))')\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpdfqeqfjs.jl:34\nin expression\
    \ starting at /tmp/tmpdfqeqfjs.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return [\"()\", \"(())\", \"(()())\"]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbbecf9mr.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"()\", \"(())\", \"(()())\"] == [\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbbecf9mr.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbbecf9mr.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpbbecf9mr.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(())\"\
    , \"(()())\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbbecf9mr.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbbecf9mr.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpbbecf9mr.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"()\", \"(())\", \"(()())\"] == [\"\
    (()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbbecf9mr.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbbecf9mr.jl:16\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbbecf9mr.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    parenthesis = [\"(\", \")\"]\n    open_counter = 0\n    group_storage\
    \ = []\n    group_string = \"\"\n    for i in paren_string\n        if i in parenthesis[1]\n\
    \            if open_counter > 0\n                group_string *= i\n        \
    \        open_counter -= 1\n            else\n                push!(group_storage,\
    \ group_string)\n                group_string = \"\"\n            end\n      \
    \  elseif i in parenthesis[2]\n            group_string *= i\n            open_counter\
    \ += 1\n        end\n    end\n    return group_storage\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpf_irmegf.jl:34\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"\", \"\", \")())((\"] == [\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf_irmegf.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf_irmegf.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpf_irmegf.jl:35\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"\", \")(\"\
    , \"))((\", \")))(((\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf_irmegf.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf_irmegf.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpf_irmegf.jl:36\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"\", \"\", \")(\", \"))((\"] == [\"\
    (()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf_irmegf.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf_irmegf.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpf_irmegf.jl:37\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"\", \")(\"] == [\"\
    ()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf_irmegf.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf_irmegf.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # find each opening paren\n    # check until you find a closing paren\n\
    \    # make a string with those parens\n    # remove it from the string\n    #\
    \ repeat\n    \n    function find_closing_paren(paren_string::String, index::Int)::Int\n\
    \        counter = 0\n        for i in index:length(paren_string)\n          \
    \  if paren_string[i] == '('\n                counter += 1\n            elseif\
    \ paren_string[i] == ')'\n                counter -= 1\n            end\n    \
    \        if counter == 0\n                return i\n            end\n        end\n\
    \    end\n    \n    strings = []\n    current_index = 0\n    for i in 1:length(paren_string)\n\
    \        if paren_string[i] == '('\n            # find the closing paren\n   \
    \         closing_paren = find_closing_paren(paren_string, i)\n            # take\
    \ the string between them and add it to strings\n            push!(strings, paren_string[i:closing_paren])\n\
    \            # set the current index after the paren we just closed\n        \
    \    current_index = closing_paren + 1\n        end\n    end\n    return strings\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfkjmnf2h.jl:48\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \"()\", \"()\", \"((()))\", \"(())\", \"()\", \"\
    ()\", \"((())()())\", \"(())\", \"()\", \"()\", \"()\"] == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfkjmnf2h.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfkjmnf2h.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpfkjmnf2h.jl:49\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(())\"\
    , \"()\", \"((()))\", \"(())\", \"()\", \"(((())))\", \"((()))\", \"(())\", \"\
    ()\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfkjmnf2h.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfkjmnf2h.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpfkjmnf2h.jl:50\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()(())((())))\", \"()\", \"(())\"\
    , \"()\", \"((()))\", \"(())\", \"()\"] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfkjmnf2h.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfkjmnf2h.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpfkjmnf2h.jl:51\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \"(( ))\",\
    \ \"( )\", \"(( )( ))\", \"( )\", \"( )\"] == [\"()\", \"(())\", \"(()())\"]\n\
    Stacktrace:\n [1] macro expansion\n "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfkjmnf2h.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    output = Vector{String}()\n\
    \    l = length(paren_string)\n    open_count = 0\n    close_count = 0\n    start\
    \ = 1\n    end = 0\n    for i = 1:l\n        if paren_string[i] == '('\n     \
    \       open_count += 1\n        elseif paren_string[i] == ')'\n            close_count\
    \ += 1\n        end\n        if open_count == close_count && close_count != 0\n\
    \            end = i\n            push!(output, paren_string[start:end])\n   \
    \         open_count = 0\n            close_count = 0\n            start = i +\
    \ 1\n        end\n    end\n    return output\nend\n \nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid assignment location \"function separate_paren_groups(paren_string::String)::Vector{String}\n\
    \    # /tmp/tmpm0gmaybv.jl, line 8\n    # /tmp/tmpm0gmaybv.jl, line 9\n    paren_string\
    \ = replace(paren_string, (\" \" => \"\"))\n    # /tmp/tmpm0gmaybv.jl, line 10\n\
    \    output = Vector{String}()\n    # /tmp/tmpm0gmaybv.jl, line 11\n    l = length(paren_string)\n\
    \    # /tmp/tmpm0gmaybv.jl, line 12\n    open_count = 0\n    # /tmp/tmpm0gmaybv.jl,\
    \ line 13\n    close_count = 0\n    # /tmp/tmpm0gmaybv.jl, line 14\n    start\
    \ = 1\nend\" around /tmp/tmpm0gmaybv.jl:1\nStacktrace:\n [1] top-level scope\n\
    \   @ /tmp/tmpm0gmaybv.jl:1\nin expression starting at /tmp/tmpm0gmaybv.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    state = 0 # 1 - balanced, 2 - not balanced\n    open_braces = 0\n    close_braces\
    \ = 0\n    paren_group = \"\"\n    groups = Vector{String}()\n    for i in paren_string\n\
    \        if i == '('\n            open_braces += 1\n            state = 1\n  \
    \      elseif i == ')'\n            close_braces += 1\n            state = 1\n\
    \        elseif i == ' ' && state == 1\n            push!(groups, paren_group)\n\
    \            paren_group = \"\"\n            state = 0\n        elseif i == '\
    \ ' && state == 0\n            next\n        else\n            return \"invalid\
    \ string\"\n        end\n        if open_braces > close_braces\n            paren_group\
    \ *= i\n        elseif open_braces == close_braces\n            paren_group *=\
    \ i\n            push!(groups, paren_group)\n            paren_group = \"\"\n\
    \            open_braces = 0\n            close_braces = 0\n        else\n   \
    \         return \"invalid string\"\n        end\n    end\n    return groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwzaj37kn.jl:49\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \"\", \" \", \"((()))\", \"\", \" \", \"()\", \"\
    \", \" \", \"((())()())\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwzaj37kn.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwzaj37kn.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpwzaj37kn.jl:50\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"\"\
    , \" \", \"(())\", \"\", \" \", \"((()))\", \"\", \" \", \"(((())))\"] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwzaj37kn.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwzaj37kn.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpwzaj37kn.jl:52\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"(\", \" )\", \"\"\
    , \" \", \"((\", \" ))\", \"\", \" \", \"((\", \" )(\", \" ))\"] == [\"()\", \"\
    (())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwzaj37kn.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwzaj37kn.jl:48\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwzaj37kn.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n\n# I am not sure how to approach this. Here is my first attempt.\nfor x in\
    \ paren_string\n    if x == \"(\"\n        count += 1\n    elseif x == \")\"\n\
    \        count -= 1\n    end\nend\ncount\n        \n    return separated_groups\n\
    end\nseparate_paren_groups(\"() (( )) (( )( ))\")\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: separated_groups not defined\nStacktrace:\n\
    \ [1] separate_paren_groups(paren_string::String)\n   @ Main /tmp/tmpdj8ar4zj.jl:20\n\
    \ [2] top-level scope\n   @ /tmp/tmpdj8ar4zj.jl:22\nin expression starting at\
    \ /tmp/tmpdj8ar4zj.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # clean up paren_string\n    paren_string = replace(paren_string, \" \"\
    \ => \"\")\n    isopen(c::Char) = c == '('\n    isclose(c::Char) = c == ')'\n\
    \    # separate groups\n    groups = []\n    start = 1\n    balance = 0\n    for\
    \ (i, c) in enumerate(paren_string)\n        if isopen(c)\n            balance\
    \ += 1\n        elseif isclose(c)\n            balance -= 1\n        end\n   \
    \     if balance == 0\n            push!(groups, paren_string[start:i])\n    \
    \        start = i + 1\n        end\n    end\n    return groups\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_groups = []\n    group = \"\"\n    paren_count = 0\n    for c in\
    \ paren_string\n        if c == ' '\n            continue\n        end\n     \
    \   if c == '('\n            paren_count += 1\n        elseif c == ')'\n     \
    \       paren_count -= 1\n        end\n        group = group * c\n        if paren_count\
    \ == 0\n            push!(paren_groups, group)\n            group = \"\"\n   \
    \     end\n    end\n    return paren_groups\nend\nseparate_paren_groups('( ) ((\
    \ )) (( )( ))')\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpq10j72v3.jl:29\nin expression\
    \ starting at /tmp/tmpq10j72v3.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    group_counter = 1\n    paren_group_start = 1\n    paren_groups = []\n\
    \    for i in eachindex(paren_string)\n        if paren_string[i] == '('\n   \
    \         group_counter += 1\n        elseif paren_string[i] == ')'\n        \
    \    group_counter -= 1\n        end\n        if group_counter == 0\n        \
    \    push!(paren_groups, paren_string[paren_group_start:i])\n            paren_group_start\
    \ = i + 1\n            group_counter = 1\n        end\n    end\n    return paren_groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgxk5kn4d.jl:31\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgxk5kn4d.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgxk5kn4d.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpgxk5kn4d.jl:32\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgxk5kn4d.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgxk5kn4d.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpgxk5kn4d.jl:33\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgxk5kn4d.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgxk5kn4d.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpgxk5kn4d.jl:34\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgxk5kn4d.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgxk5kn4d.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    string = remove(paren_string, \" \")\n    open_parens = findall(string,\
    \ \"(\")\n    close_parens = findall(string, \")\")\n    paren_groups = []\n \
    \   i = 1\n    j = 1\n    while i <= length(open_parens)\n        start = open_parens[i]\n\
    \        while j <= length(close_parens)\n            finish = close_parens[j]\n\
    \            if finish > start\n                paren_groups = append!(paren_groups,\
    \ string[start:finish])\n                i += 1\n                j += 1\n    \
    \            break\n            end\n            j += 1\n        end\n    end\n\
    \    return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpgjwiw_i6.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  UndefVarError: remove not defined\\\
    n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\n     @ Main\
    \ /tmp/tmpgjwiw_i6.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpgjwiw_i6.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpgjwiw_i6.jl:34\\ntest set:\
    \ Error During Test at /tmp/tmpgjwiw_i6.jl:36\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  UndefVarError: remove not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpgjwiw_i6.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpgjwiw_i6.jl:36 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpgjwiw_i6.jl:34\\ntest set:\
    \ Error During Test at /tmp/tmpgjwiw_i6.jl:37\\n  Test threw exception\\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n  UndefVarError: remove\
    \ not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpgjwiw_i6.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpgjwiw_i6.jl:37 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpgjwiw_i6.jl:34\\ntest set:\
    \ Error During Test at /tmp/tmpgjwiw_i6.jl:38\\n  Test threw exception\\n  E"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    n = length(paren_string)\n    open_count = 0\n    close_count = 0\n  \
    \  paren_groups = []\n    for i = 1:n\n        if paren_string[i] == '('\n   \
    \         push!(paren_groups, i)\n            open_count += 1\n        elseif\
    \ paren_string[i] == ')'\n            close_count += 1\n            if open_count\
    \ == close_count\n                push!(paren_groups, i)\n                open_count\
    \ = 0\n                close_count = 0\n            end\n        end\n    end\n\
    \    array = Vector{String}(length(paren_groups)\xF72)\n    for i = 1:length(paren_groups)\xF7\
    2\n        array[i] = paren_string[paren_groups[2i-1]:paren_groups[2i]]\n    end\n\
    \    return array\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpjlkpmftl.jl:37\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ Vector{String}(::Int64)\\n  Closest candidates are:\\n    Vector{T}() where\
    \ T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\\\
    n    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpjlkpmftl.jl:26\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpjlkpmftl.jl:37 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpjlkpmftl.jl:36\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    start_pos = 1 # where to start looking for new groups\n    paren_group_list\
    \ = [] # initialize empty list to contain groups\n    while true # will break\
    \ out of loop at end of file\n        # look for first open parenthesis\n    \
    \    pos = findfirst(x -> x == '(', paren_string[start_pos:end])\n        # if\
    \ no parenthesis found, break out of loop\n        if isnothing(pos)\n       \
    \     break\n        end\n        # once an open parenthesis is found, define\
    \ the beginning of the group\n        paren_begin = start_pos + pos[1]\n     \
    \   # need to find the last matching parenthesis and save it in a variable called\
    \ paren_end\n        # I suggest a simple loop that adds one and decrements a\
    \ counter until the counter = 0\n        # Once you've done that, add the substring\
    \ of the paren_string to the paren_group_list\n        # and reset the start_pos\
    \ to the next position after the end of the group\n        # (don't forget to\
    \ account for spaces!)\n        # Don't forget to break if no parenthesis are\
    \ found!\n    end\n    return paren_group_list\nend\n \noutput = separate_paren_groups('(\
    \ ) (( )) (( )( ))')\n \n# this should print [\"()\", \"(())\", \"(()())\"]\n\
    println(output)\n \n# check to see if the length of output matches the expected\
    \ answer\nprintln(length(output) == 3)\n \n# check to see if the type of output\
    \ matches the expected answer\nprintln(typeof(output) == Vector{String})\n \n\
    \ \n \n \n \n################################################################################################\n\
    #                                            PROBLEM 3                       \
    \                  #\n################################################################################################\n\
    \ \n\"\"\" Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    separate those group into separate strings\
    \ and return the list of those.\n    Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n    Ignore any spaces\
    \ in the input string.\n    >>> separate_paren_groups('(((()))))()()')\n    ['(((())))',\
    \ '()', '()']\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpmy9613wm.jl:30\nin expression\
    \ starting at /tmp/tmpmy9613wm.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # create a vector that you append your group strings to\n    group_strings\
    \ = Vector{String}()\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpi5vwvx40.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpi5vwvx40.jl:1\n\
    in expression starting at /tmp/tmpi5vwvx40.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    #\n    # paren_string = filter(x -> !isspace(x), paren_string)\n    #\
    \ n = length(paren_string)\n    # current_group = []\n    # groups = []\n    #\
    \ for i in 1:n\n    #     if paren_string[i] == '('\n    #         push!(current_group,\
    \ '(')\n    #     elseif paren_string[i] == ')'\n    #         if current_group[end]\
    \ == '('\n    #             pop!(current_group)\n    #             if length(current_group)\
    \ == 0\n    #                 push!(groups, join(paren_string[prev_open+1:i]))\n\
    \    #                 prev_open = i\n    #             end\n    #         else\n\
    \    #             # TODO: This is where we error\n    #         end\n    #  \
    \   end\n    # end\n    # return groups\n    #\n    # Initialize a vector to store\
    \ our nested parentheses\n    paren_string = filter(x -> !isspace(x), paren_string)\n\
    \    paren_vector = []\n    for p in paren_string\n        push!(paren_vector,\
    \ p)\n    end\n    n = length(paren_vector)\n    # Now we will iterate through\
    \ the vector, finding each group and deleting it, appending\n    # the group to\
    \ our output vector\n    output = []\n    while true\n        # We need to check\
    \ if there are any parentheses remaining, and if not, break.\n        if isempty(paren_vector)\n\
    \            break\n        end\n        # Now we will look for the next opening\
    \ parenthesis\n        open_paren = findall(x -> x == '(', paren_vector)\n   \
    \     if isempty(open_paren)\n            break\n        end\n        # Now we\
    \ will take the first element and treat it as our 'left parenthesis'.\n      \
    \  # If a right parenthesis is found before a left parenthesis, we have a problem\n\
    \        # because our string is unbalanced. \n        paren_stack = []\n    \
    \    i = 1\n        while true\n            if paren_vector[i] == '('\n      \
    \          push!(paren_stack, '('\nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp6k5jk2li.jl:59\nin expression starting at\
    \ /tmp/tmp6k5jk2li.jl:59\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    counter = 0\n    result = Vector{String}()\n    temp = \"\"\n    for c\
    \ in paren_string\n        if c != ' '\n            temp *= c\n            if\
    \ c == '('\n                counter += 1\n            elseif c == ')'\n      \
    \          counter -= 1\n            end\n        end\n        if counter == 0\n\
    \            if length(temp) > 0\n                push!(result, temp)\n      \
    \          temp = \"\"\n            end\n        end\n    end\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    return [paren_string[i:j] for i in 1:length(paren_string), j in 1:length(paren_string)\
    \ if paren_string[i] == \"(\" && paren_string[j] == \")\" && isbalanced(paren_string[i:j])]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5ykx7jmx.jl:16\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5ykx7jmx.jl:16 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5ykx7jmx.jl:15\ntest set: Test\
    \ Failed at /tmp/tmp5ykx7jmx.jl:17\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5ykx7jmx.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5ykx7jmx.jl:15\ntest set: Test\
    \ Failed at /tmp/tmp5ykx7jmx.jl:18\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5ykx7jmx.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5ykx7jmx.jl:15\ntest set: Test\
    \ Failed at /tmp/tmp5ykx7jmx.jl:19\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5ykx7jmx.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5ykx7jmx.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_paren = '( '\n    close_paren = ' )'\n    paren_string = replace(paren_string,\
    \ open_paren, '(')\n    paren_string = replace(paren_string, close_paren, ')')\n\
    \    paren_string = replace(paren_string, \" \", \"\")\n    n = length(paren_string)\n\
    \    groups = []\n    brace_count = 0\n    for i in eachindex(paren_string)\n\
    \        if paren_string[i] == '('\n            brace_count += 1\n        elseif\
    \ paren_string[i] == ')'\n            brace_count -= 1\n        end\n        if\
    \ brace_count == 0 && i != n\n            push!(groups, paren_string[1:i])\n \
    \           paren_string = paren_string[i+1:end]\n            n = length(paren_string)\n\
    \            i = 0\n        end\n    end\n    push!(groups, paren_string)\n  \
    \  return groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpgh19nz1q.jl:9\nin expression starting\
    \ at /tmp/tmpgh19nz1q.jl:9\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_stack = Deque{String}()\n    open_paren = 0\n    close_paren = 0\n\
    \    current_subgroup = \"\"\n    subgroups = []\n    for (i, c) in enumerate(paren_string)\n\
    \        if(c == '(')\n            push!(paren_stack, c)\n            open_paren\
    \ += 1\n        elseif(c == ')')\n            pop!(paren_stack)\n            close_paren\
    \ += 1\n        end\n        if(open_paren == close_paren)\n            push!(subgroups,\
    \ current_subgroup)\n            current_subgroup = \"\"\n            open_paren\
    \ = 0\n            close_paren = 0\n        else\n            current_subgroup\
    \ = current_subgroup * c\n        end\n    end\n    return subgroups\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpthto3wx4.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  UndefVarError: Deque not defined\\\
    n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\n     @ Main\
    \ /tmp/tmpthto3wx4.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpthto3wx4.jl:38 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpthto3wx4.jl:37\\ntest set:\
    \ Error During Test at /tmp/tmpthto3wx4.jl:39\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  UndefVarError: Deque not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpthto3wx4.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpthto3wx4.jl:39 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpthto3wx4.jl:37\\ntest set:\
    \ Error During Test at /tmp/tmpthto3wx4.jl:40\\n  Test threw exception\\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n  UndefVarError: Deque\
    \ not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpthto3wx4.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpthto3wx4.jl:40 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpthto3wx4.jl:37\\ntest set:\
    \ Error During Test at /tmp/tmpthto3wx4.jl:41\\n  Test threw exception\\n  Expr"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \"\"\"\n    This initializes the output vector\n    \"\"\"\n    output\
    \ = Vector{String}(0)\n    i=1\n    \"\"\"\n    this loops through the string\
    \ and checks the first character of each group.\n    it must be an open brace.\n\
    \    if it is, it pushes the contents into the output vector and then starts over\n\
    \    incrementing the start index by 1.\n    \"\"\"\n    while i<=length(paren_string)\n\
    \        if paren_string[i] == '('\n            if length(paren_string)>i\n  \
    \              end_idx = find_paren_pair(paren_string, i)\n                push!(output,\
    \ paren_string[i:end_idx])\n                i = end_idx+1\n            else\n\
    \                push!(output, paren_string[i])\n                i+=1\n      \
    \      end\n        else\n            i+=1\n        end\n    end\n    return output\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpyjwdwsm6.jl:41\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ Vector{String}(::Int64)\\n  Closest candidates are:\\n    Vector{T}() where\
    \ T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\\\
    n    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpyjwdwsm6.jl:12\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpyjwdwsm6.jl:41 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpyjwdwsm6.jl:40\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    if length(paren_string) == 0\n        return []\n    end\n    res = []\n\
    \    start = 1\n    last_open = 1\n    n = length(paren_string)\n    for i in\
    \ 2:n\n        if paren_string[i] == '('\n            last_open = i\n        elseif\
    \ paren_string[i] == ')'\n            if paren_string[last_open] == '('\n    \
    \            if last_open == start\n                    if i == n || (i != n &&\
    \ paren_string[i+1] != '(')\n                        push!(res, paren_string[start:i])\n\
    \                        start = i+1\n                    end\n              \
    \  else\n                    push!(res, paren_string[start:i])\n             \
    \       start = i+1\n                end\n            end\n        end\n    end\n\
    \    return res\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp51y5f8j7.jl:40\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"()\", \")\", \" ((()\", \")\", \")\", \" ()\", \"\
    \ ((()\", \")\", \"()()\", \")\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp51y5f8j7.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp51y5f8j7.jl:39\ntest set: Test\
    \ Failed at /tmp/tmp51y5f8j7.jl:41\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \" (()\"\
    , \")\", \" ((()\", \")\", \")\", \" (((()\", \")\", \")\", \")\"] == [\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp51y5f8j7.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp51y5f8j7.jl:39\ntest set: Test\
    \ Failed at /tmp/tmp51y5f8j7.jl:42\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"(()\", \")\", \"((()\", \"\
    )\", \")\", \")\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp51y5f8j7.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp51y5f8j7.jl:39\ntest set: Test\
    \ Failed at /tmp/tmp51y5f8j7.jl:43\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \" (( )\",\
    \ \")\", \" (( )\", \"( )\", \")\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp51y5f8j7.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    paren_string = replace(paren_string, r\"\\s+\"=>\"\")\n    if count(paren_string,\
    \ '(') != count(paren_string, ')')\n        error(\"Unbalanced\")\n    end\n \
    \   \n    open_positions = findall(paren_string, '\\(')\n    close_positions =\
    \ findall(paren_string, '\\)')\n    \n    paren_groups = []\n    open_remaining\
    \ = []\n    for i in 1:length(open_positions)\n        if i == 1\n           \
    \ push!(open_remaining, open_positions[i])\n        else\n            for j in\
    \ 1:length(open_remaining)\n                if open_positions[i] < open_remaining[j]\n\
    \                    push!(open_remaining, open_positions[i])\n              \
    \      break\n                end\n            end\n        end\n    end\n   \
    \ \n    for i in 1:length(close_positions)\n        push!(paren_groups, paren_string[open_remaining[i]:close_positions[i]])\n\
    \    end\n    \n    return paren_groups\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid escape sequence\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpey9oo9ed.jl:15\nin expression starting at /tmp/tmpey9oo9ed.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # construct a vector to store each group\n    groups = Vector{String}()\n\
    \    # keep track of where each group starts and ends\n    start = 0\n    end\
    \ = 0\n    # counter to keep track of the number of parentheses\n    # we need\
    \ to keep track of where each group starts, so we can slice the string\n    counter\
    \ = 0\n    # loop through every character\n    for i in 1:length(paren_string)\n\
    \        if paren_string[i] == '('\n            # if the counter is 0, it means\
    \ we are looking at the start of a new group\n            if counter == 0\n  \
    \              start = i\n            end\n            # increment the counter\n\
    \            counter += 1\n        elseif paren_string[i] == ')'\n           \
    \ # decrement the counter\n            counter -= 1\n            # if the counter\
    \ is 0, it means we are looking at the end of a group\n            if counter\
    \ == 0\n                end = i\n                # slice the string and store\
    \ the group\n                push!(groups, paren_string[start:end])\n        \
    \    end\n        end\n    end\n    return groups\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid assignment location \"function separate_paren_groups(paren_string::String)::Vector{String}\n\
    \    # /tmp/tmpv_w0_mhg.jl, line 8\n    # /tmp/tmpv_w0_mhg.jl, line 10\n    groups\
    \ = Vector{String}()\n    # /tmp/tmpv_w0_mhg.jl, line 12\n    start = 0\nend\"\
    \ around /tmp/tmpv_w0_mhg.jl:1\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpv_w0_mhg.jl:1\n\
    in expression starting at /tmp/tmpv_w0_mhg.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # this is the vector that is going to contain the strings of each group\n\
    \    groups = Vector{String}()\n    # this is the number of '(' that we have to\
    \ match with the number of ')'\n    opened = 0\n    # this is the string that\
    \ will represent the current group that we are considering\n    current_group\
    \ = \"\"\n    # iterate through the string\n    for i = 1:length(paren_string)\n\
    \        # if we have a '(' we increment the opened counter\n        if paren_string[i]\
    \ == '('\n            opened += 1\n        # if we have a ')' and opened is not\
    \ 0 we decrement the opened counter and if opened is 0\n        # we reset it\
    \ to 0\n        elseif paren_string[i] == ')'\n            if opened != 0\n  \
    \              opened -= 1\n            else\n                opened = 0\n   \
    \         end\n        end\n        # everytime we find a '(' or a ')' we add\
    \ it to the current group\n        current_group *= paren_string[i]\n        #\
    \ if opened is 0 it means that we have just finished the current group so we add\
    \ it to the list\n        # of groups and reset the current group\n        if\
    \ opened == 0\n            push!(groups, current_group)\n            current_group\
    \ = \"\"\n        end\n    end\n    return groups\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsip_kkoh.jl:45\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsip_kkoh.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsip_kkoh.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpsip_kkoh.jl:46\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \" \"\
    , \"(())\", \" \", \"((()))\", \" \", \"(((())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsip_kkoh.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsip_kkoh.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpsip_kkoh.jl:48\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \" \", \"((\
    \ ))\", \" \", \"(( )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsip_kkoh.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsip_kkoh.jl:44\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsip_kkoh.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_count = 0\n    found_parens = Vector{Bool}()\n    paren_groups =\
    \ []\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmphq4hrsu_.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmphq4hrsu_.jl:1\n\
    in expression starting at /tmp/tmphq4hrsu_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpzc4r_h6e.jl:16\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\") # remove all spaces\n\
    \    left_paren = findfirst(x -> x == '(' , paren_string)\n    right_paren = findfirst(x\
    \ -> x == ')' , paren_string)\n    current_paren = paren_string[left_paren:right_paren]\n\
    \    current_paren_list = []\n    paren_list = []\n    while(left_paren != 0)\n\
    \        if(current_paren == \"\")\n            push!(paren_list, join(current_paren_list))\n\
    \            current_paren_list = []\n            paren_string = paren_string[right_paren+1:end]\n\
    \            left_paren = findfirst(x -> x == '(' , paren_string)\n          \
    \  right_paren = findfirst(x -> x == ')' , paren_string)\n            current_paren\
    \ = paren_string[left_paren:right_paren]\n        else\n            push!(current_paren_list,\
    \ current_paren)\n            paren_string = paren_string[right_paren+1:end]\n\
    \            left_paren = findfirst(x -> x == '(' , paren_string)\n          \
    \  right_paren = findfirst(x -> x == ')' , paren_string)\n            current_paren\
    \ = paren_string[left_paren:right_paren]\n        end\n    end\n    push!(paren_list,\
    \ join(current_paren_list))\n    return paren_list\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpiog3q6ij.jl:39\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ (::Colon)(::Nothing, ::Int64)\\n  Closest candidates are:\\n    (::Colon)(::T,\
    \ ::Any, !Matched::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:40\\\
    n    (::Colon)(!Matched::T, ::Real, !Matched::T) where T<:AbstractFloat at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:18\\\
    n    (::Colon)(!Matched::T, ::T) where T<:Real at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:5\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpiog3q6ij.jl:28\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpiog3q6ij.jl:39 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpiog3q6ij.jl:38\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    group_separate = \"(\" #left parenthesis\n    group_separate1 = \")\"\
    \ #right parenthesis\n    s = Vector{String}()\n    temp = \"\"\n    paren_groups\
    \ = split(paren_string, \" \")\n    for i in 1:length(paren_groups)\n        if\
    \ contains(paren_groups[i], group_separate) && contains(paren_groups[i], group_separate1)\n\
    \            push!(s, paren_groups[i])\n        end\n    end\n    return s\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpim9z2f4v.jl:29\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\")(\"\
    ] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpim9z2f4v.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpim9z2f4v.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     1      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpim9z2f4v.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    output = Vector{String}()\n    start_idx = findnext(x -> x == '(', paren_string,\
    \ 1)\n    for i in start_idx:\n        close_idx = findclose(paren_string, i)\n\
    \        push!(output, paren_string[i:close_idx])\n    end\n    return output\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmppnrv3e7h.jl:12\nin expression starting at\
    \ /tmp/tmppnrv3e7h.jl:12\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    #write your code here\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpja2gj848.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{String}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpja2gj848.jl:10\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpja2gj848.jl:16 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpja2gj848.jl:15\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n \nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t\
    @test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3fluo0mv.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp3fluo0mv.jl:1\n\
    in expression starting at /tmp/tmp3fluo0mv.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_parens = findall(x -> x == \"(\", paren_string)\n    closed_parens\
    \ = findall(x -> x == \")\", paren_string)\n    depth = 0\n    groups = []\n \
    \   current_group = \"\"\n    count = 0\n    for char in paren_string\n      \
    \  if char == \"(\"\n            depth += 1\n        elseif char == \")\"\n  \
    \          depth -= 1\n        end\n        if depth > 0\n            current_group\
    \ *= char\n        elseif depth == 0\n            push!(groups, current_group)\n\
    \            current_group = \"\"\n        end\n    end\n    return groups\nend\n\
    \ \n \nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t\
    @test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnndxodv2.jl:37\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" \
    \ \u2026  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"] == [\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnndxodv2.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnndxodv2.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpnndxodv2.jl:38\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"\", \"\",\
    \ \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"  \u2026  \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnndxodv2.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnndxodv2.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpnndxodv2.jl:39\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"\", \"\", \"\", \"\", \"\", \"\",\
    \ \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnndxodv2.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnndxodv2.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpnndxodv2.jl:40\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnndxodv2.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_count = 0\n    current_group = \"\"\n    groups = []\n    for char\
    \ in paren_string\n        if char == '('\n            open_count += 1\n     \
    \   elseif char == ')'\n            open_count -= 1\n        end\n        if open_count\
    \ == 0\n            push!(groups, current_group)\n            current_group =\
    \ \"\"\n        else\n            current_group *= char\n        end\n    end\n\
    \    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpv6nqyjdo.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv6nqyjdo.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv6nqyjdo.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpv6nqyjdo.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"(\", \"\"\
    , \"(()\", \"\", \"((())\", \"\", \"(((()))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv6nqyjdo.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv6nqyjdo.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpv6nqyjdo.jl:34\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()(())((()))\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv6nqyjdo.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv6nqyjdo.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpv6nqyjdo.jl:35\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( \", \"\", \"(( )\"\
    , \"\", \"(( )( )\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv6nqyjdo.jl:35 [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv6nqyjdo.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # initialize variables\n    count = 0\n    tmp_str = \"\"\n    open_paren\
    \ = \"(\"\n    closed_paren = \")\"\n    output = []\n    \n    # loop through\
    \ input string, counting opened and closed parentheses\n    for i in 1:length(paren_string)\n\
    \        if paren_string[i] == open_paren\n            count += 1\n        elseif\
    \ paren_string[i] == closed_paren\n            count -= 1\n        end\n     \
    \   \n        # if count has reached 0, this means a group has been detected\n\
    \        if count == 0\n            push!(output, tmp_str)\n            tmp_str\
    \ = \"\"\n        else\n            tmp_str = string(tmp_str, paren_string[i])\n\
    \        end\n    end\n    \n    # return the list of detected groups\n    return\
    \ output\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprnb8iqz7.jl:41\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" \
    \ \u2026  \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"] == [\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprnb8iqz7.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprnb8iqz7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmprnb8iqz7.jl:42\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"\", \"\",\
    \ \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"  \u2026  \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprnb8iqz7.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprnb8iqz7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmprnb8iqz7.jl:43\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"\", \"\", \"\", \"\", \"\", \"\",\
    \ \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprnb8iqz7.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprnb8iqz7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmprnb8iqz7.jl:44\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprnb8iqz7.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, r\"\\s\", \"\")\n    groups = []\n\
    \    group = \"\"\n    balance = 0\n    for c in paren_string\n        if c ==\
    \ '('\n            balance += 1\n        elseif c == ')'\n            balance\
    \ -= 1\n        end\n        group *= c\n        if balance == 0\n           \
    \ push!(groups, group)\n            group = \"\"\n        end\n    end\n    return\
    \ groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpwu6xz3v2.jl:32\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ replace(::String, ::Regex, ::String)\\n  Closest candidates are:\\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\\\
    n    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\\\
    n    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpwu6xz3v2.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpwu6xz3v2.jl:32 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpwu6xz3v2.jl:31\\ntest set:\
    \ Error During Test at /tmp/tmpwu6xz3v2.jl:33\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  MethodError: no method matching replace(::String, ::Regex, ::String)\\\
    n  Closest candidates are:\\n    replace(!Matched::Union{Function, Type}, ::Any;\
    \ count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\\n    replace(::String,\
    \ !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\\\
    n    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpwu6xz3v2.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpwu6xz3v2.jl:33 [inlined]\\\
    n   [4] "
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Create a Vector of all the characters in the string\n    paren_characters\
    \ = collect(string(paren_string))\n    # Create an empty Vector to store the separate\
    \ paren groups\n    paren_groups = Vector{String}()\n    # Initialize a counter\
    \ to 0\n    paren_counter = 0\n    # Create an empty string to store a single\
    \ paren group\n    single_paren_group = \"\"\n    # Traverse through the paren_characters\n\
    \    for paren_character in paren_characters\n        # Use an if/else if/else\
    \ block to check if the paren_character is:\n        # An open brace '('\n   \
    \     if paren_character == '('\n            # If it is, then increment the paren_counter\
    \ and add it to the single_paren_group\n            paren_counter += 1\n     \
    \       push!(single_paren_group, paren_character)\n        # A closed brace ')'\n\
    \        elseif paren_character == ')'\n            # If it is, then decrement\
    \ the paren_counter and add it to the single_paren_group\n            paren_counter\
    \ -= 1\n            push!(single_paren_group, paren_character)\n        # A space\
    \ ' '\n        else\n            # If it is, then do nothing\n            # Else,\
    \ it's not a paren, so add it to the single_paren_group\n        end\n       \
    \ # If paren_counter is 0:\n        if paren_counter == 0\n            # Add the\
    \ single_paren_group to the paren_groups\n            push!(paren_groups, single_paren_group)\n\
    \            # Reset the single_paren_group\n            single_paren_group =\
    \ \"\"\n        end\n    end\n    # Return the paren_groups\n    return paren_groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpfg1335ax.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ push!(::String, ::Char)\\n  Closest candidates are:\\n    push!(::Any, ::Any,\
    \ !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2970\\\
    n    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2971\\\
    n    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:605\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpfg1335ax.jl:24\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpfg1335ax.jl:51 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpfg1335ax.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpfg1335ax.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  MethodError: no method matching push!(::String, ::Char)\\n  Closest\
    \ candidates are:\\n    push!(::Any, ::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2970\\\
    n    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2971\\\
    n    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:605\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpfg1335ax.jl:24\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpfg1335ax.jl:52 [inlined]\\\
    n   [4] macro expansion\\n "
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n \n   open = count(x -> x == '(' , paren_string) #number of open parens\n\
    \   close = count(x -> x == ')' , paren_string) #number of close parens\n   open_list\
    \ = findall(x -> x == '(' , paren_string) #list of open paren locations\n   close_list\
    \ = findall(x -> x == ')' , paren_string) #list of close paren locations\n   if\
    \ open == close #if each open is closed \n       \n       group = []\n       for\
    \ i in 1:length(open_list) #iterate through open paren list\n           if open_list[i]\
    \ < close_list[i] #if open is before close\n               open = open_list[i]\
    \ #open location\n               close = close_list[i] #close location\n     \
    \          push!(group, paren_string[open:close]) #group is string between open\
    \ and close\n           end\n       end \n       return group #returns vector\
    \ of strings in between open and close\n   else #if there is no matching open\
    \ and close\n       error(\"No matching parens\") #error message\n   end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxv8dkdgb.jl:34\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"()()\", \"())\", \"((()\", \"(())\", \"()))\", \"\
    ()\", \"((()\", \"(())\", \"())()\", \"()()\", \"())\"] == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxv8dkdgb.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxv8dkdgb.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpxv8dkdgb.jl:35\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(()\"\
    , \"())\", \"((()\", \"(())\", \"()))\", \"(((()\", \"((())\", \"(()))\", \"())))\"\
    ] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxv8dkdgb.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxv8dkdgb.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpxv8dkdgb.jl:36\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"()(()\", \"(())\", \"())((()\"\
    , \"((())\", \"(()))\", \"())))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxv8dkdgb.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxv8dkdgb.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpxv8dkdgb.jl:37\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \"(( )\", \"\
    ( ))\", \"(( )\", \"( )( )\", \"( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxv8dkdgb.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp4rb0husr.jl:17\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{String}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmp4rb0husr.jl:10\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp4rb0husr.jl:17 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp4rb0husr.jl:16\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    pattern = r\"\\([^()]*\\)\"\n    match = eachmatch(pattern, paren_string)\n\
    \    for m in match\n        #find balance between open and close\n        open_braces\
    \ = 0\n        close_braces = 0\n        for c in m.match\n            if c ==\
    \ '('\n                open_braces = open_braces + 1\n            else\n     \
    \           close_braces = close_braces + 1\n        end\n        if open_braces\
    \ != close_braces\n            #not balanced\n            continue\n        end\n\
    \        #check if nested\n        flag = false\n        inner_braces = 0\n  \
    \      for i in 1:length(m.match)\n            if m.match[i] == '('\n        \
    \        inner_braces = inner_braces + 1\n            else\n                inner_braces\
    \ = inner_braces - 1\n            end\n            if inner_braces < 0\n     \
    \           flag = true\n                break\n            end\n        end\n\
    \        if flag\n            continue\n        end\n        #it's good\n    \
    \    push!(result, m.match)\n    end\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpy9xrfzz9.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpy9xrfzz9.jl:1\n\
    in expression starting at /tmp/tmpy9xrfzz9.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_string\
    \ = replace(paren_string, \")(\" => \") (\")\n    paren_string = replace(paren_string,\
    \ \"(\" => \" (\")\n    paren_string = replace(paren_string, \")\" => \") \")\n\
    \    paren_string = replace(paren_string, \"  \" => \" \")\n    paren_string =\
    \ split(paren_string, \" \")\n    # for p in paren_string\n    #     println(p)\n\
    \    # end\n    paren_vec = []\n    for p in paren_string\n        if findfirst(p,\
    \ \"(\" ) == 1 && findfirst(p, \")\" ) == length(p)\n            push!(paren_vec,\
    \ p)\n        end\n    end\n    # println(paren_vec)\n    paren_vec\nend\nseparate_paren_groups(\"\
    (()(()))\")\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpc8vcqn72.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc8vcqn72.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc8vcqn72.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpc8vcqn72.jl:34\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc8vcqn72.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc8vcqn72.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpc8vcqn72.jl:35\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc8vcqn72.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc8vcqn72.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpc8vcqn72.jl:36\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc8vcqn72.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpc8vcqn72.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    separate_paren_groups(paren_string::String) = # TODO: fill in with your\
    \ code here\nend;\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: unexpected \"end\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpfdyhx6rb.jl:10\nin expression starting at /tmp/tmpfdyhx6rb.jl:10\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO\n    return [paren_string]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5ns5c37a.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()()) ((())) () ((())()())\"] == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5ns5c37a.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5ns5c37a.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp5ns5c37a.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"() (()) ((()))\
    \ (((())))\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5ns5c37a.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5ns5c37a.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp5ns5c37a.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( ) (( )) (( )( ))\"\
    ] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5ns5c37a.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5ns5c37a.jl:16\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5ns5c37a.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    length_string = length(paren_string)\n    # length_string = length(replace(paren_string,\
    \ \" \" => \"\"))\n    pos_ini = findfirst(paren_string, '(')\n    pos_fin = 0\n\
    \    arr_strings = []\n    for i = pos_ini:length_string\n        if paren_string[i]\
    \ == '('\n            pos_ini = i\n        elseif paren_string[i] == ')'\n   \
    \         pos_fin = i\n            push!(arr_strings, paren_string[pos_ini:pos_fin])\n\
    \        end\n    end\n    return arr_strings\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpen0bk086.jl:29\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ findfirst(::String, ::Char)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\n    findfirst(::AbstractString,\
    \ !Matched::AbstractString) at /shared/centos7/julia/1.7.3/share/julia/base/strings/search.jl:104\\\
    n    findfirst(::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\\
    n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\n     @ Main\
    \ /tmp/tmpen0bk086.jl:11\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpen0bk086.jl:29 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpen0bk086.jl:28\\ntest set:\
    \ Error During Test at /tmp/tmpen0bk086.jl:30\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  MethodError: no method matching findfirst(::String, ::Char)\\\
    n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\\
    n    findfirst(::AbstractString, !Matched::AbstractString) at /shared/centos7/julia/1.7.3/share/julia/base/strings/search.jl:104\\\
    n    findfirst(::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\\
    n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\n     @ Main\
    \ /tmp/tmpen0bk086.jl:11\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpen0bk086.jl:30 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     "
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    return [process_paren_group(paren_string)]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpyjgcmwv4.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  UndefVarError: process_paren_group\
    \ not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpyjgcmwv4.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpyjgcmwv4.jl:16 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpyjgcmwv4.jl:15\\ntest set:\
    \ Error During Test at /tmp/tmpyjgcmwv4.jl:17\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  UndefVarError: process_paren_group not defined\\n  Stacktrace:\\\
    n   [1] separate_paren_groups(paren_string::String)\\n     @ Main /tmp/tmpyjgcmwv4.jl:9\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpyjgcmwv4.jl:17 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpyjgcmwv4.jl:15\\ntest set:\
    \ Error During Test at /tmp/tmpyjgcmwv4.jl:18\\n  Test threw exception\\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\\n  UndefVarError: process_paren_group\
    \ not defined\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpyjgcmwv4.jl:9\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpyjgcmwv4.jl:18 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpyjgcmwv4.jl:15\\ntest set:\
    \ Error During Test at /tmp/tmpyjgc"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_parens = 0\n    groups = Vector{String}()\n    current_group = \"\
    \"\n    for c in paren_string\n        if c == '('\n            open_parens +=\
    \ 1\n        elseif c == ')'\n            open_parens -= 1\n        end\n    \
    \    if open_parens == 0\n            push!(groups, current_group)\n         \
    \   current_group = \"\"\n        else\n            current_group *= c\n     \
    \   end\n    end\n    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyesogau_.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyesogau_.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyesogau_.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyesogau_.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"(\", \"\"\
    , \"(()\", \"\", \"((())\", \"\", \"(((()))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyesogau_.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyesogau_.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyesogau_.jl:34\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()(())((()))\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyesogau_.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyesogau_.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyesogau_.jl:35\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( \", \"\", \"(( )\"\
    , \"\", \"(( )( )\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyesogau_.jl:35 [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyesogau_.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    res = []\n    # we need to accumulate the characters within a group, so\
    \ we don't want to\n    # create a new string at every iteration\n    group =\
    \ \"\"\n    paren_idx = 0\n    while paren_idx < length(paren_string)\n      \
    \  if paren_string[paren_idx] == '('\n            if isempty(group) \n       \
    \         # we have a new group, let's add the opening parenthesis to it\n   \
    \             group = '('\n            else\n                # we are in the middle\
    \ of another group, let's ignore the parenthesis\n                pass\n     \
    \   elseif paren_string[paren_idx] == ')'\n            if isempty(group)\n   \
    \             # we've encountered a closing paren without having seen an opening\
    \ one\n                # this means the parentheses are not balanced, so let's\
    \ throw an error\n                throw(ArgumentError(\"the parentheses are not\
    \ balanced\"))\n            else\n                # closing paren for the current\
    \ group, let's add it to the group\n                group *= ')'\n           \
    \     # and push it to the vector of groups\n                push!(res, group)\n\
    \                # and reset the group to start fresh\n                group =\
    \ \"\"\n        elseif paren_string[paren_idx] == ' '\n            # ignore spaces\n\
    \            pass\n        else\n            # if we hit this point it means that\
    \ we have characters that are neither\n            # parentheses nor spaces, so\
    \ let's throw an error\n            throw(ArgumentError(\"wrong character in the\
    \ string\"))\n        end\n        paren_idx += 1\n    end\n    # if we get here\
    \ it means that we are done iterating over the string\n    # but we may not have\
    \ balanced parentheses\n    if !isempty(group)\n        # we have an open parenthesis\
    \ without a closing one\n        throw(ArgumentError(\"the parentheses are not\
    \ balanced\"))\n    end\n    return res\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmp4khrf9bc.jl:16 expected \"\
    end\", got \"elseif\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4khrf9bc.jl:22\n\
    in expression starting at /tmp/tmp4khrf9bc.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    group_open = 0\n    group_close = 0\n    group_start = 1\n    group_end\
    \ = 0\n    group_split = []\n    for index in 1:length(paren_string)\n       \
    \ if paren_string[index] == '('\n            group_open += 1\n            if group_open\
    \ == 1\n                group_start = index\n            end\n        elseif paren_string[index]\
    \ == ')'\n            group_close += 1\n            if group_close == group_open\n\
    \                group_end = index\n                push!(group_split, paren_string[group_start:group_end])\n\
    \                group_open = 0\n                group_close = 0\n           \
    \ end\n        end\n    end\n    return group_split\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpy8cjz5uf.jl:40\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\"\
    , \"(( ))\", \"(( )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy8cjz5uf.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy8cjz5uf.jl:36\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     1      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy8cjz5uf.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    results = []\n    op = 0\n    cp = 0\n    found = 0\n    start = 0\n \
    \   for i in range(1, length(paren_string)):\n        if paren_string[i] == '('\n\
    \            op += 1\n        elseif paren_string[i] == ')'\n            cp +=\
    \ 1\n        if op == cp\n            push!(results, paren_string[start:i])\n\
    \            start = i+1\n            op = 0\n            cp = 0\n           \
    \ found += 1\n        end\n    end\n    return results\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: line break in \":\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpib116vyl.jl:15\nin expression starting at\
    \ /tmp/tmpib116vyl.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    @assert paren_string[1] == '('\n    paren_string = delete(paren_string,\
    \ isspace) # Remove all spaces\n    open_parens = 0\n    string_list = Vector{String}()\n\
    \    curr_string = \"\"\n    for c in paren_string\n        if c == '('\n    \
    \        open_parens += 1\n        elseif c == ')'\n            open_parens -=\
    \ 1\n        end\n        curr_string *= c\n        if open_parens == 0\n    \
    \        push!(string_list, curr_string)\n            curr_string = \"\"\n   \
    \     end\n    end\n    return string_list\nend\n \nsep_paren_groups = separate_paren_groups(paren_string)\n\
    sep_paren_groups = map(string_to_int, sep_paren_groups)\nprintln(sum(map(calc_group_score,\
    \ sep_paren_groups)))\nprintln(sum(map(calc_garbage_score, sep_paren_groups)))\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: paren_string not defined\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgfao85j4.jl:29\nin expression starting at\
    \ /tmp/tmpgfao85j4.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    end\nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmphz493uok.jl:16\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{String}\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmphz493uok.jl:10\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmphz493uok.jl:16 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmphz493uok.jl:15\\ntest set:\
    \ Error During Test at /tmp/tmphz493uok.jl:17\\n  Test threw exception\\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\\n  MethodError: Cannot `convert` an object of type Nothing to an\
    \ object of type Vector{String}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \"\"\" \n    # the goal of this part is to find the indices of each open\
    \ and close parentheses\n    # open and close indices are stored in 2 separate\
    \ arrays\n    # the code below splits the string into a character array and then\
    \ iterates through this array\n    # for every open paren, we store the index\n\
    \    # for every close paren, we store the index\n    # this code also handles\
    \ if there are a non-matching number of open and close parens\n    \"\"\"\n  \
    \  open_paren_idx = []\n    close_paren_idx = []\n    paren_string_arr = split(paren_string,\
    \ \"\")\n    for i in eachindex(paren_string_arr)\n        if paren_string_arr[i]\
    \ == \"(\"\n            push!(open_paren_idx, i)\n        elseif paren_string_arr[i]\
    \ == \")\"\n            push!(close_paren_idx, i)\n        end\n    end\n    if\
    \ length(open_paren_idx) != length(close_paren_idx)\n        println(\"There are\
    \ not matching number of open and close parentheses\")\n        return\n    end\n\
    \    \"\"\"\n    # the goal of this part is to find all the groups of matching\
    \ parentheses and store them as a string\n    # we store these in a vector which\
    \ will be returned at the end\n    # we will be removing from the open and close\
    \ parentheses indices as we process them\n    # if there are any left, we will\
    \ have an error message and return nothing\n    \"\"\"\n    paren_groups = []\n\
    \    while length(open_paren_idx) > 0\n        first_open_paren = open_paren_idx[1]\n\
    \        last_close_paren = close_paren_idx[end]\n        push!(paren_groups,\
    \ join(paren_string_arr[first_open_paren:last_close_paren]))\n        open_paren_idx\
    \ = open_paren_idx[(first_open_paren + 1):(end - 1)]\n        close_paren_idx\
    \ = close_paren_idx[2:end]\n    end\n    if length(open_paren_idx) > 0\n     \
    \   println(\"There are not matching number of open\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space before \"(\" not allowed in \"\"There are\
    \ not matching number of open\\nusing Test\\n\\n@testset begin\\n\\ncandidate\
    \ = separate_paren_groups;\\n\\t@test(candidate(\"(()()) (\" at /tmp/tmpp86kocpk.jl:52\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpp86kocpk.jl:52\nin expression\
    \ starting at /tmp/tmpp86kocpk.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # method to initialize open count and close count for each group \n  \
    \  function initialize_paren_counts(paren_string::String)::Vector{Int}\n     \
    \   count_vector = Array{Int}(undef,length(paren_string))\n        for i in 1:length(paren_string)\n\
    \            if paren_string[i] == '('\n                count_vector[i] = 1\n\
    \            elseif paren_string[i] == ')'\n                count_vector[i] =\
    \ -1\n            else\n                count_vector[i] = 0\n            end\n\
    \        end\n        return count_vector\n    end\n    \n    # method to append\
    \ indices of each group to a list\n    function find_paren_groups(paren_string::String)::Vector{Int}\n\
    \        paren_counts = initialize_paren_counts(paren_string)\n        group_indices\
    \ = [1]\n        for i in 2:length(paren_counts)\n            if paren_counts[i]\
    \ == 1 && paren_counts[i-1] == 0\n                push!(group_indices,i)\n   \
    \         end\n        end\n        return group_indices\n    end\n    \n    #\
    \ method to calculate end indices of each group and then append paren groups to\
    \ a list\n    function find_indices_of_paren_groups(paren_string::String)::Vector{Int}\n\
    \        group_indices = find_paren_groups(paren_string)\n        end_indices\
    \ = group_indices[2:end]\n        for i in 1:length(group_indices)-1\n       \
    \     j = group_indices[i]\n            total = 0\n            while total !=\
    \ 0 || j == group_indices[i]\n                total += paren_counts[j]\n     \
    \           j += 1\n            end\n            push!(end_indices,j-1)\n    \
    \    end\n        return end_indices\n    end\n    \n    # method to return a\
    \ list of paren groups\n    function paren_groups(paren_string::String)::Vector{String}\n\
    \        end_indices = find_indices_of_paren_groups(paren_string)\n        group_indices\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmplyr50lqb.jl:53\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplyr50lqb.jl:1\n\
    in expression starting at /tmp/tmplyr50lqb.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Print input string\n    println(\"The string is: \", paren_string)\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpmptrrdat.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpmptrrdat.jl:1\n\
    in expression starting at /tmp/tmpmptrrdat.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # keep track of how many open left parens you've seen\n    # so that you\
    \ know where to start and end your slice\n    counter = 0\n    start = 0\n   \
    \ end = 0\n    groups = Vector{String}()\n    for char in paren_string\n     \
    \   # ignore spaces\n        if char == ' '\n            continue\n        end\
    \ += 1\n        if char == '('\n            counter += 1\n        else\n     \
    \       counter -= 1\n        end\n        # if you've seen all the open parens,\
    \ you're at the end of a group\n        if counter == 0\n            # push that\
    \ slice of the string onto the vector\n            push!(groups, paren_string[start:end-1])\n\
    \            # increment start to the beginning of the next group\n          \
    \  start = end\n        end\n    end\n    groups\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid assignment location \"function separate_paren_groups(paren_string::String)::Vector{String}\n\
    \    # /tmp/tmpz5seyt6o.jl, line 8\n    # /tmp/tmpz5seyt6o.jl, line 11\n    counter\
    \ = 0\n    # /tmp/tmpz5seyt6o.jl, line 12\n    start = 0\nend\" around /tmp/tmpz5seyt6o.jl:1\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpz5seyt6o.jl:1\nin expression starting\
    \ at /tmp/tmpz5seyt6o.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n \n    open_idx = findall(x -> x == '(' || x == '( ', paren_string)\n    close_idx\
    \ = findall(x -> x == ')' || x == ') ', paren_string)\n    \n    num_parens =\
    \ length(open_idx)\n    groups = Vector{String}(num_parens)\n    \n    for i =\
    \ 1:num_parens\n        groups[i] = paren_string[open_idx[i]:close_idx[i]]\n \
    \   end\n    \n    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpy4mmnfsp.jl:10\nin expression\
    \ starting at /tmp/tmpy4mmnfsp.jl:10\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_paren = count(x -> x == '(' , paren_string)\n    close_paren = count(x\
    \ -> x == ')' , paren_string)\n    sub_string = []\n    if open_paren != close_paren\n\
    \        print(\"Invalid Input!\")\n    else\n        while length(paren_string)\
    \ != 0\n            i = 1\n            count = 0\n            while (i <= length(paren_string))\n\
    \                if paren_string[i] == '('\n                    count += 1\n \
    \               elseif paren_string[i] == ')'\n                    count -= 1\n\
    \                end\n                if count == 0\n                    println(paren_string[1:i])\n\
    \                    push!(sub_string, paren_string[1:i])\n                  \
    \  paren_string = paren_string[i+1:end]\n                    break\n         \
    \       end\n                i += 1\n            end\n        end\n    end\n \
    \   return sub_string\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "(()())\n \n((()))\n \n()\n \n((())()())\ntest set: Test Failed at /tmp/tmpr2ehi60k.jl:41\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n   Evaluated: [\"(()())\", \" \", \"((()))\", \" \"\
    , \"()\", \" \", \"((())()())\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr2ehi60k.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr2ehi60k.jl:40\n()\n \n(())\n\
    \ \n((()))\n \n(((())))\ntest set: Test Failed at /tmp/tmpr2ehi60k.jl:42\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n   Evaluated: [\"()\", \" \", \"(())\", \" \", \"((()))\", \" \"\
    , \"(((())))\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr2ehi60k.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr2ehi60k.jl:40\n(()(())((())))\n\
    ( )\n \n(( ))\n \n(( )( ))\ntest set: Test Failed at /tmp/tmpr2ehi60k.jl:44\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"( )\", \" \", \"(( ))\", \" \", \"(( )( ))\"] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr2ehi60k.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr2ehi60k.jl:40\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr2ehi60k.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # write your code here\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpz5m_9qrz.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpz5m_9qrz.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpz5m_9qrz.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpz5m_9qrz.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpz5m_9qrz.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpz5m_9qrz.jl:"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz5m_9qrz.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    group_starts = findall(x -> x == '(', paren_string)\n    group_ends =\
    \ findall(x -> x == ')', paren_string)\n    # Check that the first open parenthesis\
    \ is the first character and the last closed is the last character\n    if group_starts[1]\
    \ == 1 && group_ends[end] == length(paren_string)\n        group_ends = group_ends[1:end-1]\n\
    \        group_starts = group_starts[2:end]\n    end\n    num_groups = length(group_starts)\n\
    \    # Create a vector of strings\n    paren_groups = Vector{String}(undef, num_groups)\n\
    \    for idx in 1:num_groups\n        start_pos = group_starts[idx]\n        end_pos\
    \ = group_ends[idx]\n        paren_groups[idx] = paren_string[start_pos:end_pos]\n\
    \    end\n    return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpuw47xa3f.jl:31\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"()\", \"()\", \"\", \"(()\", \"())\", \"\", \"\", \"(()\"\
    , \"())\", \"()\", \"()\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpuw47xa3f.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuw47xa3f.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpuw47xa3f.jl:32\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"\", \"()\"\
    , \"\", \"(()\", \"())\", \"\", \"((()\", \"(())\", \"()))\"] == [\"()\", \"(())\"\
    , \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpuw47xa3f.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuw47xa3f.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpuw47xa3f.jl:33\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"()\", \"(()\", \"())\", \"((()\",\
    \ \"(())\", \"()))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpuw47xa3f.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuw47xa3f.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpuw47xa3f.jl:34\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"\", \"( )\", \"\"\
    , \"( )\", \"( )\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuw47xa3f.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Initialize variables\n    index = 1                                \
    \                             # Counter for index of string\n    str_start = 1\
    \                                                         # Start index of new\
    \ string\n    num_paren = 0                                                  \
    \       # Number of parentheses already seen\n    num_groups = 0             \
    \                                           # Number of separate groups found\n\
    \    group_start = 0                                                       # Index\
    \ of start of current group\n    paren_groups = String[]                     \
    \                          # Vector of strings for each group\n    \n    # Loop\
    \ through the input string\n    while index <= length(paren_string)\n        curr_char\
    \ = paren_string[index]                                   # Current character\
    \ in the string\n        \n        # Update variables when it is an open parenthesis\n\
    \        if curr_char == '('\n            str_start = index + 1              \
    \                           # Reset the start index of string\n            num_paren\
    \ += 1                                                # Update the count of parentheses\
    \ seen\n            if num_paren == 1                                        \
    \     # Found the start of a new group\n                group_start = index  \
    \                                     # Save the start index of the group\n  \
    \              num_groups += 1                                           # Update\
    \ the number of groups\n            end\n        end\n        \n        # Update\
    \ variables when it is a closed parenthesis\n        if curr_char == ')'\n   \
    \         num_paren -= 1                                                # Update\
    \ the count of parentheses seen\n            if num_paren == 0               \
    \                              # Found the end of a group\n                push!(paren_groups,\
    \ paren_string[group_start:index])      # Add the string of this group to the\
    \ list\n            end\n        end\n        \n        index += 1           \
    \                                             # Update index of the string\n \
    \   end\n    \n    return paren_groups\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplj1od7k8.jl:52\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\"\
    , \"(( ))\", \"(( )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplj1od7k8.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplj1od7k8.jl:48\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     1      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplj1od7k8.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    group_list = Vector{String}()\n    group_string = \"\"\n    counter =\
    \ 0\n    for paren in paren_string\n        if paren == '('\n            counter\
    \ += 1\n        elseif paren == ')'\n            counter -= 1\n        end\n \
    \       group_string *= paren\n        if counter == 0\n            push!(group_list,\
    \ group_string)\n            group_string = \"\"\n        end\n    end\n    return\
    \ group_list\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmg98ihp9.jl:31\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmg98ihp9.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmg98ihp9.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpmg98ihp9.jl:32\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \" \"\
    , \"(())\", \" \", \"((()))\", \" \", \"(((())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmg98ihp9.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmg98ihp9.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpmg98ihp9.jl:34\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \" \", \"((\
    \ ))\", \" \", \"(( )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmg98ihp9.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmg98ihp9.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmg98ihp9.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    #\n    # Remove spaces first\n    #\n    string_list = split(paren_string,\
    \ \" \")\n    no_space_string = join(string_list, \"\")\n    #\n    # Process\
    \ the paren_string\n    #\n    paren_group_list = []\n    paren_group = \"\"\n\
    \    num_open_braces = 0\n    for paren in no_space_string\n        if paren ==\
    \ '('\n            push!(paren_group, paren)\n            num_open_braces += 1\n\
    \        elseif paren == ')'\n            push!(paren_group, paren)\n        \
    \    num_open_braces -= 1\n            if num_open_braces == 0\n             \
    \   push!(paren_group_list, paren_group)\n                paren_group = \"\"\n\
    \            end\n        end\n    end\n    return paren_group_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9jjnfps3.jl:40\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching push!(::String, ::Char)\n\
    \  Closest candidates are:\n    push!(::Any, ::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2970\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2971\n\
    \    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:605\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp9jjnfps3.jl:22\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9jjnfps3.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9jjnfps3.jl:39\ntest set:\
    \ Error During Test at /tmp/tmp9jjnfps3.jl:41\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching push!(::String, ::Char)\n  Closest\
    \ candidates are:\n    push!(::Any, ::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2970\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2971\n\
    \    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:605\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp9jjnfps3.jl:22\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9jjnfps3.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9jjnfps3.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    groups = Vector{String}()\n    group = \"\"\n    level = 0\n    for i\
    \ in paren_string\n        if i == '('\n            group = group * i\n      \
    \      level += 1\n        elseif i == ')'\n            level -= 1\n         \
    \   group = group * i\n            if level == 0\n                push!(groups,\
    \ group)\n                group = \"\"\n            end\n        end\n    end\n\
    \    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    count_open_paren = 0 \n    n = length(paren_string)\n\
    \    groups = []\n    current_group = \"\"\n    for i in 1:n\n        if paren_string[i]\
    \ == '('\n            count_open_paren += 1\n            push!(current_group,\
    \ paren_string[i])\n        elseif paren_string[i] == ')'\n            count_open_paren\
    \ -= 1\n            push!(current_group, paren_string[i])\n        end\n     \
    \   if count_open_paren == 0\n            push!(groups, current_group)\n     \
    \       current_group = \"\"\n        end\n    end\n    return groups\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0kan7qxz.jl:34\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching push!(::String, ::Char)\n\
    \  Closest candidates are:\n    push!(::Any, ::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2970\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2971\n\
    \    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:605\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp0kan7qxz.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0kan7qxz.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0kan7qxz.jl:33\ntest set:\
    \ Error During Test at /tmp/tmp0kan7qxz.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching push!(::String, ::Char)\n  Closest\
    \ candidates are:\n    push!(::Any, ::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2970\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2971\n\
    \    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:605\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp0kan7qxz.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0kan7qxz.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0kan7qxz.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    start_paren_idx = findall(x -> x == '(' , paren_string)\n    end_paren_idx\
    \ = findall(x -> x == ')' , paren_string)\n    if start_paren_idx == end_paren_idx\n\
    \        start_idx = 1\n        end_idx = length(start_paren_idx)\n        paren_groups\
    \ = []\n        for i = start_idx:end_idx\n            push!(paren_groups,paren_string[start_paren_idx[i]:end_paren_idx[i]])\n\
    \        end\n        return paren_groups\n    else\n        return \"Error: Parens\
    \ are not balanced\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpz2wqpve1.jl:28\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpz2wqpve1.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpz2wqpve1.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpz2wqpve1.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpz2wqpve1.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type String to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpz2wqpve1.jl:20"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz2wqpve1.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    list_to_return = Vector{String}()\n    paren_string = replace(paren_string,\
    \ \" \" => \"\")\n    current_string = \"\"\n    open_p = 0\n    done = false\n\
    \    i = 1\n    while (i <= length(paren_string))\n        char = paren_string[i]\n\
    \        if (char == '(')\n            open_p += 1\n        elseif (char == ')')\n\
    \            open_p -= 1\n        end\n        current_string *= char\n      \
    \  if (open_p == 0)\n            list_to_return = [list_to_return; current_string]\n\
    \            current_string = \"\"\n        end\n        i += 1\n    end\n   \
    \ return list_to_return\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    split_paren_groups = split(paren_string, \" \") \n    paren_groups = []\
    \ \n    for i in 1:length(split_paren_groups) \n        if isbalanced(split_paren_groups[i])\
    \ \n            push!(paren_groups, split_paren_groups[i]) \n        end \n  \
    \  end \n    return paren_groups \nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxvqvp4uz.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: isbalanced not defined\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpxvqvp4uz.jl:12\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxvqvp4uz.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxvqvp4uz.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpxvqvp4uz.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: isbalanced not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpxvqvp4uz.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxvqvp4uz.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxvqvp4uz.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpxvqvp4uz.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpxvqvp4uz.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxvqvp4uz.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxvqvp4uz.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpxvqvp4uz.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (("
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxvqvp4uz.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    temp = \"\"\n    result = Vector{String}(0)\n    counter = 0\n    for\
    \ i = 1:length(paren_string)\n        if paren_string[i] == '('\n            counter\
    \ += 1\n        elseif paren_string[i] == ')'\n            counter -= 1\n    \
    \    end\n        temp = temp * paren_string[i]\n        if counter == 0\n   \
    \         push!(result, temp)\n            temp = \"\"\n        end\n    end\n\
    \    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpk7c0kvfx.jl:31\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching Vector{String}(::Int64)\n\
    \  Closest candidates are:\n    Vector{T}() where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n\
    \    Array{T, N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpk7c0kvfx.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpk7c0kvfx.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpk7c0kvfx.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpk7c0kvfx.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching Vector{String}(::Int64)\n  Closest\
    \ candidates are:\n    Vector{T}() where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n\
    \    Array{T, N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpk7c0kvfx.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpk7c0kvfx.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n    "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk7c0kvfx.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    ...\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid identifier name \"...\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqslttkc4.jl:9\nin expression starting at /tmp/tmpqslttkc4.jl:9\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your solution here\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpe53380r0.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpe53380r0.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpe53380r0.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpe53380r0.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpe53380r0.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpe53380r0.jl:"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe53380r0.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) ((\
    \ )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    length = length(paren_string)\n    current_group = \"\"\n    all_groups\
    \ = []\n    paren_count = 0\n    for i in 1:length\n        if paren_string[i]\
    \ == '('\n            current_group = current_group * \"(\"\n            paren_count\
    \ += 1\n        elseif paren_string[i] == ')'\n            current_group = current_group\
    \ * \")\"\n            paren_count -= 1\n        end\n        if paren_count ==\
    \ 0 && !isempty(current_group)\n            push!(all_groups, current_group)\n\
    \            current_group = \"\"\n        end\n    end\n    return all_groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmkdg0pnl.jl:33\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: length not defined\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpmkdg0pnl.jl:9\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmkdg0pnl.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpmkdg0pnl.jl:32\ntest set:\
    \ Error During Test at /tmp/tmpmkdg0pnl.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: length not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpmkdg0pnl.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmkdg0pnl.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpmkdg0pnl.jl:32\ntest set:\
    \ Error During Test at /tmp/tmpmkdg0pnl.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: length\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpmkdg0pnl.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmkdg0pnl.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpmkdg0pnl.jl:32\ntest set:\
    \ Error During Test at /tmp/tmpmkdg0pnl.jl:36\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"("
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmkdg0pnl.jl:30\n"
  exit_code: 1
  status: SyntaxError
