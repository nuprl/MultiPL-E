name: HumanEval_103_rounded_avg
language: jl
prompt: "\"\"\"You are given two positive integers n and m, and your task is to compute\
  \ the\n    average of the integers from n through m (including n and m). \n    Round\
  \ the answer to the nearest integer and convert that to binary.\n    If n is greater\
  \ than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7,\
  \ 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"\
  0b11010\"\n    \"\"\"\nfunction rounded_avg(n::Int64, m::Int64)::Union{String, Int64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = rounded_avg;\n\t@test(candidate(1,\
  \ 5) == \"0b11\")\n\t@test(candidate(7, 13) == \"0b1010\")\n\t@test(candidate(964,\
  \ 977) == \"0b1111001010\")\n\t@test(candidate(996, 997) == \"0b1111100100\")\n\t\
  @test(candidate(560, 851) == \"0b1011000010\")\n\t@test(candidate(185, 546) == \"\
  0b101101110\")\n\t@test(candidate(362, 496) == \"0b110101101\")\n\t@test(candidate(350,\
  \ 902) == \"0b1001110010\")\n\t@test(candidate(197, 233) == \"0b11010111\")\n\t\
  @test(candidate(7, 5) == -1)\n\t@test(candidate(5, 1) == -1)\n\t@test(candidate(5,\
  \ 5) == \"0b101\")\nend\n"
completions: ["    if n < m\n        return string(Int64(round(mean(n:m))))\n    else\n\
    \        return -1\n    end\nend", "    \n    if n > m\n        return -1\n  \
    \  end", "    if m > n return -1 end\n    sum = 0\n    for i in n:m\n        sum\
    \ += i\n    end\n    return \"0b\" * string(Int64, round(sum / (m - n + 1)))\n\
    end", "    if n > m\n        return -1\n    end\n    average = ceil(Int64, mean([n,\
    \ m]))\n    return convert(String, string(base(average, 2)))\nend", "    r = (n\
    \ + m) / 2\n    if n > m\n        return -1\n    else\n        return (Int64(r)\
    \ >> 0 | 0x80000000)\n    end\nend", "    n > m && return -1\n    avg = floor(Int64,\
    \ (n + m) / 2)\n    return string(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(replace",
  "    (n + m) % 2 == 0 ? convert(Int64, string(base(Int64,(n + m) / 2, 2))) : return\
    \ -1\nend", "    if n > m\n        return -1\n    end\n    # uses the formula\
    \ (n + m) / 2\n    # rounding off to nearest integer using round(val, digits =\
    \ 0)\n    # converting int to binary string using \"0b$(integer)\"\n    return\
    \ \"0b$(round((n + m) / 2))\"\nend", "    if n > m\n        return -1\n    end\n\
    \    return round(Int64, (n + m) / 2) |> string\nend\nrounded_avg(20, 33)", " \
    \   if n > m\n        return -1\n    end\n    return convert(UInt64, round(Int64,\
    \ (n + m) / 2))::Int64\nend", "    if n > m\n        return -1\n    end\n    middle\
    \ = round(Int64, (n + m) / 2)\n    return \"0b\" * bin(middle)\nend\n\"\"\"\n\
    The polar angle of the vector (x, y) is the angle between this vector and the\
    \ x-axis. \nWrite a function that returns the polar angle of the vector (x, y)\
    \ in degrees \nrounded to the nearest integer in clockwise direction. \nIf the\
    \ argument is (0, 0), then return 0.\nExamples:\npolar_angle(1, 0) => 0\npolar_angle(1,\
    \ 1) => 45\npolar_angle(0, 1) => 90\npolar_angle(-1, 1) => 135\npolar_angle(-1,\
    \ 0) => 180\npolar_angle(-1, -1) => 225\npolar_angle(0, -1) => 270\npolar_angle(1,\
    \ -1) => 315\n\"\"\"", "    if n>m\n        return -1\n    end\n    avg = convert(Int64,\
    \ round(mean([n,m])))\n    return bin(avg)\nend", "    if n > m\n        return\
    \ -1\n    end\n    int_avg = round(Int64, (n + m) / 2)\n    return \"0b\" * string(Int,\
    \ base=2, int_avg)\nend", "    if n > m\n        return -1\n    end\n    return\
    \ \"0b\" * binary(round(Int64, sum(n:m) / length(n:m)))\nend\n\"\"\"\n    Example:\n\
    \    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10,\
    \ 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n\"\"\"", "    if\
    \ n > m \n        return -1\n    end\n    return decimal2binary( round( Int64,\
    \ mean(n:m) ) )\nend", "    total = (n + m) * ((m - n + 1) / 2)\n    if n > m\
    \ \n        return -1\n    else\n        return \"0b\" * string(round(Int64, total))\n\
    \    end\nend", "    return ifelse(n>m, -1, string(binary(convert(Int64, round(mean([n:m...]))))))\n\
    end", "    if n > m\n        return -1\n    end\n    return dec2bin(Int64(round(sum(n:m)/length(n:m))))\n\
    end\n@testset \"Example Tests\" begin\n    @test rounded_avg(1, 5) == \"0b11\"\
    \n    @test rounded_avg(7, 5) == -1\n    @test rounded_avg(10, 20) == \"0b1111\"\
    \n    @test rounded_avg(20, 33) == \"0b11010\"\nend\n@testset \"Random Tests\"\
    \ begin\n    @testset \"10 Tests\" for i=1:10 begin\n        n = rand(Int32)\n\
    \        m = rand(Int32)\n        if n > m\n            @test rounded_avg(n, m)\
    \ == -1\n        else\n            @test rounded_avg(n, m) == dec2bin(Int64(round(sum(n:m)/length(n:m))))\n\
    \        end\n    end\nend\n \n# Problem 3:\n\"\"\" You will be given a string\
    \ of digits (e.g., \"1234\"). \n    Create a new string where the leftmost digit\
    \ is moved to the end of the string\n    and remove the leftmost digit from the\
    \ string (e.g., \"1234\" -> \"234\").\n    The new string must have the same length\
    \ as the original string.\n    Example:\n    left_remove(\"12345\") => \"23451\"\
    \n    left_remove(\"1432\") => \"432\"\n    left_remove(\"123\") => \"23\"\n \
    \   \"\"\"", "    if n > m \n        return -1\n    end\n    return \"0b\" * convert(String,\
    \ Int(round(Int, (n + m) / 2)))\nend", "    output = Int64(0)\n    output = floor(Int64(round(mean([n,\
    \ m]), digits=2)))\n    if n > m\n        return -1\n    else\n        return\
    \ @sprintf(\"0b%d\", output)\n    end\nend", "    if n > m\n        return -1\n\
    \    end\n    sum_n_m = n + m\n    # average of n and m\n    avg = sum_n_m >>\
    \ 1\n    # rounding the average\n    if sum_n_m % 2 == 1 && n % 2 == 0\n     \
    \   avg += 1\n    end\n    # convert to binary\n    return \"0b\" * string(base(avg,\
    \ 2))\nend", "    n < m || return -1\n    mean = round(Int64, (n + m) / 2)\n \
    \   \"0b$(string(dec2bin(mean)))\"\nend", "    sum = 0\n    i = 0\n    if n <\
    \ m\n        for i in n:m\n            sum += i\n        end\n        avg = sum/(m-n+1)\n\
    \        avg = floor(Int64, avg)\n        return decimal2binary(avg)\n    elseif\
    \ n > m\n        return -1\n    else\n        return decimal2binary(n)\n    end\n\
    end", "    if n > m\n        return -1\n    end\n    a = convert(Int64, round(mean(n:m)))\n\
    \    a = convert(Int64, to_string(a, 2))\n    return \"0b$a\"\nend", "    if n\
    \ > m\n        return -1\n    end\n    sum = 0\n    for i in n:m\n        sum\
    \ += i\n    end\n    string(0b, Int64(round(sum / (m - n + 1))))\nend", "    \n\
    \    if n > m\n        return -1\n    end", "    return n < m ? bin(Int64(ceil(mean([n:m])\
    \ + eps()))) : -1\nend\nrounded_avg(1, 5)", "    if n > m\n        return -1\n\
    \    end\n    return Int64(\"0b\" * string(Int64, round(Int64, mean(n:m))))\n\
    end", "    if n>m\n        return -1\n    end\n    return convert(Int64, round(mean(n:m)))\
    \ |> Int \nend", "    return m >= n ? string(dec2bin(round(Int64, mean(n:m))))\
    \ : -1\nend", "    if n > m\n        return -1\n    end\n    ans = round(Int64,\
    \ (n + m) / 2)\n    return binary(ans)\nend", "    if n > m \n        return -1\n\
    \    end \n    avg = round(Int64, (n + m) / 2)\n    return \"0b\" * bin(avg)\n\
    end ", "    if n > m \n        return -1\n    end\n    avg = round(Int64, (n +\
    \ m) / 2)\n    return \"0b\" * string(dec2bin(avg))\nend\n    \nprintln(rounded_avg(1,\
    \ 5))\nprintln(rounded_avg(7, 5))\nprintln(rounded_avg(10, 20))\nprintln(rounded_avg(20,\
    \ 33))\nprintln(rounded_avg(1234, 5678))", "    if n <= m\n        integer(round(Int64,\
    \ mean([n:m]))) |> int_to_bin\n    else\n        -1\n    end\nend", "    round_avg\
    \ = round(Int64, (n + m) / 2)\n    if n > m \n        return -1\n    else \n \
    \       return join([\"0b\",\n                     dec2bin(round_avg)])\n    end\n\
    end", "    if n > m\n        return -1\n    end\n    avg = round(Int64, (n + m)\
    \ / 2)\n    binary = Int64(avg, base=2)\n    return \"0b$binary\"\nend", "   \
    \ if n > m \n        return -1\n    end\n    return Int2str(round(Int(n+m)/2),\
    \ 2)\nend\n@testset \"Example Tests\" begin\n    @test rounded_avg(1, 5) == \"\
    0b11\"\n    @test rounded_avg(7, 5) == -1\n    @test rounded_avg(10, 20) == \"\
    0b1111\"\n    @test rounded_avg(20, 33) == \"0b11010\"\nend", "    if n > m\n\
    \        return -1\n    end\n    x = trunc(Int64, (n + m) / 2)\n    x = bin(x)\n\
    \    return x\nend", "    if n > m\n        return -1\n    end\n    avg = round(Int64,\
    \ (n + m) / 2)\n    return \"0b\" * string(dec2bin(avg))\nend\n ", "    \n   \
    \ if n > m\n        return -1\n    end\n    \n    avg::Int64 = round(Int64, (n\
    \ + m) / 2)\n    return \"0b\" * bin(avg)\nend\n \n@testset \"Test\" begin\n \
    \   @test rounded_avg(1, 5) == \"0b11\"\n    @test rounded_avg(7, 5) == -1\n \
    \   @test rounded_avg(10, 20) == \"0b1111\"\n    @test rounded_avg(20, 33) ==\
    \ \"0b11010\"\nend", "    if n <= m\n        return decimal_to_binary( round(\
    \ Int, (m + n) / 2 ) )\n    else\n        return -1\n    end\nend", "    \n  \
    \  if n > m\n        return -1\n    end\n    \n    return string(Base.bin(round(Int64,\
    \ (n + m) / 2)))\nend", "    # your code here\n    return \"Write your code here\"\
    \nend", "    if n > m\n        return -1\n    end\n    a = Int64(round(mean([n,\
    \ m])))\n    return string(a)\nend\nprintln(rounded_avg(1, 5))\nprintln(rounded_avg(7,\
    \ 5))\nprintln(rounded_avg(10, 20))\nprintln(rounded_avg(20, 33))\n \n \n\"\"\"\
    A friend of yours is embarrassed that he can't spell \"embarrassed\" correctly.\
    \ \n    He's hoping you can create a simple application that will tell him how\
    \ to \n    spell it.\n    Create a simple application that will take a string\
    \ and return it back in a \n    different order.\n    create_word(\"word\") =>\
    \ \"drow\"\n    create_word(\"localization\") => \"lacolozatin\"\n    create_word(\"\
    internationalization\") => \"latinazinoitanern\"\n    create_word(\"pneumonoultramicroscopicsilicovolcanoconiosis\"\
    ) => \n    \"punsiliconvolcanoconiosisultramicroscopicoinoulmon\"\n    \"\"\"",
  "    if n>m\n        return -1\n    end\n    sum = 0\n    for i in n:m\n       \
    \ sum += i\n    end\n    rounded_sum = round(Int64, sum/(m-n+1))\n    return \"\
    0b\" * string(dec2bin(rounded_sum))\nend", "    return (n > m) ? -1 : Int(round(sum(n:m)/(m-n+1)))\n\
    end", "    # your code here\n    return \"\"\nend", "    if n > m\n        return\
    \ -1\n    end\n    if n == m\n        return \"0b\" * string(dec2bin(n))\n   \
    \ end\n    return \"0b\" * string(dec2bin(floor(Int64, (n + m) / 2)))\nend", " \
    \   if m < n\n        return -1\n    end\n    return bin(round(Int64, (n + m)\
    \ / 2))\nend", "    if n > m \n        return -1\n    end\n    sum = 0\n    for\
    \ i = n:m\n        sum += i\n    end\n    avg = sum / (m - n + 1)\n    #@show(avg)\n\
    \    ans = round(avg)\n    #@show(ans)\n    return \"0b\" * string(ans, base=2)\n\
    end", "    if n > m\n        return -1\n    end\n    avg = trunc(Int64, round(Int64,\
    \ mean([i for i in n:m])))\n    return \"0b\" * string(Base.bin(avg))\nend", " \
    \   # your code here\n    return -1\nend", "    if n > m \n        return -1\n\
    \    end\n    avg::Int64 = (n + m) / 2\n    avg_bin::String = Int(avg, 2)\n  \
    \  return avg_bin\nend", "    return n > m ? -1 : string(n > m ? -1 : reverse(Int.((n+m)/2\
    \ + 1/2 .>= [0; cumprod(reverse(2 .^ (0:log2(n+m-1) - 1)))]))[1:log2(n+m-1)+1])\n\
    end", "    \n    if n <= m\n        avg = round(Int64, (n + m) / 2)\n        output\
    \ = string(bits(avg))\n        return output\n    else\n        return -1\n  \
    \  end\nend", "    a = collect(n:m)\n    b = round(Int64, mean(a))\n    if n >\
    \ m \n        return -1\n    else\n        return Int64(b)\n    end\nend", " \
    \   if n>m\n        return -1\n    end", "    if n > m\n        return -1\n  \
    \  end\n    res = round(Int64, (n + m) / 2)\n    return binary(res)\nend", " \
    \   if n > m \n        return -1\n    end\n    avg = round(Int64, (n + m) / 2)\n\
    \    return \"0b\" * string(base(avg, 2))\nend", "    if n>m\n        return -1\n\
    \    end\n    return convert(Int64, round(Int64, (n+m)/2))\nend\nprintln(rounded_avg(1,\
    \ 5))\nprintln(rounded_avg(7, 5))\nprintln(rounded_avg(10, 20))\nprintln(rounded_avg(20,\
    \ 33))", "    if m < n\n        return -1\n    end\n    rounded = round(Int64,\
    \ (n + m) / 2)\n    return decimal_to_binary(rounded)\nend", "    if n > m\n \
    \       return -1\n    end\n    return \"0b\" * string(Int(round(mean([n:m]))))\n\
    end", "    if n>m \n        return -1\n    end\n    return convert(Int64,round(sum(n:m)/(m-n+1)))\n\
    end", "    if n > m\n        return -1\n    end\n    output = convert(Int64, round(sum(n:m)/length(n:m)))\n\
    \    output = \"0b\" * string(output)\n    return output\nend", "    if n > m\n\
    \        return -1\n    end\n    res = round(Int64, (n + m) / 2)\n    return string(\"\
    0b\", bin(res))\nend", "    m, n = sort(n, m)\n    if n > m\n        return -1\n\
    \    end\n    avg = floor(Int64, (n + m) / 2)\n    return replace(@sprintf(\"\
    %b\", avg), \"0b\" => \"0b\")\nend", "    if n <= m \n        avg = round(Int64,\
    \ mean(n:m))\n        return \"0b$(int(avg, 2))\"\n    else\n        return -1\n\
    \    end\nend", "    if n > m \n        return -1\n    end\n    c = ceil(Int64,\
    \ (n + m) / 2)\n    return bitstring(c)\nend", "    if n > m\n        return -1\n\
    \    end\n    result = round(Int64, (n + m) / 2)\n    return string(string(base(2,\
    \ pad=2), \"b\"), result)\nend\n\"\"\"\n    -------------------------\n    \"\"\
    \"", "    #if n > m\n    #    return -1\n    #end\n    avgn = Int64(ceil(sum(n:m)/(m-n+1)))\n\
    \    return binary(avgn)\nend", "    if n>m\n        return -1\n    end\n    bin\
    \ = 0b0\n    power = -1\n    sum = 0\n    for i in n:m\n        sum += i\n   \
    \ end\n    rounded = round(Int64, sum/(m-n+1))\n    while rounded != 0\n     \
    \   if isodd(rounded)\n            bin += 0b1*2^power\n        end\n        rounded\
    \ = div(rounded, 2)\n        power += 1\n    end\n    return \"0b$bin\"\nend\n\
    \ \nprintln(rounded_avg(1,5))\nprintln(rounded_avg(7,5))\nprintln(rounded_avg(10,20))\n\
    println(rounded_avg(20,33))", "    if n > m\n        return -1\n    end\n    n_m\
    \ = [i for i in n:m]\n    avg = Int(ceil(mean(n_m)))\n    return decimal_to_binary(avg)\n\
    end", "    if n > m\n        return -1\n    end\n    mean = round(Int64, (n +\
    \ m) / 2)\n    return binary(mean)\nend", "    avg = round(Int64, (n + m) / 2)\n\
    \    if n > m\n        return -1\n    else\n        return string(Int64, \"0b\"\
    , bitstring(avg))\n    end\nend\n\"\"\"You are given an integer i, an integer\
    \ j, and a binary string s.\n    Convert i and j to binary, concatenate them together,\
    \ and return the binary\n    string s with the concatenated binary inserted in\
    \ the middle.\n    Example:\n    insert_binary(10, 20, \"abc\") => \"ab10100c\"\
    \n    insert_binary(20, 10, \"abc\") => \"ab01001c\"\n    insert_binary(10, 10,\
    \ \"abc\") => \"ab1010c\"\n    \"\"\"", "    if n <= m\n        return float(n+m)/2.0\n\
    \    else\n        return -1\n    end\nend", "    if n > m\n        return -1\n\
    \    end\n    avg = round(Int64, mean(n:m))\n    return \"0b\" * string(avg)\n\
    end", "    (n > m) && return -1\n    t = div(n + m, 2)\n    b = Base.digits(t,\
    \ 2)\n    b = padarray(b, (32 - length(b)), 0, 'pre')\n    b = join([\"0b\", b])\n\
    \    return b\nend", "    if n > m \n        return -1\n    end\n    sum = 0\n\
    \    for i in n:m\n        sum += i\n    end\n    return Int64(round(Int64, sum/(m-n+1)))\n\
    end", "    if n > m\n        return -1\n    end\n    return dec2bin(floor(Int64,\
    \ (n + m) / 2))\nend", "    if n > m \n        return -1\n    end\n    answer\
    \ = round(Int64, (n + m) / 2)\n    return \"0b\" * string(answer)\nend", "   \
    \ if n > m\n        return -1\n    end\n    sum_ = 0\n    for i in n:m\n     \
    \   sum_ += i\n    end\n    return decimal2binary(round(Int64, sum_ / (m - n +\
    \ 1)))\nend\n\"\"\"You are given an array of integers and an integer n. You will\
    \ return an array of integers\n    where each index i holds the product of all\
    \ integers except the integer at i.\n    You may assume that n is greater than\
    \ or equal to the length of the array.\n    Example:\n    product_of_all_but_me([3,2,1],\
    \ 3) => [2,3,6]\n    product_of_all_but_me([1,2,3,5], 4) => [30,15,10,6]\n   \
    \ product_of_all_but_me([1,7,3,4], 4) => [84,12,28,21]\n    \"\"\"", "    if n\
    \ > m\n        return -1\n    end\n    return Int2Bin(Int64(round(mean([n:m]))))\n\
    end", "    if n > m\n        return -1\n    end\n    sum = 0\n    for i in n:m\n\
    \        sum += i\n    end\n    return sum % 2 == 0 ? \"0b$(Int(sum / (m - n +\
    \ 1)))\"::String : \"0b$(Int(sum / (m - n + 1)) + 1)::String\nend", "    if n\
    \ > m\n        return -1\n    end\n    s = sum(n:m)\n    num = Int(round(s/(m-n+1)))\n\
    \    return \"0b\" * string(binary(num))\nend\n \n    ", "    count = 0\n    total\
    \ = 0\n    curr = n\n    if n > m\n        return -1\n    end\n    while curr\
    \ <= m\n        total += curr\n        count += 1\n        curr += 1\n    end\n\
    \    return binary(round(Int64, total/count))\nend", "    n > m && return -1\n\
    \    v = convert(Int64, round(sum(collect(n:m))/(m-n+1)))\n    \"0b\" * dec2bin(v)\n\
    end", "    if n > m\n        return -1\n    end\n    return \"0b\" * string(dec2bin(round(Int64,\
    \ (n + m) / 2)))\nend", "    if n > m\n        return -1\n    end\n    round(Int64,\
    \ mean(n:m)) |> Int64 |> binary_string\nend", "    if n > m\n        return -1\n\
    \    end\n    v = convert(Int64, round(mean([n:m])))\n    return \"0b\" * string(v,\
    \ base=2)\nend", "    if n > m \n        return -1\n    end\n    avg = round(Int64,\
    \ (n + m) / 2)\n    return \"0b\" * string(avg)\nend", "    # Fill in your code\
    \ here\n    return 0\nend", "    if n > m\n        return -1\n    end\n    return\
    \ decimal_to_binary(round(Int64, (n + m) / 2))\nend", "    if n > m\n        return\
    \ -1\n    end\n    i = n\n    sum = 0\n    while i <= m\n        sum += i\n  \
    \      i += 1\n    end\n    return \"0b\" * string(Int(round(sum / (m - n + 1))))\n\
    end", "    if n > m\n        return -1\n    end\n    floor(Int64, (n + m) / 2)\
    \ |> int2str(2) |> s -> \"0b\" * s\nend\n \n\"\"\"A number is said to be \"special\"\
    \ if the greatest prime factor of that number is less than or equal to 5. \n \
    \   You must create a function that takes a number and returns \"special\" if\
    \ the number is special, or \"not special\" if it is not.\n    Examples:\n   \
    \ is_special(32) => \"special\"\n    is_special(30) => \"not special\"\n    is_special(4)\
    \ => \"special\"\n    is_special(27) => \"not special\"\n    \"\"\"", "    if\
    \ n > m \n        return -1\n    end\n    int_avg = round(Int64, (n + m) / 2)\n\
    \    return Int64(int_avg)\nend", "    if n > m\n        return -1\n    end\n\
    \    a = round(Int64, (n + m) / 2)\n    bin_a = Int64(convert(Int, to_binary(a)))\n\
    \    return bin_a\nend", "    if n <= m\n        return Int64(round(sum(n:m)/(m-n+1)))\
    \ |> Int64 |> binary \n    else\n        return -1\n    end\nend", "    if n >\
    \ m \n        return -1\n    end\n    avg = round(Int64, (n + m) / 2)\n    return\
    \ \"0b\" * string(avg)\nend", "    if n > m\n        return -1\n    end\n    return\
    \ Int64(floor(mean([n:m]))) |> binary\nend", "    m >= n || return -1\n    avg\
    \ = sum(n:m) ./ (m - n + 1) |> round |> convert(Int64, 2)\n    return \"0b$avg\"\
    \nend", "    n>m && return -1\n    sum=0\n    for i in n:m\n        sum+=i\n \
    \   end\n    average=ceil(Int64,sum/(m-n+1))\n    return binary(average)\nend",
  "    if n > m\n        return -1\n    end\n    avg::Int64 = trunc(Int64, (n + m)\
    \ / 2)\n    b::String = string(base(avg, 2))\n    return string(\"0b\", b)\nend",
  "    if n > m\n        return -1\n    end\n    return Int(round(mean([n, m])))\n\
    end", "    if n > m\n        return -1\n    end\n    sum = 0\n    for i in n:m\n\
    \        sum += i\n    end\n    return bits(floor(Int64, sum / (m - n + 1)))\n\
    end\n\"\"\"Return the maximum number of consecutive 0's in the binary number.\n\
    \    Example:\n    bin_with_most_zeros(1) => 0\n    bin_with_most_zeros(2) =>\
    \ 1\n    bin_with_most_zeros(3) => 0\n    bin_with_most_zeros(4) => 2\n    bin_with_most_zeros(5)\
    \ => 0\n    bin_with_most_zeros(6) => 1\n    bin_with_most_zeros(7) => 0\n   \
    \ bin_with_most_zeros(8) => 3\n    \"\"\"", "    if n > m\n        return -1\n\
    \    end\n    avg = round(Int64, (n + m) / 2)\n    return \"0b\" * string(base(avg,\
    \ 2))\nend", "    if n > m \n        return -1\n    end\n    avg::Int64 = round(Int64,\
    \ (n + m) / 2)\n    return \"0b\" * string(avg)\nend\nprintln(rounded_avg(1, 5))\n\
    println(rounded_avg(7, 5))\nprintln(rounded_avg(10, 20))\nprintln(rounded_avg(20,\
    \ 33))\n ", "    if n < m\n        s = sum(n:m)\n        n = n / length(n:m)\n\
    \        n = round(n)\n        n = bitstring(n)\n        return n\n    elseif\
    \ n > m\n        return -1\n    end\nend", "    return i < m ? \"0b$(bitstring(avg))::Signed\"\
    \ : -1\nend", "    if n <= m\n        bin = round(Int64, (n + m) / 2)\n      \
    \  return \"0b$bin\"\n    else\n        return -1\n    end\nend\nrounded_avg(1,\
    \ 5)", "    if n > m\n        return -1\n    end\n    sum = 0\n    for i = n:m\n\
    \        sum += i\n    end\n    return convert(Int64, round(sum / (m - n + 1)))\n\
    end", "    if n < m\n        return round(Int64, (n + m) / 2) |> decimal_to_binary\n\
    \    else\n        return -1\n    end\nend\nrounded_avg(1, 5)", "    if n>m \n\
    \        return -1\n    end\n    return int2str(bin, round(Int64, (n+m)/2))\n\
    end", "    if n > m \n        return -1\n    end \n    return Int64(round(Int64,\
    \ (n + m) / 2) * 2)\nend \nrounded_avg(1, 5)\nrounded_avg(7, 5)\nrounded_avg(10,\
    \ 20)\nrounded_avg(20, 33)", "    if n>m\n        return -1\n    end\n    return\
    \ \"0b\"*string(convert(Int64, round(mean([n:m]))))\nend", "    return -1 == m\
    \ > n ? -1 : *\"0b$(Int(round(mean(n:m))))\"\nend", "    if n <= m\n        return\
    \ convert(Int64, round(mean([n:m;])))\n    else\n        return -1\n    end\n\
    end", "    (n > m) && return -1\n    n == m && return bits(n)\n    return bits(round(Int64,\
    \ sum(n:m) / (m - n + 1)))\nend", "    if n>m\n        return -1\n    end\n  \
    \  x = round(Int64, mean([n,m]))\n    return \"0b\" * base(x, 2)\nend\n\"\"\"\n\
    \"\"\"\n \n## Problem 2: Lexical Analysis\nLexical analysis is the process of\
    \ converting a sequence of characters into a sequence\n    of tokens. In this\
    \ problem, you will be given an input word, and you must tell \n    whether it\
    \ is a valid word.\n    words should contain only lowercase letters and no other\
    \ characters.\n    Words are separated by whitespace (\" \") characters.\n   \
    \ Return False if the input word is not valid, else return True.\n    Example:\n\
    \    valid_word(\"hello\") == True\n    valid_word(\"asd4\") == False\n    valid_word(\"\
    as d4\") == False\n    valid_word(\"as\") == True\n    valid_word(\"  hello\"\
    ) == False\n    valid_word(\"hell  o\") == False\n\"\"\"", "    if n > m\n   \
    \     return -1\n    end\n    return bin(int(round(mean(n:m))))\nend", "    x\
    \ = div(n + m, 2)\n    if n > m\n        return -1\n    else\n        return decimal_to_binary(x)\n\
    \    end\nend", "    if n > m \n        return -1\n    end\n    return \"0b\"\
    \ * bits(round(Int64,(n+m)/2))\nend", "    if n > m\n        return -1\n    end\n\
    \    sum = 0\n    for x in n:m\n        sum += x\n    end\n    mean = Int64(round(sum\
    \ / (m - n + 1)))\n    return \"0b\" * binary(mean)\nend", "    if n > m \n  \
    \      return -1\n    end\n    return Int64(round(Int64, mean(n:m)))\nend", " \
    \   if n > m\n        return -1\n    end\n    return Int2Bin(round(Int, (n + m)\
    \ / 2))\nend", "    avg = round(Int64, (n + m) / 2)\n    if n > m\n        return\
    \ -1\n    else\n        return convert(Int64, \"0b\" * string(avg))\n    end\n\
    end", "    avg = (n + m) / 2\n    if m < n\n        return -1\n    else\n    \
    \    return \"0b\" * convert(String, round(avg))\n    end\nend", "    if n > m\n\
    \        return -1\n    end\n    m += 1\n    v = Int64[]\n    for i = n:m-1\n\
    \        push!(v, i)\n    end\n    avg = round(Int64, (sum(v) / length(v)))\n\
    \    return \"0b\" * string(avg)\nend", "    if n > m\n        return -1\n   \
    \ end", "    # n should be less than m\n    if n > m\n        return -1\n    end\n\
    \    return \"0b\" * string(convert(Int64, round(mean([n:m]))))\nend", "    if\
    \ n > m\n        return -1\n    end", "    if n > m \n        return -1\n    end\n\
    \    avg = round(Int64, (n + m) / 2)\n    \"0b$(dec2bin(avg))\"\nend", "    if\
    \ n > m\n        return -1\n    end\n    _range = n:m\n    _avg = round(Int64,\
    \ mean(_range))\n    return \"0b\" * string(_avg, base=2)\nend", "    if n > m\n\
    \        return -1\n    end\n    s = 0\n    for i = n:m\n        s += i\n    end\n\
    \    x = round(Int64, s / (m - n + 1))\n    x = dec2bin(x)\n    return \"0b$x\"\
    \nend", "    if n > m\n        return -1\n    end\n    sum = 0\n    for i in range(n,\
    \ m + 1)\n        sum += i\n    end\n    average = round(Int64, sum / (m - n +\
    \ 1))\n    return \"0b\" * string(dec2bin(average))\nend", "    n > m && return\
    \ -1\n    return Int64(convert(Float64, (n + m)/2))\nend", "    avg = Int64(round(sum(n:m)/length(n:m)))\n\
    \    if n > m\n        return -1\n    else\n        return \"0b$(base(avg, 2))\"\
    \n    end\nend", "    # Inputs are expected to be integers, but \"n\" needs to\
    \ be less than \"m\".\n    if n > m\n        return -1\n    end\n    # Calculate\
    \ the average of \"n\" and \"m\"\n    avg = ceil(Int64, (n + m) / 2)\n    # Convert\
    \ \"avg\" to a binary string\n    return \"0b\" * string(avg)\nend", "    # total\
    \ length of input numbers\n    n_l = ceil(log2(n))\n    m_l = ceil(log2(m))\n\
    \    length = max(n_l, m_l)\n    n = n << (length - n_l)\n    m = m << (length\
    \ - m_l)\n    if n > m\n        return -1\n    end\n    sum = n + m\n    # The\
    \ last bit is just rounding, so we can remove it from the result\n    res = 0\n\
    \    for i = 1:length-1\n        res = res + (sum >> i & 1) << (i-1)\n    end\n\
    \    return \"0b$res\"\nend", "    if n > m\n        return -1\n    end\n    if\
    \ (m+n)%2 == 0\n        return \"0b\"*string(bin(round(Int64, (m+n)/2)))\n   \
    \ else\n        return \"0b\"*string(bin(round(Int64, (m+n)/2.0)))\n    end\n\
    end", "    if n>m\n        return -1\n    end\n    return \"0b\"*(string(Int(round(mean([n:m])))))\n\
    end\n    \n    \n\"\"\"Given a non-negative integer, return the corresponding\
    \ column title as appear in an Excel sheet.\n    For example:\n    1 -> A\n  \
    \  2 -> B\n    3 -> C\n    ...\n    26 -> Z\n    27 -> AA\n    28 -> AB\n    \"\
    \"\"", "    if n>m\n        return -1\n    end\n    return convert(Int64, string(\
    \ numpy.mean(numpy.arange(n, m+1))))\nend", "    if n > m\n        return -1\n\
    \    end\n    total = 0\n    for i in n:m\n        total += i\n    end\n    rounded\
    \ = round(Int64, total/(m-n+1))\n    return decimal_to_binary(rounded)\nend",
  "    len = m - n + 1\n    avg = (n + m) / 2\n    floor(avg)\n    ceil(avg)\n   \
    \ if n > m\n        return -1\n    else\n        return \"0b\" * string(dec2bin(floor(avg)))\n\
    \    end\nend", "    # error handling\n    if n > m\n        return -1\n    end\n\
    \    # the average\n    avg = Int64(floor( (n + m) / 2 ))\n    # convert to binary\n\
    \    bin_avg = bin(avg)\n    # return the binary string\n    return bin_avg\n\
    end", "    if n > m\n        return -1\n    end\n    val = Int(round(n + (m -\
    \ n) / 2))\n    return join((\"0b\", Int,(val)))\nend", "    if n > m\n      \
    \  return -1\n    end\n    avrg = round(Int64, (n + m) / 2)\n    return \"0b\"\
    \ * string(avrg, base=2)\nend", "    if n > m\n        return -1\n    end\n  \
    \  avg = round(Int64, (n + m) / 2)\n    return string(Int64, \"0b\", bitstring(avg))\n\
    end", "    result = 0\n    len = 0\n    if n > m\n        return -1\n    end\n\
    \    for i = n:m\n        result += i\n        len += 1\n    end\n    result =\
    \ convert(Int64, result/len + 0.5)\n    bin_rep = convert(Binary, result)\n  \
    \  return string(\"0b\", bin_rep)\nend", "    if n > m \n        return -1\n \
    \   end\n    avgg = round(Int64, mean([n:m;]))\n    return string(base(2, avgg))\n\
    end", "    if n > m\n        return -1\n    end\n    return Int(round(mean([n,\
    \ m])))\nend", "    if n > m\n        return -1\n    end\n    l = m - n + 1\n\
    \    sum = Int64(0)\n    for i in n:m\n        sum += i\n    end\n    ans = sum\
    \ \xF7 l\n    @show ans\n    val = bitstring(ans)\n    return \"0b$val\"\nend",
  "    n > m && return -1\n    return n == m ? convert(Int64, n) : Int64(trunc(Int,\
    \ (n + m) / 2))\nend", "    if n > m\n        return -1\n    end", "    if n <=\
    \ m \n        average = round(Int64, (n + m) / 2)\n        return \"0b\" * string(bitstring(average))\n\
    \    else\n        return -1\n    end\nend", "    if n>m\n        return -1\n\
    \    end\n    return bin(round(Int64, (n+m)/2))\nend", "    if n > m\n       \
    \ return -1\n    end\n    bin_string = Int64(Int(round(mean([n:m]))))\n    return\
    \ \"0b\" * string(bin_string)\nend\n ", "    if n > m \n        return -1\n  \
    \  end\n    average = round(Int64, (n + m) / 2)\n    return \"0b\" * string(dec2bin(average))\n\
    end", "    if n > m\n        return -1\n    end\n    return dec2bin(ceil(Int64,\
    \ (n + m) / 2))\nend", "    total = 0\n    for i in n:m\n        total += i\n\
    \    end\n    if n > m\n        return -1\n    else\n        return round(Int64,\
    \ total/(m-n+1))\n    end\nend", "    if n > m\n        return -1\n    end\n \
    \   return bin(floor(Int64, (n + m) / 2))\nend\n \n\"\"\"Your task is to create\
    \ a function which returns the sum of following series upto nth term(parameter).\n\
    \    Series: 1 + 1/4 + 1/7 + 1/10 + 1/13 + 1/16 +...\n    Rules:\n    You need\
    \ to round the answer to 2 decimal places and return it as String.\n    If the\
    \ given value is 0 then it should return 0.00\n    You will only be given Natural\
    \ Numbers as arguments.\n    Examples:\n    SeriesSum(1) => 1 = \"1.00\"\n   \
    \ SeriesSum(2) => 1 + 1/4 = \"1.25\"\n    SeriesSum(5) => 1 + 1/4 + 1/7 + 1/10\
    \ + 1/13 = \"1.57\"\n    \"\"\"", "    return string(m <= n, round(Int64, (n +\
    \ m) / 2), base=2)\nend", "    sum(n:m) == 0 ? return -1 : return \"0b\" * string(int(ceil(Int64,\
    \ sum(n:m)/(m-n+1))))\nend", "    # your code here\nend\n\"\"\"\n    For this\
    \ exercise, you are given a string s and an integer n.\n    Complete the function\
    \ such that it returns the first n characters of the \n    string concatenated\
    \ with the last n characters of the string.\n    If the string has less than n\
    \ characters, return the whole string.\n    Example:\n    first_last(\"abcdefg\"\
    , 4) => \"abcdg\"\n    first_last(\"abc\", 5) => \"abcabc\"\n    first_last(\"\
    abc\", 4) => \"abcc\"\n    first_last(\"\", 4) => \"\"\n    \"\"\"", "    if n\
    \ > m \n        return -1\n    end\n    avg = round(Int64, (n + m) / 2)\n    return\
    \ \"0b\" * string(avg, base=2)\nend", "    if n > m\n        return -1\n    end\n\
    \    if n < m\n        sum_n_m = n + m\n        avg = sum_n_m / 2\n        return\
    \ string(\"0b\", dec2bin(round(avg)))\n    end\nend", "    if n > m\n        return\
    \ -1\n    end\n    return Int(round(mean([n:m]))) |> bits |> x -> \"0b$x\"\nend",
  "    if n > m\n        return -1\n    end\n    average = round(Int64, (n + m) /\
    \ 2)\n    string(0x2, \"b\", base(2, average))\nend", "    if n > m\n        return\
    \ -1\n    end\n    return convert(Int64, round(Int64, (n + m) / 2))\nend", " \
    \   if n > m\n        return -1\n    end\n    avg = round(Int64, (n + m) / 2)\n\
    \    return bin(avg)\nend", "    if n > m \n        return -1\n    end\n    if\
    \ n == m\n        return \"0b\" * string(dec2bin(n))\n    end\n    return \"0b\"\
    \ * string(dec2bin(round(Int64, (n + m) / 2)))\nend", "    if n > m\n        return\
    \ -1\n    end\n    return Int2Bin(round(Int, (n + m) / 2))\nend", "    @assert\
    \ n > 0 && m > 0 && (n < m || n == m)\n    if n > m\n        return -1\n    end\n\
    \    x = round(Int64, mean(n:m))\n    x = string(x, \"b\")\n    return x\nend",
  "    if n>m\n        return -1\n    end\n    sum = 0\n    for i = n:m\n        sum\
    \ += i\n    end\n    avg = sum/(m-n+1)\n    avg_bin = int2bin(Int64(round(avg)))\n\
    \    return \"0b$avg_bin\"\nend", "    if n > m\n        return -1\n    end\n\
    \    avg = round(Int64, (n + m) / 2)\n    return \"0b\" * string(base(avg, 2))\n\
    end\n\"\"\"Determine if two string versions of integers are equivalent when an\
    \ even number\n    of alphabetic characters are removed from each string.\n  \
    \  Example:\n    str_eq_num(\"14\", \"4\") => true\n    str_eq_num(\"3a3\", \"\
    3\") => true\n    str_eq_num(\"a\", \"b\") => false\n    str_eq_num(\"a\", \"\
    bb\") => false\n    str_eq_num(\"a\", \"A\") => false\n    str_eq_num(\"1\", \"\
    b\") => false\n    \"\"\"", "    if n > m\n        return -1\n    end", "    if\
    \ n > m\n        return -1\n    end\n    return bits(round(Int64, sum(n:m) / (m\
    \ - n + 1)))\nend", "    if n > m\n        return -1\n    end\n    return \"0b\"\
    \ * string(Int64, round(Int64, sum(collect(n:m)) / (m - n + 1)))\nend", "    if\
    \ n > m\n        return -1\n    end\n    n, m = n % 2 == 0 ? n : n+1, m % 2 ==\
    \ 0 ? m : m-1\n    return \"0b\" * string(Int64(round(sum(n:2:m)/(m-n+1), digits=0)))\n\
    end\nprint(rounded_avg(1, 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10,\
    \ 20))\nprint(rounded_avg(20, 33))", "    return isnothing(n) || isnothing(m)\
    \ ? throw(DomainError()) : string(Int, round(Int, sum(n:m)/(m-n+1))) * \"b\"\n\
    end", "    v = (n + m) / 2\n    v % 1 == 0 ? string(bin(Int64(v))) : -1\nend",
  "    return (n+m)/2\nend", "    if n > m \n        return -1\n    end\n    return\
    \ dec2bin(round(Int64, (n + m) / 2))\nend", "    \n    # if (m < n)\n    #   \
    \  return -1\n    # end\n    \n    function f(n, m)::Int64\n        if (n > m)\n\
    \            return -1\n        end\n        return Int64(round(Int64, (n + m)\
    \ / 2))\n    end\n    \n    if (m < n)\n        return -1\n    end\n    \n   \
    \ return \"0b\" * string(Int64, binary(f(n, m)))\nend", "    if n > m\n      \
    \  return -1\n    end\n    sum = 0\n    for i in n:m\n        sum += i\n    end\n\
    \    avg = round(Int64, sum / (m - n + 1))\n    return decimal_to_binary(avg)\n\
    end", "    if n > m\n        return -1\n    end\n    avg = (n + m) >> 1\n    return\
    \ \"0b\" * string(int2bin(avg)[1])\nend", "    if n > m\n        return -1\n \
    \   end\n    n_sum = sum(n:m)\n    n_sum = round(Int64, n_sum / (m - n + 1))\n\
    \    return \"0b\" * string(n_sum)\nend\nprintln(rounded_avg(10, 20))\nprintln(rounded_avg(20,\
    \ 33))\nprintln(rounded_avg(20, 33))\nprintln(rounded_avg(20, 33))\nprintln(rounded_avg(1,\
    \ 5))", "    if n > m\n        return -1\n    end\n    return dec2bin(Int64(ceil(mean([n:m]))))\n\
    end\nrounded_avg(5,5)", "    if n>m\n        return -1\n    end\n    sum = 0\n\
    \    for i in n:m\n        sum += i\n    end\n    avg = ceil(Int64, sum/(m-n+1))\n\
    \    return \"0b\"*string(dec2bin(avg))\nend", "    if n > m\n        return -1\n\
    \    end\n    avg = round(Int64, (n + m) / 2)\n    return \"0b\" * string(base(2,\
    \ avg))\nend", "    if n > m\n        return -1\n    end\n    avg = round(Int64,\
    \ (n + m) / 2)\n    return bits(avg)\nend", "    if n > m\n        return -1\n\
    \    end", "    if n > m\n        return -1\n    end\n    avg = round(Int64, sum(n:m)\
    \ / (m - n + 1))\n    return \"0b\" * string(digits(avg, base=2))\nend", "   \
    \ if n > m\n        return -1\n    end\n    i::Int64 = n\n    sum::Int64 = 0\n\
    \    while i <= m\n        sum += i\n        i += 1\n    end\n    to_binary(round(Int64,\
    \ sum/(m-n+1)))\nend\nrounded_avg(1, 5)", "    if n > m\n        return -1\n \
    \   end\n    mid = convert(Int64, floor(Int64, (n + m) / 2))\n    return string(\"\
    0b\", binary(mid))\nend", "    if n > m\n        return -1\n    end\n    return\
    \  \"0b\" * dec2bin(round(Int64, (n + m) / 2))\nend", "    if n > m\n        return\
    \ -1\n    end\n    avg = round(Int64, (n + m) / 2)\n    return \"0b\" * string(bits(avg))\n\
    end", "    if n > m\n        return -1\n    end\n    sum = n\n    for i in n+1:m\n\
    \        sum += i\n    end\n    x = round(Int64, sum / (m-n+1))\n    return \"\
    0b\" * string(Int64, x)\nend", "    if n>m\n        return -1\n    end\n    return\
    \ Int64(round(sum(n:m)/(m-n+1)))\nend", "    if n > m\n        return -1\n   \
    \ end\n    sum = 0\n    for i = n:m\n        sum += i\n    end\n    return \"\
    0b\" * dec2bin(round(Int64, sum/(m-n+1)))\nend", "    \n    if n>m\n        return\
    \ -1\n    end\n    \n    summ = 0\n    for i in n:m\n        summ = summ + i\n\
    \    end\n    \n    return bin(round(Int64, summ/(m-n+1)))\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
