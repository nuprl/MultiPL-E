name: HumanEval_21_rescale_to_unit
language: jl
prompt: "\"\"\" Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n    such that the smallest number will become 0 and the largest\
  \ will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25,\
  \ 0.5, 0.75, 1.0]\n    \"\"\"\nfunction rescale_to_unit(numbers::Vector{Float64})::Vector{Float64}\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = rescale_to_unit;\n\t@test(candidate([2.0,\
  \ 49.9]) == [0.0, 1.0])\n\t@test(candidate([100.0, 49.9]) == [1.0, 0.0])\n\t@test(candidate([1.0,\
  \ 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\n\t@test(candidate([2.0,\
  \ 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\n\t@test(candidate([12.0,\
  \ 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nend\n"
completions: ["    (numbers .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\n\
    end", "    min_n = minimum(numbers)\n    max_n = maximum(numbers)\n    return\
    \ (numbers .- min_n) ./ (max_n - min_n)\nend", "    minvalue = minimum(numbers)\n\
    \    range = maximum(numbers) - minvalue\n    return (numbers .- minvalue) ./\
    \ range\nend", "    min = findmin(numbers)[1]\n    max = findmax(numbers)[1]\n\
    \    range = max - min\n    return [ (x - min) / range for x in numbers ]\nend",
  "    min_n = minimum(numbers)\n    max_n = maximum(numbers)\n    length_n = max_n\
    \ - min_n\n    return [(number - min_n) / length_n for number in numbers]\nend\n\
    \ ", "    min_num = minimum(numbers)\n    max_num = maximum(numbers)\n    transformed_numbers\
    \ = []\n    for num in numbers\n        transformed_numbers = vcat(transformed_numbers,\
    \ (num - min_num) / (max_num - min_num))\n    end\n    return transformed_numbers\n\
    end", "    (numbers - minimum(numbers)) / (maximum(numbers) - minimum(numbers))\n\
    end", "    # at least two elements\n    @assert length(numbers) > 1\n    min_number\
    \ = minimum(numbers)\n    max_number = maximum(numbers)\n    return (numbers .-\
    \ min_number) ./ (max_number - min_number)\nend", "    min_value = minimum(numbers)\n\
    \    max_value = maximum(numbers)\n    return (numbers - min_value) / (max_value\
    \ - min_value)\nend", "    # Validate input\n    if length(numbers) < 2\n    \
    \    error(\"input vector must contain at least two elements\")\n    end\n   \
    \ \n    # Get min and max\n    min_value = minimum(numbers)\n    max_value = maximum(numbers)\n\
    \    \n    # Compute rescaled vector\n    rescaled_numbers = [(number - min_value)\
    \ / (max_value - min_value) for number in numbers]\n    \n    return rescaled_numbers\n\
    end", "    lo = minimum(numbers)\n    hi = maximum(numbers)\n    if hi == lo \n\
    \        return fill(0.5, length(numbers))\n    end\n    (numbers .- lo) ./ (hi\
    \ - lo)\nend", "    minimum = minimum(numbers)\n    maximum = maximum(numbers)\n\
    \    if maximum == minimum\n        raise ArgumentError(\"Can't rescale: all numbers\
    \ are equal\")\n    end\n    alpha = 1 / (maximum - minimum)\n    beta = - minimum\
    \ * alpha\n    numbers .* alpha .+ beta\nend", "    if length(numbers) < 2\n \
    \       error(\"rescale_to_unit() expects a list of at least two numbers\")\n\
    \    end\n    if all(numbers .== numbers[1])\n        return numbers ./ numbers[1]\n\
    \    end\n    min_value = minimum(numbers)\n    max_value = maximum(numbers)\n\
    \    if min_value == max_value\n        return zeros(length(numbers))\n    end\n\
    \    return (numbers .- min_value) ./ (max_value - min_value)\nend", "    smallest\
    \ = minimum(numbers)\n    largest = maximum(numbers)\n    scale = largest - smallest\n\
    \    return map(n -> (n - smallest) / scale, numbers)\nend", "    cmin, cmax =\
    \ extrema(numbers)\n    return (numbers .- cmin) ./ (cmax - cmin)\nend", "   \
    \ # your code goes here\nend", "    \"\"\" Rescale the given list of numbers so\
    \ that the smallest element becomes 0 and the largest 1.\n        >>> rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])\n        [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    x_min\
    \ = minimum(numbers)\n    x_max = maximum(numbers)\n    x_range = x_max - x_min\n\
    \    x_range_inv = 1 / x_range\n    return [(x - x_min) * x_range_inv for x in\
    \ numbers]\nend", "    minimum = minimum(numbers)\n    maximum = maximum(numbers)\n\
    \    rescaled = []\n    for number in numbers\n        push!(rescaled, (number\
    \ - minimum) / (maximum - minimum))\n    end\n    return rescaled\nend", "   \
    \ (numbers .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\nend",
  "    min_n = minimum(numbers)\n    max_n = maximum(numbers)\n    return [(n - min_n)\
    \ / (max_n - min_n) for n in numbers]\nend;\nproportion_numbers = [1.0, 1.0, 1.0,\
    \ 1.0, 1.0]\nrescale_to_unit(proportion_numbers)", "    return map(x -> (x - minimum(numbers))\
    \ / (maximum(numbers) - minimum(numbers)), numbers)\nend", "    smallest = minimum(numbers)\n\
    \    biggest = maximum(numbers)\n    return (numbers - smallest) / (biggest -\
    \ smallest)\nend", "    (numbers .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\n\
    end", "    max_val = maximum(numbers)\n    min_val = minimum(numbers)\n    numbers_substracted\
    \ = numbers .- min_val\n    rescaled = numbers_substracted ./ (max_val - min_val)\n\
    \    return rescaled\nend", "    minimum = numbers[1]\n    maximum = numbers[1]\n\
    \    for i in 2:length(numbers)\n        if numbers[i] < minimum\n           \
    \ minimum = numbers[i]\n        end\n        if numbers[i] > maximum\n       \
    \     maximum = numbers[i]\n        end\n    end\n    \u03B1 = 1 / (maximum -\
    \ minimum)\n    \u03B2 = 1 - \u03B1 * maximum\n    transformed = \u03B1 * numbers\
    \ .+ \u03B2\n    return transformed\nend", "    min_num = minimum(numbers)\n \
    \   max_num = maximum(numbers)\n    length = max_num - min_num", "    return (numbers\
    \ .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\nend", "    minvalue\
    \ = minimum(numbers)\n    maxvalue = maximum(numbers)\n    # you can use the +\
    \ operator on vectors in Julia\n    # it will sum up the individual elements\n\
    \    return (numbers .- minvalue) ./ (maxvalue - minvalue)\nend", "    minval\
    \ = minimum(numbers)\n    maxval = maximum(numbers)\n    if maxval == minval\n\
    \        return ones(length(numbers))\n    end\n    (numbers .- minval) ./ (maxval\
    \ - minval)\nend", "    vmin = minimum(numbers)\n    vmax = maximum(numbers)\n\
    \    return (numbers .- vmin) ./ (vmax - vmin)\nend", "    minimum = minimum(numbers)\n\
    \    maximum = maximum(numbers)\n    range = maximum - minimum\n    return (numbers\
    \ .- minimum) ./ range\nend", "    min = minimum(numbers)\n    max = maximum(numbers)\n\
    \    subtract_and_add = map(x -> (x - min) / (max - min), numbers)\n    return\
    \ subtract_and_add\nend", "    max = maximum(numbers)\n    min = minimum(numbers)\n\
    \    numbers .- min / (max - min)\nend", "    assert(length(numbers) >= 2, \"\
    at least two numbers are required\")\n    local minval, maxval = minimum(numbers),\
    \ maximum(numbers)\n    # TODO: implement a linear transform of the given vector,\
    \ such that the smallest number will become 0 and the largest will become 1\n\
    \    return @. (numbers - minval) / (maxval - minval)\nend", "    # TODO: find\
    \ the largest and smallest number and apply linear transformation\n    return\
    \ numbers\nend", "    max_val = maximum(numbers)\n    min_val = minimum(numbers)\n\
    \    return (numbers .- min_val) ./ (max_val - min_val)\nend", "    n = length(numbers)\n\
    \    out = zeros(n)\n    for i in 1:n\n        out[i] = (numbers[i] - minimum(numbers))\
    \ / (maximum(numbers) - minimum(numbers))\n    end\n    return out\nend", "  \
    \  #the minimum number of numbers\n    min_num = minimum(numbers)\n    #the maximum\
    \ number of numbers\n    max_num = maximum(numbers)\n    #the linear transform\n\
    \    return (numbers .- min_num) ./ (max_num - min_num)\nend", "    min_val =\
    \ minimum(numbers)\n    max_val = maximum(numbers)\n    return (numbers .- min_val)\
    \ ./ (max_val - min_val)\nend", "    minimum = minimum(numbers)\n    range = maximum(numbers)\
    \ - minimum\n    rescaled = zeros(length(numbers))\n    for (index, value) in\
    \ enumerate(numbers)\n        rescaled[index] = (value - minimum) / range\n  \
    \  end\n    return rescaled\nend", "    maximum = maximum(numbers)\n    minimum\
    \ = minimum(numbers)\n    range = maximum - minimum\n    numbers = (numbers .-\
    \ minimum) ./ range\n    return numbers\nend", "    minimum = minimum(numbers)\n\
    \    maximum = maximum(numbers)\n    minimum_maximum_range = maximum - minimum\n\
    \    if minimum_maximum_range == 0\n        return map(numbers) do number\n  \
    \          return 0.0\n        end\n    end\n    return map(numbers) do number\n\
    \        return (number - minimum) / minimum_maximum_range\n    end\nend", " \
    \   min_number = minimum(numbers)\n    max_number = maximum(numbers)\n    return\
    \ map(x -> (x - min_number) / (max_number - min_number), numbers)\nend", "   \
    \ \n    # Get max and min values\n    min_val = minimum(numbers)\n    max_val\
    \ = maximum(numbers)\n    \n    # Apply transform\n    return (numbers .- min_val)\
    \ ./ (max_val - min_val)\n    \nend", "    m, M = minimum(numbers), maximum(numbers)\n\
    \    if m == M\n        return fill(1.0, length(numbers))\n    end\n    return\
    \ (numbers .- m) ./ (M - m)\nend", "    range = maximum(numbers) - minimum(numbers)\n\
    \    return (numbers .- minimum(numbers)) / range\nend", "    # reorder numbers,\
    \ assuming that the last element is the largest\n    (smallest, largest) = sort(numbers)\n\
    \    largest -= smallest # subtract smallest from all numbers, now largest is\
    \ the largest number", "    # all this code is basically from https://en.wikipedia.org/wiki/Feature_scaling#Rescaling_(min-max_normalization)\n\
    \    min_val = minimum(numbers)\n    max_val = maximum(numbers)\n    if max_val\
    \ - min_val != 0.0\n        return (numbers - min_val) / (max_val - min_val)\n\
    \    else\n        return ones(numbers)\n    end\nend", "    # Precompute the\
    \ min, max, and range\n    min_number = minimum(numbers)\n    max_number = maximum(numbers)\n\
    \    range_number = max_number - min_number\n    \n    # Apply the linear transform\
    \ to each number\n    return [(num - min_number) / range_number for num in numbers]\n\
    end", "    min_value = minimum(numbers)\n    max_value = maximum(numbers)\n  \
    \  \u0394 = max_value - min_value\n    numbers .- min_value ./ \u0394\nend", " \
    \   # make a copy of the input, so that we preserve the original\n    result =\
    \ copy(numbers)\n    minimum, maximum = extrema(result)\n    for i in 1:length(result)\n\
    \        result[i] = (result[i] - minimum) / (maximum - minimum)\n    end\n  \
    \  return result\nend", "    if length(numbers) < 2\n        error(\"rescale_to_unit\
    \ requires a vector of at least 2 numbers\")\n    end\n    if isequal(numbers,\
    \ [0.0])\n        return [0.0]\n    end\n    if isequal(numbers, [1.0])\n    \
    \    return [1.0]\n    end\n    result = zeros(length(numbers))\n    @inbounds\
    \ for i in 1:length(numbers)\n        result[i] = (numbers[i] - minimum(numbers))\
    \ / (maximum(numbers) - minimum(numbers))\n    end\n    return result\nend", " \
    \   # What type of numbers do we expect as input? \n    # What should our function\
    \ return? \n    rescaled = []\n    return rescaled\nend", "    minimum, maximum\
    \ = minimum(numbers), maximum(numbers)\n    return (numbers - minimum) / (maximum\
    \ - minimum)\nend", "    _min, _max = extrema(numbers)\n    _min, _max = Float64(_min),\
    \ Float64(_max)\n    retval = Float64[]\n    for n in numbers\n        retval\
    \ = [retval; (n - _min) / (_max - _min)]\n    end\n    return retval\nend", " \
    \   return (numbers .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\n\
    end", "    return (numbers .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\n\
    end", "    return (numbers .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\n\
    end", "    # sort the list of numbers into ascending order\n    sorted_values\
    \ = sort(numbers)\n    # create a new vector of the same size\n    rescaled_values\
    \ = Vector{Float64}(undef, length(numbers))\n    # rescale the values\n    for\
    \ i in 1:length(numbers)\n        rescaled_values[i] = (sorted_values[i] - sorted_values[1])\
    \ / (sorted_values[end] - sorted_values[1])\n    end\n    return rescaled_values\n\
    end", "    return (numbers - minimum(numbers)) / (maximum(numbers) - minimum(numbers))\n\
    end", "    min = minimum(numbers)\n    max = maximum(numbers)\n    return (numbers\
    \ .- min) ./ (max - min)\nend", "    minimum, maximum = extrema(numbers)\n   \
    \ (numbers .- minimum) ./ (maximum - minimum)\nend", "    min, max = extrema(numbers)\n\
    \    return map(numbers) do x\n        (x - min) / (max - min)\n    end\nend",
  "    # we get the minimum and maximum values\n    # note that if we had `using Statistics`\
    \ this would be `minimum(numbers)` and `maximum(numbers)`\n    min = numbers[1]\n\
    \    max = numbers[1]\n    for number in numbers\n        if number < min\n  \
    \          min = number\n        end\n        if number > max\n            max\
    \ = number\n        end\n    end\n    # here we are converting the numbers\n \
    \   # * by taking (number - min) we get the distance from the lower bound\n  \
    \  # * by dividing that by (max - min) we get a fraction of the difference\n \
    \   # * by multiplying that by 1 we get a fraction of the difference between 0\
    \ and 1\n    # * by adding 0 we shift the values to be between 0 and 1\n    #\
    \ * by rounding we get back to integers\n    return [round((number - min) / (max\
    \ - min) * 1 + 0) for number in numbers]\nend", "    # make a copy of the list\n\
    \    result = copy(numbers)", "    minimum = minimum(numbers)\n    maximum = maximum(numbers)\n\
    \    return (numbers .- minimum) ./ (maximum - minimum)\nend", "    min_n = minimum(numbers)\n\
    \    max_n = maximum(numbers)\n    return (numbers .- min_n) ./ (max_n - min_n)\n\
    end", "    n = length(numbers)\n    result = zeros(n)\n    lo = minimum(numbers)\n\
    \    hi = maximum(numbers)\n    for i in 1:n\n        result[i] = (numbers[i]\
    \ - lo) / (hi - lo)\n    end\n    return result\nend", "    min_number = minimum(numbers)\n\
    \    max_number = maximum(numbers)\n    step = 1.0 / (max_number - min_number)\n\
    \    return (numbers .- min_number) .* step\nend", "    minimum = minimum(numbers)\n\
    \    maximum = maximum(numbers)\n    assert maximum > minimum, \"Empty list\"\n\
    \    return (numbers .- minimum) ./ (maximum - minimum)\nend", "    # there is\
    \ a formula that does this, but for the sake of simplicity and readability\n \
    \   # of the code, we will implement it from scratch\n    if length(numbers) <\
    \ 2\n        error(\"Number of elements in input vector should be at least 2\"\
    )\n    end\n    # find smallest number in the vector\n    minimum_value = minimum(numbers)\n\
    \    # find largest number in the vector\n    maximum_value = maximum(numbers)\n\
    \    # calculate the difference between min and max\n    diff = maximum_value\
    \ - minimum_value\n    # create an empty vector that will store rescaled values\n\
    \    rescaled_values = Vector{Float64}(undef, length(numbers))\n    # iterate\
    \ over each number in the input vector\n    for (index, number) in enumerate(numbers)\n\
    \        # calculate rescaled value for the current number\n        # and assign\
    \ it to the corresponding position in the rescaled_values vector\n        rescaled_values[index]\
    \ = (number - minimum_value) / diff\n    end\n    # return rescaled values\n \
    \   return rescaled_values\nend", "    # find max and min\n    min_num = minimum(numbers)\n\
    \    max_num = maximum(numbers)\n    # find the difference between max and min\n\
    \    max_min_diff = max_num - min_num\n    # apply the linear transform\n    return\
    \ [ (num - min_num) / max_min_diff for num in numbers ]\nend", "    minimum =\
    \ minimum(numbers)\n    maximum = maximum(numbers)\n    return (numbers .- minimum)\
    \ ./ (maximum - minimum)\nend", "    max_num = maximum(numbers)\n    min_num =\
    \ minimum(numbers)\n    return (numbers .- min_num) ./ (max_num - min_num)\nend",
  "    range = maximum(numbers) - minimum(numbers)\n    minimum_value = minimum(numbers)\n\
    \    return [ (x - minimum_value) / range for x in numbers ]\nend", "    numbers\
    \ = copy(numbers)\n    range = maximum(numbers) - minimum(numbers)\n    for i\
    \ in 1:length(numbers)\n        numbers[i] = (numbers[i] - minimum(numbers)) /\
    \ range\n    end\n    return numbers\nend", "    v_min = minimum(numbers)\n  \
    \  v_max = maximum(numbers)\n    return [x - v_min / (v_max - v_min) for x in\
    \ numbers]\nend", "    min_num = minimum(numbers)\n    max_num = maximum(numbers)\n\
    \    return (numbers - min_num)/(max_num - min_num)\nend", "    if length(numbers)\
    \ < 2\n        error(\"Vector has to be of at least 2 elements\")\n    end\n \
    \   min_val = minimum(numbers)\n    max_val = maximum(numbers)\n    return (numbers\
    \ .- min_val) ./ (max_val - min_val)\nend", "    vmin = minimum(numbers)\n   \
    \ vmax = maximum(numbers)\n    return (numbers .- vmin) ./ (vmax - vmin)\nend",
  "    minimum = minimum(numbers)\n    maximum = maximum(numbers)\n    return [(x\
    \ - minimum) / (maximum - minimum) for x in numbers]\nend", "    min = minimum(numbers)\n\
    \    max = maximum(numbers)\n    return (numbers .- min) ./ (max - min)\nend",
  "    # Take the minimum and maximum, then apply the affine transform\n    minimum\
    \ = minimum(numbers)\n    maximum = maximum(numbers)\n    return [\n        (x\
    \ - minimum) / (maximum - minimum)\n        for x in numbers\n    ]\nend\n \n ",
  "    (numbers .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\nend",
  "    min_number = minimum(numbers)\n    max_number = maximum(numbers)\n    assert\
    \ max_number != min_number\n    return [(x - min_number) / (max_number - min_number)\
    \ for x in numbers]\nend", "    if length(numbers) < 2\n        error(\"Expected\
    \ at least two elements\")\n    end\n    (numbers .- minimum(numbers)) ./ (maximum(numbers)\
    \ - minimum(numbers))\nend", "    offset = minimum(numbers)\n    scale = 1 / (maximum(numbers)\
    \ - offset)\n    return (numbers .- offset) .* scale\nend", "    n = length(numbers)\n\
    \    max_num = maximum(numbers)\n    min_num = minimum(numbers)\n    scale = 1\
    \ / (max_num - min_num)\n    return [scale * (num - min_num) for num in numbers]\n\
    end", "    return (numbers .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\n\
    end", "    min_num = minimum(numbers)\n    max_num = maximum(numbers)\n    x_i\
    \ = (numbers .- min_num) ./ (max_num - min_num)\n    return x_i\nend", "    #\
    \ Find the range of values the list holds\n    max_value = maximum(numbers)\n\
    \    min_value = minimum(numbers)\n    range = max_value - min_value\n    \n \
    \   # Apply the transform\n    if range != 0\n        numbers = (numbers .- min_value)\
    \ ./ range\n    end\n    \n    return numbers\nend\n    \n    \n\"\"\" Given a\
    \ list of numbers, return a list of indices that would sort the list from lowest\
    \ to highest.\n    >>> find_sort_order([5, 3, 6, 7, 2])\n    [5, 2, 1, 3, 4]\n\
    \    \"\"\"", "    min_number = minimum(numbers)\n    max_number = maximum(numbers)\n\
    \    if max_number - min_number == 0\n        return fill(0.5, length(numbers))\n\
    \    end\n    numbers .- min_number\n    numbers ./ (max_number - min_number)\n\
    end", "    min_n = minimum(numbers)\n    max_n = maximum(numbers)\n    return\
    \ map(x -> (x - min_n) / (max_n - min_n), numbers)\nend", "    min_n, max_n =\
    \ extrema(numbers)\n    return (numbers .- min_n) ./ (max_n - min_n)\nend", " \
    \   return (numbers - minimum(numbers))/(maximum(numbers) - minimum(numbers))\n\
    end", "    minimum = minimum(numbers)\n    maximum = maximum(numbers)\n    return\
    \ [(x - minimum) / (maximum - minimum) for x in numbers]\nend", "    # Get max\
    \ and min of input\n    maximum = maximum(numbers)\n    minimum = minimum(numbers)\n\
    \    # Generate empty output\n    output = zeros(length(numbers))\n    # Apply\
    \ linear transform to each element of input\n    for i in 1:length(numbers)\n\
    \        output[i] = (numbers[i] - minimum) / (maximum - minimum)\n    end\n \
    \   # Return output\n    return output\nend", "    min_n, max_n = extrema(numbers)\n\
    \    return (numbers .- min_n) ./ (max_n - min_n)\nend", "    min_value = minimum(numbers)\n\
    \    max_value = maximum(numbers)\n    range = max_value - min_value\n    return\
    \ (numbers .- min_value) ./ range\nend", "    the_min = minimum(numbers)\n   \
    \ the_max = maximum(numbers)\n    return (numbers .- the_min) ./ (the_max - the_min)\n\
    end", "    # TODO: get min and max of numbers\n    # TODO: apply linear transform\
    \ to each number in numbers, such that the smallest\n    # number becomes 0 and\
    \ the largest number becomes 1\n    # hint: you may want to use min, max, findmin\
    \ and findmax from DataStructures.jl\n    # TODO: use broadcasting to apply the\
    \ transform to each number in numbers\nend", "    min_value = minimum(numbers)\n\
    \    max_value = maximum(numbers)\n    denom = max_value - min_value\n    return\
    \ (numbers .- min_value) ./ denom\nend", "    n = length(numbers)\n    @assert\
    \ n >= 2 \"Number of values to rescale should be 2 or more\"\n    minval = numbers[1]\n\
    \    maxval = numbers[1]\n    for i in 2:n\n        minval = min(minval, numbers[i])\n\
    \        maxval = max(maxval, numbers[i])\n    end\n    @assert maxval != minval\
    \ \"All values are the same, cannot rescale\"\n    rn = zeros(n)\n    for i in\
    \ 1:n\n        rn[i] = (numbers[i] - minval) / (maxval - minval)\n    end\n  \
    \  return rn\nend", "    mm = fit!(MinMaxScaler(), numbers)\n    return transform(mm,\
    \ numbers)\nend", "    min, max = extrema(numbers)\n    return (numbers .- min)\
    \ ./ (max - min)\nend", "    l = length(numbers)\n    A = zeros(l,2)\n    A[:,1]\
    \ = 1\n    A[:,2] = numbers\n    x = A\\[1.0, maximum(numbers)]\n    return 1.0\
    \ ./ x[2] .* numbers\nend", "    min_val = minimum(numbers)\n    max_val = maximum(numbers)\n\
    \    return (numbers .- min_val) ./ (max_val - min_val)\nend", "    min = minimum(numbers)\n\
    \    max = maximum(numbers)\n    scaled = map(x -> (x - min) / (max - min), numbers)\n\
    \    return scaled\nend", "    # We have to have a min and max value in order\
    \ to scale\n    min_val = minimum(numbers)\n    max_val = maximum(numbers)\n \
    \   # scale between 0 and 1\n    return (numbers .- min_val) ./ (max_val - min_val)\n\
    end", "    min_n, max_n = extrema(numbers)\n    return (numbers .- min_n) ./ (max_n\
    \ - min_n)\nend", "    n::Int = length(numbers)\n    if n < 2\n        error(\"\
    Cannot rescale list with less than two elements\")\n    end\n    min::Float64\
    \ = minimum(numbers)\n    max::Float64 = maximum(numbers)\n    scale::Float64\
    \ = max - min\n    if scale == 0.0\n        return ones(n)\n    end\n    return\
    \ [(x - min) / scale for x in numbers]\nend", "    smallest = minimum(numbers)\n\
    \    delta = maximum(numbers) - smallest", "    min_value = minimum(numbers)\n\
    \    max_value = maximum(numbers)\n    return (numbers .- min_value) ./ (max_value\
    \ - min_value)\nend", "    local m = minimum(numbers)\n    local M = maximum(numbers)\n\
    \    return (numbers - m) / (M - m)\nend", "    local_max = maximum(numbers)\n\
    \    local_min = minimum(numbers)\n    local_range = local_max - local_min\n \
    \   return (numbers .- local_min) ./ local_range\nend", "    # find a - using\
    \ the minimum\n    a = minimum(numbers)\n    # find b - using the maximum\n  \
    \  b = maximum(numbers)\n    # for each value in the list, divide by b and subtract\
    \ a\n    c = (numbers .- a) ./ (b .- a)\n    return c\nend", "    output = []\n\
    \    #output = [round(Float64(item - min(numbers)) / (max(numbers) - min(numbers)),\
    \ digits=4) for item in numbers]\n    for item in numbers\n        push!(output,\
    \ round(Float64(item - min(numbers)) / (max(numbers) - min(numbers)), digits=4))\n\
    \    end\n    return output\nend", "    a = minimum(numbers)\n    b = maximum(numbers)\n\
    \    return (numbers .- a) ./ (b .- a)\nend", "    (numbers .- minimum(numbers))\
    \ ./ (maximum(numbers) - minimum(numbers))\nend", "    minval = minimum(numbers)\n\
    \    maxval = maximum(numbers)\n    return (numbers - minval)/(maxval - minval)\n\
    end", "    old_min = minimum(numbers)\n    old_max = maximum(numbers)\n    new_range\
    \ = 1.0 - 0.0\n    return (numbers .- old_min) ./ (old_max - old_min) .* new_range\
    \ .+ 0.0\nend", "    sorted_numbers = sort(numbers)\n    minimum, maximum = sorted_numbers[1],\
    \ sorted_numbers[end]\n    range = maximum - minimum\n    numbers_rescaled = (numbers\
    \ .- minimum) ./ range\n    return numbers_rescaled\nend", "    (minimum(numbers),\
    \ maximum(numbers)) = extrema(numbers)\n    return map(x -> (x - minimum) / (maximum\
    \ - minimum), numbers)\nend;\n \n\"\"\" Given two vectors of values, return correlation\n\
    \    http://nbviewer.ipython.org/github/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/blob/master/Chapter2_MorePyMC/Ch2_MorePyMC_PyMC3.ipynb\n\
    \    >>> corr([1.0, 2.0, 3.0, 4.0, 5.0], [1.0, 1.0, 2.0, 3.0, 5.0])\n    0.8\"\
    \"\"", "    m = minimum(numbers)\n    M = maximum(numbers)\n    \u0394 = M - m\n\
    \    return [n/\u0394 for n in numbers]\nend", "    minimum = findmin(numbers)[1]\n\
    \    maximum = findmax(numbers)[1]\n    return (numbers .- minimum) ./ (maximum\
    \ - minimum)\nend", "    a = numbers[1]\n    b = numbers[end]\n    return (numbers\
    \ .- a) ./ (b - a)\nend", "    \"\"\"\n    >>> rescale_to_unit([1.0, 2.0, 3.0,\
    \ 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    maximum = max(numbers)\n\
    \    minimum = min(numbers)\n    return (numbers .- minimum) ./ (maximum - minimum)\n\
    end", "    assert(length(numbers) >= 2, \"rescale_to_unit() is only defined for\
    \ at least two elements\")\n    return (numbers .- minimum(numbers)) ./ (maximum(numbers)\
    \ - minimum(numbers))\nend", "    minimum, maximum = minimum(numbers), maximum(numbers)\n\
    \    return (numbers .- minimum) ./ (maximum - minimum)\nend;\n \n \n\"\"\" Given\
    \ the values of a function at a set of points, create a \"tally\" histogram of\
    \ the function at those points\n    >>> histogram([0.0, 0.1, 0.2, 0.3, 0.4, 0.5,\
    \ 0.6, 0.7, 0.8, 0.9, 1.0])\n    [0.0, 0.2, 0.2, 0.2, 0.2, 0.2]\n    \"\"\"",
  "    min, max = minimum(numbers), maximum(numbers)\n    return (numbers .- min)\
    \ ./ (max - min)\nend", "    return (numbers .- minimum(numbers)) / (maximum(numbers)\
    \ - minimum(numbers))\nend", "    m = numbers .- minimum(numbers)\n    d = maximum(numbers)\
    \ - minimum(numbers)\n    m ./ d\nend", "    minimum = minimum(numbers)\n    range\
    \ = maximum(numbers) - minimum\n    return (numbers .- minimum) ./ range\nend",
  "    min = findmin(numbers)[1]\n    max = findmax(numbers)[1]\n    return (numbers\
    \ .- min) ./ (max .- min)\nend;\n \n# Find points of intersection between two\
    \ curves", "    min_number = minimum(numbers)\n    max_number = maximum(numbers)\n\
    \    return (numbers .- min_number) ./ (max_number - min_number)\nend", "    x_min\
    \ = minimum(numbers)\n    x_max = maximum(numbers)\n    return (numbers .- x_min)\
    \ ./ (x_max - x_min)\nend", "    min_val = minimum(numbers)\n    max_val = maximum(numbers)\n\
    \    return (numbers .- min_val) ./ (max_val - min_val)\nend", "    numbers_min\
    \ = minimum(numbers)\n    numbers_max = maximum(numbers)\n    numbers_diff = numbers_max\
    \ - numbers_min\n    rescaled_numbers = (numbers .- numbers_min) ./ numbers_diff\n\
    \    return rescaled_numbers\nend", "    minimum = minimum(numbers)\n    maximum\
    \ = maximum(numbers)\n    scale = maximum - minimum\n    # equivalent to:\n  \
    \  # return numbers .- minimum ./ scale\n    return (numbers .- minimum) ./ scale\n\
    end", "    mn = minimum(numbers)\n    mx = maximum(numbers)\n    return (numbers\
    \ .- mn) ./ (mx - mn)\nend", "    return (numbers - minimum(numbers)) / (maximum(numbers)\
    \ - minimum(numbers))\nend", "    # Compute max and min\n    max_value = maximum(numbers)\n\
    \    min_value = minimum(numbers)\n    # Compute number of elements\n    n = length(numbers)\n\
    \    # Compute delta for rescaling\n    delta = (max_value - min_value) / (n -\
    \ 1)\n    # Build rescaled vector\n    rescaled_numbers = [(number - min_value)\
    \ / delta for number in numbers]\n    return rescaled_numbers\nend", "    return\
    \ (numbers .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\nend",
  "    return (numbers .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\n\
    end", "    # This function takes a list of numbers, and returns a list of the\
    \ same numbers rescaled to 0-1\n    # There's a built-in function for this, but\
    \ this is more fun :)\n    # Step 1: return the same vector if there are less\
    \ than 2 elements.\n    if length(numbers) < 2\n        return numbers\n    end\n\
    \    # Step 2: Find min and max values\n    min_val = minimum(numbers)\n    max_val\
    \ = maximum(numbers)\n    # Step 3: Calculate the scale factor\n    scale_factor\
    \ = 1.0 / (max_val - min_val)\n    # Step 4: Calculate the new vector of values\
    \ (NOTE: This is not an efficient way to do this!\n    # The next chapter will\
    \ cover better vectorization techniques.)\n    new_vals = scale_factor .* (numbers\
    \ .- min_val)\n    # Step 5: Return the new vector\n    return new_vals\nend",
  "    return (numbers - minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\n\
    end", "    minimum = minimum(numbers)\n    maximum = maximum(numbers)\n    if\
    \ minimum == maximum\n        return ones(Float64, length(numbers))\n    end\n\
    \    return (numbers - minimum) / (maximum - minimum)\nend", "    \"\"\"\n   \
    \ Apply linear transform to a vector of numbers such that the smallest number\
    \ will become 0 and the largest will become 1\n    Parameters\n    ----------\n\
    \    numbers: Vector{Float64}\n        Vector of numbers (at least 2 elements)\n\
    \    Returns\n    -------\n    norm_numbers: Vector{Float64}\n        Vector of\
    \ numbers (at least 2 elements) with linear transform applied\n    \"\"\"\n  \
    \  minimum = minimum(numbers)\n    range = maximum(numbers) - minimum\n    norm_numbers\
    \ = (numbers .- minimum) ./ range\n    return norm_numbers\nend", "    min = minimum(numbers)\n\
    \    max = maximum(numbers)\n    return (numbers .- min) ./ (max - min)\nend;\n\
    \"\"\" Given a list of numbers, calculate the mean of all numbers\n    >>> mean([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])\n    3.0\n    \"\"\"", "    numbers = float.(numbers)\n\
    \    min_val = minimum(numbers)\n    max_val = maximum(numbers)\n    return (numbers\
    \ - min_val) / (max_val - min_val)\nend", "    minVal = minimum(numbers)\n   \
    \ maxVal = maximum(numbers)\n    rangeVal = maxVal - minVal\n    outputVals =\
    \ (numbers .- minVal) ./ rangeVal\n    return outputVals\nend", "    xmin = minimum(numbers)\n\
    \    xmax = maximum(numbers)\n    return (numbers .- xmin)./(xmax - xmin)\nend",
  "    min_n, max_n = minimum(numbers), maximum(numbers)\n    vec_scale = 1.0 / (max_n\
    \ - min_n)\n    vec_translate = min_n\n    return (numbers .- vec_translate) .*\
    \ vec_scale\nend", "    # Find the minimum and maximum values\n    min, max =\
    \ extrema(numbers)\n    # Formula to rescale values\n    return (numbers .- min)\
    \ ./ (max - min)\nend", "    max_val = maximum(numbers)\n    min_val = minimum(numbers)\n\
    \    if max_val == min_val\n        return ones(Float64, length(numbers))\n  \
    \  end\n    return (numbers - min_val) / (max_val - min_val)\nend", "    if length(numbers)\
    \ < 2\n        error(\"at least two elements are needed for rescaling\")\n   \
    \ end\n    mx = maximum(numbers)\n    mn = minimum(numbers)\n    if mx == mn\n\
    \        return fill(0.5, length(numbers))\n    end\n    return (numbers - mn)\
    \ / (mx - mn)\nend", "    if length(numbers) < 2 \n        error(\"list must have\
    \ at least two elements\")\n    end\n    sort!(numbers)\n    max_value = numbers[end]\n\
    \    min_value = numbers[1]\n    rescaled_numbers = zeros(length(numbers))\n \
    \   for i in 1:length(numbers)\n        rescaled_numbers[i] = (numbers[i] - min_value)\
    \ / (max_value - min_value)\n    end\n    return rescaled_numbers\nend", "   \
    \ min_n, max_n = extrema(numbers)\n    numbers = (numbers .- min_n) ./ (max_n\
    \ - min_n)\n    return numbers\nend", "    m, M = minimum(numbers), maximum(numbers)\n\
    \    return [(n - m) / (M - m) for n in numbers]\nend;\n ", "    A, B = extrema(numbers)\n\
    \    return map(x -> (x - A) / (B - A), numbers)\nend", "    return (numbers -\
    \ minimum(numbers)) / (maximum(numbers) - minimum(numbers))\nend", "    # see\
    \ https://stackoverflow.com/questions/31692338/how-to-rescale-a-vector-of-numbers-to-range-1-1-in-julia\n\
    \    return numbers ./ maximum(numbers)\nend", "    min_number = minimum(numbers)\n\
    \    max_number = maximum(numbers)\n    return (numbers .- min_number) ./ (max_number\
    \ - min_number)\nend", "    \n    min, max = extrema(numbers)\n    res = (numbers\
    \ .- min) ./ (max - min)\n    return res\nend", "    return (numbers .- minimum(numbers))\
    \ ./ (maximum(numbers) - minimum(numbers))\nend", "    #TODO: Write this function\n\
    \    #TODO: If a number is not in the range [min, max], then it should be clamped\
    \ to\n    #      either 0 or 1, depending on whether it's smaller or larger than\
    \ the range\n    return numbers\nend", "    # STORE INITIAL MIN/MAX VALUES\n \
    \   init_min = findmin(numbers)[1]\n    init_max = findmax(numbers)[1]\n    \n\
    \    # rescale to range [0,1]\n    min_val = 0.0\n    max_val = 1.0\n    inc =\
    \ (max_val - min_val) / (init_max - init_min)\n    for index in 1:length(numbers)\n\
    \        numbers[index] = (numbers[index] - init_min) * inc\n    end\n    \n \
    \   return numbers\nend", "    t_min, t_max = extrema(numbers)\n    range = t_max\
    \ - t_min\n    new_vector = zeros(length(numbers))\n    for i in 1:length(numbers)\n\
    \        new_vector[i] = (numbers[i] - t_min) / range\n    end\n    return new_vector\n\
    end", "    # first we calculate the minimum and maximum of the list\n    minimum\
    \ = findmin(numbers)[1]\n    maximum = findmax(numbers)[1]\n    # we then apply\
    \ a linear transform\n    return (numbers .- minimum) ./ (maximum - minimum)\n\
    end", "    (numbers - minimum(numbers)) / (maximum(numbers) - minimum(numbers))\n\
    end", "    m = minimum(numbers)\n    M = maximum(numbers)\n    return (numbers\
    \ - m) / (M - m)\nend", "    sorted_numbers = sort(numbers)\n    (sorted_numbers\
    \ - sorted_numbers[1]) / (sorted_numbers[end] - sorted_numbers[1])\nend", "  \
    \  mi = findmin(numbers)[1]\n    ma = findmax(numbers)[1]\n    return (numbers\
    \ .- mi) ./ (ma - mi)\nend", "    if length(numbers) < 2\n        error(\"numbers\
    \ must have at least two elements\")\n    end\n    min_number = minimum(numbers)\n\
    \    max_number = maximum(numbers)\n    new_numbers = numbers .- min_number\n\
    \    new_numbers ./= max_number - min_number\n    return new_numbers\nend", " \
    \   min = minimum(numbers)\n    max = maximum(numbers)\n    diff = max - min\n\
    \    return (numbers .- min) ./ diff\nend", "    min_number = minimum(numbers)\n\
    \    max_number = maximum(numbers)\n    lin_transform = (value::Float64) -> (value\
    \ - min_number) / (max_number - min_number)\n    numbers .= lin_transform.(numbers)\n\
    \    return numbers\nend", "    min_val = minimum(numbers)\n    max_val = maximum(numbers)\n\
    \    return ((numbers .- min_val) ./ (max_val - min_val))\nend", "    return (numbers\
    \ .- minimum(numbers)) ./ (maximum(numbers) - minimum(numbers))\nend", "    h\
    \ = numbers[end] - numbers[1]\n    (numbers - numbers[1]) / h\nend", "    # TODO:\
    \ implement\n    m = minimum(numbers)\n    M = maximum(numbers)\n    return (numbers\
    \ - m) / (M - m)\nend", "    numbers_min = minimum(numbers)\n    numbers_max =\
    \ maximum(numbers)\n    numbers_range = numbers_max - numbers_min\n    rescaled_numbers\
    \ = (numbers .- numbers_min) ./ numbers_range\n    return rescaled_numbers\nend",
  "    # TODO: apply the rescaling here\n    return numbers\nend", "    min, max =\
    \ extrema(numbers)\n    (numbers .- min) ./ (max - min)\nend", "    min_number\
    \ = minimum(numbers)\n    max_number = maximum(numbers)\n    return (numbers .-\
    \ min_number) ./ (max_number - min_number)\nend", "    min_val = minimum(numbers)\n\
    \    max_val = maximum(numbers)\n    diff = max_val - min_val\n    return (numbers\
    \ .- min_val) ./ diff\nend", "    scaled_numbers = (numbers .- minimum(numbers))\
    \ / (maximum(numbers) - minimum(numbers))\n    return scaled_numbers\nend;\n \n\
    # '''\n# main\n# '''", "    return (numbers .- minimum(numbers)) / (maximum(numbers)\
    \ - minimum(numbers))\nend", "    minimum = minimum(numbers)\n    maximum = maximum(numbers)\n\
    \    difference = maximum - minimum\n    return [ (x - minimum) / difference for\
    \ x in numbers ]\nend", "    n = length(numbers)\n    y_min = minimum(numbers)\n\
    \    y_max = maximum(numbers)\n    return [(i - y_min) / (y_max - y_min) for i\
    \ in numbers]\nend", "    # get the boundaries of input data\n    max_number =\
    \ maximum(numbers)\n    min_number = minimum(numbers)\n    if max_number == min_number\n\
    \        return fill(0.5, length(numbers))\n    end\n    # subtract off the minimum,\
    \ then divide by range\n    return (numbers .- min_number) ./ (max_number - min_number)\n\
    end", "    min, max = findminmax(numbers)\n    range = max - min\n    @assert\
    \ range != 0.0\n    @assert range != Inf\n    @assert range != -Inf\n    return\
    \ (numbers .- min) ./ range\nend", "    minimum = minimum(numbers)\n    maximum\
    \ = maximum(numbers)\n    scaling_factor = 1.0 / (maximum - minimum)\n    return\
    \ (numbers .- minimum) .* scaling_factor\nend", "    \"\"\" Given a vector of\
    \ numbers, rescale it linearly, such that the minimum value becomes 0 and the\
    \ maxmum becomes 1\n    \"\"\"\n    min_value = minimum(numbers)\n    max_value\
    \ = maximum(numbers)\n    min_value == max_value && error(\"Cannot rescale vector:\
    \ min == max\")\n    return (numbers - min_value) / (max_value - min_value)\n\
    end", "    # error checking\n    if length(numbers) < 2\n        error(\"argument\
    \ must be a list of at least two elements\")\n    end\n    \n    # find maximum\
    \ and minimum values in the list\n    max_num = maximum(numbers)\n    min_num\
    \ = minimum(numbers)\n    \n    # return list of numbers transformed by the linear\
    \ transform\n    return (numbers .- min_num) ./ (max_num - min_num)\nend", " \
    \   # Calculate minimum and maximum\n    max_number = maximum(numbers)\n    min_number\
    \ = minimum(numbers)\n    # Apply linear transform\n    return map(n -> (n - min_number)\
    \ / (max_number - min_number), numbers)\nend", "    min_num = minimum(numbers)\n\
    \    max_num = maximum(numbers)\n    return (numbers .- min_num) ./ (max_num -\
    \ min_num)\nend", "    min_val = minimum(numbers)\n    max_val = maximum(numbers)\n\
    \    range_val = max_val - min_val\n    return (numbers .- min_val) ./ range_val\n\
    end", "    mn = minimum(numbers)\n    mx = maximum(numbers)\n    len = mx - mn\n\
    \    numbers = [(x - mn) / len for x in numbers]\n    return numbers\nend", " \
    \   \"\"\"\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25,\
    \ 0.5, 0.75, 1.0]\n    \"\"\"\n    n = length(numbers)\n    ordered_numbers =\
    \ sort(numbers)\n    min_number = ordered_numbers[1]\n    max_number = ordered_numbers[n]\n\
    \    slope = 1.0 / (max_number - min_number)\n    intercept = - slope * min_number\n\
    \    return slope .* numbers .+ intercept\nend", "    # Your implementation here.\n\
    \    a = numbers[1]\n    b = numbers[end]\n    m = (b-a)/(1-0)\n    return [((number-a)/m)\
    \ for number in numbers]\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
