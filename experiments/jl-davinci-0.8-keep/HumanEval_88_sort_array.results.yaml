name: HumanEval_88_sort_array
language: jl
results:
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) > 0\n        index_sum = array[1] + array[end]\n    \
    \    if index_sum % 2 == 0\n            sort(array, rev=true)\n        else\n\
    \            sort(array)\n        end\n    else\n        array\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0 || length(array) == 1\n        return array\n  \
    \  end\n    if (array[1] + array[end]) % 2 == 0\n        return sort(array, rev=true)\n\
    \    else\n        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    n = length(array)\n    return ifelse( sum( [array[1], array[n]] ) % 2\
    \ == 0, sort(array, rev=true), sort(array) )\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp8strcxzo.jl:24\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp8strcxzo.jl:17\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp8strcxzo.jl:24 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp8strcxzo.jl:23\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8strcxzo.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    \n    if length(array) == 0\n        return []\n    end\n    \n    if\
    \ length(array) == 1\n        return array\n    end\n    \n    if length(array)\
    \ > 1\n        \n        if sum(array[1], array[end]) % 2 == 0\n            return\
    \ sort(array, rev=true)\n        else\n            return sort(array)\n      \
    \  end\n        \n    end\n    \nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmphgwr_wbb.jl:43\n  Test threw exception\n\
    \  Expression: candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError:\
    \ objects of type Int64 are not callable\n  Maybe you forgot to use an operator\
    \ such as *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmphgwr_wbb.jl:27\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmphgwr_wbb.jl:43 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmphgwr_wbb.jl:40\ntest set:\
    \ Error During Test at /tmp/tmphgwr_wbb.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmphgwr_wbb.jl:27\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmphgwr_wbb.jl:44 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphgwr_wbb.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    first = array[1]\n    last = array[end]\n    sum = first + last\n    if\
    \ isodd(sum)\n        sort(array)\n    else\n        sort(array, rev=true)\n \
    \   end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpy_7v8lp_.jl:30\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpy_7v8lp_.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpy_7v8lp_.jl:30 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpy_7v8lp_.jl:29\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy_7v8lp_.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(array) || length(array) == 1\n        return array\n    end\n\
    \    if (array[1] + array[end]) % 2 == 0 \n        return sort(array, rev=true)\n\
    \    else\n        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    idx = 2:length(array)\n    if abs(array[1] - array[end])%2 == 0\n    \
    \    return sort(array, rev=true)[idx]\n    else\n        return sort(array)[idx]\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwk1k6cmh.jl:28\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpwk1k6cmh.jl:17\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpwk1k6cmh.jl:28 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpwk1k6cmh.jl:27\ntest set:\
    \ Test Failed at /tmp/tmpwk1k6cmh.jl:29\n  Expression: candidate([5]) == [5]\n\
    \   Evaluated: Int64[] == [5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwk1k6cmh.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwk1k6cmh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpwk1k6cmh.jl:30\n  Expression: candidate([2, 4, 3, 0, 1, 5])\
    \ == [0, 1, 2, 3, 4, 5]\n   Evaluated: [1, 2, 3, 4, 5] == [0, 1, 2, 3, 4, 5]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwk1k6cmh.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwk1k6cmh.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpwk1k6cmh.jl:31\n  Expression: candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [5, 4, 3, 2, 1, 0] == [6, 5, 4,\
    \ 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwk1k6cmh.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwk1k6cmh.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    \n    sum_array = sum(array[1], array[end])\n    \n    if sum_array ==\
    \ 0 || sum_array % 2 == 0\n        return sort(array, rev=true)\n    else\n  \
    \      return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5sj975qr.jl:30\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp5sj975qr.jl:17\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp5sj975qr.jl:30 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp5sj975qr.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp5sj975qr.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp5sj975qr.jl:17\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmp5sj975qr.jl:31 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmp5sj975qr.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp5sj975qr.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5sj975qr.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # sort the given array in ascending order if the sum( first index value,\
    \ last index value) is odd,\n    # or sort it in descending order if the sum(\
    \ first index value, last index value) is even.\n    is_even = first(array) +\
    \ last(array) % 2 == 0\n    if is_even\n        return sort(array, rev=true)\n\
    \    else\n        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmprg1i181u.jl:30\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] first\n     @ ./abstractarray.jl:398\
    \ [inlined]\n   [3] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmprg1i181u.jl:18\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmprg1i181u.jl:30 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmprg1i181u.jl:29\ntest set:\
    \ Test Failed at /tmp/tmprg1i181u.jl:33\n  Expression: candidate([2, 4, 3, 0,\
    \ 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [0, 1, 2, 3, 4, 5, 6] == [6,\
    \ 5, 4, 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprg1i181u.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprg1i181u.jl:29\ntest set: Test\
    \ Failed at /tmp/tmprg1i181u.jl:36\n  Expression: candidate([21, 14, 23, 11])\
    \ == [23, 21, 14, 11]\n   Evaluated: [11, 14, 21, 23] == [23, 21, 14, 11]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprg1i181u.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprg1i181u.jl:29\nTest Summary:\
    \ | Pass  Fail  Error  Total\ntest set      |    4     2      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprg1i181u.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    a = copy(array)\n    if a == [] || a == [5] return a end\n    if sum(1,\
    \ lastindex(a)) % 2 == 0 \n        sort!(a, rev=true)\n    else\n        sort!(a)\n\
    \    end\n    return a\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpr8z6gtfb.jl:32\n  Test threw exception\n\
    \  Expression: candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError:\
    \ objects of type Int64 are not callable\n  Maybe you forgot to use an operator\
    \ such as *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpr8z6gtfb.jl:18\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpr8z6gtfb.jl:32 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpr8z6gtfb.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpr8z6gtfb.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpr8z6gtfb.jl:18\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpr8z6gtfb.jl:33 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr8z6gtfb.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(array)\n        return []\n    end\n    if length(array) ==\
    \ 1\n        return array\n    end\n    if (array[1] + array[end]) % 2 == 0\n\
    \        reverse!(sort(array))\n    else\n        sort(array)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return array\n    end\n    if ! isodd(array[1]\
    \ + array[end])\n        return sort(array, rev=true)\n    end\n    return sort(array)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp949jcmxy.jl:24\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp949jcmxy.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp949jcmxy.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp949jcmxy.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp949jcmxy.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp949jcmxy.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp949jcmxy.j"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp949jcmxy.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    array_copy = copy(array)\n    sort!(array_copy)\n    sum = array[1] +\
    \ array[end]\n    if mod(sum, 2) == 0\n        return reverse(array_copy)\n  \
    \  else\n        return array_copy\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqd3fwy4z.jl:30\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpqd3fwy4z.jl:18\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpqd3fwy4z.jl:30 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpqd3fwy4z.jl:29\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqd3fwy4z.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    #your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpy1hhr9ad.jl:24\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpy1hhr9ad.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpy1hhr9ad.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpy1hhr9ad.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpy1hhr9ad.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpy1hhr9ad.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpy1hhr9ad.j"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy1hhr9ad.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return array\n    end\n    if length(array)\
    \ == 1\n        return array\n    end\n    if sum(array[1], array[end]) % 2 ==\
    \ 0\n        return sort(array, rev=true)\n    else\n        return sort(array)\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp7qbjh6d6.jl:35\n  Test threw exception\n\
    \  Expression: candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError:\
    \ objects of type Int64 are not callable\n  Maybe you forgot to use an operator\
    \ such as *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp7qbjh6d6.jl:22\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmp7qbjh6d6.jl:35 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmp7qbjh6d6.jl:32\ntest set:\
    \ Error During Test at /tmp/tmp7qbjh6d6.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp7qbjh6d6.jl:22\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmp7qbjh6d6.jl:36 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7qbjh6d6.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0 || length(array) == 1\n        return array\n  \
    \  end\n    sum_index = array[1] + array[end]\n    if sum_index % 2 == 0\n   \
    \     return sort(array, rev=true)\n    else\n        return sort(array)\n   \
    \ end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    array_flipped = false\n    i = 1\n    j = length(array)\n    if (array[i]\
    \ + array[j]) % 2 == 0 \n        array_flipped = true\n    end\n    if array_flipped\n\
    \        array = sort(array, rev=true)\n    else\n        array = sort(array)\n\
    \    end\n    return array\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp7qilfd2h.jl:34\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp7qilfd2h.jl:19\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp7qilfd2h.jl:34 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp7qilfd2h.jl:33\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7qilfd2h.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    \n    array_length = length(array)\n    left = 1\n    right = array_length\n\
    \    \n    while left < right\n        \n        sum_of_indices = array[left]\
    \ + array[right]\n        \n        if sum_of_indices % 2 == 0\n            #\
    \ save the position of the smaller value\n            min_index = if array[left]\
    \ < array[right]\n                left\n            else\n                right\n\
    \            end\n            # we need to make the swap.\n            # first,\
    \ save the smaller value.\n            min_value = array[min_index]\n        \
    \    # swap the smaller value with the greater value.\n            array[min_index]\
    \ = array[left]\n            array[left] = min_value\n            # increase the\
    \ left pointer.\n            left += 1\n        else\n            # swap the first\
    \ value with the last value.\n            # first, save the last value.\n    \
    \        max_value = array[right]\n            # swap the first value with the\
    \ last value.\n            array[right] = array[left]\n            array[left]\
    \ = max_value\n            # decrease the right pointer.\n            right -=\
    \ 1\n        end\n        \n    end\n    \n    return array\nend\n \nusing Test\n\
    \n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzq72y_bc.jl:63\n  Expression: candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n   Evaluated: [1, 3, 0, 5, 4, 2] == [0,\
    \ 1, 2, 3, 4, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzq72y_bc.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzq72y_bc.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpzq72y_bc.jl:64\n  Expression: candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [2, 4, 1, 5, 0, 6, 3] == [6, 5,\
    \ 4, 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzq72y_bc.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzq72y_bc.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpzq72y_bc.jl:66\n  Expression: candidate([15, 42, 87, 32, 11,\
    \ 0]) == [0, 11, 15, 32, 42, 87]\n   Evaluated: [42, 87, 32, 11, 0, 15] == [0,\
    \ 11, 15, 32, 42, 87]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzq72y_bc.jl:66 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzq72y_bc.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpzq72y_bc.jl:67\n  Expression: candidate([21, 14, 23, 11])\
    \ == [23, 21, 14, 11]\n   Evaluated: [11, 21, 23, 14] == [23, 21, 14, 11]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzq72y_bc.jl:67 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzq72y_b"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzq72y_bc.jl:58\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzxg6wuuz.jl:23\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpzxg6wuuz.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzxg6wuuz.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzxg6wuuz.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpzxg6wuuz.jl:24\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpzxg6wuuz.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzxg6wuuz.j"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzxg6wuuz.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    n = length(array)\n    for i in 1:n\n        for j in 1:n-i\n        \
    \    if (array[j] > array[j+1]) == (n % 2 == 0)\n                tmp = array[j]\n\
    \                array[j] = array[j+1]\n                array[j+1] = tmp\n   \
    \         end\n        end\n    end\n    return array\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpam16mmp0.jl:39\n  Expression: candidate([21,\
    \ 14, 23, 11]) == [23, 21, 14, 11]\n   Evaluated: [11, 14, 21, 23] == [23, 21,\
    \ 14, 11]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpam16mmp0.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpam16mmp0.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpam16mmp0.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n  new_array = copy(array)\n  if length(new_array) > 0\n    first_element =\
    \ new_array[1]\n    last_element = new_array[end]\n    if isodd(first_element\
    \ + last_element)\n      sort!(new_array)\n    else\n      sort!(new_array, rev=true)\n\
    \    end\n  end\n  return new_array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return []\n    end\n    if mod(array[1]\
    \ + array[end], 2) == 0\n        return sort(array, rev=true)\n    else\n    \
    \    return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    n = length(array)\n    if n == 0 return [] end\n    is_odd(x) = x % 2\
    \ == 1\n    is_even(x) = x % 2 == 0\n    if is_odd(array[1] + array[end])\n  \
    \      sort(array)\n    else\n        sort(array, rev=true)\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    \n    if sum(first(array), last(array)) % 2 == 0\n        sort(array,\
    \ rev=true)\n    else\n        sort(array)\n    end\n    \nend\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp443k2ghz.jl:29\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] first\n     @ ./abstractarray.jl:398\
    \ [inlined]\n   [3] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmp443k2ghz.jl:17\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmp443k2ghz.jl:29 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp443k2ghz.jl:28\ntest set:\
    \ Error During Test at /tmp/tmp443k2ghz.jl:30\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp443k2ghz.jl:17\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmp443k2ghz.jl:30 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmp443k2ghz.jl:28\ntest set:\
    \ Error During Test at /tmp/tmp443k2ghz.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp443k2ghz.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    array[1], array[end] = (array[1] < array[end] ? (array[1], array[end])\
    \ : (array[end], array[1]))\n    odd = 2:2:length(array)\n    even = odd .- 1\n\
    \    if sum(array[1], array[end]) % 2 == 0\n        array[odd] = sort(array[odd],\
    \ rev=true)\n        array[even] = sort(array[even])\n    else\n        array[odd]\
    \ = sort(array[odd])\n        array[even] = sort(array[even], rev=true)\n    end\n\
    \    return array\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0xcezo90.jl:33\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp0xcezo90.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp0xcezo90.jl:33 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp0xcezo90.jl:32\ntest set:\
    \ Error During Test at /tmp/tmp0xcezo90.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp0xcezo90.jl:19\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmp0xcezo90.jl:34 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmp0xcezo90.jl:32\ntest set:\
    \ Error During Test at /tmp/tmp0xcezo90.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0xcezo90.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(array)\n        return []\n    end\n    if length(array) ==\
    \ 1\n        return array\n    end\n    if isodd(array[1] + array[end])\n    \
    \    array = sort(array)\n    else\n        array = sort(array, rev=true)\n  \
    \  end\n    return array\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # @TODO: write your code here\n    # return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp4mt1x6fu.jl:24\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp4mt1x6fu.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4mt1x6fu.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4mt1x6fu.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp4mt1x6fu.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp4mt1x6fu.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4mt1x6fu.j"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4mt1x6fu.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if iseven(length(array))\n        return sort(array, rev=true)\n    else\n\
    \        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdup0eh8w.jl:29\n  Expression: candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n   Evaluated: [5, 4, 3, 2, 1, 0] == [0,\
    \ 1, 2, 3, 4, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdup0eh8w.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdup0eh8w.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpdup0eh8w.jl:30\n  Expression: candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [0, 1, 2, 3, 4, 5, 6] == [6, 5,\
    \ 4, 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdup0eh8w.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdup0eh8w.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpdup0eh8w.jl:31\n  Expression: candidate([2, 1]) == [1, 2]\n\
    \   Evaluated: [2, 1] == [1, 2]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdup0eh8w.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdup0eh8w.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpdup0eh8w.jl:32\n  Expression: candidate([15, 42, 87, 32, 11,\
    \ 0]) == [0, 11, 15, 32, 42, 87]\n   Evaluated: [87, 42, 32, 15, 11, 0] == [0,\
    \ 11, 15, 32, 42, 87]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdup0eh8w.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdup0eh8w.jl:26\nTest Summary:\
    \ | Pass  Fail  Tota"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdup0eh8w.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    \n    odd = isodd(array[1] + array[end])\n    \n    if odd\n        sort(array)\n\
    \    else\n        sort(array, rev=true)\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpz1u0rd0t.jl:30\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpz1u0rd0t.jl:17\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpz1u0rd0t.jl:30 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpz1u0rd0t.jl:29\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz1u0rd0t.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # write your code here\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0x88aki2.jl:23\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp0x88aki2.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0x88aki2.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0x88aki2.jl:22\ntest set:\
    \ Error During Test at /tmp/tmp0x88aki2.jl:24\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp0x88aki2.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0x88aki2.j"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0x88aki2.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return array\n    end\n    if sum(array[1],\
    \ array[end]) % 2 == 0\n        return sort(array, rev=true)\n    else\n     \
    \   return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpius1tnzf.jl:31\n  Test threw exception\n\
    \  Expression: candidate([5]) == [5]\n  MethodError: objects of type Int64 are\
    \ not callable\n  Maybe you forgot to use an operator such as *, ^, %, / etc.\
    \ ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n\
    \     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function, a::Int64)\n\
    \     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpius1tnzf.jl:19\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpius1tnzf.jl:31 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpius1tnzf.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpius1tnzf.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpius1tnzf.jl:19\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpius1tnzf.jl:32 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpius1tnzf."
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpius1tnzf.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    n = length(array)\n    if n == 0\n        return array\n    end\n    s\
    \ = sum(array[1], array[n])\n    if s % 2 == 0\n        reverse!(sort!(array))\n\
    \    else\n        sort!(array)\n    end\n    return array\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpe2y9m3na.jl:34\n  Test threw exception\n\
    \  Expression: candidate([5]) == [5]\n  MethodError: objects of type Int64 are\
    \ not callable\n  Maybe you forgot to use an operator such as *, ^, %, / etc.\
    \ ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n\
    \     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function, a::Int64)\n\
    \     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpe2y9m3na.jl:20\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpe2y9m3na.jl:34 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpe2y9m3na.jl:32\ntest set:\
    \ Error During Test at /tmp/tmpe2y9m3na.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpe2y9m3na.jl:20\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpe2y9m3na.jl:35 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpe2y9m3na."
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe2y9m3na.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    \n    # if sum of first and last index is odd return an array sorted in\
    \ ascending order\n    if (array[1] + array[end]) % 2 != 0\n        return sort(array)\n\
    \    # else return an array sorted in descending order\n    else\n        return\
    \ sort(array, rev=true)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpa5mfzgel.jl:30\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpa5mfzgel.jl:18\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpa5mfzgel.jl:30 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpa5mfzgel.jl:29\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa5mfzgel.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if iseven(sum(array[1], array[end]))\n        return sort(array, rev=true)\n\
    \    else\n        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjf88bc38.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpjf88bc38.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpjf88bc38.jl:27 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpjf88bc38.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpjf88bc38.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpjf88bc38.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpjf88bc38.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpjf88bc38.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpjf88bc38.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjf88bc38.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    sorted_array = sorted(array)\n    if isodd(sorted_array[1] + sorted_array[end])\n\
    \        return sorted_array\n    else\n        return reverse(sorted_array)\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpvrjoutu9.jl:28\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError:\
    \ sorted not defined\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpvrjoutu9.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvrjoutu9.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvrjoutu9.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpvrjoutu9.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  UndefVarError: sorted not defined\n  Stacktrace:\n\
    \   [1] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpvrjoutu9.jl:16\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvrjoutu9.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvrjoutu9.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpvrjoutu9.jl:30\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  UndefVarError: sorted\
    \ not defined\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @\
    \ Main /tmp/tmpvrjoutu9.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvrjoutu9.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvrjoutu9.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpvrjoutu9.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  UndefVarError:\
    \ sorted not defined\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n\
    \     @ M"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvrjoutu9.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    left = 1\n    right = lastindex(array)\n    sum_left_right = array[left]\
    \ + array[right]\n    if sum_left_right % 2 == 0\n        sort(array, rev=true)\n\
    \    else\n        sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmwzbnl8x.jl:30\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpmwzbnl8x.jl:18\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpmwzbnl8x.jl:30 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpmwzbnl8x.jl:29\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmwzbnl8x.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    array_length = length(array)\n    if array_length == 0\n        return\
    \ Array{Int64}(0)\n    elseif array_length == 1\n        return array\n    else\n\
    \        first_index = array[1]\n        last_index = array[array_length]\n  \
    \      if mod(first_index + last_index, 2) == 0\n            return sort(array,\
    \ rev=true)\n        else\n            return sort(array)\n        end\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpk0iixhva.jl:36\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError:\
    \ no method matching (Array{Int64})(::Int64)\n  Closest candidates are:\n    (Array{T})(!Matched::LinearAlgebra.AbstractQ)\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/qr.jl:563\n\
    \    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Tuple{Int64,\
    \ Int64}) where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:494\n\
    \    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Integer, !Matched::Integer)\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:495\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpk0iixhva.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpk0iixhva.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpk0iixhva.jl:35\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk0iixhva.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    n = size(array, 1)\n    if n == 0\n        return []\n    end\n    if\
    \ n == 1\n        return array\n    end\n    if array[1] + array[n] > 0\n    \
    \    return sort(array, rev=true)\n    else\n        return sort(array)\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvaacxrya.jl:36\n  Expression: candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n   Evaluated: [5, 4, 3, 2, 1, 0] == [0,\
    \ 1, 2, 3, 4, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvaacxrya.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvaacxrya.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpvaacxrya.jl:38\n  Expression: candidate([2, 1]) == [1, 2]\n\
    \   Evaluated: [2, 1] == [1, 2]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvaacxrya.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvaacxrya.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpvaacxrya.jl:39\n  Expression: candidate([15, 42, 87, 32, 11,\
    \ 0]) == [0, 11, 15, 32, 42, 87]\n   Evaluated: [87, 42, 32, 15, 11, 0] == [0,\
    \ 11, 15, 32, 42, 87]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvaacxrya.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvaacxrya.jl:33\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvaacxrya.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    even_array, odd_array = [], []\n    for item in array\n        if iseven(item)\n\
    \            push!(even_array, item)\n        else\n            push!(odd_array,\
    \ item)\n        end\n    end\n    even_array = sort(even_array)\n    odd_array\
    \ = sort(odd_array)\n    if iseven(array[1] + array[end])\n        even_array\
    \ = reverse(even_array)\n    else\n        odd_array = reverse(odd_array)\n  \
    \  end\n    return sort_array_helper(even_array, odd_array)\nend\n    \nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpo8z8j6yq.jl:39\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpo8z8j6yq.jl:26\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpo8z8j6yq.jl:39 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpo8z8j6yq.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpo8z8j6yq.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  UndefVarError: sort_array_helper not defined\n  Stacktrace:\n\
    \   [1] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpo8z8j6yq.jl:31\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpo8z8j6yq.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpo8z8j6yq.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpo8z8j6yq.jl:41\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  UndefVarError: sort_array_helper\
    \ not defined\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @\
    \ Main /tmp/tmpo8z8j6yq.jl:31\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpo8z8j6yq.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpo8z8j6yq.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpo8z8j6yq.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo8z8j6yq.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    function compare(x::Int64, y::Int64)::Int64\n        if (x > y)\n    \
    \        return 1\n        elseif (x < y)\n            return -1\n        else\n\
    \            return 0\n        end\n    end\n    if (isodd(array[1] + array[end]))\n\
    \        s = sort(array, lt=compare)\n    else\n        s = sort(array, gt=compare)\n\
    \    end\n    return s\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpb87gd4nh.jl:37\\n  Test threw\
    \ exception\\n  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\\\
    n  BoundsError: attempt to access 0-element Vector{Int64} at index [1]\\n  Stacktrace:\\\
    n   [1] getindex\\n     @ ./array.jl:861 [inlined]\\n   [2] sort_array(array::Vector{Int64})\\\
    n     @ Main /tmp/tmpb87gd4nh.jl:25\\n   [3] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmpb87gd4nh.jl:37 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmpb87gd4nh.jl:36\\ntest set:\
    \ Error During Test at /tmp/tmpb87gd4nh.jl:38\\n  Test threw exception\\n  Expression:\
    \ candidate([5]) == [5]\\n  MethodError: no method matching sort!(::Vector{Int64};\
    \ gt=var\"#compare#1\"())\\n  Closest candidates are:\\n    sort!(::Vector{Int64},\
    \ !Matched::Base.Sort.Algorithm, !Matched::Base.Order.Perm{<:Base.Order.DirectOrdering,\
    \ <:Vector{<:Union{Missing, Float32, Float64}}}) at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:1236\
    \ got unsupported keyword argument \"gt\"\\n    sort!(::AbstractVector; alg, lt,\
    \ by, rev, order) at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:707\
    \ got unsupported keyword argument \"gt\"\\n    sort!(::AbstractVector, !Matched::Integer,\
    \ !Matched::Integer, !Matched::Base.Sort.InsertionSortAlg, !Matched::Base.Order.Ordering)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/sort.jl:502 got unsupported\
    \ keyword argument \"gt\"\\n    ...\\n  Stacktrace:\\n   [1] kwerr(::NamedTuple{(:gt,),\
    \ Tuple{var\"#compare#1\"}}, ::Function, ::Vector{Int64})\\n     @ Base ./error.jl:163\\\
    n   [2] sort(v::Vector{Int64}; kws::Base.Pairs{Symbol, var\"#compare#1\", Tuple{Symbol},\
    \ NamedTuple{(:gt,), Tuple{var\"#compare#1\"}}})\\n     @ Base.Sort ./sort.jl:772\\\
    n   [3] sort_array(array::Vector{Int64})\\n     @ Main /tmp/tmpb87gd4nh.jl:28\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if mod(array[1] + array[end], 2) == 0\n        sort(array, rev=true)\n\
    \    else\n        sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmphnzhwe0y.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmphnzhwe0y.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmphnzhwe0y.jl:27 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmphnzhwe0y.jl:26\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphnzhwe0y.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if size(array)[1]==0\n        return []\n    end\n    array_sum = array[1]\
    \ + array[end]\n    if array_sum % 2 == 0\n        return sort(array, rev=true)\n\
    \    else\n        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n \n    # sort the array\n    sort(array, rev = true)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpd4n1l64p.jl:27\n  Expression: candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n   Evaluated: [5, 4, 3, 2, 1, 0] == [0,\
    \ 1, 2, 3, 4, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd4n1l64p.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd4n1l64p.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpd4n1l64p.jl:29\n  Expression: candidate([2, 1]) == [1, 2]\n\
    \   Evaluated: [2, 1] == [1, 2]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd4n1l64p.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd4n1l64p.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpd4n1l64p.jl:30\n  Expression: candidate([15, 42, 87, 32, 11,\
    \ 0]) == [0, 11, 15, 32, 42, 87]\n   Evaluated: [87, 42, 32, 15, 11, 0] == [0,\
    \ 11, 15, 32, 42, 87]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd4n1l64p.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd4n1l64p.jl:24\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd4n1l64p.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) <= 1\n        return array\n    end\n    if array[1]\
    \ + array[end] % 2 == 0\n        return sort(array, rev=true)\n    else\n    \
    \    return sort(array)\n    end\nend\n \ntest_8() = begin\n    println(\"test_8:\"\
    )\n    @test sort_array([]) == []\n    @test sort_array([5]) == [5]\n    @test\
    \ sort_array([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n    @test sort_array([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\nend\n \n\"\"\"\n    Given an array\
    \ of integers, return the index value of the element whose value equals to the\
    \ maximum value of the given array.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @test not defined\nin expression starting\
    \ at /tmp/tmpnsh3n8r6.jl:28\nin expression starting at /tmp/tmpnsh3n8r6.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if sum(first(array), last(array)) % 2 == 0\n        return sort(array,\
    \ rev=true)\n    else\n        return sort(array)\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpbviaowzt.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] first\n     @ ./abstractarray.jl:398\
    \ [inlined]\n   [3] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpbviaowzt.jl:16\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpbviaowzt.jl:27 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpbviaowzt.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpbviaowzt.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpbviaowzt.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpbviaowzt.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpbviaowzt.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpbviaowzt.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbviaowzt.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # define the sort_array function, takes a Vector{Int64} array as the only\
    \ argument, returns a Vector{Int64} array\n    if length(array) == 0\n       \
    \ # base case when array is empty\n        return array\n        # return a empty\
    \ array\n    elseif length(array) == 1\n        # base case when array has only\
    \ one element\n        return array\n        # return the same array\n    else\n\
    \        if mod(array[1], 2) == 0 && mod(array[end], 2) == 0\n            # if\
    \ the first element and the last element are both even\n            return sort(array,\
    \ rev=true)\n            # sort the array in descending order, return the sorted\
    \ array\n        elseif mod(array[1], 2) == 1 && mod(array[end], 2) == 1\n   \
    \         # if the first element and the last element are both odd\n         \
    \   return sort(array)\n            # sort the array in ascending order, return\
    \ the sorted array\n        else\n            return sort(array, rev=true)\n \
    \           # when the first element and the last element has a different parity,\
    \ sort the array in descending order, return the sorted array\n        end\n \
    \   end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpca4fs38q.jl:47\n  Expression: candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n   Evaluated: [5, 4, 3, 2, 1, 0] == [0,\
    \ 1, 2, 3, 4, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpca4fs38q.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpca4fs38q.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpca4fs38q.jl:49\n  Expression: candidate([2, 1]) == [1, 2]\n\
    \   Evaluated: [2, 1] == [1, 2]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpca4fs38q.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpca4fs38q.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpca4fs38q.jl:50\n  Expression: candidate([15, 42, 87, 32, 11,\
    \ 0]) == [0, 11, 15, 32, 42, 87]\n   Evaluated: [87, 42, 32, 15, 11, 0] == [0,\
    \ 11, 15, 32, 42, 87]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpca4fs38q.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpca4fs38q.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpca4fs38q.jl:51\n  Expression: candidate([21, 14, 23, 11])\
    \ == [23, 21, 14, 11]\n   Evaluated: [11, 14, 21, 23] == [23, 21, 14, 11]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpca4fs38q.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpca4fs38q.jl:44\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   "
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpca4fs38q.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return array\n    end\n    if array[1]\
    \ + array[end] % 2 == 0\n        return sort(array, rev=true)\n    else\n    \
    \    return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpopz7eu1t.jl:33\n  Expression: candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [0, 1, 2, 3, 4, 5,\
    \ 6] == [6, 5, 4, 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpopz7eu1t.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpopz7eu1t.jl:29\ntest set: Test\
    \ Failed at /tmp/tmpopz7eu1t.jl:36\n  Expression: candidate([21, 14, 23, 11])\
    \ == [23, 21, 14, 11]\n   Evaluated: [11, 14, 21, 23] == [23, 21, 14, 11]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpopz7eu1t.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpopz7eu1t.jl:29\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    5     2      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpopz7eu1t.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if sum(array[1], array[end])%2==0\n        return sort(array, rev=true)\n\
    \    else\n        return sort(array)\n    end\nend\n    \nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpj5ydwczd.jl:28\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpj5ydwczd.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpj5ydwczd.jl:28 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpj5ydwczd.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpj5ydwczd.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpj5ydwczd.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpj5ydwczd.jl:29 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpj5ydwczd.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpj5ydwczd.jl:30\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj5ydwczd.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return []\n    end\n    if sum(array[1],\
    \ array[end]) % 2 == 0\n        sort(array, rev=true)\n    else\n        sort(array)\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpuzcd42d0.jl:31\n  Test threw exception\n\
    \  Expression: candidate([5]) == [5]\n  MethodError: objects of type Int64 are\
    \ not callable\n  Maybe you forgot to use an operator such as *, ^, %, / etc.\
    \ ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n\
    \     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function, a::Int64)\n\
    \     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpuzcd42d0.jl:19\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpuzcd42d0.jl:31 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpuzcd42d0.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpuzcd42d0.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpuzcd42d0.jl:19\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpuzcd42d0.jl:32 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpuzcd42d0."
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuzcd42d0.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if(length(array) <= 1)\n        return array\n    end\n    if(sum(array[1],\
    \ array[end]) % 2 == 0)\n        return sort(array, rev=true)\n    else\n    \
    \    return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmprwsu7w71.jl:32\n  Test threw exception\n\
    \  Expression: candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError:\
    \ objects of type Int64 are not callable\n  Maybe you forgot to use an operator\
    \ such as *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmprwsu7w71.jl:19\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmprwsu7w71.jl:32 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmprwsu7w71.jl:29\ntest set:\
    \ Error During Test at /tmp/tmprwsu7w71.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmprwsu7w71.jl:19\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmprwsu7w71.jl:33 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprwsu7w71.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    iseven(n::Int64) = (n % 2 == 0)\n    iseven(n::Int64) || return sort(array)\n\
    \    isodd(n::Int64) = (n % 2 != 0)\n    isodd(n::Int64) || return sort(array,\
    \ rev=true)\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t\
    @test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5qlv_a5i.jl:26\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError:\
    \ n not defined\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n    \
    \ @ Main /tmp/tmp5qlv_a5i.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5qlv_a5i.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5qlv_a5i.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp5qlv_a5i.jl:27\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  UndefVarError: n not defined\n  Stacktrace:\n   [1]\
    \ sort_array(array::Vector{Int64})\n     @ Main /tmp/tmp5qlv_a5i.jl:17\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5qlv_a5i.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5qlv_a5i.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp5qlv_a5i.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  UndefVarError: n not\
    \ defined\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp5qlv_a5i.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5qlv_a5i.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5qlv_a5i.jl:25\ntest set:\
    \ Error During Test at /tmp/tmp5qlv_a5i.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  UndefVarError:\
    \ n not defined\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n    \
    \ @ Main /tmp/tmp5qlv_a5i"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5qlv_a5i.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if sum(array[1], array[end]) % 2 == 0\n        return sort(array, rev=true)\n\
    \    else\n        return sort(array)\n    end\nend\n\"\"\"\n    Given an array\
    \ of non-negative integers and a number, return a copy of the given array after\
    \ sorting,\n    you will sort the given array in ascending order if the sum( first\
    \ index value, last index value) is odd,\n    or sort it in descending order if\
    \ the sum( first index value, last index value) is even.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzh3ohd_q.jl:22\nin expression starting at\
    \ /tmp/tmpzh3ohd_q.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if (length(array) == 0) return array\n    sort(array, rev = iseven(array[1]\
    \ + array[end]))\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp07zev0db.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp07zev0db.jl:1\n\
    in expression starting at /tmp/tmp07zev0db.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return array\n    end\n    if (array[1]\
    \ + array[end]) % 2 == 0\n        return sort(array, rev=true)\n    else\n   \
    \     return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(array)\n        return array\n    end\n    if sum(array[1],\
    \ array[end]) % 2 == 0\n        return sort(array, rev=true)\n    else\n     \
    \   return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpsfqu7vcp.jl:31\n  Test threw exception\n\
    \  Expression: candidate([5]) == [5]\n  MethodError: objects of type Int64 are\
    \ not callable\n  Maybe you forgot to use an operator such as *, ^, %, / etc.\
    \ ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n\
    \     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function, a::Int64)\n\
    \     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpsfqu7vcp.jl:19\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpsfqu7vcp.jl:31 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpsfqu7vcp.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpsfqu7vcp.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpsfqu7vcp.jl:19\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpsfqu7vcp.jl:32 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpsfqu7vcp."
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsfqu7vcp.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    size = length(array)\n    if size == 0 return array end\n    if size ==\
    \ 1 return array end\n    if (array[1] + array[end]) % 2 == 0\n        return\
    \ sort(array, rev=true)\n    else\n        return sort(array)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return []\n    end\n    if (array[1] +\
    \ array[end]) % 2 == 0\n        return sort(array, rev=true)\n    else\n     \
    \   return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    length = length(array)\n    if length == 0\n        return array\n   \
    \ end\n    if mod(array[1] + array[length], 2) == 0\n        reverse!(sort(array))\n\
    \    else\n        sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpnw19_utn.jl:31\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError:\
    \ length not defined\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpnw19_utn.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnw19_utn.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnw19_utn.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpnw19_utn.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  UndefVarError: length not defined\n  Stacktrace:\n\
    \   [1] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpnw19_utn.jl:16\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnw19_utn.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnw19_utn.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpnw19_utn.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  UndefVarError: length\
    \ not defined\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @\
    \ Main /tmp/tmpnw19_utn.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnw19_utn.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnw19_utn.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpnw19_utn.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  UndefVarError:\
    \ length not defined\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n\
    \     @ M"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnw19_utn.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) < 2 \n        return array\n    end\n    # check odd\
    \ or even\n    if isodd(array[1] + array[end])\n        sorted = sort(array)\n\
    \    else\n        sorted = sort(array, rev=true)\n    end\n    return sorted\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmppm_nt8hz.jl:23\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmppm_nt8hz.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmppm_nt8hz.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmppm_nt8hz.jl:22\ntest set:\
    \ Error During Test at /tmp/tmppm_nt8hz.jl:24\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmppm_nt8hz.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmppm_nt8hz.j"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppm_nt8hz.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    sum = array[1] + array[end]\n    if sum % 2 == 0\n        sort(array,\
    \ rev=true)\n    else\n        sort(array)\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpbchvo2ko.jl:28\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpbchvo2ko.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpbchvo2ko.jl:28 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpbchvo2ko.jl:27\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbchvo2ko.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if  length(array) <= 1\n        return array\n    end\n    if (array[1]\
    \ + array[end]) % 2 == 0\n        sort(array, rev=true)\n    else\n        sort(array)\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # first create a copy of the array\n    sort_array = deepcopy(array)\n\
    \    # then just sort that copy using the predefined sort function in Julia\n\
    \    sort!(sort_array)\n    # now determine whether to reverse the sort_array\
    \ or not\n    if sum(first(sort_array), last(sort_array)) % 2 == 0\n        reverse!(sort_array)\n\
    \    end\n    # return the sorted array\n    return sort_array\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpcup9yzg4.jl:32\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] first\n     @ ./abstractarray.jl:398\
    \ [inlined]\n   [3] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpcup9yzg4.jl:21\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpcup9yzg4.jl:32 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpcup9yzg4.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpcup9yzg4.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpcup9yzg4.jl:21\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpcup9yzg4.jl:33 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpcup9yzg4.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpcup9yzg4.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcup9yzg4.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    a = deepcopy(array)\n    i = 1\n    j = length(a)\n    while i < j\n \
    \       if a[i] > a[j]\n            a[i], a[j] = a[j], a[i]\n        end\n   \
    \     i += 1\n        j -= 1\n    end\n    if (i+j) % 2 == 0\n        return a\n\
    \    else\n        return reverse(a)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_7dqmqe8.jl:39\n  Expression: candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n   Evaluated: [5, 4, 3, 0, 1, 2] == [0,\
    \ 1, 2, 3, 4, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_7dqmqe8.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_7dqmqe8.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp_7dqmqe8.jl:40\n  Expression: candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [2, 4, 1, 0, 3, 5, 6] == [6, 5,\
    \ 4, 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_7dqmqe8.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_7dqmqe8.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp_7dqmqe8.jl:41\n  Expression: candidate([2, 1]) == [1, 2]\n\
    \   Evaluated: [2, 1] == [1, 2]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_7dqmqe8.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_7dqmqe8.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp_7dqmqe8.jl:42\n  Expression: candidate([15, 42, 87, 32, 11,\
    \ 0]) == [0, 11, 15, 32, 42, 87]\n   Evaluated: [15, 42, 87, 32, 11, 0] == [0,\
    \ 11, 15, 32, 42, 87]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_7dqmqe8.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_7dqmqe8.jl:36\ntest set: Test\
    \ Failed at /tmp/tm"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_7dqmqe8.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    length = size(array)[1]\n    if length == 0 return [] end\n    even =\
    \ (array[1] + array[length]) % 2 == 0\n    return sort(array, by = x -> (even\
    \ ? -x : x))\nend\n \nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if sum(first(array), last(array)) % 2 == 0\n        return sort(array,\
    \ rev=true)\n    else\n        return sort(array)\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp7869xw7m.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] first\n     @ ./abstractarray.jl:398\
    \ [inlined]\n   [3] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmp7869xw7m.jl:16\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmp7869xw7m.jl:27 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp7869xw7m.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp7869xw7m.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp7869xw7m.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmp7869xw7m.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmp7869xw7m.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp7869xw7m.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7869xw7m.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    return isodd(sum(array[1], array[end])) ? sort(array) : sort(array, rev=true)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmppt1g5id5.jl:23\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmppt1g5id5.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmppt1g5id5.jl:23 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmppt1g5id5.jl:22\ntest set:\
    \ Error During Test at /tmp/tmppt1g5id5.jl:24\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmppt1g5id5.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmppt1g5id5.jl:24 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmppt1g5id5.jl:22\ntest set:\
    \ Error During Test at /tmp/tmppt1g5id5.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppt1g5id5.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    sorted_array = sort(array)\n    if(sum(array[1], array[end]) % 2 == 0)\n\
    \        reverse!(sorted_array)\n    end\n    return sorted_array\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpy4yls67d.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpy4yls67d.jl:17\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpy4yls67d.jl:27 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpy4yls67d.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpy4yls67d.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpy4yls67d.jl:17\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpy4yls67d.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpy4yls67d.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpy4yls67d.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy4yls67d.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if sum(first(array), last(array)) % 2 == 0 \n        return sort(array,\
    \ rev=true)\n    else\n        return sort(array)\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpb81qe8v2.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] first\n     @ ./abstractarray.jl:398\
    \ [inlined]\n   [3] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpb81qe8v2.jl:16\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpb81qe8v2.jl:27 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpb81qe8v2.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpb81qe8v2.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpb81qe8v2.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpb81qe8v2.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpb81qe8v2.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpb81qe8v2.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb81qe8v2.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    n = length(array)\n    if n % 2 == 0\n        return sort(array, rev=true)\n\
    \    else\n        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpv2c42rky.jl:30\n  Expression: candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n   Evaluated: [5, 4, 3, 2, 1, 0] == [0,\
    \ 1, 2, 3, 4, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv2c42rky.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv2c42rky.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpv2c42rky.jl:31\n  Expression: candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [0, 1, 2, 3, 4, 5, 6] == [6, 5,\
    \ 4, 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv2c42rky.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv2c42rky.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpv2c42rky.jl:32\n  Expression: candidate([2, 1]) == [1, 2]\n\
    \   Evaluated: [2, 1] == [1, 2]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv2c42rky.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv2c42rky.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpv2c42rky.jl:33\n  Expression: candidate([15, 42, 87, 32, 11,\
    \ 0]) == [0, 11, 15, 32, 42, 87]\n   Evaluated: [87, 42, 32, 15, 11, 0] == [0,\
    \ 11, 15, 32, 42, 87]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv2c42rky.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv2c42rky.jl:27\nTest Summary:\
    \ | Pass  Fail  Tota"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv2c42rky.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    sum(array[1], array[end])%2 != 0 ? sort(array) : sort(array, rev=true)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqyopufbi.jl:23\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpqyopufbi.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpqyopufbi.jl:23 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpqyopufbi.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpqyopufbi.jl:24\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpqyopufbi.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpqyopufbi.jl:24 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpqyopufbi.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpqyopufbi.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqyopufbi.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(array)\n        return []\n    end\n    if length(array) ==\
    \ 1\n        return array\n    end\n    sum = array[1] + array[end]\n    if sum\
    \ % 2 == 0\n        sort(array, rev=true)\n    else\n        sort(array)\n   \
    \ end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return array\n    end\n    if length(array)\
    \ == 1\n        return array\n    end\n    if isodd(array[1] + array[end])\n \
    \       sort(array)\n    else\n        sort(array, rev=true)\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    first_idx = array[1]\n    last_idx = array[end]\n    if first_idx + last_idx\
    \ % 2 == 0\n        sort(array)\n    else\n        sort(array, rev=true)\n   \
    \ end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpql3bbae_.jl:29\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpql3bbae_.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpql3bbae_.jl:29 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpql3bbae_.jl:28\ntest set:\
    \ Test Failed at /tmp/tmpql3bbae_.jl:31\n  Expression: candidate([2, 4, 3, 0,\
    \ 1, 5]) == [0, 1, 2, 3, 4, 5]\n   Evaluated: [5, 4, 3, 2, 1, 0] == [0, 1, 2,\
    \ 3, 4, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpql3bbae_.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpql3bbae_.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpql3bbae_.jl:33\n  Expression: candidate([2, 1]) == [1, 2]\n\
    \   Evaluated: [2, 1] == [1, 2]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpql3bbae_.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpql3bbae_.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpql3bbae_.jl:34\n  Expression: candidate([15, 42, 87, 32, 11,\
    \ 0]) == [0, 11, 15, 32, 42, 87]\n   Evaluated: [87, 42, 32, 15, 11, 0] == [0,\
    \ 11, 15, 32, 42, 87]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpql3bbae_.jl:34 [inlined]\n [3]\
    \ macro expansion"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 3 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpql3bbae_.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0 || length(array) == 1\n        return array\n  \
    \  end\n    array_sum = array[1] + array[end]\n    if array_sum % 2 == 0\n   \
    \     return sort(array, rev=true)\n    else\n        return sort(array)\n   \
    \ end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    isodd(x) = isodd(x) ? false : true\n    x, y = first(array), last(array)\n\
    \    if isodd(x + y)\n        return sort(array)\n    else\n        return sort(array,\
    \ rev=true)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp4sjp2ruj.jl:29\\n  Test threw\
    \ exception\\n  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\\\
    n  BoundsError: attempt to access 0-element Vector{Int64} at index [1]\\n  Stacktrace:\\\
    n   [1] getindex\\n     @ ./array.jl:861 [inlined]\\n   [2] first\\n     @ ./abstractarray.jl:398\
    \ [inlined]\\n   [3] sort_array(array::Vector{Int64})\\n     @ Main /tmp/tmp4sjp2ruj.jl:17\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [5] macro expansion\\n     @ /tmp/tmp4sjp2ruj.jl:29 [inlined]\\\
    n   [6] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [7] top-level scope\\n     @ /tmp/tmp4sjp2ruj.jl:28\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    sum(array[1], array[end]) % 2 == 0 ? sort(array, rev=true) : sort(array)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpo4h7zjsd.jl:23\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpo4h7zjsd.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpo4h7zjsd.jl:23 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpo4h7zjsd.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpo4h7zjsd.jl:24\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpo4h7zjsd.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpo4h7zjsd.jl:24 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpo4h7zjsd.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpo4h7zjsd.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo4h7zjsd.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if (sum(first(array), last(array)) % 2 == 0)\n        return sort(array,\
    \ rev=true)\n    else\n        return sort(array)\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwllsxsvu.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] first\n     @ ./abstractarray.jl:398\
    \ [inlined]\n   [3] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpwllsxsvu.jl:16\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpwllsxsvu.jl:27 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpwllsxsvu.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpwllsxsvu.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpwllsxsvu.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpwllsxsvu.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpwllsxsvu.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpwllsxsvu.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwllsxsvu.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    begin\n        return copy(sort(array))\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfvui72no.jl:28\n  Expression: candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [0, 1, 2, 3, 4, 5,\
    \ 6] == [6, 5, 4, 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfvui72no.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfvui72no.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpfvui72no.jl:31\n  Expression: candidate([21, 14, 23, 11])\
    \ == [23, 21, 14, 11]\n   Evaluated: [11, 14, 21, 23] == [23, 21, 14, 11]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfvui72no.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfvui72no.jl:24\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    5     2      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfvui72no.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return []\n    end\n    if (array[1] +\
    \ array[end]) % 2 == 0\n        array = sort(array, rev=true)\n    else\n    \
    \    array = sort(array)\n    end\n    return array\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if  length(array) != 0\n        sum_first_last = array[1] + array[end]\n\
    \        if sum_first_last % 2 == 0\n            # sorting in descending order\n\
    \            sort(array, rev=true)\n        else\n            # sorting in ascending\
    \ order\n            sort(array)\n        end\n    else\n        # if length is\
    \ zero\n        array\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # Your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpekvpgc4c.jl:24\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpekvpgc4c.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpekvpgc4c.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpekvpgc4c.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpekvpgc4c.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpekvpgc4c.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpekvpgc4c.j"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpekvpgc4c.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    array[(length(array) + 1) \xF7 2] % 2 == 0 ?  sort(array, rev=true) :\
    \ sort(array)\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t\
    @test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqgxc_jru.jl:23\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [0]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpqgxc_jru.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpqgxc_jru.jl:23 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpqgxc_jru.jl:22\ntest set:\
    \ Test Failed at /tmp/tmpqgxc_jru.jl:27\n  Expression: candidate([2, 1]) == [1,\
    \ 2]\n   Evaluated: [2, 1] == [1, 2]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqgxc_jru.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqgxc_jru.jl:22\nTest Summary:\
    \ | Pass  Fail  Error  Total\ntest set      |    5     1      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 1 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqgxc_jru.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # array[1], array[end] -> the beginning and the end of the array\n   \
    \ # sum([array[1], array[end]]) -> add the beginning and the end of the array\n\
    \    # sum([array[1], array[end]]) % 2 != 0 -> checks if it is even or odd\n \
    \   #   a % b -> gives the remainder of a/b (the remainder is a number between\
    \ 0 and b)\n    #   a % 2 != 0 -> checks if a is even or odd (with a is an int,\
    \ and not a float)\n    #     -> a%2 == 0 is even,\n    #     -> a%2 != 0 is odd\n\
    \    # end is the last index of the array\n    # sort() is used to sort the array\n\
    \    # if condition1\n    #   do something\n    # elseif condition2\n    #   do\
    \ something else\n    # else\n    #   do something else\n    # end\n    if sum([array[1],\
    \ array[end]]) % 2 != 0 \n        return sort(array)\n    else\n        return\
    \ sort(array, rev=true)\n    end\nend\n# test with the first example\n# when the\
    \ sum(first index value, last index value) is odd\nsort_array([])\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: MethodError: no method matching sort_array(::Vector{Any})\n\
    Closest candidates are:\n  sort_array(!Matched::Vector{Int64}) at /tmp/tmppmbzq08k.jl:15\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmppmbzq08k.jl:40\nin expression\
    \ starting at /tmp/tmppmbzq08k.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    sum_first_last = array[1] + array[end]\n    if sum_first_last % 2 == 0\n\
    \        sort(array, rev=true)\n    else\n        sort(array)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzzmual4p.jl:28\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpzzmual4p.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpzzmual4p.jl:28 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpzzmual4p.jl:27\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzzmual4p.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    sum = (array[1] + array[end])\n    if isodd(sum)\n        array = sort(array)\n\
    \    else\n        array = sort(array, rev=true)\n    end\n    return array\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpadliqvg5.jl:29\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpadliqvg5.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpadliqvg5.jl:29 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpadliqvg5.jl:28\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpadliqvg5.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    @assert length(array) == 0 || length(array) == 1 || length(array) > 1\n\
    \    if length(array) == 0 || length(array) == 1\n        return array\n    end\n\
    \    if (array[1] + array[end]) % 2 == 0\n        return sort(array, rev=true)\n\
    \    else\n        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    sorted_array = sort(array)\n    if (array[1] + array[end]) % 2 == 0\n\
    \        sorted_array = reverse(sorted_array)\n    end\n    return sorted_array\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp8qxukqnp.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp8qxukqnp.jl:17\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp8qxukqnp.jl:27 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp8qxukqnp.jl:26\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8qxukqnp.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if (sum(array[1:1]) + sum(array[end:end])) % 2 == 0\n        return sort(array,\
    \ rev=true)\n    else\n        return sort(array)\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5iy8_ty4.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1:1]\n  Stacktrace:\n  \
    \ [1] throw_boundserror(A::Vector{Int64}, I::Tuple{UnitRange{Int64}})\n     @\
    \ Base ./abstractarray.jl:691\n   [2] checkbounds\n     @ ./abstractarray.jl:656\
    \ [inlined]\n   [3] getindex\n     @ ./array.jl:867 [inlined]\n   [4] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp5iy8_ty4.jl:16\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp5iy8_ty4.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp5iy8_ty4.jl:26\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5iy8_ty4.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    return nothing\nend\nsort_array([2, 4, 3, 0, 1, 5])\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\nClosest candidates are:\n  convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \  convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \  ...\nStacktrace:\n [1] sort_array(array::Vector{Int64})\n   @ Main /tmp/tmp3564r7xx.jl:16\n\
    \ [2] top-level scope\n   @ /tmp/tmp3564r7xx.jl:18\nin expression starting at\
    \ /tmp/tmp3564r7xx.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    total = array[1] + array[end]\n    if total % 2 == 0\n        sort(array,\
    \ rev=true)\n    else\n        sort(array)\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9315hju6.jl:28\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp9315hju6.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp9315hju6.jl:28 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp9315hju6.jl:27\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9315hju6.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if !isempty(array) && length(array) != 1\n        sum_first_last = array[1]\
    \ + array[end]\n        if sum_first_last % 2 == 0\n            reverse!(sort(array))\n\
    \        else\n            sort(array)\n        end\n    else\n        array\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    length = size(array)[1]\n    if length == 0\n        return array\n  \
    \  end\n    if length == 1\n        return array\n    end\n    if (array[1] +\
    \ array[length]) % 2 == 0\n        return sort(array, rev=true)\n    else\n  \
    \      return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(array, lt = x->sum(x)%2==0)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxn8zpa2o.jl:25\n  Test threw exception\n\
    \  Expression: candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError:\
    \ no method matching (::var\"#1#2\")(::Int64, ::Int64)\n  Closest candidates are:\n\
    \    (::var\"#1#2\")(::Any) at /tmp/tmpxn8zpa2o.jl:16\n  Stacktrace:\n    [1]\
    \ (::Base.Order.var\"#1#3\"{var\"#1#2\", typeof(identity)})(x::Int64, y::Int64)\n\
    \      @ Base.Order ./ordering.jl:125\n    [2] lt(o::Base.Order.Lt{Base.Order.var\"\
    #1#3\"{var\"#1#2\", typeof(identity)}}, a::Int64, b::Int64)\n      @ Base.Order\
    \ ./ordering.jl:112\n    [3] sort!\n      @ ./sort.jl:507 [inlined]\n    [4] sort!\n\
    \      @ ./sort.jl:574 [inlined]\n    [5] sort!\n      @ ./sort.jl:664 [inlined]\n\
    \    [6] #sort!#8\n      @ ./sort.jl:725 [inlined]\n    [7] sort(v::Vector{Int64};\
    \ kws::Base.Pairs{Symbol, var\"#1#2\", Tuple{Symbol}, NamedTuple{(:lt,), Tuple{var\"\
    #1#2\"}}})\n      @ Base.Sort ./sort.jl:772\n    [8] sort_array(array::Vector{Int64})\n\
    \      @ Main /tmp/tmpxn8zpa2o.jl:16\n    [9] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [10] macro expansion\n      @ /tmp/tmpxn8zpa2o.jl:25 [inlined]\n\
    \   [11] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [12] top-level scope\n      @ /tmp/tmpxn8zpa2o.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpxn8zpa2o.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  MethodError: no\
    \ method matching (::var\"#1#2\")(::Int64, ::Int64)\n  Closest candidates are:\n\
    \    (::var\"#1#2\")(::Any) at /tmp/tmpxn8zpa2o.jl:16\n  Stacktrace:\n    [1]\
    \ (::Base.Order.var\"#1#3\"{var\"#1#2\", typeof(identity)})(x::Int64, y::Int64)\n\
    \      @ Base.Order ./ordering.jl:125\n    [2] lt(o::Base.Order.Lt{Base.Order.var\"\
    #1#3\"{var\"#1#2\", typeof(identity)}}, a::Int64, b::Int64)\n      @ Base.Order\
    \ ./ordering.jl:112\n    [3] sort!\n      @ ./sort.jl:507 [inlined]\n    [4] sort!\n\
    \      @ ./sort.jl:574 [inlined]\n    [5] sort!\n      @ ./sort.jl:664 [inlined]\n\
    \    [6] #sort!#8\n      @ "
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxn8zpa2o.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    array_length = length(array)\n    sum_length = array[1] + array[array_length]\n\
    \    if sum_length % 2 == 0\n        sort(array, rev=true)\n    else\n       \
    \ sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpbpdr1n0c.jl:29\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpbpdr1n0c.jl:17\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpbpdr1n0c.jl:29 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpbpdr1n0c.jl:28\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbpdr1n0c.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    @assert typeof(array) == Vector{Int64}\n    @assert all(element -> element\
    \ >= 0, array)\n    @assert length(array) > 0\n    return sort(array, by=x->abs(x))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmps_ampryl.jl:26\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  AssertionError:\
    \ length(array) > 0\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmps_ampryl.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmps_ampryl.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmps_ampryl.jl:25\ntest set:\
    \ Test Failed at /tmp/tmps_ampryl.jl:29\n  Expression: candidate([2, 4, 3, 0,\
    \ 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [0, 1, 2, 3, 4, 5, 6] == [6,\
    \ 5, 4, 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmps_ampryl.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps_ampryl.jl:25\ntest set: Test\
    \ Failed at /tmp/tmps_ampryl.jl:32\n  Expression: candidate([21, 14, 23, 11])\
    \ == [23, 21, 14, 11]\n   Evaluated: [11, 14, 21, 23] == [23, 21, 14, 11]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmps_ampryl.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps_ampryl.jl:25\nTest Summary:\
    \ | Pass  Fail  Error  Total\ntest set      |    4     2      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps_ampryl.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return []\n    end\n    if length(array)\
    \ == 1\n        return array\n    end\n    newarray = copy(array)\n    if isodd(newarray[1]\
    \ + newarray[end])\n        sort!(newarray)\n    else\n        sort!(newarray,\
    \ rev=true)\n    end\n    return newarray\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    @assert length(array) < 1, \"Invalid input: array must be non-empty\"\n\
    \    new_array = sort(array)\n    (first_val(new_array) + last_val(new_array))\
    \ % 2 == 0 ? reverse(new_array) : new_array\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp0ykl62i0.jl:25\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  TypeError:\
    \ non-boolean (Tuple{Bool, String}) used in boolean context\n  Stacktrace:\n \
    \  [1] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmp0ykl62i0.jl:16\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0ykl62i0.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0ykl62i0.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp0ykl62i0.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  TypeError: non-boolean (Tuple{Bool, String}) used in\
    \ boolean context\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n  \
    \   @ Main /tmp/tmp0ykl62i0.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0ykl62i0.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0ykl62i0.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp0ykl62i0.jl:27\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  TypeError: non-boolean\
    \ (Tuple{Bool, String}) used in boolean context\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp0ykl62i0.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0ykl62i0.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0ykl62i0.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp0ykl62i0.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2,"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0ykl62i0.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n   \n    sum,res = 0,array\n    \n    if length(array) == 0 || length(array)\
    \ == 1\n        return array\n    end\n    \n    sum = array[1] + array[end]\n\
    \    \n    if sum % 2 == 0\n        res = sort(array,rev=true)\n    else\n   \
    \     res = sort(array)\n    end\n    \n    return res\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0 || length(array) == 1\n        return array\n  \
    \  end\n    if sum(array[1], array[end]) % 2 == 0\n        return sort(array,\
    \ rev=true)\n    else\n        return sort(array)\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpz5pza9ax.jl:32\n  Test threw exception\n\
    \  Expression: candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError:\
    \ objects of type Int64 are not callable\n  Maybe you forgot to use an operator\
    \ such as *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpz5pza9ax.jl:19\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpz5pza9ax.jl:32 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpz5pza9ax.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpz5pza9ax.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpz5pza9ax.jl:19\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpz5pza9ax.jl:33 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz5pza9ax.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0 || length(array) == 1\n        return array\n  \
    \  end\n    odd = false\n    if (array[1] + array[end]) % 2 == 1\n        odd\
    \ = true\n    end\n    if odd\n        sort(array)\n    else\n        sort(array,\
    \ rev=true)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    \n    # if vector is empty\n    if isempty(array)\n        return array\n\
    \    end\n    \n    # if vector is a singleton\n    if length(array) == 1\n  \
    \      return array\n    end\n    \n    # if sum of first and last indices is\
    \ odd\n    if sum(array[1], array[end]) % 2 == 1\n        sorted_array = sort(array)\n\
    \    else\n        sorted_array = sort(array, rev=true)\n    end\n    \n    return\
    \ sorted_array\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpvs6asyvz.jl:43\n  Test threw exception\n\
    \  Expression: candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError:\
    \ objects of type Int64 are not callable\n  Maybe you forgot to use an operator\
    \ such as *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpvs6asyvz.jl:28\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpvs6asyvz.jl:43 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpvs6asyvz.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpvs6asyvz.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpvs6asyvz.jl:28\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpvs6asyvz.jl:44 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvs6asyvz.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    n = length(array)\n    if n == 0\n        return array\n    end\n    if\
    \ mod(array[1] + array[n], 2) == 0\n        # sort it in descending order\n  \
    \      return sort(array, rev=true)\n    else\n        # sort it in ascending\
    \ order\n        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    total = size(array)[1] - 1\n    if isodd(array[1] + array[total])\n  \
    \      sort(array)\n    else\n        sort(array, rev=true)\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmppx51junm.jl:28\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmppx51junm.jl:17\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmppx51junm.jl:28 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmppx51junm.jl:27\ntest set:\
    \ Error During Test at /tmp/tmppx51junm.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  BoundsError: attempt to access 1-element Vector{Int64}\
    \ at index [0]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861 [inlined]\n\
    \   [2] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmppx51junm.jl:17\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmppx51junm.jl:29 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmppx51junm.jl:27\ntest set:\
    \ Test Failed at /tmp/tmppx51junm.jl:31\n  Expression: candidate([2, 4, 3, 0,\
    \ 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [0, 1, 2, 3, 4, 5, 6] == [6,\
    \ 5, 4, 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppx51junm.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppx51junm.jl:27\ntest set: Test\
    \ Failed at /tmp/tmppx51junm.jl:32\n  Expression: candidate([2, 1]) == [1, 2]\n\
    \   Evaluated: [2, 1] == [1, 2]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 2 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppx51junm.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # your solution here\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpl6u_5pva.jl:23\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpl6u_5pva.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpl6u_5pva.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpl6u_5pva.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpl6u_5pva.jl:24\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpl6u_5pva.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpl6u_5pva.j"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl6u_5pva.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    sort(array, by=x->sum(x...))\nend\n#Some tests\n\
    @testset \"example1\" begin\n    @test sort_array([]) == []\n    @test sort_array([5])\
    \ == [5]\n    @test sort_array([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n   \
    \ @test sort_array([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @testset not defined\nin expression starting\
    \ at /tmp/tmpykkx58nc.jl:20\nin expression starting at /tmp/tmpykkx58nc.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    \n    # Make copy\n    copy = copy(array)\n    \n    # Check for even/odd\
    \ length\n    length = size(copy)[1] % 2 == 0\n    \n    # Check for even/odd\
    \ sum of first and last element\n    sum = copy[1] + copy[end] % 2 == 0\n    \n\
    \    # Check if even or odd length\n    if length == sum\n        return sort(copy,\
    \ rev=true)\n    else \n        return sort(copy)\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpl2hxmt2w.jl:38\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError:\
    \ copy not defined\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n \
    \    @ Main /tmp/tmpl2hxmt2w.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpl2hxmt2w.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpl2hxmt2w.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpl2hxmt2w.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  UndefVarError: copy not defined\n  Stacktrace:\n  \
    \ [1] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpl2hxmt2w.jl:18\n \
    \  [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpl2hxmt2w.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpl2hxmt2w.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpl2hxmt2w.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  UndefVarError: copy not\
    \ defined\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpl2hxmt2w.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpl2hxmt2w.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpl2hxmt2w.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpl2hxmt2w.jl:41\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  UndefVarError:\
    \ copy not defined\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n \
    \    @ Main /tmp"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl2hxmt2w.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n   \n    # two ways of getting the first and last index value\n    # a = array[1]\n\
    \    # b = array[end]\n    a, b = array[1], array[end]\n    \n    # the sum of\
    \ the first and last index value\n    if a + b % 2 == 0\n        sort(array, rev=true)\n\
    \    else\n        sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpbf_l3nyu.jl:34\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpbf_l3nyu.jl:20\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpbf_l3nyu.jl:34 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpbf_l3nyu.jl:33\ntest set:\
    \ Test Failed at /tmp/tmpbf_l3nyu.jl:37\n  Expression: candidate([2, 4, 3, 0,\
    \ 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [0, 1, 2, 3, 4, 5, 6] == [6,\
    \ 5, 4, 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbf_l3nyu.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbf_l3nyu.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpbf_l3nyu.jl:40\n  Expression: candidate([21, 14, 23, 11])\
    \ == [23, 21, 14, 11]\n   Evaluated: [11, 14, 21, 23] == [23, 21, 14, 11]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbf_l3nyu.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbf_l3nyu.jl:33\nTest Summary:\
    \ | Pass  Fail  Error  Total\ntest set      |    4     2      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbf_l3nyu.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if size(array, 1) == 0\n        return array\n    end\n    head, tail\
    \ = array[1], array[end]\n    if rem(head + tail, 2) == 0\n        sort(array,\
    \ rev=true)\n    else\n        sort(array)\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    new_array = copy(array)\n    if length(new_array) == 0\n        return\
    \ new_array\n    end\n    if ((new_array[1] + new_array[end]) % 2 == 0)\n    \
    \    sort!(new_array, rev=true)\n    else\n        sort!(new_array)\n    end\n\
    \    return new_array\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    iseven(x) = x % 2 == 0\n    # function to check whether the sum of the\
    \ first and last element of the array is even \n    return iseven(array[1] + array[end])\
    \ ? sort(array, rev=true) : sort(array)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpr3k5b1j3.jl:25\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpr3k5b1j3.jl:18\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpr3k5b1j3.jl:25 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpr3k5b1j3.jl:24\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr3k5b1j3.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    sum = array[1] + array[end]\n    if sum % 2 == 0\n        sorted = sort(array,\
    \ rev=true)\n    else\n        sorted = sort(array)\n    end\n    return sorted\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpy2_81eg8.jl:29\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpy2_81eg8.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpy2_81eg8.jl:29 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpy2_81eg8.jl:28\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy2_81eg8.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # create a vector to store result, then fill it with the original array\n\
    \    result = Vector{Int64}(undef, length(array))\n    copy!(result, array)\n\
    \    \n    # find the first and last index of array\n    first, last = 1, length(array)\n\
    \    \n    # check if the sum of first and last index is odd or even\n    if mod(result[first]\
    \ + result[last], 2) == 0\n        # if even, sort the array by reverse order\n\
    \        sort!(result, rev=true)\n    else\n        # if odd, sort the array by\
    \ ascending order\n        sort!(result)\n    end\n    \n    # return the result\n\
    \    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpm01d3n6u.jl:40\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpm01d3n6u.jl:24\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpm01d3n6u.jl:40 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpm01d3n6u.jl:39\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm01d3n6u.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    begin_val = array[1]\n    end_val = array[end]\n    if mod(begin_val +\
    \ end_val, 2) == 0 \n        sort(array, rev=true)\n    else\n        sort(array)\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp107mod0e.jl:29\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp107mod0e.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp107mod0e.jl:29 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp107mod0e.jl:28\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp107mod0e.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    \n    if isempty(array) || length(array) == 1\n        return array\n\
    \    end\n    \n    even = sum(array[1], array[end]) % 2 == 0\n    \n    sort(array,\
    \ rev=even)\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t\
    @test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpkd8mr44p.jl:32\n  Test threw exception\n\
    \  Expression: candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError:\
    \ objects of type Int64 are not callable\n  Maybe you forgot to use an operator\
    \ such as *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpkd8mr44p.jl:21\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpkd8mr44p.jl:32 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpkd8mr44p.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpkd8mr44p.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpkd8mr44p.jl:21\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpkd8mr44p.jl:33 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkd8mr44p.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if !length(array)==0\n        s = sum(array[1],array[end])\n        if\
    \ s%2==0\n            sort(array,rev=true)\n        else\n            sort(array)\n\
    \        end\n    else\n        array\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpx3wrej6m.jl:32\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError:\
    \ no method matching !(::Int64)\n  Closest candidates are:\n    !(!Matched::Function)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:1117\n    !(!Matched::Bool)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/bool.jl:35\n    !(!Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:101\n  Stacktrace:\n\
    \   [1] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpx3wrej6m.jl:16\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx3wrej6m.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx3wrej6m.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpx3wrej6m.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: no method matching !(::Int64)\n  Closest\
    \ candidates are:\n    !(!Matched::Function) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:1117\n\
    \    !(!Matched::Bool) at /shared/centos7/julia/1.7.3/share/julia/base/bool.jl:35\n\
    \    !(!Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:101\n\
    \  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpx3wrej6m.jl:16\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx3wrej6m.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx3wrej6m.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpx3wrej6m.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: no method\
    \ matching !(::Int64)\n  Closest candidates are:\n    !(!Matched::Function) at\
    \ /shared/centos7/julia/1"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpx3wrej6m.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return array\n    end\n    if array[1]\
    \ % 2 == 1 && array[end] % 2 == 1\n        array[1] , array[end] = array[end]\
    \ , array[1]\n    end\n    if length(array) == 1\n        return array\n    end\n\
    \    if array[1] % 2 == 0 && array[end] % 2 == 0\n        return sort(array)\n\
    \    end\n    if array[1] % 2 == 1 && array[end] % 2 == 0\n        array[1] ,\
    \ array[end] = array[end] , array[1]\n        return sort(array)\n    end\nend\n\
    sort_array([])\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: MethodError: no method matching sort_array(::Vector{Any})\n\
    Closest candidates are:\n  sort_array(!Matched::Vector{Int64}) at /tmp/tmp5oj2se4z.jl:15\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp5oj2se4z.jl:33\nin expression\
    \ starting at /tmp/tmp5oj2se4z.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    #Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp4a3w3uzc.jl:23\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp4a3w3uzc.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4a3w3uzc.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4a3w3uzc.jl:22\ntest set:\
    \ Error During Test at /tmp/tmp4a3w3uzc.jl:24\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp4a3w3uzc.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4a3w3uzc.j"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4a3w3uzc.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    sum_first_last = array[1] + array[end]\n    if sum_first_last % 2 == 0\n\
    \        # even\n        return sort(array, rev=true)\n    else\n        # odd\n\
    \        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxlsry2mf.jl:30\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpxlsry2mf.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpxlsry2mf.jl:30 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpxlsry2mf.jl:29\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxlsry2mf.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    n = length(array)\n    if n > 1\n        if (array[1] + array[n]) % 2\
    \ == 0\n            # even: sort in descending order\n            return sort(array,\
    \ rev=true)\n        else\n            # odd: sort in ascending order\n      \
    \      return sort(array)\n        end\n    else\n        return array\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0 return array end\n    first, last = array[1], array[end]\n\
    \    sum = first + last\n    if sum % 2 == 0 \n        sort(array, rev=true)\n\
    \    else\n        sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return array\n    end\n    if array[1]\
    \ + array[end] % 2 == 0\n        return sort(array, rev=true)\n    else\n    \
    \    return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9x8gmr63.jl:33\n  Expression: candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [0, 1, 2, 3, 4, 5,\
    \ 6] == [6, 5, 4, 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9x8gmr63.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9x8gmr63.jl:29\ntest set: Test\
    \ Failed at /tmp/tmp9x8gmr63.jl:36\n  Expression: candidate([21, 14, 23, 11])\
    \ == [23, 21, 14, 11]\n   Evaluated: [11, 14, 21, 23] == [23, 21, 14, 11]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9x8gmr63.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9x8gmr63.jl:29\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    5     2      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9x8gmr63.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    first_last_sum = sum(array[1], array[end])\n    sort(array, by = x ->\
    \ first_last_sum % 2 == 0 ? -x : x)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpaz07q6wp.jl:24\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpaz07q6wp.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpaz07q6wp.jl:24 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpaz07q6wp.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpaz07q6wp.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpaz07q6wp.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpaz07q6wp.jl:25 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpaz07q6wp.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpaz07q6wp.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpaz07q6wp.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if sum(first(array), last(array)) % 2 == 0\n        sort(array; rev=true)\n\
    \    else\n        sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpivczsdqe.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] first\n     @ ./abstractarray.jl:398\
    \ [inlined]\n   [3] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpivczsdqe.jl:16\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpivczsdqe.jl:27 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpivczsdqe.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpivczsdqe.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpivczsdqe.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpivczsdqe.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpivczsdqe.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpivczsdqe.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpivczsdqe.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if sum(array[1], array[end]) % 2 == 0 \n        sort(array, rev=true)\n\
    \    else\n        sort(array)\n    end\nend\n \n    \nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp60z5m3ow.jl:29\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp60z5m3ow.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp60z5m3ow.jl:29 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp60z5m3ow.jl:28\ntest set:\
    \ Error During Test at /tmp/tmp60z5m3ow.jl:30\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp60z5m3ow.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmp60z5m3ow.jl:30 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmp60z5m3ow.jl:28\ntest set:\
    \ Error During Test at /tmp/tmp60z5m3ow.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp60z5m3ow.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return array\n    end\n    sum = array[1]\
    \ + array[end]\n    if sum % 2 == 0\n        return sort(array, rev=true)\n  \
    \  else\n        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    i, j = 1, length(array)\n    if i + j == 1\n        return array\n   \
    \ end\n    if (i + j) % 2 == 0\n        return sort(array, rev=true)\n    else\n\
    \        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8clsvb7n.jl:37\n  Expression: candidate([21,\
    \ 14, 23, 11]) == [23, 21, 14, 11]\n   Evaluated: [11, 14, 21, 23] == [23, 21,\
    \ 14, 11]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8clsvb7n.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8clsvb7n.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8clsvb7n.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    n = length(array)\n    array_sum = array[1] + array[n]\n    sorted_array\
    \ = sort(array)\n    if array_sum % 2 == 0 \n        sorted_array = sorted_array[end:-1:1]\n\
    \    end\n    return sorted_array\nend\nprintln(sort_array([1, 5, 4, 3, 2, 6]))\n\
    println(sort_array([2, 4, 3, 0, 1, 5]))\nprintln(sort_array([1, 5, 4, 3, 2, 6,\
    \ 8]))\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "[1, 2, 3, 4, 5, 6]\n[0, 1, 2, 3, 4, 5]\n[1, 2, 3, 4, 5, 6, 8]\ntest set:\
    \ Error During Test at /tmp/tmph71dd931.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n  \
    \   @ Main /tmp/tmph71dd931.jl:17\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmph71dd931.jl:32 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmph71dd931.jl:31\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph71dd931.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # Code here!\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1lefg2bt.jl:23\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp1lefg2bt.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1lefg2bt.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1lefg2bt.jl:22\ntest set:\
    \ Error During Test at /tmp/tmp1lefg2bt.jl:24\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp1lefg2bt.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1lefg2bt.j"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1lefg2bt.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    sum_first_last = array[1] + array[end]\n    if sum_first_last % 2 == 0\n\
    \        sort(array, rev=true)\n    else\n        sort(array)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmprdlscei6.jl:28\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmprdlscei6.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmprdlscei6.jl:28 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmprdlscei6.jl:27\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprdlscei6.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array)==0\n        return array\n    end\n    if sum(array[1],array[end])%2\
    \ == 0\n        return sort(array,rev=true)\n    else\n        return sort(array)\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpnfr10_zn.jl:31\n  Test threw exception\n\
    \  Expression: candidate([5]) == [5]\n  MethodError: objects of type Int64 are\
    \ not callable\n  Maybe you forgot to use an operator such as *, ^, %, / etc.\
    \ ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n\
    \     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function, a::Int64)\n\
    \     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpnfr10_zn.jl:19\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpnfr10_zn.jl:31 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpnfr10_zn.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpnfr10_zn.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpnfr10_zn.jl:19\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpnfr10_zn.jl:32 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpnfr10_zn."
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnfr10_zn.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array)==0 || length(array)==1\n        return array\n    end\n\
    \    if array[1]+array[end]%2==0 # if even\n        return sort(array,rev=true)\n\
    \    else \n        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplptnmt8x.jl:33\n  Expression: candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [0, 1, 2, 3, 4, 5,\
    \ 6] == [6, 5, 4, 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplptnmt8x.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplptnmt8x.jl:29\ntest set: Test\
    \ Failed at /tmp/tmplptnmt8x.jl:36\n  Expression: candidate([21, 14, 23, 11])\
    \ == [23, 21, 14, 11]\n   Evaluated: [11, 14, 21, 23] == [23, 21, 14, 11]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplptnmt8x.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplptnmt8x.jl:29\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    5     2      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplptnmt8x.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    evenodd =  (array[1] + array[end]) % 2 == 0\n    iseven = (k -> k % 2\
    \ == 0)\n    comp = (iseven(x) == evenodd ? x <=> y : y <=> x)\n    sort(array,\
    \ comp)\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \">\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprrtnkzpd.jl:18\nin expression starting at\
    \ /tmp/tmprrtnkzpd.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    \n    array_length = length(array)\n    if array_length == 0\n       \
    \ return array\n    end\n    \n    if array_length == 1\n        return array\n\
    \    end\n    \n    if array_length == 2\n        if array[1] + array[end] ==\
    \ 1\n            return array\n        end\n        if array[1] > array[end]\n\
    \            return [array[end], array[1]]\n        end\n        return array\n\
    \    end\n    \n    if (array[1] + array[end]) % 2 == 0\n        if (array[1]\
    \ + array[end]) == 0\n            return array\n        end\n        return sort(array,\
    \ rev=true)\n    end\n    return sort(array)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    res = copy(array)\n    if sum(res[1], res[end])\
    \ % 2 == 0\n        sort!(res, rev=true)\n    else\n        sort!(res)\n    end\n\
    \    return res\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzrwaonky.jl:30\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpzrwaonky.jl:18\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpzrwaonky.jl:30 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpzrwaonky.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpzrwaonky.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpzrwaonky.jl:18\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpzrwaonky.jl:31 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpzrwaonky.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpzrwaonky.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzrwaonky.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if sum(first(array), last(array)) % 2 == 0\n        return sort(array,\
    \ rev=true)\n    else\n        return sort(array)\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzoj_dhly.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] first\n     @ ./abstractarray.jl:398\
    \ [inlined]\n   [3] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpzoj_dhly.jl:16\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpzoj_dhly.jl:27 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpzoj_dhly.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpzoj_dhly.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpzoj_dhly.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpzoj_dhly.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpzoj_dhly.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpzoj_dhly.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzoj_dhly.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return []\n    end\n    if (array[1] +\
    \ array[end]) % 2 == 0\n        reverse!(sort(array))\n    else\n        sort(array)\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return []\n    end\n    if length(array)\
    \ == 1\n        return array\n    end\n    if sum(array[1], array[end]) % 2 ==\
    \ 0\n        return sort(array, rev=true)\n    else\n        return sort(array)\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpvax7d2ti.jl:35\n  Test threw exception\n\
    \  Expression: candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError:\
    \ objects of type Int64 are not callable\n  Maybe you forgot to use an operator\
    \ such as *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpvax7d2ti.jl:22\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpvax7d2ti.jl:35 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpvax7d2ti.jl:32\ntest set:\
    \ Error During Test at /tmp/tmpvax7d2ti.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpvax7d2ti.jl:22\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpvax7d2ti.jl:36 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvax7d2ti.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # if isempty(array)\n    #     return []\n    # end\n    if mod(array[1]\
    \ + array[end], 2) == 0\n        return sort(array, rev=true)\n    else\n    \
    \    return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6wuwbv_9.jl:30\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp6wuwbv_9.jl:19\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp6wuwbv_9.jl:30 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp6wuwbv_9.jl:29\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6wuwbv_9.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if sum(first(array), last(array)) % 2 == 0\n        sort(array, rev=true)\n\
    \    else\n        sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpj41pcq2h.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] first\n     @ ./abstractarray.jl:398\
    \ [inlined]\n   [3] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpj41pcq2h.jl:16\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpj41pcq2h.jl:27 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpj41pcq2h.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpj41pcq2h.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpj41pcq2h.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpj41pcq2h.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpj41pcq2h.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpj41pcq2h.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj41pcq2h.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if iseven(sum(array[1], array[end]))\n        sort(array, rev=true)\n\
    \    else\n        sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpszx2lh2_.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpszx2lh2_.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpszx2lh2_.jl:27 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpszx2lh2_.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpszx2lh2_.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpszx2lh2_.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpszx2lh2_.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpszx2lh2_.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpszx2lh2_.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpszx2lh2_.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    n = size(array, 1)\n    if n == 0 || n == 1\n        return array\n  \
    \  end\n    if mod(array[1] + array[n], 2) == 0\n        return sort(array, rev=true)\n\
    \    else\n        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(array) return [] end\n    sum = array[1] + array[end]\n   \
    \ if sum % 2 == 0 \n        return sort(array, rev=true)\n    else\n        return\
    \ sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(array)\n        return []\n    end\n    if length(array) ==\
    \ 1\n        return array\n    end\n    head, tail = array[1], array[end]\n  \
    \  if isodd(head + tail)\n        return sort(array)\n    else\n        return\
    \ sort(array, rev=true)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # if the length of given array is 0, return an empty vector\n    if length(array)\
    \ == 0\n        return Vector{Int64}()\n    end\n    # get the sum of first and\
    \ last values of the given array\n    sum_of_first_and_last = array[1] + array[end]\n\
    \    # if the sum of first and last values of the given array is even,\n    #\
    \ sort the given array in descending order, otherwise sort it in ascending order\n\
    \    if iseven(sum_of_first_and_last)\n        return sort(array, rev=true)\n\
    \    else\n        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if sum(first(array), last(array)) % 2 == 0\n        return sort(array,\
    \ rev=true)\n    else\n        return sort(array)\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqcndrgrd.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] first\n     @ ./abstractarray.jl:398\
    \ [inlined]\n   [3] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpqcndrgrd.jl:16\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpqcndrgrd.jl:27 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpqcndrgrd.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpqcndrgrd.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpqcndrgrd.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpqcndrgrd.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpqcndrgrd.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpqcndrgrd.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqcndrgrd.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    n = length(array)\n    if n == 0 || n == 1\n        return array\n   \
    \ end\n    if iseven(array[1] + array[end])\n        sort(array,rev=true)\n  \
    \  else\n        sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    x = sum(array[1], array[end])\n    if x % 2 == 0\n        return sort(array,\
    \ rev=true)\n    else\n        return sort(array)\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp86xepyov.jl:28\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp86xepyov.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp86xepyov.jl:28 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp86xepyov.jl:27\ntest set:\
    \ Error During Test at /tmp/tmp86xepyov.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp86xepyov.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmp86xepyov.jl:29 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmp86xepyov.jl:27\ntest set:\
    \ Error During Test at /tmp/tmp86xepyov.jl:30\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp86xepyov.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # Your code goes here\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2t2v8e2i.jl:23\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp2t2v8e2i.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2t2v8e2i.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2t2v8e2i.jl:22\ntest set:\
    \ Error During Test at /tmp/tmp2t2v8e2i.jl:24\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp2t2v8e2i.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2t2v8e2i.j"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2t2v8e2i.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if sum(first(array), last(array)) % 2 == 0\n        sort(array, rev=true)\n\
    \    else\n        sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6mo_g3kj.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] first\n     @ ./abstractarray.jl:398\
    \ [inlined]\n   [3] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmp6mo_g3kj.jl:16\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmp6mo_g3kj.jl:27 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp6mo_g3kj.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp6mo_g3kj.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp6mo_g3kj.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmp6mo_g3kj.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmp6mo_g3kj.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp6mo_g3kj.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6mo_g3kj.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # TODO: validate array\n    N = length(array)\n    is_even = (array[1]\
    \ + array[N]) % 2 == 0 \n    array_sort_order = sortperm(array, rev = is_even)\n\
    \    return array[array_sort_order]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpnzt1nokk.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpnzt1nokk.jl:18\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpnzt1nokk.jl:27 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpnzt1nokk.jl:26\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnzt1nokk.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) < 2\n        return array\n    end\n    if (array[1]\
    \ + array[end]) % 2 == 0\n        return sort(array,rev=true)\n    else\n    \
    \    return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    array_size = length(array)\n    if (array_size == 0) || (array_size ==\
    \ 1)\n        return array\n    end\n    if (array[1] + array[end]) % 2 == 0\n\
    \        # the sum is even \n        return sort(array, rev=true)\n    else\n\
    \        # the sum is odd\n        return sort(array)\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if sum(first(array), last(array)) % 2 == 0\n        sort(array, rev=true)\n\
    \    else\n        sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp4u0vm_da.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] first\n     @ ./abstractarray.jl:398\
    \ [inlined]\n   [3] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmp4u0vm_da.jl:16\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmp4u0vm_da.jl:27 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp4u0vm_da.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp4u0vm_da.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp4u0vm_da.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmp4u0vm_da.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmp4u0vm_da.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp4u0vm_da.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4u0vm_da.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(array) return [] end\n    if length(array) == 1 return array\
    \ end\n    if mod(array[1], 2) == mod(array[end], 2) return sort(array) end\n\
    \    if mod(array[1], 2) == 1 return sort(array, rev=true) end\n    if mod(array[1],\
    \ 2) == 0 return sort(array) end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvlsb5mdn.jl:30\n  Expression: candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [0, 1, 2, 3, 4, 5,\
    \ 6] == [6, 5, 4, 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvlsb5mdn.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvlsb5mdn.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpvlsb5mdn.jl:32\n  Expression: candidate([15, 42, 87, 32, 11,\
    \ 0]) == [0, 11, 15, 32, 42, 87]\n   Evaluated: [87, 42, 32, 15, 11, 0] == [0,\
    \ 11, 15, 32, 42, 87]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvlsb5mdn.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvlsb5mdn.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpvlsb5mdn.jl:33\n  Expression: candidate([21, 14, 23, 11])\
    \ == [23, 21, 14, 11]\n   Evaluated: [11, 14, 21, 23] == [23, 21, 14, 11]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvlsb5mdn.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvlsb5mdn.jl:26\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvlsb5mdn.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(array)\n        return []\n    end\n    mid = div(length(array),\
    \ 2)\n    if (array[1] + array[end]) % 2 == 0\n        return [array[end-i+1]\
    \ for i in 1:mid] * [array[i] for i in mid+1:end]\n    else\n        return [array[i]\
    \ for i in 1:mid] * [array[end-i+1] for i in mid+1:end]\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing last argument in \"(mid + 1):\" range\
    \ expression \nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9g2ujgpz.jl:21\n\
    in expression starting at /tmp/tmp9g2ujgpz.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    even = sum(array[1], array[end]) % 2 == 0\n    sort!(array, rev=even)\n\
    \    return array\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwtlfbsy_.jl:25\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpwtlfbsy_.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpwtlfbsy_.jl:25 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpwtlfbsy_.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpwtlfbsy_.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpwtlfbsy_.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpwtlfbsy_.jl:26 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpwtlfbsy_.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpwtlfbsy_.jl:27\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwtlfbsy_.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    \n    evens = []\n    odds = []\n    \n    for (i, x) in enumerate(array)\n\
    \        if x % 2 == 0\n            push!(evens, x)\n        else\n          \
    \  push!(odds, x)\n        end\n    end\n    \n    sort!(evens)\n    sort!(odds)\n\
    \    \n    evens_iterator = Base.Iterators.reverse(evens)\n    odds_iterator =\
    \ Base.Iterators.reverse(odds)\n    \n    sorted_array = []\n    \n    for x in\
    \ array\n        if x % 2 == 0\n            push!(sorted_array, pop!(evens_iterator))\n\
    \        else\n            push!(sorted_array, pop!(odds_iterator))\n        end\n\
    \    end\n    \n    return sorted_array\nend\nusing Test\n\n@testset begin\n\n\
    candidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpljjm59t0.jl:52\n  Test threw exception\n\
    \  Expression: candidate([5]) == [5]\n  MethodError: no method matching pop!(::Base.Iterators.Reverse{Vector{Any}})\n\
    \  Closest candidates are:\n    pop!(!Matched::Base.IdSet, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/idset.jl:21\n\
    \    pop!(!Matched::Base.IdSet, !Matched::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/idset.jl:22\n\
    \    pop!(!Matched::Base.InvasiveLinkedListSynchronized) at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:623\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpljjm59t0.jl:40\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpljjm59t0.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpljjm59t0.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpljjm59t0.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: no method\
    \ matching pop!(::Base.Iterators.Reverse{Vector{Any}})\n  Closest candidates are:\n\
    \    pop!(!Matched::Base.IdSet, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/idset.jl:21\n\
    \    pop!(!Matched::Base.IdSet, !Matched::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/idset.jl:22\n\
    \    pop!(!Matched::Base.InvasiveLinkedListSynchronized) at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:623\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpljjm59t0.jl:38\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpljjm59t0.jl:53 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpljjm59t0.jl:50\ntest set:\
    \ Error Du"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpljjm59t0.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if sum(array[1], array[end]) % 2 == 0\n        sort(array; rev=true)\n\
    \    else\n        sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_ui3izj5.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp_ui3izj5.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp_ui3izj5.jl:27 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp_ui3izj5.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp_ui3izj5.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp_ui3izj5.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmp_ui3izj5.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmp_ui3izj5.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp_ui3izj5.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_ui3izj5.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    return array[end:-1:1]\nend\n\"\"\"\n    Given an array of integers, return\
    \ an array of the same size with all even integers sorted in descending order\
    \ and\n    all odd integers sorted in ascending order.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnuutrrta.jl:18\nin expression starting at\
    \ /tmp/tmpnuutrrta.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    newarray = copy(array)\n    isodd(x::Int64) = x % 2 == 1\n    if isodd(length(newarray))\n\
    \        return sort(newarray)\n    else\n        return sort(newarray, rev=true)\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmnw5cndm.jl:31\n  Expression: candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n   Evaluated: [5, 4, 3, 2, 1, 0] == [0,\
    \ 1, 2, 3, 4, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmnw5cndm.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmnw5cndm.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpmnw5cndm.jl:32\n  Expression: candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [0, 1, 2, 3, 4, 5, 6] == [6, 5,\
    \ 4, 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmnw5cndm.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmnw5cndm.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpmnw5cndm.jl:33\n  Expression: candidate([2, 1]) == [1, 2]\n\
    \   Evaluated: [2, 1] == [1, 2]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmnw5cndm.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmnw5cndm.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpmnw5cndm.jl:34\n  Expression: candidate([15, 42, 87, 32, 11,\
    \ 0]) == [0, 11, 15, 32, 42, 87]\n   Evaluated: [87, 42, 32, 15, 11, 0] == [0,\
    \ 11, 15, 32, 42, 87]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmnw5cndm.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmnw5cndm.jl:28\nTest Summary:\
    \ | Pass  Fail  Tota"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmnw5cndm.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(array) return array end\n    return sort(array, by=x->(x[1]\
    \ + x[end]) % 2 == 0 ? -1 : 1)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprl73x36z.jl:26\n  Expression: candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n   Evaluated: [2, 4, 3, 0, 1, 5] == [0,\
    \ 1, 2, 3, 4, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprl73x36z.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprl73x36z.jl:23\ntest set: Test\
    \ Failed at /tmp/tmprl73x36z.jl:27\n  Expression: candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [2, 4, 3, 0, 1, 5, 6] == [6, 5,\
    \ 4, 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprl73x36z.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprl73x36z.jl:23\ntest set: Test\
    \ Failed at /tmp/tmprl73x36z.jl:28\n  Expression: candidate([2, 1]) == [1, 2]\n\
    \   Evaluated: [2, 1] == [1, 2]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprl73x36z.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprl73x36z.jl:23\ntest set: Test\
    \ Failed at /tmp/tmprl73x36z.jl:29\n  Expression: candidate([15, 42, 87, 32, 11,\
    \ 0]) == [0, 11, 15, 32, 42, 87]\n   Evaluated: [15, 42, 87, 32, 11, 0] == [0,\
    \ 11, 15, 32, 42, 87]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprl73x36z.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprl73x36z.jl:23\ntest set: Test\
    \ Failed at /tmp/tm"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprl73x36z.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if sum(array[1], array[end]) % 2 == 0\n        sort(array, rev=true)\n\
    \    else\n        sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpccghdehi.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpccghdehi.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpccghdehi.jl:27 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpccghdehi.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpccghdehi.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpccghdehi.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpccghdehi.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpccghdehi.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpccghdehi.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpccghdehi.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    \nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpuqud9_k_.jl:23\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpuqud9_k_.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpuqud9_k_.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpuqud9_k_.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpuqud9_k_.jl:24\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpuqud9_k_.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpuqud9_k_.j"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuqud9_k_.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6j0tqk3i.jl:23\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp6j0tqk3i.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6j0tqk3i.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6j0tqk3i.jl:22\ntest set:\
    \ Error During Test at /tmp/tmp6j0tqk3i.jl:24\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp6j0tqk3i.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6j0tqk3i.j"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6j0tqk3i.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return array\n    end\n    if length(array)\
    \ == 1\n        return array\n    end\n    odd_index = []\n    even_index = []\n\
    \    for (index, value) in enumerate(array)\n        if index % 2 == 0\n     \
    \       odd_index = push!(odd_index, value)\n        else\n            even_index\
    \ = push!(even_index, value)\n        end\n    end\n    odd_index = sort(odd_index)\n\
    \    even_index = sort(even_index, rev=true)\n    for i in 1:length(array)\n \
    \       if i % 2 == 0\n            array[i] = odd_index[i]\n        else\n   \
    \         array[i] = even_index[i]\n        end\n    end\n    return array\nend\n\
    using Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpb526ljd3.jl:49\n  Test threw exception\n\
    \  Expression: candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  BoundsError:\
    \ attempt to access 3-element Vector{Any} at index [4]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpb526ljd3.jl:35\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpb526ljd3.jl:49 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpb526ljd3.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpb526ljd3.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  BoundsError: attempt\
    \ to access 3-element Vector{Any} at index [4]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n  \
    \   @ Main /tmp/tmpb526ljd3.jl:35\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpb526ljd3.jl:50 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpb526ljd3.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpb526ljd3.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([2, 1]) == [1, 2]\n  BoundsError: attempt to access 1-element Vector{Any}\
    \ at index [2]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861 [inlined]\n\
    \   [2] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpb526ljd3.jl:35\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpb526ljd3.jl:51 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpb526ljd3"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb526ljd3.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) < 2\n        return array\n    end\n    tmp = sort(array)\n\
    \    if array[1] + array[end] % 2 == 0\n        return reverse(tmp)\n    else\n\
    \        return tmp\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphqv0rj5l.jl:34\n  Expression: candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [0, 1, 2, 3, 4, 5,\
    \ 6] == [6, 5, 4, 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphqv0rj5l.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphqv0rj5l.jl:30\ntest set: Test\
    \ Failed at /tmp/tmphqv0rj5l.jl:37\n  Expression: candidate([21, 14, 23, 11])\
    \ == [23, 21, 14, 11]\n   Evaluated: [11, 14, 21, 23] == [23, 21, 14, 11]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphqv0rj5l.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphqv0rj5l.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    5     2      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphqv0rj5l.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n  \n  if array == nothing || length(array) == 0\n    return []\n  end\n  \n\
    \  if array[1] % 2 == 0\n    array = sort(array, rev=true)\n  else\n    array\
    \ = sort(array)\n  end\n  \n  return array\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppavpxild.jl:36\n  Expression: candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n   Evaluated: [5, 4, 3, 2, 1, 0] == [0,\
    \ 1, 2, 3, 4, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppavpxild.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppavpxild.jl:33\ntest set: Test\
    \ Failed at /tmp/tmppavpxild.jl:38\n  Expression: candidate([2, 1]) == [1, 2]\n\
    \   Evaluated: [2, 1] == [1, 2]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppavpxild.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppavpxild.jl:33\ntest set: Test\
    \ Failed at /tmp/tmppavpxild.jl:40\n  Expression: candidate([21, 14, 23, 11])\
    \ == [23, 21, 14, 11]\n   Evaluated: [11, 14, 21, 23] == [23, 21, 14, 11]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppavpxild.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppavpxild.jl:33\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     3      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppavpxild.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if sum(first(array), last(array)) % 2 == 0\n        return sort(array,\
    \ rev=true)\n    else\n        return sort(array)\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxyxzcho7.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] first\n     @ ./abstractarray.jl:398\
    \ [inlined]\n   [3] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpxyxzcho7.jl:16\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpxyxzcho7.jl:27 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpxyxzcho7.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpxyxzcho7.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpxyxzcho7.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpxyxzcho7.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpxyxzcho7.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpxyxzcho7.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxyxzcho7.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return []\n    end\n    if length(array)\
    \ == 1\n        return array\n    end\n    if (sum(array[1], array[end]) % 2)\
    \ == 0\n        return sort(array, rev=true)\n    else\n        return sort(array)\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmph00c8qrh.jl:35\n  Test threw exception\n\
    \  Expression: candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError:\
    \ objects of type Int64 are not callable\n  Maybe you forgot to use an operator\
    \ such as *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmph00c8qrh.jl:22\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmph00c8qrh.jl:35 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmph00c8qrh.jl:32\ntest set:\
    \ Error During Test at /tmp/tmph00c8qrh.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmph00c8qrh.jl:22\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmph00c8qrh.jl:36 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph00c8qrh.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(array)\n        return array\n    end\n    if (array[1] + array[end])\
    \ % 2 == 0\n        return sort(array, rev=true)\n    else\n        return sort(array)\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    \n    function isEven(n::Int64)::Bool\n        return mod(n, 2) == 0 ?\
    \ true : false\n    end\n    \n    if length(array) < 2\n        return array\n\
    \    end\n    \n    first = array[1]\n    last = array[end]\n    \n    if isEven(first\
    \ + last)\n        sort(array, rev=true)\n    else\n        sort(array)\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return array\n    end\n    if length(array)\
    \ == 1\n        return array\n    end\n    if (array[1] + array[end]) % 2 == 0\n\
    \        return sort(array, rev=true)\n    else\n        return sort(array)\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    len = length(array)\n    first = array[1]\n    last = array[len]\n   \
    \ total = first + last\n    sorted_array = sort(array)\n    if total % 2 == 0\n\
    \        reverse!(sorted_array)\n    end\n    return sorted_array\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpw5d08atz.jl:31\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpw5d08atz.jl:17\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpw5d08atz.jl:31 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpw5d08atz.jl:30\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw5d08atz.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    first_value = array[1]\n    last_value = array[end]\n    sum_value = first_value\
    \ + last_value\n    if sum_value % 2 == 0\n        sort(array; rev=true)\n   \
    \ else\n        sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjcdr32pp.jl:30\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpjcdr32pp.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpjcdr32pp.jl:30 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpjcdr32pp.jl:29\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjcdr32pp.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    return sort(array, rev = iseven(array[1] + array[end]))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6ps5fi48.jl:23\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp6ps5fi48.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp6ps5fi48.jl:23 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp6ps5fi48.jl:22\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6ps5fi48.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if iseven(sum(array[1], array[end]))\n        return sort(array, rev=true)\n\
    \    else\n        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpi56tfuxj.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpi56tfuxj.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpi56tfuxj.jl:27 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpi56tfuxj.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpi56tfuxj.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpi56tfuxj.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpi56tfuxj.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpi56tfuxj.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpi56tfuxj.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi56tfuxj.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    ind = size(array)[1]\n    if (rem(array[1] + array[ind], 2) == 0)\n  \
    \      #sort in descending order\n        sorted_array = sort(array, rev=true)\n\
    \    else\n        #sort in ascending order\n        sorted_array = sort(array)\n\
    \    end\n    return sorted_array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5smcv8zx.jl:31\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp5smcv8zx.jl:17\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp5smcv8zx.jl:31 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp5smcv8zx.jl:30\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5smcv8zx.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if !isempty(array) && (array[1] + array[end]) % 2 == 0\n        return\
    \ sort(array, rev=true)\n    else\n        return sort(array)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if sum(first(array), last(array)) % 2 == 0\n        return sort(array,\
    \ rev=true)\n    else\n        return sort(array)\n    end\nend\n# Test Cases\n\
    using Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpsb3rznh3.jl:28\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] first\n     @ ./abstractarray.jl:398\
    \ [inlined]\n   [3] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpsb3rznh3.jl:16\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpsb3rznh3.jl:28 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpsb3rznh3.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpsb3rznh3.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpsb3rznh3.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpsb3rznh3.jl:29 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpsb3rznh3.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpsb3rznh3.jl:30\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsb3rznh3.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) > 0\n        first = array[1]\n        last = array[end]\n\
    \        if (first + last) % 2 == 0\n            reverse!(sort(array))\n     \
    \   else\n            sort(array)\n        end\n    else\n        array\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n  odd_indexed = []\n  even_indexed = []\n  sorted_odd_indexed = []\n  sorted_even_indexed\
    \ = []\n  result = []\n  if length(array) == 0\n    return array\n  end\n  if\
    \ length(array) == 1\n    return array\n  end\n  if (array[1] + array[end]) %\
    \ 2 == 0\n    for i in 1:length(array)\n      if i % 2 == 0\n        push!(even_indexed,\
    \ array[i])\n      else\n        push!(odd_indexed, array[i])\n      end\n   \
    \ end\n    sorted_odd_indexed = sort(odd_indexed, rev=true)\n    sorted_even_indexed\
    \ = sort(even_indexed, rev=true)\n    for i in 1:length(array)\n      if i % 2\
    \ == 0\n        push!(result, sorted_even_indexed[i])\n      else\n        push!(result,\
    \ sorted_odd_indexed[i])\n      end\n    end\n    return result\n  else\n    for\
    \ i in 1:length(array)\n      if i % 2 == 0\n        push!(even_indexed, array[i])\n\
    \      else\n        push!(odd_indexed, array[i])\n      end\n    end\n    sorted_odd_indexed\
    \ = sort(odd_indexed)\n    sorted_even_indexed = sort(even_indexed)\n    for i\
    \ in 1:length(array)\n      if i % 2 == 0\n        push!(result, sorted_even_indexed[i])\n\
    \      else\n        push!(result, sorted_odd_indexed[i])\n      end\n    end\n\
    \    return result\n  end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpvax7nv17.jl:72\n  Test threw exception\n\
    \  Expression: candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  BoundsError:\
    \ attempt to access 3-element Vector{Any} at index [4]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpvax7nv17.jl:57\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpvax7nv17.jl:72 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpvax7nv17.jl:69\ntest set:\
    \ Error During Test at /tmp/tmpvax7nv17.jl:73\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  BoundsError: attempt\
    \ to access 3-element Vector{Any} at index [4]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n  \
    \   @ Main /tmp/tmpvax7nv17.jl:39\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpvax7nv17.jl:73 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpvax7nv17.jl:69\ntest set:\
    \ Error During Test at /tmp/tmpvax7nv17.jl:74\n  Test threw exception\n  Expression:\
    \ candidate([2, 1]) == [1, 2]\n  BoundsError: attempt to access 1-element Vector{Any}\
    \ at index [2]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861 [inlined]\n\
    \   [2] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpvax7nv17.jl:57\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpvax7nv17.jl:74 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpvax7nv17"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvax7nv17.jl:67\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(array) || length(array)==1\n        return array\n    end\n\
    \    total = sum(array[1], array[end])\n    if total % 2 == 0\n        return\
    \ sort(array, rev=true)\n    else\n        return sort(array)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpbzc3axm7.jl:33\n  Test threw exception\n\
    \  Expression: candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError:\
    \ objects of type Int64 are not callable\n  Maybe you forgot to use an operator\
    \ such as *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpbzc3axm7.jl:19\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpbzc3axm7.jl:33 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpbzc3axm7.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpbzc3axm7.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpbzc3axm7.jl:19\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpbzc3axm7.jl:34 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbzc3axm7.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    sorted_array = copy(array)\n    if (sorted_array[1] + sorted_array[end])\
    \ % 2 == 0\n        sort!(sorted_array, rev=true)\n    else\n        sort!(sorted_array)\n\
    \    end\n    return sorted_array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp71nph6ie.jl:29\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp71nph6ie.jl:17\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp71nph6ie.jl:29 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp71nph6ie.jl:28\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    6      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 0 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp71nph6ie.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    odd_index = get_odd_index(array)\n    even_index = get_even_index(array)\n\
    \    return sort_values(odd_index, even_index)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwgnl901a.jl:25\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError:\
    \ get_odd_index not defined\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpwgnl901a.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwgnl901a.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwgnl901a.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpwgnl901a.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  UndefVarError: get_odd_index not defined\n  Stacktrace:\n\
    \   [1] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpwgnl901a.jl:16\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwgnl901a.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwgnl901a.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpwgnl901a.jl:27\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  UndefVarError: get_odd_index\
    \ not defined\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @\
    \ Main /tmp/tmpwgnl901a.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwgnl901a.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwgnl901a.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpwgnl901a.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  UndefVarError:\
    \ get_odd_index not defined\n  Stacktrace:\n   [1] sort_array(ar"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwgnl901a.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # check if array is empty or array has 1 element.\n    if length(array)\
    \ <= 1\n        return array\n    end\n    \n    # check if the sum of array's\
    \ first and last elements is odd or even.\n    if (array[1] + array[end]) % 2\
    \ == 0\n        return sort(array, rev=true)\n    else\n        return sort(array)\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return []\n    end\n    if length(array)\
    \ == 1\n        return array\n    end\n    sumIndex = array[1] + array[end]\n\
    \    if sumIndex % 2 == 0\n        return sort(array, rev=true)\n    else\n  \
    \      return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    start = length(array) > 0 ? array[1] : 1\n    end = length(array) > 0\
    \ ? array[end] : 0\n    is_even = (start + end) % 2 == 0\n    tmp = (sort(array,\
    \ rev=is_even))\n    tmp \nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: malformed expression\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmp1tgi0ch_.jl:1\nin expression starting at /tmp/tmp1tgi0ch_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0 || length(array) == 1\n        return array\n  \
    \  end\n    if (array[1] + array[end]) % 2 == 0\n        return sort(array, rev=true)\n\
    \    else\n        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(array)\n        return array\n    end\n    is_odd = (array[1]\
    \ + array[end]) % 2 == 1\n    array = merge_sort(array)\n    if is_odd\n     \
    \   array = reverse(array)\n    end\n    return array\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpg035ntx2.jl:32\n  Test threw exception\n\
    \  Expression: candidate([5]) == [5]\n  UndefVarError: merge_sort not defined\n\
    \  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpg035ntx2.jl:20\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg035ntx2.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg035ntx2.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpg035ntx2.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  UndefVarError: merge_sort\
    \ not defined\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n     @\
    \ Main /tmp/tmpg035ntx2.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg035ntx2.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg035ntx2.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpg035ntx2.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  UndefVarError:\
    \ merge_sort not defined\n  Stacktrace:\n   [1] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpg035ntx2.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg035ntx2.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg035ntx2.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpg035ntx2.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([2, 1]) == [1, 2]\n  UndefVarError: merge_sort not defined\n  Stacktrace:\n\
    \   [1] sort_array(array::Vector{Int64})\n     @ Main /t"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg035ntx2.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    odd = false\n    if (array[1] + array[end]) % 2 == 1\n        odd = true\n\
    \    end\n    return sort(array, by = x -> abs(odd ? x : -x))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpcl40139m.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpcl40139m.jl:17\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpcl40139m.jl:27 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpcl40139m.jl:26\ntest set:\
    \ Test Failed at /tmp/tmpcl40139m.jl:30\n  Expression: candidate([2, 4, 3, 0,\
    \ 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [0, 1, 2, 3, 4, 5, 6] == [6,\
    \ 5, 4, 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcl40139m.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcl40139m.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpcl40139m.jl:33\n  Expression: candidate([21, 14, 23, 11])\
    \ == [23, 21, 14, 11]\n   Evaluated: [11, 14, 21, 23] == [23, 21, 14, 11]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcl40139m.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcl40139m.jl:26\nTest Summary:\
    \ | Pass  Fail  Error  Total\ntest set      |    4     2      1      7\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcl40139m.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    # good luck\n    # BEGIN\n    if sum(array[1], array[end]) % 2 == 0\n\
    \        return sort(array, rev=true)\n    else\n        return sort(array)\n\
    \    end\n    # END\nend\n \nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpadsa5uan.jl:31\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpadsa5uan.jl:18\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpadsa5uan.jl:31 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpadsa5uan.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpadsa5uan.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpadsa5uan.jl:18\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpadsa5uan.jl:32 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpadsa5uan.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpadsa5uan.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpadsa5uan.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    index_sum = sum(array[1], array[end])\n    println(index_sum)\n    println(array)\n\
    \    if index_sum % 2 == 0\n        println(\"even\")\n        return sort(array,\
    \ rev=true)\n    else\n        println(\"odd\")\n        return sort(array)\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5]) == [5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15,\
    \ 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14,\
    \ 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9m0k74nu.jl:32\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp9m0k74nu.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp9m0k74nu.jl:32 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp9m0k74nu.jl:31\ntest set:\
    \ Error During Test at /tmp/tmp9m0k74nu.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp9m0k74nu.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmp9m0k74nu.jl:33 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmp9m0k74nu.jl:31\ntest set:\
    \ Error During Test at /tmp/tmp9m0k74nu.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9m0k74nu.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    newarray = copy(array)\n    if sum(first(array), last(array))%2==0\n \
    \       sort!(newarray,rev=true)\n    else\n        sort!(newarray)\n    end\n\
    \    return newarray\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpkj2ol1aa.jl:29\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] first\n     @ ./abstractarray.jl:398\
    \ [inlined]\n   [3] sort_array(array::Vector{Int64})\n     @ Main /tmp/tmpkj2ol1aa.jl:17\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpkj2ol1aa.jl:29 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpkj2ol1aa.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpkj2ol1aa.jl:30\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpkj2ol1aa.jl:17\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpkj2ol1aa.jl:30 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpkj2ol1aa.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpkj2ol1aa.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkj2ol1aa.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if sum(array[1], array[end]) % 2 == 0\n        return sort(array, rev=true)\n\
    \    else\n        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_p89wenq.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmp_p89wenq.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp_p89wenq.jl:27 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp_p89wenq.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp_p89wenq.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmp_p89wenq.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmp_p89wenq.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmp_p89wenq.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp_p89wenq.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_p89wenq.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return []\n    end\n    midpoint = length(array)//2\n\
    \    if array[1] % 2 == 1 \n        (odds = [i for i in array if i % 2 == 1])\n\
    \        (evens = [i for i in array if i % 2 == 0])\n        vcat(sort(odds),\
    \ sort(evens))\n    else\n        (odds = [i for i in array if i % 2 == 1])\n\
    \        (evens = [i for i in array if i % 2 == 0])\n        vcat(sort(evens),\
    \ sort(odds))\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = sort_array;\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5])\
    \ == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5])\n\t@test(candidate([2,\
    \ 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0])\n\t@test(candidate([2, 1]) == [1,\
    \ 2])\n\t@test(candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87])\n\
    \t@test(candidate([21, 14, 23, 11]) == [23, 21, 14, 11])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbqd25vrh.jl:37\n  Expression: candidate([2,\
    \ 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n   Evaluated: [0, 2, 4, 1, 3, 5] == [0,\
    \ 1, 2, 3, 4, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbqd25vrh.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbqd25vrh.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpbqd25vrh.jl:38\n  Expression: candidate([2, 4, 3, 0, 1, 5,\
    \ 6]) == [6, 5, 4, 3, 2, 1, 0]\n   Evaluated: [0, 2, 4, 6, 1, 3, 5] == [6, 5,\
    \ 4, 3, 2, 1, 0]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbqd25vrh.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbqd25vrh.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpbqd25vrh.jl:39\n  Expression: candidate([2, 1]) == [1, 2]\n\
    \   Evaluated: [2, 1] == [1, 2]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbqd25vrh.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbqd25vrh.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpbqd25vrh.jl:40\n  Expression: candidate([15, 42, 87, 32, 11,\
    \ 0]) == [0, 11, 15, 32, 42, 87]\n   Evaluated: [11, 15, 87, 0, 32, 42] == [0,\
    \ 11, 15, 32, 42, 87]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbqd25vrh.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbqd25vrh.jl:34\ntest set: Test\
    \ Failed at /tmp/tm"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbqd25vrh.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if length(array) == 0\n        return []\n    end\n    if length(array)\
    \ == 1\n        return array\n    end\n    index = length(array)\n    sum = array[1]\
    \ + array[index]\n    if sum % 2 == 0\n        return reverse(sort(array))\n \
    \   else\n        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    7      7\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if array == [] || length(array) == 1\n        return array\n    end\n\
    \    if sum(array[1], array[end]) % 2 == 0\n        # sort in descending order\n\
    \        return sort(array, rev=true)\n    else\n        # sort in ascending order\n\
    \        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t\
    @test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpba2bopqy.jl:34\n  Test threw exception\n\
    \  Expression: candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError:\
    \ objects of type Int64 are not callable\n  Maybe you forgot to use an operator\
    \ such as *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpba2bopqy.jl:19\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpba2bopqy.jl:34 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpba2bopqy.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpba2bopqy.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ./reduce.jl:394\n   [2] mapreduce(f::Int64, op::Function,\
    \ a::Int64)\n     @ Base ./reduce.jl:421\n   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol,\
    \ Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n     @ Base ./reduce.jl:503\n \
    \  [4] sum(f::Int64, a::Int64)\n     @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpba2bopqy.jl:19\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpba2bopqy.jl:35 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpba2bopqy.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given an array of non-negative integers, return a copy of\
    \ the given array after sorting,\n    you will sort the given array in ascending\
    \ order if the sum( first index value, last index value) is odd,\n    or sort\
    \ it in descending order if the sum( first index value, last index value) is even.\n\
    \n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([])\
    \ => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) =>\
    \ [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3,\
    \ 2, 1, 0]\n    \"\"\"\nfunction sort_array(array::Vector{Int64})::Vector{Int64}\
    \ \n    if (sum(array[1], array[end]) % 2 == 0) \n        return sort(array, rev=true)\n\
    \    else\n        return sort(array)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = sort_array;\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5]) == [5])\n\t@test(candidate([2, 4, 3, 0, 1, 5]) == [0, 1,\
    \ 2, 3, 4, 5])\n\t@test(candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1,\
    \ 0])\n\t@test(candidate([2, 1]) == [1, 2])\n\t@test(candidate([15, 42, 87, 32,\
    \ 11, 0]) == [0, 11, 15, 32, 42, 87])\n\t@test(candidate([21, 14, 23, 11]) ==\
    \ [23, 21, 14, 11])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzob8klsx.jl:27\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError:\
    \ attempt to access 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1]\
    \ getindex\n     @ ./array.jl:861 [inlined]\n   [2] sort_array(array::Vector{Int64})\n\
    \     @ Main /tmp/tmpzob8klsx.jl:16\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpzob8klsx.jl:27 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpzob8klsx.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpzob8klsx.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([5]) == [5]\n  MethodError: objects of type Int64 are not callable\n\
    \  Maybe you forgot to use an operator such as *, ^, %, / etc. ?\n  Stacktrace:\n\
    \   [1] mapreduce_first(f::Int64, op::Function, x::Int64)\n     @ Base ./reduce.jl:394\n\
    \   [2] mapreduce(f::Int64, op::Function, a::Int64)\n     @ Base ./reduce.jl:421\n\
    \   [3] sum(f::Int64, a::Int64; kw::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(),\
    \ Tuple{}}})\n     @ Base ./reduce.jl:503\n   [4] sum(f::Int64, a::Int64)\n  \
    \   @ Base ./reduce.jl:503\n   [5] sort_array(array::Vector{Int64})\n     @ Main\
    \ /tmp/tmpzob8klsx.jl:16\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpzob8klsx.jl:28 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpzob8klsx.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpzob8klsx.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]\n  MethodError: objects\
    \ of type Int64 are not callable\n  Maybe you forgot to use an operator such as\
    \ *, ^, %, / etc. ?\n  Stacktrace:\n   [1] mapreduce_first(f::Int64, op::Function,\
    \ x::Int64)\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzob8klsx.jl:24\n"
  exit_code: 1
  status: SyntaxError
