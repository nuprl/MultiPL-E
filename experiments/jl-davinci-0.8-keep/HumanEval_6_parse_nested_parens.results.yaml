name: HumanEval_6_parse_nested_parens
language: jl
results:
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    parsed_string = split(paren_string, ' ')\n    final_depth = []\n    for\
    \ i in 1:length(parsed_string)\n        temp_depth = 0\n        max_depth = 0\n\
    \        for j in 1:length(parsed_string[i])\n            if parsed_string[i][j]\
    \ == '('\n                temp_depth += 1\n            elseif parsed_string[i][j]\
    \ == ')'\n                temp_depth -= 1\n            end\n            if temp_depth\
    \ > max_depth\n                max_depth = temp_depth\n            end\n     \
    \   end\n        push!(final_depth, max_depth)\n    end\n    return final_depth\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    depth_counter::Vector{Int64} = zeros(Int64, length(paren_string))\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpobr5fnl8.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpobr5fnl8.jl:1\n\
    in expression starting at /tmp/tmpobr5fnl8.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_re = r\"[()]+\"\n    paren_groups = matchall(Regex(paren_re), paren_string)\n\
    \    return [parse_max_nesting(group) for group in paren_groups]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpweqe1hdp.jl:18\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching Regex(::Regex)\n  Closest candidates are:\n    Regex(!Matched::AbstractString)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/regex.jl:70\n    Regex(!Matched::AbstractString,\
    \ !Matched::Integer, !Matched::Integer) at /shared/centos7/julia/1.7.3/share/julia/base/regex.jl:36\n\
    \    Regex(!Matched::AbstractString, !Matched::AbstractString) at /shared/centos7/julia/1.7.3/share/julia/base/regex.jl:55\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpweqe1hdp.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpweqe1hdp.jl:18 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpweqe1hdp.jl:17\ntest set:\
    \ Error During Test at /tmp/tmpweqe1hdp.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching Regex(::Regex)\n  Closest candidates are:\n    Regex(!Matched::AbstractString)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/regex.jl:70\n    Regex(!Matched::AbstractString,\
    \ !Matched::Integer, !Matched::Integer) at /shared/centos7/julia/1.7.3/share/julia/base/regex.jl:36\n\
    \    Regex(!Matched::AbstractString, !Matched::AbstractString) at /shared/centos7/julia/1.7.3/share/julia/base/regex.jl:55\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpweqe1hdp.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpweqe1hdp.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpweqe1hdp.jl:17\ntest set:\
    \ Error Duri"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpweqe1hdp.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    n_paren_groups = split(paren_string, \" \")\n    max_depth = zeros(Int64,\
    \ length(n_paren_groups))\n    for i = 1:length(n_paren_groups)\n        max_depth[i]\
    \ = calculate_max_depth(n_paren_groups[i])\n    end\n    return max_depth\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpu8trvclu.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ calculate_max_depth not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpu8trvclu.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpu8trvclu.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpu8trvclu.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpu8trvclu.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: calculate_max_depth\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpu8trvclu.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpu8trvclu.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpu8trvclu.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpu8trvclu.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: calculate_max_depth not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n \
    \    @ Main /tmp/tmpu8trvclu.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpu8trvclu.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpu8trvclu.jl:20\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu8trvclu.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    (paren_string,)[:] == ('(()()) ((())) () ((())()())',)\n    (paren_string,)[:]\
    \ == ('((()))',)\n    # Split paren_string into a vector of groups\n    groups\
    \ = split(paren_string, \" \")\n    @show groups\n    group_deepest_parens = []\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpqektu4uz.jl:9\nin expression starting\
    \ at /tmp/tmpqektu4uz.jl:9\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, ' ')\n    return [max_nested_parens(each_group)\
    \ for each_group in paren_list]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp498x84y0.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ max_nested_parens not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(each_group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp498x84y0.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp498x84y0.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp498x84y0.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp498x84y0.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: max_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(each_group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp498x84y0.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp498x84y0.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp498x84y0.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp498x84y0.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: max_nested_parens not\
    \ defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(each_group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Ba"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp498x84y0.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    max_depth = 0\n    curr_depth = 0\n    depths = Vector{Int64}()\n    for\
    \ ch in paren_string\n        if ch == '('\n            curr_depth += 1\n    \
    \        if curr_depth > max_depth\n                max_depth = curr_depth\n \
    \           end\n        elseif ch == ')'\n            curr_depth -= 1\n     \
    \   elseif ch == ' '\n            push!(depths, max_depth)\n            max_depth\
    \ = 0\n            curr_depth = 0\n        end\n    end\n    push!(depths, max_depth)\n\
    \    return depths\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    parsed_nested_parens = Vector{Int64}()\n    for group in split(paren_string,\
    \ \" \")\n        push!(parsed_nested_parens, parse_parens(group))\n    end\n\
    \    return parsed_nested_parens\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpp99ghjmq.jl:20\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpp99ghjmq.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpp99ghjmq.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpp99ghjmq.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpp99ghjmq.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpp99ghjmq.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpp99ghjmq.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpp99ghjmq.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpp99ghjmq.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpp99ghjmq.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpp99ghjmq.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpp99ghjmq.jl:19\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp99ghjmq.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    max_levels_list = []\n    for paren_group in split(paren_string, \" \"\
    )\n        max_levels_list = [max_levels_list; find_max_nested_parens(paren_group)]\n\
    \    end\n    return max_levels_list\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpk1xrcoac.jl:20\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ find_max_nested_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpk1xrcoac.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpk1xrcoac.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpk1xrcoac.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpk1xrcoac.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: find_max_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpk1xrcoac.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpk1xrcoac.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpk1xrcoac.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpk1xrcoac.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: find_max_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpk1xrcoac.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpk1xrcoac.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpk1xrcoac.jl:19\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk1xrcoac.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = join(split(paren_string, \" \"), \"\")\n    levels = Vector{Int64}(undef,\
    \ length(paren_string))\n    n = 0\n    levels[1] = 1\n    i = 2\n    for c in\
    \ paren_string[2:end]\n        if c == '('\n            n += 1\n            levels[i]\
    \ = n\n        else\n            levels[i] = n\n            n -= 1\n        end\n\
    \        i += 1\n    end\n    return levels\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpav8listl.jl:31\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [1, 1, 1, 1, 1,\
    \ 0, 0, 1, 2, 2  \u2026  0, 1, 2, 2, 1, 1, 1, 1, 1, 0] == [2, 3, 1, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpav8listl.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpav8listl.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpav8listl.jl:32\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 0, 0, 1, 1, 0, 0, 1, 2, 2, 1, 0, 0, 1, 2,\
    \ 3, 3, 2, 1, 0] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpav8listl.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpav8listl.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpav8listl.jl:33\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [1, 1, 1, 1, 2, 2, 1, 1, 2, 3, 3, 2, 1, 0] == [4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpav8listl.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpav8listl.jl:30\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpav8listl.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    count = 1\n    max_count = 0\n    result = []\n    for char in paren_string\n\
    \        if char == '('\n            count += 1\n            if count > max_count\n\
    \                max_count = count\n            end\n        elseif char == ')'\n\
    \            count -= 1\n        elseif char == ' '\n            push!(result,\
    \ max_count)\n            max_count = 0\n            count = 1\n        end\n\
    \    end\n    return result\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwbsvuhag.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [3, 4, 2] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwbsvuhag.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwbsvuhag.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpwbsvuhag.jl:34\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [2, 3, 4] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwbsvuhag.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwbsvuhag.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpwbsvuhag.jl:35\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpwbsvuhag.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwbsvuhag.jl:32\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwbsvuhag.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, ' ')\n    depths = []\n    for group in groups\n\
    \        depth = 0\n        max_depth = 0\n        for char in group\n       \
    \     if char == '('\n                depth += 1\n            elseif char == ')'\n\
    \                depth -= 1\n            end\n            if depth > max_depth\n\
    \                max_depth = depth\n            end\n        end\n        push!(depths,\
    \ max_depth)\n    end\n    return depths\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    depth = Vector{Int64}()\n    for str in split(paren_string, \" \")\n \
    \       depth_loc = 0\n        max_depth = 0\n        for c in str\n         \
    \   if c == '('\n                depth_loc += 1\n            elseif c == ')'\n\
    \                depth_loc -= 1\n            end\n            if depth_loc > max_depth\n\
    \                max_depth = depth_loc\n            end\n        end\n       \
    \ push!(depth, max_depth)\n    end\n    return depth\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \n    open_parens = 0 \n    max_nest = 0 \n    paren_group = Vector{Int64}()\n\
    \    \n    for (i, c) in enumerate(paren_string)\n        if c == '('\n      \
    \      open_parens += 1\n            if open_parens > max_nest\n             \
    \   max_nest = open_parens\n            end\n        elseif c == ')'\n       \
    \     open_parens -= 1\n        elseif c == ' '\n            push!(paren_group,\
    \ max_nest)\n            max_nest = 0\n            open_parens = 0\n        end\n\
    \    end\n    \n    push!(paren_group, max_nest)\n    \n    return paren_group\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = strip(paren_string) # remove any leading and trailing whitespace\n\
    \    tokens = split(paren_string, r\"\\s+\") # split paren_string into tokens\
    \ on any whitespace\n    return map(x -> parse_single_parens(x), tokens)\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp_8n4e1cs.jl:18\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_single_parens not defined\n  Stacktrace:\n    [1] (::var\"#1#2\")(x::SubString{String})\n\
    \      @ Main /tmp/tmp_8n4e1cs.jl:11\n    [2] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n    [3] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n      @\
    \ Base ./array.jl:744\n    [4] collect_similar\n      @ ./array.jl:653 [inlined]\n\
    \    [5] map\n      @ ./abstractarray.jl:2867 [inlined]\n    [6] parse_nested_parens(paren_string::String)\n\
    \      @ Main /tmp/tmp_8n4e1cs.jl:11\n    [7] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmp_8n4e1cs.jl:18 [inlined]\n\
    \    [9] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [10] top-level scope\n      @ /tmp/tmp_8n4e1cs.jl:17\ntest set:\
    \ Error During Test at /tmp/tmp_8n4e1cs.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_single_parens\
    \ not defined\n  Stacktrace:\n    [1] (::var\"#1#2\")(x::SubString{String})\n\
    \      @ Main /tmp/tmp_8n4e1cs.jl:11\n    [2] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n    [3] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n      @\
    \ Base ./array.jl:744\n    [4] collect_similar\n      @ ./array.jl:653 [inlined]\n\
    \    [5] map\n      @ ./abstractarray.jl:2867 [inlined]\n    [6] parse_nested_parens(paren_string::String)\n\
    \      @ Main /tmp/tmp_8n4e1cs.jl:11\n    [7] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmp_8n4e1cs.jl:19 [inlined]\n\
    \    [9] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/j"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_8n4e1cs.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    deep_parens = [0 for i\
    \ in paren_groups]\n    for i in 1:length(paren_groups)\n        curr_paren_group\
    \ = paren_groups[i]\n        curr_paren_group_max_nesting = 0\n        curr_paren_group_nesting\
    \ = 0\n        for j in 1:length(curr_paren_group)\n            if curr_paren_group[j]\
    \ == '('\n                curr_paren_group_nesting += 1\n            elseif curr_paren_group[j]\
    \ == ')'\n                curr_paren_group_nesting -= 1\n            end\n   \
    \         if curr_paren_group_nesting > curr_paren_group_max_nesting\n       \
    \         curr_paren_group_max_nesting = curr_paren_group_nesting\n          \
    \  end\n        end\n        deep_parens[i] = curr_paren_group_max_nesting\n \
    \   end\n    return deep_parens\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    return [max_paren_level(group) for group in split(paren_string)]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpbeovtewk.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ max_paren_level not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpbeovtewk.jl:9\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpbeovtewk.jl:16 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpbeovtewk.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpbeovtewk.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: max_paren_level\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpbeovtewk.jl:9\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpbeovtewk.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpbeovtewk.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpbeovtewk.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: max_paren_level not defined\n\
    \  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n     @ Main\
    \ ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{Sub"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbeovtewk.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, \" \")\n    counts = Vector{Int64}(undef,\
    \ length(groups))\n    for i in 1:length(groups)\n        counts[i] = parse_parens(groups[i])\n\
    \    end\n    return counts\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3mx1j0pl.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp3mx1j0pl.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3mx1j0pl.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3mx1j0pl.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp3mx1j0pl.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp3mx1j0pl.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3mx1j0pl.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3mx1j0pl.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp3mx1j0pl.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmp3mx1j0pl.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3mx1j0pl.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3mx1j0pl.jl:20\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3mx1j0pl.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_str_vector = split(paren_string, ' ')\n    paren_count = Vector{Int64}(undef,\
    \ length(paren_str_vector))\n    for i in 1:length(paren_str_vector)\n       \
    \ count = 0\n        maximum = 0\n        for j in 1:length(paren_str_vector[i])\n\
    \            if paren_str_vector[i][j] == '('\n                count += 1\n  \
    \          elseif paren_str_vector[i][j] == ')'\n                count -= 1\n\
    \            end\n            if count > maximum\n                maximum = count\n\
    \            end\n        end\n        paren_count[i] = maximum\n    end\n   \
    \ return paren_count\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    depth_vec = []\n    for\
    \ paren_group in paren_groups\n        depth = 0\n        current_max = 0\n  \
    \      for paren in paren_group\n            if paren == '('\n               \
    \ depth += 1\n            elseif paren == ')'\n                depth -= 1\n  \
    \          end\n            if depth > current_max\n                current_max\
    \ = depth\n            end\n        end\n        push!(depth_vec, current_max)\n\
    \    end\n    return depth_vec\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    res = Int64[]\n    for s in split(paren_string, \" \")\n        count\
    \ = 0\n        maximum = 0\n        for c in s\n            if c == '('\n    \
    \            count += 1\n            elseif c == ')'\n                count -=\
    \ 1\n            end\n            if count > maximum\n                maximum\
    \ = count\n            end\n        end\n        push!(res, maximum)\n    end\n\
    \    return res\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open_paren_count = 0\n    max_open_paren_count = 0\n    res = []\n   \
    \ for c in paren_string\n        if c == '('\n            open_paren_count +=\
    \ 1\n            max_open_paren_count = max(max_open_paren_count, open_paren_count)\n\
    \        elseif c == ')'\n            open_paren_count -= 1\n        elseif c\
    \ == ' '\n            push!(res, max_open_paren_count)\n            max_open_paren_count\
    \ = 0\n            open_paren_count = 0\n        end\n    end\n    push!(res,\
    \ max_open_paren_count)\n    return res\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\" Count the maximum depth of nested parentheses for each group in\
    \ the parentheses string \"\"\"\n    max_depth = Vector{Int64}()\n    open_paren_count\
    \ = 0\n    max_open_paren_count = 0\n    for letter in paren_string\n        if\
    \ letter == '('\n            open_paren_count += 1\n            if open_paren_count\
    \ > max_open_paren_count\n                max_open_paren_count = open_paren_count\n\
    \            end\n        elseif letter == ')'\n            open_paren_count -=\
    \ 1\n        elseif letter == ' '\n            if open_paren_count == 0\n    \
    \            push!(max_depth, max_open_paren_count)\n                max_open_paren_count\
    \ = 0\n            end\n        end\n    end\n    push!(max_depth, max_open_paren_count)\n\
    \    return max_depth\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # We'll first split the string into multiple groups separated by space\n\
    \    paren_groups = split(paren_string, \" \")\n    deepest_nesting = Int64[]\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpmkwgsfm_.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpmkwgsfm_.jl:1\n\
    in expression starting at /tmp/tmpmkwgsfm_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, \" \")\n    depths = Array{Int64}(length(groups))\n\
    \    i = 1\n    for g in groups\n        depths[i] = depth(g)\n        i += 1\n\
    \    end\n    return depths\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpy4qnbdkp.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching (Array{Int64})(::Int64)\n  Closest candidates are:\n    (Array{T})(!Matched::LinearAlgebra.AbstractQ)\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/qr.jl:563\n\
    \    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Tuple{Int64,\
    \ Int64}) where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:494\n\
    \    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Integer, !Matched::Integer)\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:495\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpy4qnbdkp.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpy4qnbdkp.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpy4qnbdkp.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpy4qnbdkp.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching (Array{Int64})(::Int64)\n  Closest candidates are:\n    (Array{T})(!Matched::LinearAlgebra.AbstractQ)\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/qr.jl:563\n\
    \    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Tuple{Int64,\
    \ Int64}) where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:494\n\
    \    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Integer, !Matched::Integer)\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:495\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy4qnbdkp.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    depths = Vector{Int64}(undef, length(paren_string))\n    max_depth = 0\n\
    \    curr_depth = 0\n    j = 1\n    for i in 1:length(paren_string)\n        if\
    \ paren_string[i] == '('\n            curr_depth += 1\n            max_depth =\
    \ max(max_depth, curr_depth)\n        elseif paren_string[i] == ')'\n        \
    \    depths[j] = curr_depth\n            j += 1\n            curr_depth -= 1\n\
    \        end\n    end\n    depths[1:j-1]\nend\n \n\"\"\" Given an array of integers,\
    \ perform at most one swap operation to make it a sorted array.\n    Return boolean\
    \ value if a swap is possible and the indices of the pair to be swapped in an\
    \ array.\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t\
    @test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkicn74r5.jl:26\nin expression starting at\
    \ /tmp/tmpkicn74r5.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # 1. Split the string by spaces\n    groups = split(paren_string, \" \"\
    )\n    # 2. For each group, compute the maximum number of nested parens\n    max_nested_parens\
    \ = [num_nested_parens(group) for group in groups]\n    return max_nested_parens\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpwqg7b8b0.jl:20\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ num_nested_parens not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpwqg7b8b0.jl:12\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpwqg7b8b0.jl:20 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpwqg7b8b0.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpwqg7b8b0.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: num_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpwqg7b8b0.jl:12\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpwqg7b8b0.jl:21 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpwqg7b8b0.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpwqg7b8b0.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: num_nested_parens not\
    \ defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Ve"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwqg7b8b0.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    stack = [0]\n    max_depth = 0\n    depths = []\n    for i in paren_string\n\
    \        if i == '('\n            push!(stack, 0)\n        elseif i == ')'\n \
    \           depth = pop!(stack)\n            push!(depths, depth)\n          \
    \  depth += 1\n            push!(stack, depth)\n        elseif i == ' '\n    \
    \        depth = pop!(stack)\n            push!(depths, depth)\n            push!(stack,\
    \ 0)\n        end\n    end\n    return depths\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4du2czw5.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 1, 2, 0,\
    \ 1, 2, 3, 0, 1, 0, 1, 0, 0, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4du2czw5.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4du2czw5.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp4du2czw5.jl:34\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3] == [1,\
    \ 2, 3, 4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4du2czw5.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4du2czw5.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp4du2czw5.jl:35\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0, 0, 1, 0, 1, 2, 3] == [4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4du2czw5.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4du2czw5.jl:32\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4du2czw5.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Extract out each group from the string\n    groups = split(paren_string,\
    \ \" \")\n    # Initialize maximum number of nesting for each group to 0\n   \
    \ max_nesting = zeros(Int64, length(groups))\n    # Loop through each group\n\
    \    for (i, group) in enumerate(groups)\n        # Remove the left parenthesis\n\
    \        group = group[2:end]\n        # Initialize count of nesting to 0\n  \
    \      count = 0\n        # Loop through each parenthesis in a group\n       \
    \ for paren in group\n            # If it is an opening parenthesis\n        \
    \    if paren == '('\n                # increment count of nesting\n         \
    \       count += 1\n            elseif paren == ')'\n                # decrement\
    \ count of nesting\n                count -= 1\n            end\n            #\
    \ If the current count of nesting is greater than the current maximum\n      \
    \      if count > max_nesting[i]\n                # Update maximum nesting\n \
    \               max_nesting[i] = count\n            end\n        end\n    end\n\
    \    # Return the maximum nesting \n    return max_nesting\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp4a0sewim.jl:44\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [1, 2, 0, 2] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4a0sewim.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4a0sewim.jl:43\ntest set: Test\
    \ Failed at /tmp/tmp4a0sewim.jl:45\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 1, 2, 3] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4a0sewim.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4a0sewim.jl:43\ntest set: Test\
    \ Failed at /tmp/tmp4a0sewim.jl:46\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [3] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4a0sewim.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4a0sewim.jl:43\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4a0sewim.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, \" \")\n    levels = zeros(length(groups))\n\
    \    for (i, group) in enumerate(groups)\n        levels[i] = maximum_nesting(group)\n\
    \    end\n    return levels\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1unjzv9c.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ maximum_nesting not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp1unjzv9c.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1unjzv9c.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1unjzv9c.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp1unjzv9c.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: maximum_nesting\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp1unjzv9c.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1unjzv9c.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1unjzv9c.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp1unjzv9c.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: maximum_nesting not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmp1unjzv9c.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1unjzv9c.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1unjzv9c.jl:20\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1unjzv9c.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    stack = []\n    total_groups = []\n    for x in paren_string\n       \
    \ if x == '('\n            push!(stack, 1)\n        elseif x == ')'\n        \
    \    if length(stack) > 0\n                pop!(stack)\n            else\n   \
    \             push!(total_groups, 0)\n            end\n        elseif x == ' '\n\
    \            push!(total_groups, length(stack))\n        end\n    end\n    total_groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpgclpk3wk.jl:31\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgclpk3wk.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgclpk3wk.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpgclpk3wk.jl:32\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgclpk3wk.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgclpk3wk.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpgclpk3wk.jl:33\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpgclpk3wk.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgclpk3wk.jl:30\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgclpk3wk.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_depth_list = []\n    paren_string_list = split(paren_string, \"\
    \ \")\n    for i in 1:length(paren_string_list)\n        paren_depth_list = push!(paren_depth_list,\
    \ get_paren_depth(paren_string_list[i]))\n    end\n    return paren_depth_list\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpzb3b39es.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ get_paren_depth not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpzb3b39es.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzb3b39es.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzb3b39es.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpzb3b39es.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: get_paren_depth\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpzb3b39es.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzb3b39es.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzb3b39es.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpzb3b39es.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: get_paren_depth not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpzb3b39es.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzb3b39es.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzb3b39es.jl:20\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzb3b39es.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string_split = split(paren_string, \" \")\n    return [count_parens(i)\
    \ for i in paren_string_split]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3n7j5e1y.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_parens not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(i::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp3n7j5e1y.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp3n7j5e1y.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp3n7j5e1y.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp3n7j5e1y.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_parens\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(i::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmp3n7j5e1y.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp3n7j5e1y.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp3n7j5e1y.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp3n7j5e1y.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: count_parens not defined\n\
    \  Stacktrace:\n   [1] (::var\"#1#2\")(i::SubString{String})\n     @ Main ./none:0\n\
    \   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ va"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3n7j5e1y.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    curr_depth = 0\n    max_depth = 0\n    is_last_paren_open = false\n  \
    \  paren_depth = []\n    for c in paren_string\n        if c == '('\n        \
    \    if is_last_paren_open\n                curr_depth += 1\n            else\n\
    \                curr_depth = 1\n            end\n            is_last_paren_open\
    \ = true\n        elseif c == ')'\n            if is_last_paren_open\n       \
    \         max_depth = curr_depth\n                push!(paren_depth, max_depth)\n\
    \                curr_depth = 0\n            else\n                curr_depth\
    \ -= 1\n            end\n            is_last_paren_open = false\n        elseif\
    \ c == ' '\n            max_depth = curr_depth\n            push!(paren_depth,\
    \ max_depth)\n            curr_depth = 0\n        end\n    end\n    if curr_depth\
    \ > 0\n        push!(paren_depth, curr_depth)\n    end\n    return paren_depth\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmphlpa_chc.jl:46\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 1, -1, 3, -2,\
    \ 1, 0, 3, 1, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphlpa_chc.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphlpa_chc.jl:45\ntest set: Test\
    \ Failed at /tmp/tmphlpa_chc.jl:47\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 0, 2, -1, 3, -2, 4] == [1, 2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphlpa_chc.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphlpa_chc.jl:45\ntest set: Test\
    \ Failed at /tmp/tmphlpa_chc.jl:48\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [2, 2, 3] == [4]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphlpa_chc.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphlpa_chc.jl:45\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphlpa_chc.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open_parens = 0\n    max_open_parens = 0\n    max_open_parens_per_group\
    \ = Vector{Int64}()\n    for c in paren_string\n        if c == '('\n        \
    \    open_parens += 1\n            if open_parens > max_open_parens\n        \
    \        max_open_parens = open_parens\n            end\n        elseif c == ')'\n\
    \            open_parens -= 1\n        elseif c == ' '\n            push!(max_open_parens_per_group,\
    \ max_open_parens)\n            max_open_parens = 0\n        end\n    end\n  \
    \  push!(max_open_parens_per_group, max_open_parens)\n    return max_open_parens_per_group\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    result = Int64[]\n    open_count = 0\n    max_count = 0\n    # At this\
    \ point paren_string is a string and not an array of characters\n    # Any string\
    \ can be converted to an array of characters by using the split() function\n \
    \   # chr = split(paren_string, \"\")\n    # The above can be written more succinctly\
    \ using string interpolation\n    chr = split(\"$paren_string\", \"\")\n    for\
    \ i in 1:length(chr)\n        if chr[i] == '('\n            open_count += 1\n\
    \            if open_count > max_count\n                max_count = open_count\n\
    \            end\n        elseif chr[i] == ')'\n            open_count -= 1\n\
    \        elseif chr[i] == ' '\n            if max_count > 0\n                push!(result,\
    \ max_count)\n                max_count = 0\n            end\n        end\n  \
    \  end\n    if max_count > 0\n        push!(result, max_count)\n    end\n    return\
    \ result\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp35fma5ph.jl:42\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: Int64[] == [2, 3,\
    \ 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp35fma5ph.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp35fma5ph.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp35fma5ph.jl:43\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: Int64[] == [1, 2, 3, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp35fma5ph.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp35fma5ph.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp35fma5ph.jl:44\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp35fma5ph.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp35fma5ph.jl:41\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp35fma5ph.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzb0jug4s.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpzb0jug4s.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzb0jug4s.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzb0jug4s.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpzb0jug4s.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Int64}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpzb0jug4s.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [i"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzb0jug4s.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    results = Vector{Int64}()\n    for paren in split(paren_string, \" \"\
    )\n        stack = Stack{Char}()\n        depth = 0\n        max_depth = 0\n \
    \       for p in paren\n            if p == '('\n                push!(stack,\
    \ p)\n                depth += 1\n                if depth > max_depth\n     \
    \               max_depth = depth\n                end\n            elseif p ==\
    \ ')'\n                pop!(stack)\n                depth -= 1\n            end\n\
    \        end\n        push!(results, max_depth)\n    end\n    return results\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpeyund44y.jl:35\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ Stack not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpeyund44y.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeyund44y.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeyund44y.jl:34\ntest set:\
    \ Error During Test at /tmp/tmpeyund44y.jl:36\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: Stack\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpeyund44y.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeyund44y.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeyund44y.jl:34\ntest set:\
    \ Error During Test at /tmp/tmpeyund44y.jl:37\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: Stack not defined\n \
    \ Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmpeyund44y.jl:11\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeyund44y.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeyund44y.jl:34\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeyund44y.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    paren_levels = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, group) in enumerate(paren_groups)\n     \
    \   group_level = 1\n        max_level = 1\n        for char in group\n      \
    \      if char == '('\n                group_level += 1\n            elseif char\
    \ == ')'\n                group_level -= 1\n            end\n            max_level\
    \ = max(max_level, group_level)\n        end\n        paren_levels[i] = max_level\n\
    \    end\n    return paren_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppt09s6li.jl:31\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [3, 4, 2, 4] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppt09s6li.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppt09s6li.jl:30\ntest set: Test\
    \ Failed at /tmp/tmppt09s6li.jl:32\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [2, 3, 4, 5] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppt09s6li.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppt09s6li.jl:30\ntest set: Test\
    \ Failed at /tmp/tmppt09s6li.jl:33\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [5] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppt09s6li.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppt09s6li.jl:30\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppt09s6li.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    max_level_vec = Vector{Int64}()\n    level = 0\n    for ch in paren_string\n\
    \        if ch == '('\n            level += 1\n        elseif ch == ')'\n    \
    \        push!(max_level_vec, level)\n            level -= 1\n        end\n  \
    \  end\n    return max_level_vec\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpumlw5qw3.jl:26\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 2, 1, 3, 2,\
    \ 1, 1, 3, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpumlw5qw3.jl:26 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpumlw5qw3.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpumlw5qw3.jl:27\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 2, 1, 3, 2, 1, 4, 3, 2, 1] == [1, 2, 3, 4]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpumlw5qw3.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpumlw5qw3.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpumlw5qw3.jl:28\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [2, 3, 2, 4, 3, 2, 1] == [4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpumlw5qw3.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpumlw5qw3.jl:25\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpumlw5qw3.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Iterate through string and find pairs of parentheses.\n    # Each time\
    \ a pair is found, erase it from the string and increment result by 1.\n    #\
    \ Repeat until no more parentheses are left in the string.\n    str_vec = collect(paren_string)\n\
    \    result = zeros(Int64, length(str_vec))\n    idx = 1\n    while length(str_vec)\
    \ > 0\n        while length(str_vec) > 0 && str_vec[1] != '('\n            str_vec\
    \ = str_vec[2:end]\n        end\n        i = 2\n        while length(str_vec)\
    \ > 0 && str_vec[i] != ')'\n            i += 1\n        end\n        result[idx]\
    \ = length(str_vec) == 0 ? 0 : 1\n        str_vec = str_vec[i+1:end]\n       \
    \ idx += 1\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw7swpkh4.jl:34\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [1, 1, 1, 1, 1,\
    \ 1, 1, 0, 0, 0  \u2026  0, 0, 0, 0, 0, 0, 0, 0, 0, 0] == [2, 3, 1, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw7swpkh4.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw7swpkh4.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpw7swpkh4.jl:35\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 1, 1, 1, 0, 0, 0, 0, 0, 0  \u2026  0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw7swpkh4.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw7swpkh4.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpw7swpkh4.jl:36\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] == [4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw7swpkh4.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw7swpkh4.jl:33\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw7swpkh4.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    depth_of_group = []\n    depth = 0\n    for paren in paren_string\n  \
    \      if paren == '('\n            depth += 1\n        elseif paren == ')'\n\
    \            push!(depth_of_group, depth)\n            depth -= 1\n        end\n\
    \    end\n    return depth_of_group\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpup1xd88e.jl:26\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 2, 1, 3, 2,\
    \ 1, 1, 3, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpup1xd88e.jl:26 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpup1xd88e.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpup1xd88e.jl:27\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 2, 1, 3, 2, 1, 4, 3, 2, 1] == [1, 2, 3, 4]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpup1xd88e.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpup1xd88e.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpup1xd88e.jl:28\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [2, 3, 2, 4, 3, 2, 1] == [4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpup1xd88e.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpup1xd88e.jl:25\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpup1xd88e.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, ' ')\n    output = zeros(Int64, size(groups,\
    \ 1))\n    for i in 1:size(groups, 1)\n        output[i] = 0\n        temp = 0\n\
    \        for char in groups[i]\n            if char == '('\n                temp\
    \ += 1\n            elseif char == ')'\n                temp -= 1\n          \
    \  end\n            if temp > output[i]\n                output[i] = temp\n  \
    \          end\n        end\n    end\n    return output\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_strings = split(paren_string, \" \")\n    depths = Vector{Int64}(undef,\
    \ length(paren_strings))\n    for i in 1:length(paren_strings)\n        depths[i]\
    \ = parse_nested_parens_helper(paren_strings[i])\n    end\n    return depths\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpux531_u5.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpux531_u5.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpux531_u5.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpux531_u5.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpux531_u5.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpux531_u5.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpux531_u5.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpux531_u5.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpux531_u5.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpux531_u5.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpux531_u5.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpux531_u5.jl:20\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpux531_u5.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open_paren_count = 0\n    i = 1\n    max_count = 0\n    count_vector =\
    \ []\n    for char in paren_string\n        if char == '('\n            open_paren_count\
    \ += 1\n            if open_paren_count > max_count\n                max_count\
    \ = open_paren_count\n            end\n        elseif char == ')'\n          \
    \  open_paren_count -= 1\n        elseif char == ' '\n            push!(count_vector,\
    \ max_count)\n            max_count = 0\n        end\n    end\n    return count_vector\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpqxo5ypls.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 3, 1] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqxo5ypls.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqxo5ypls.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpqxo5ypls.jl:34\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 2, 3] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqxo5ypls.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqxo5ypls.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpqxo5ypls.jl:35\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqxo5ypls.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqxo5ypls.jl:32\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqxo5ypls.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    depth = Vector{Int64}()\n    levels = 0\n    for p in paren_string\n \
    \       if p == '('\n            levels += 1\n        elseif p == ')'\n      \
    \      push!(depth, levels)\n            levels -= 1\n        elseif p == ' '\n\
    \            levels = 0\n        end\n    end\n    return depth\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp04wbezj8.jl:28\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 2, 1, 3, 2,\
    \ 1, 1, 3, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp04wbezj8.jl:28 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp04wbezj8.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp04wbezj8.jl:29\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 2, 1, 3, 2, 1, 4, 3, 2, 1] == [1, 2, 3, 4]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp04wbezj8.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp04wbezj8.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp04wbezj8.jl:30\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [2, 3, 2, 4, 3, 2, 1] == [4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp04wbezj8.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp04wbezj8.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp04wbezj8.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_vec = [paren_string]\n\
    \    while length(paren_vec) != 0\n        paren_vec = [child for parent in paren_vec\
    \ \n                        for child in split(parent, r\"\\)\\(\") \n       \
    \                 if occursin(r\"\\)\\(\", parent)]\n    end\n    paren_depth\
    \ = [length(findall(r\"\\(\", paren)) for paren in paren_vec]\n    return paren_depth\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp37o9aidl.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp37o9aidl.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp37o9aidl.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp37o9aidl.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp37o9aidl.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp37o9aidl.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp37o9aidl.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp37o9aidl.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    c = 0\n    max_c = 0\n    output = []\n    for i = 1:length(paren_string)\n\
    \        if paren_string[i] == '('\n            c += 1\n            if c > max_c\n\
    \                max_c = c\n            end\n        elseif paren_string[i] ==\
    \ ')'\n            c -= 1\n        elseif paren_string[i] == ' '\n           \
    \ push!(output, max_c)\n            max_c = 0\n            c = 0\n        end\n\
    \    end\n    push!(output, max_c)\n    return output\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_group = split(paren_string, \" \")\n    max_nest_lst = zeros(Int64,\
    \ length(paren_group))\n    for i in 1:length(paren_group)\n        max_nest_lst[i]\
    \ = count_nested_parens(paren_group[i])\n    end\n    return max_nest_lst\nend\n\
    \        \n \nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpvdzfqm2z.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_nested_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpvdzfqm2z.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvdzfqm2z.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvdzfqm2z.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpvdzfqm2z.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpvdzfqm2z.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvdzfqm2z.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvdzfqm2z.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpvdzfqm2z.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: count_nested_parens not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n \
    \    @ Main /tmp/tmpvdzfqm2z.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvdzfqm2z.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvdzfqm2z.jl:22\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvdzfqm2z.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, \" \")\n    depths = []\n    for group in\
    \ groups\n        depth = 0\n        max_depth = 0\n        for char in group\n\
    \            if char == '('\n                depth += 1\n            elseif char\
    \ == ')'\n                depth -= 1\n            end\n            if depth >\
    \ max_depth\n                max_depth = depth\n            end\n        end\n\
    \        push!(depths, max_depth)\n    end\n    return depths\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = paren_string.replace(\" \", \"\")\n    stack = Stack{Char}()\n\
    \    results = Vector{Int64}()\n    max_level = 0\n    for i in paren_string\n\
    \        if i == '('\n            push!(stack, i)\n            max_level += 1\n\
    \        else\n            pop!(stack)\n            if isempty(stack)\n      \
    \          push!(results, max_level)\n                max_level = 0\n        \
    \    end\n        end\n    end\n    return results\nend\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpitfjab7x.jl:27\nin expression\
    \ starting at /tmp/tmpitfjab7x.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, ' ' => '')\n    group_counts = [deepest_nesting(group)\
    \ for group in eachmatch(r\"(\\(.*?\\))\", paren_string)]\n    return group_counts\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid empty character literal\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptvelxw0u.jl:9\nin expression starting at /tmp/tmptvelxw0u.jl:9\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    processed_groups = []\n    for group in split(paren_string, \" \")\n \
    \       paren_stack = []\n        depth = 0\n        max_depth = 0\n        for\
    \ paren in group\n            if paren == '('\n                push!(paren_stack,\
    \ paren)\n                depth += 1\n                if depth > max_depth\n \
    \                   max_depth = depth\n                end\n            elseif\
    \ paren == ')'\n                pop!(paren_stack)\n                depth -= 1\n\
    \            end\n        end\n        push!(processed_groups, max_depth)\n  \
    \  end\n    return processed_groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    n_groups = length(paren_groups)\n\
    \    n_parens = zeros(Int64, n_groups)\n    for i = 1:n_groups\n        paren_group\
    \ = paren_groups[i]\n        for c in paren_group\n            if c == '('\n \
    \               n_parens[i] += 1\n            elseif c == ')'\n              \
    \  n_parens[i] -= 1\n            end\n        end\n    end\n    return n_parens\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpvx6y5fah.jl:29\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvx6y5fah.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvx6y5fah.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpvx6y5fah.jl:30\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvx6y5fah.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvx6y5fah.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpvx6y5fah.jl:31\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvx6y5fah.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvx6y5fah.jl:28\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvx6y5fah.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    max_level = 0\n    curr_level = 0\n    levels = []\n    for i in paren_string\n\
    \        if i == '('\n            curr_level += 1\n            if curr_level >\
    \ max_level\n                max_level = curr_level\n            end\n       \
    \ elseif i == ')'\n            push!(levels, curr_level)\n            curr_level\
    \ -= 1\n        end\n    end\n    if curr_level != 0\n        throw(DomainError(\"\
    Uneven number of parentheses\"))\n    end\n    return levels\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpsehdszt9.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 2, 1, 3, 2,\
    \ 1, 1, 3, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpsehdszt9.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsehdszt9.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpsehdszt9.jl:34\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 2, 1, 3, 2, 1, 4, 3, 2, 1] == [1, 2, 3, 4]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsehdszt9.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsehdszt9.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpsehdszt9.jl:35\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [2, 3, 2, 4, 3, 2, 1] == [4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsehdszt9.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsehdszt9.jl:32\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsehdszt9.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    result = []\n    for paren_group in split(paren_string, ' ')\n       \
    \ level = 0\n        for paren in paren_group\n            if paren == '('\n \
    \               level += 1\n            elseif paren == ')'\n                level\
    \ -= 1\n            end\n        end\n        push!(result, level)\n    end\n\
    \    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpm5kscnnn.jl:28\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm5kscnnn.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm5kscnnn.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpm5kscnnn.jl:29\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm5kscnnn.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm5kscnnn.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpm5kscnnn.jl:30\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm5kscnnn.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm5kscnnn.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm5kscnnn.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    input_groups = split(paren_string, \" \")\n    output_groups = Vector{Int64}(undef,\
    \ length(input_groups))\n    i = 1\n    while i <= length(input_groups)\n    \
    \    output_groups[i] = calculate_depth(input_groups[i])\n        i += 1\n   \
    \ end\n    return output_groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpep5j8_mk.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ calculate_depth not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpep5j8_mk.jl:13\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpep5j8_mk.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpep5j8_mk.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpep5j8_mk.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: calculate_depth\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpep5j8_mk.jl:13\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpep5j8_mk.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpep5j8_mk.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpep5j8_mk.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: calculate_depth not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpep5j8_mk.jl:13\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpep5j8_mk.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpep5j8_mk.jl:22\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpep5j8_mk.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    depth_list = []\n    for\
    \ i in paren_list\n        depth = 0\n        max_depth = 0\n        for char\
    \ in i\n            if char == '('\n                depth += 1\n            elseif\
    \ char == ')'\n                depth -= 1\n            end\n            if depth\
    \ > max_depth\n                max_depth = depth\n            end\n        end\n\
    \        push!(depth_list, max_depth)\n    end\n    return depth_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \n    # Initialize output as empty vector\n    output = Vector{Int64}()\n\
    \    \n    # For every group\n    for paren_group in split(paren_string, \" \"\
    )\n        \n        # Number of nested parentheses within each group, initialized\
    \ as 0\n        nested_parens = 0\n        \n        # If the first character\
    \ is a left parenthesis, i.e. a valid group\n        if paren_group[1] == '('\n\
    \            \n            # For every character in the group\n            for\
    \ paren in paren_group\n                \n                # If the character is\
    \ a left parenthesis, increment the depth of nesting\n                if paren\
    \ == '('\n                    nested_parens += 1\n                # If the character\
    \ is a right parenthesis, decrement the depth of nesting\n                elseif\
    \ paren == ')'\n                    nested_parens -= 1\n                # Raise\
    \ an error if the character is anything else\n                else\n         \
    \           error(\"Invalid string\")\n                end\n            end\n\
    \        # Raise an error if the first character is not a left parenthesis\n \
    \       else\n            error(\"Invalid string\")\n        end\n        \n \
    \       # Push the depth of nesting onto the output vector\n        push!(output,\
    \ nested_parens)\n    end\n    \n    # Return the output vector\n    return output\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp0u6s1ejm.jl:53\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0u6s1ejm.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0u6s1ejm.jl:52\ntest set: Test\
    \ Failed at /tmp/tmp0u6s1ejm.jl:54\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0u6s1ejm.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0u6s1ejm.jl:52\ntest set: Test\
    \ Failed at /tmp/tmp0u6s1ejm.jl:55\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0u6s1ejm.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0u6s1ejm.jl:52\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0u6s1ejm.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_strings = split(paren_string, \" \")\n    depths = []\n    for s\
    \ in paren_strings\n        depths = push!(depths, parse_single_parens(s))\n \
    \   end\n    return depths\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpudd9rgg3.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_single_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpudd9rgg3.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpudd9rgg3.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpudd9rgg3.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpudd9rgg3.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_single_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpudd9rgg3.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpudd9rgg3.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpudd9rgg3.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpudd9rgg3.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_single_parens not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n \
    \    @ Main /tmp/tmpudd9rgg3.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpudd9rgg3.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpudd9rgg3.jl:20\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpudd9rgg3.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_vec = split(paren_string, \" \")\n    paren_count = []\n    for\
    \ paren in paren_vec\n        push!(paren_count, count_parens(paren))\n    end\n\
    \    return paren_count\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6gv6nbh3.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp6gv6nbh3.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6gv6nbh3.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6gv6nbh3.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp6gv6nbh3.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp6gv6nbh3.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6gv6nbh3.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6gv6nbh3.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp6gv6nbh3.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: count_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmp6gv6nbh3.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6gv6nbh3.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6gv6nbh3.jl:20\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6gv6nbh3.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    levels = Vector{Int64}(undef, 0)\n    n_levels = 0\n    for c in paren_string\n\
    \        if c == '('\n            n_levels += 1\n        elseif c == ')'\n   \
    \         n_levels -= 1\n        elseif c == ' '\n            push!(levels, n_levels)\n\
    \        end\n    end\n    return levels\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5nbrvbz0.jl:27\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5nbrvbz0.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5nbrvbz0.jl:26\ntest set: Test\
    \ Failed at /tmp/tmp5nbrvbz0.jl:28\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5nbrvbz0.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5nbrvbz0.jl:26\ntest set: Test\
    \ Failed at /tmp/tmp5nbrvbz0.jl:29\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp5nbrvbz0.jl:29 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5nbrvbz0.jl:26\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5nbrvbz0.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    parse_nested_parens(paren_string::String, 0)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpj556ny5t.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching parse_nested_parens(::String, ::Int64)\n  Closest candidates\
    \ are:\n    parse_nested_parens(::String) at /tmp/tmpj556ny5t.jl:8\n  Stacktrace:\n\
    \   [1] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmpj556ny5t.jl:9\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpj556ny5t.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpj556ny5t.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpj556ny5t.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching parse_nested_parens(::String, ::Int64)\n  Closest candidates are:\n\
    \    parse_nested_parens(::String) at /tmp/tmpj556ny5t.jl:8\n  Stacktrace:\n \
    \  [1] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmpj556ny5t.jl:9\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpj556ny5t.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpj556ny5t.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpj556ny5t.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  MethodError: no method matching parse_nested_parens(::String,\
    \ ::Int64)\n  Closest candidates are:\n    parse_nested_parens(::String) at /tmp/tmpj556ny5t.jl:8\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpj556ny5t.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpj556ny5t.jl:18 [inlined]\n\
    \   "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj556ny5t.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # each element of the vector represents the max nesting level for each\
    \ of the groups\n    max_nesting_vector = Int64[]\n    for paren_group in split(paren_string,\
    \ ' ')\n        max_nesting_level = 0\n        # level of nesting increases by\
    \ 1 for each time an opening bracket is seen,\n        # and decreases by 1 for\
    \ each time a closing bracket is seen\n        level = 0\n        for bracket\
    \ in paren_group\n            if bracket == '('\n                level += 1\n\
    \            elseif bracket == ')'\n                level -= 1\n            end\n\
    \            if level > max_nesting_level\n                max_nesting_level =\
    \ level\n            end\n        end\n        # append the max nesting level\
    \ for the current group to the vector\n        push!(max_nesting_vector, max_nesting_level)\n\
    \    end\n    return max_nesting_vector\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # split by space\n    paren_list = split(paren_string, \" \")\n    # create\
    \ vector of length same as number of groups\n    max_nesting = zeros(Int64, length(paren_list))\n\
    \    # loop over all groups\n    for (idx, paren) in enumerate(paren_list)\n \
    \       # make stack to keep track of parenthesis counts\n        stack = []\n\
    \        # set the current nesting level\n        curr_nesting = 0\n        #\
    \ loop over all parenthesis in the group\n        for p in paren\n           \
    \ # if open paren, increase the nesting level by 1 and append\n            # to\
    \ the stack to keep track\n            if p == '('\n                curr_nesting\
    \ += 1\n                push!(stack, curr_nesting)\n            # if closing paren,\
    \ then pop the last element from the stack and\n            # compare with the\
    \ current nesting level. If they are the same,\n            # then decrease the\
    \ current nesting level by 1.\n            elseif p == ')'\n                if\
    \ curr_nesting == stack[end]\n                    curr_nesting -= 1\n        \
    \            pop!(stack)\n                end\n            end\n        end\n\
    \        # curr_nesting represents the deepest level of nesting for this group\n\
    \        max_nesting[idx] = curr_nesting\n    end\n    return max_nesting\nend\n\
    \ \nparse_nested_parens('(()()) ((())) () ((())()())')\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmppv8fu8sj.jl:42\nin expression\
    \ starting at /tmp/tmppv8fu8sj.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    depth = 0\n    depth_groups = Int64[]\n    for i = 1:length(paren_string)\n\
    \        if paren_string[i] == '('\n            depth += 1\n        elseif paren_string[i]\
    \ == ')'\n            depth -= 1\n        elseif paren_string[i] == ' '\n    \
    \        push!(depth_groups, depth)\n        end\n    end\n    return depth_groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpp5jnq_08.jl:27\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpp5jnq_08.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpp5jnq_08.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpp5jnq_08.jl:28\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpp5jnq_08.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpp5jnq_08.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpp5jnq_08.jl:29\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpp5jnq_08.jl:29 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpp5jnq_08.jl:26\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp5jnq_08.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \n    paren_arr = collect(paren_string)\n    groups = split(paren_string,\
    \ ' ')\n    max_levels = []\n    \n    for g in groups\n        level = 0\n  \
    \      max_level = 0\n        for p in collect(g)\n            if p == '('\n \
    \               level += 1\n            elseif p == ')'\n                level\
    \ -= 1\n            end\n            if level > max_level\n                max_level\
    \ = level\n            end\n        end\n        push!(max_levels, max_level)\n\
    \    end\n    return max_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # parse the string.\n    paren_groups = [i for i in split(paren_string)]\n\
    \    levels = Vector{Int64}(length(paren_groups))\n    for i = 1:length(paren_groups)\n\
    \        levels[i] = 1\n        n = length(paren_groups[i])\n        for j = 1:n\n\
    \            if paren_groups[i][j] == '('\n                levels[i] += 1\n  \
    \          elseif paren_groups[i][j] == ')'\n                levels[i] -= 1\n\
    \            end\n        end\n    end\n    return levels\nend\nprintln(parse_nested_parens('(()())\
    \ ((())) () ((())()())'))\nprintln(parse_nested_parens('((())) () ((())()())'))\n\
    println(parse_nested_parens('(()())'))\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp3g08scro.jl:25\nin expression\
    \ starting at /tmp/tmp3g08scro.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, \" \")\n    max_nesting = 0\n    max_nesting_vec\
    \ = Int64[]\n    for group in groups\n        max_nesting = 0\n        current_nesting\
    \ = 0\n        for character in group\n            if character == '('\n     \
    \           current_nesting += 1\n            elseif character == ')'\n      \
    \          current_nesting -= 1\n            end\n            if current_nesting\
    \ > max_nesting\n                max_nesting = current_nesting\n            end\n\
    \        end\n        push!(max_nesting_vec, max_nesting)\n    end\n    return\
    \ max_nesting_vec\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_stack = Stack(UInt64)\n    max_depth = Dict{UInt64, Int64}()\n \
    \   group_num = 0\n    for c in paren_string\n        if c == '('\n          \
    \  push!(paren_stack, group_num)\n        elseif c == ')'\n            if isempty(paren_stack)\n\
    \                throw(ArgumentError(\"Encountered extra closing parentheses\"\
    ))\n            end\n            curr_depth = count(paren_stack)\n           \
    \ max_depth[pop!(paren_stack)] = curr_depth\n        elseif c == ' '\n       \
    \     group_num += 1\n        else\n            throw(ArgumentError(\"Invalid\
    \ character in input string\"))\n        end\n    end\n    while !isempty(paren_stack)\n\
    \        curr_depth = count(paren_stack)\n        max_depth[pop!(paren_stack)]\
    \ = curr_depth\n    end\n    return map(x -> max_depth[x], 0:group_num)\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmprod1tlx1.jl:38\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ Stack not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmprod1tlx1.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprod1tlx1.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprod1tlx1.jl:37\ntest set:\
    \ Error During Test at /tmp/tmprod1tlx1.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: Stack\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmprod1tlx1.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprod1tlx1.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprod1tlx1.jl:37\ntest set:\
    \ Error During Test at /tmp/tmprod1tlx1.jl:40\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: Stack not defined\n \
    \ Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmprod1tlx1.jl:9\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprod1tlx1.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprod1tlx1.jl:37\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprod1tlx1.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a stack and a vector of max depths\n    stack = Array{Char,\
    \ 1}()\n    max_depths = Array{Int64, 1}()\n    \n    # Split the string into\
    \ groups\n    groups = split(paren_string, ' ')\n    \n    # For each group\n\
    \    for group in groups\n        # Initialize the max depth to zero\n       \
    \ max_depth = 0\n        \n        # For each character in the group\n       \
    \ for c in group\n            # If the character is an opening paren, push it\
    \ to the stack and increase the max depth\n            if c == '('\n         \
    \       push!(stack, c)\n                max_depth += 1\n            # If the\
    \ character is a closing paren, pop from the stack and decrease the max depth\n\
    \            elseif c == ')'\n                pop!(stack)\n                max_depth\
    \ -= 1\n            # If the character is neither of them, it's invalid, so print\
    \ an error message and return\n            else\n                println(\"Invalid\
    \ character found: $c\")\n                return\n            end\n        end\n\
    \        \n        # Push the max depth of the group to the max depths vector\n\
    \        push!(max_depths, max_depth)\n    end\n    \n    # If the stack is not\
    \ empty, it means the string is invalid, so print an error message and return\n\
    \    if !isempty(stack)\n        println(\"Invalid nesting of parentheses\")\n\
    \        return\n    end\n    \n    # Return the vector of max depths\n    return\
    \ max_depths\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcrauc6gk.jl:56\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcrauc6gk.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcrauc6gk.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpcrauc6gk.jl:57\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcrauc6gk.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcrauc6gk.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpcrauc6gk.jl:58\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcrauc6gk.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcrauc6gk.jl:55\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcrauc6gk.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    levels = []\n    for group in split(paren_string, \" \")\n        level\
    \ = 0\n        for paren in group\n            level += 1 if paren == '(' else\
    \ -1\n        end\n        push!(levels, level)\n    end\n    return levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"for\" at /tmp/tmplwnm6bnl.jl:12 expected \"\
    end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmplwnm6bnl.jl:13\n\
    in expression starting at /tmp/tmplwnm6bnl.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    group_vector = split(paren_string, \" \") # Splits string into groups\
    \ of nested parentheses\n    result_vector = Int64[] # Vector to hold results\n\
    \    level = 0 # Keeps track of how many levels deep you are\n    # Iterate through\
    \ each group of nested parentheses\n    for group_string in group_vector\n   \
    \     level = 0 # Resets level\n        result = 0 # Resets result\n        #\
    \ Iterate through each character in a group of nested parentheses\n        for\
    \ character in group_string\n            if character == '('\n               \
    \ level += 1 # Increases nesting level\n                if level > result\n  \
    \                  result = level # Sets new result\n                end\n   \
    \         elseif character == ')'\n                level -= 1 # Decreases nesting\
    \ level\n            end\n        end\n        push!(result_vector, result) #\
    \ Appends result to result vector\n    end\n    return result_vector\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # remove spaces from the string\n    paren_string = replace(paren_string,\
    \ \" \" => \"\")\n    paren_indices = [i for (i, c) in enumerate(paren_string)\
    \ if c in \"()\"]\n    depths = zeros(Int64, length(paren_indices))\n    curr_depth\
    \ = 0\n    for (i, idx) in enumerate(paren_indices)\n        depths[i] = curr_depth\n\
    \        if paren_string[idx] == '('\n            curr_depth += 1\n        else\n\
    \            curr_depth -= 1\n        end\n    end\n    depths\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp7w14g6se.jl:29\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 1, 2, 1, 2,\
    \ 1, 0, 1, 2, 3  \u2026  0, 1, 2, 3, 2, 1, 2, 1, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7w14g6se.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7w14g6se.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp7w14g6se.jl:30\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 1, 0, 1, 2, 1, 0, 1, 2, 3, 2, 1, 0, 1, 2,\
    \ 3, 4, 3, 2, 1] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7w14g6se.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7w14g6se.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp7w14g6se.jl:31\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0, 1, 2, 1, 2, 3, 2, 1, 2, 3, 4, 3, 2, 1] == [4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7w14g6se.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7w14g6se.jl:28\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7w14g6se.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    return [maximum([maximum(findnest(chars(x))) for x in levels(chars(x))])\
    \ for x in split(paren_string)]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpnyg0e31f.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ chars not defined\n  Stacktrace:\n   [1] (::var\"#1#3\")(x::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#3\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpnyg0e31f.jl:9\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpnyg0e31f.jl:16 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpnyg0e31f.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpnyg0e31f.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: chars\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#3\")(x::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#3\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmpnyg0e31f.jl:9\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpnyg0e31f.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpnyg0e31f.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpnyg0e31f.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: chars not defined\n \
    \ Stacktrace:\n   [1] (::var\"#1#3\")(x::SubString{String})\n     @ Main ./none:0\n\
    \   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#3\"})\n     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnyg0e31f.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Create a vector with each parentheses group as a separate element.\n\
    \    paren_vec = split(paren_string, \" \")\n    # Create a vector to store the\
    \ depth of each of the parentheses groups.\n    depth_vec = zeros(Int64, length(paren_vec))\n\
    \    # For each of the parentheses group.\n    for i = 1:length(paren_vec)\n \
    \       # Get the current parentheses group.\n        paren_group = paren_vec[i]\n\
    \        # Set the initial depth count to 0.\n        depth = 0\n        # Set\
    \ the maximum depth count to 0.\n        max_depth = 0\n        # For each of\
    \ the parentheses character in the group.\n        for paren in paren_group\n\
    \            # If the character is '(' update the depth count by 1.\n        \
    \    if paren == '('\n                depth += 1\n            # If the character\
    \ is ')' update the depth count by -1.\n            elseif paren == ')'\n    \
    \            depth -= 1\n            end\n            # Update the maximum depth\
    \ count.\n            max_depth = max(max_depth, depth)\n        end\n       \
    \ # Store the maximum depth in the depth vector.\n        depth_vec[i] = max_depth\n\
    \    end\n    # Return the depth vector.\n    return depth_vec\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    i = 0\n    j = 0\n    # Creates a vector to store number of levels of\
    \ nesting for each group\n    level_of_nesting = Vector{Int64}()\n    num_paren\
    \ = 0\n    # Iterates through the string and counts left and right parentheses\n\
    \    for i in 1:length(paren_string)\n        if paren_string[i] == '('\n    \
    \        num_paren += 1\n        elseif paren_string[i] == ')'\n            num_paren\
    \ -= 1\n        elseif paren_string[i] == ' '\n            # At each space, we\
    \ reset num_paren, and push back num_paren at the previous space to the vector\n\
    \            push!(level_of_nesting, num_paren)\n            num_paren = 0\n \
    \       end\n    end\n    # We push back the last value of num_paren\n    push!(level_of_nesting,\
    \ num_paren)\n    return level_of_nesting\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3ldamdmh.jl:35\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3ldamdmh.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3ldamdmh.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp3ldamdmh.jl:36\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3ldamdmh.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3ldamdmh.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp3ldamdmh.jl:37\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3ldamdmh.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3ldamdmh.jl:34\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3ldamdmh.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open_par_indices = findall(x -> x == '(' , paren_string)\n    close_par_indices\
    \ = findall(x -> x == ')' , paren_string)\n    groups = split(paren_string, \"\
    \ \")\n    return_vector = []\n    max_depth = 0\n    open_index = 0\n    close_index\
    \ = 0\n    for group in groups\n        open_index = 0\n        close_index =\
    \ 0\n        max_depth = 0\n        open_par_stack = []\n        while open_index\
    \ <= length(group) && close_index <= length(group)\n            if open_index\
    \ <= length(group) && group[open_index] == '('\n                push!(open_par_stack,\
    \ open_index)\n                open_index += 1\n            elseif close_index\
    \ <= length(group) && group[close_index] == ')'\n                pop!(open_par_stack)\n\
    \                close_index += 1\n            end\n            max_depth = max(max_depth,\
    \ length(open_par_stack))\n        end\n        push!(return_vector, max_depth)\n\
    \    end\n    return return_vector\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3e08b3k3.jl:40\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  BoundsError:\
    \ attempt to access 6-codeunit SubString{String} at index [0]\n  Stacktrace:\n\
    \   [1] checkbounds\n     @ ./strings/basic.jl:216 [inlined]\n   [2] getindex(s::SubString{String},\
    \ i::Int64)\n     @ Base ./strings/substring.jl:83\n   [3] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp3e08b3k3.jl:22\n   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmp3e08b3k3.jl:40 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp3e08b3k3.jl:39\ntest set:\
    \ Error During Test at /tmp/tmp3e08b3k3.jl:41\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  BoundsError: attempt\
    \ to access 2-codeunit SubString{String} at index [0]\n  Stacktrace:\n   [1] checkbounds\n\
    \     @ ./strings/basic.jl:216 [inlined]\n   [2] getindex(s::SubString{String},\
    \ i::Int64)\n     @ Base ./strings/substring.jl:83\n   [3] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp3e08b3k3.jl:22\n   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmp3e08b3k3.jl:41 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp3e08b3k3.jl:39\ntest set:\
    \ Error During Test at /tmp/tmp3e08b3k3.jl:42\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  BoundsError: attempt to access 14-codeunit\
    \ SubString{String} at index [0]\n  Stacktrace:\n   [1] checkbounds\n     @ ./strings/basic.jl:216\
    \ [inlined]\n   [2] getindex(s::SubString{String}, i::Int64)\n     @ Base ./strings/substring.jl:83\n\
    \   [3] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmp3e08"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3e08b3k3.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    count = 0 # store the depth of nested parentheses\n    res = [] # store\
    \ the result\n    for c in paren_string\n        # start counting nested parentheses\
    \ only if encountered '('\n        if c == '('\n            count += 1\n     \
    \   # the depth of nested parentheses is updated only when encountered ')'\n \
    \       elseif c == ')'\n            res = push!(res, count)\n            count\
    \ -= 1\n        end\n    end\n    return res\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpici24bk2.jl:28\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 2, 1, 3, 2,\
    \ 1, 1, 3, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpici24bk2.jl:28 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpici24bk2.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpici24bk2.jl:29\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 2, 1, 3, 2, 1, 4, 3, 2, 1] == [1, 2, 3, 4]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpici24bk2.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpici24bk2.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpici24bk2.jl:30\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [2, 3, 2, 4, 3, 2, 1] == [4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpici24bk2.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpici24bk2.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpici24bk2.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, \" \")\n    depths = []\n    for paren_group\
    \ in groups\n        curr_depth = 0\n        max_depth = 0\n        for paren\
    \ in paren_group\n            if paren == '('\n                curr_depth += 1\n\
    \            elseif paren == ')'\n                curr_depth -= 1\n          \
    \  end\n            if curr_depth > max_depth\n                max_depth = curr_depth\n\
    \            end\n        end\n        push!(depths, max_depth)\n    end\n   \
    \ return depths\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Store the max. number of parenthesis so far.\n    max_depth = 0\n  \
    \  # Store the current depth of nesting.\n    depth = 0\n    # Store the output\
    \ vector, each element of which is a max. depth of a separate group of parentheses.\n\
    \    output = Vector{Int64}()\n    # Keep track of the parens that haven't been\
    \ closed yet.\n    # State 0 means the previous character wasn't a paren.\n  \
    \  # State 1 means that we have a left paren and need a right one.\n    # State\
    \ 2 means that we have a left paren and already encountered a right one.\n   \
    \ state = 0\n    for c in paren_string\n        if state == 0 && c == '('\n  \
    \          # Update state for next iteration.\n            state = 1\n       \
    \     # Increment the depth.\n            depth += 1\n            # Update max_depth\
    \ if needed.\n            if depth > max_depth\n                max_depth = depth\n\
    \            end\n        elseif state == 1 && c == ')'\n            # Update\
    \ state for next iteration.\n            state = 2\n            # Decrement the\
    \ depth.\n            depth -= 1\n        elseif state == 2 && c == '('\n    \
    \        # Update state for next iteration.\n            state = 1\n         \
    \   # Increment the depth.\n            depth += 1\n            # Update max_depth\
    \ if needed.\n            if depth > max_depth\n                max_depth = depth\n\
    \            end\n        elseif state == 2 && c == ' '\n            # Update\
    \ state for next iteration.\n            state = 0\n            # Save the current\
    \ depth in the output vector.\n            push!(output, max_depth)\n        \
    \    # Reset depth and max_depth for the next group of parens.\n            depth\
    \ = 0\n            max_depth = 0\n        end\n    end\n    # Save the last group\
    \ of parens.\n    push!(output, max_depth)\n    return output\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpkmeq1ia5.jl:63\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [1, 1, 1, 1] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkmeq1ia5.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkmeq1ia5.jl:62\ntest set: Test\
    \ Failed at /tmp/tmpkmeq1ia5.jl:64\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 1, 1, 1] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkmeq1ia5.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkmeq1ia5.jl:62\ntest set: Test\
    \ Failed at /tmp/tmpkmeq1ia5.jl:65\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [1] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkmeq1ia5.jl:65 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkmeq1ia5.jl:62\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkmeq1ia5.jl:60\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    group_arr = split(paren_string, \" \") # split the string into groups\
    \ of parentheses\n    depth_arr = zeros(Int64, size(group_arr)) # initialize array\
    \ to hold depth of each group\n    for (i, paren_group) in enumerate(group_arr)\
    \ # iterate through groups\n        depth = 0 # current depth\n        max_depth\
    \ = 0 # max depth in this group\n        for c in paren_group #iterate through\
    \ characters in a group\n            if c == '('\n                depth += 1\n\
    \            elseif c == ')'\n                depth -= 1\n            end\n  \
    \          if depth > max_depth\n                max_depth = depth\n         \
    \   end\n        end\n        depth_arr[i] = max_depth\n    end\n    return depth_arr\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    #@@@ initialize the vector with zeros that will be filled later @@@\n\
    \    deepest_nesting = Vector{Int64}(0)\n    i = 1\n    while i <= length(paren_string)\n\
    \        if paren_string[i] == '('\n            #@@@ if you find an opening parenthesis,\
    \ add 1 to the count @@@\n            counter = 1\n            #@@@ start your\
    \ loop @@@\n            for j in (i+1):length(paren_string)\n                if\
    \ paren_string[j] == '('\n                    #@@@ if you find an opening parenthesis,\
    \ add 1 to the count @@@\n                    counter += 1\n                elseif\
    \ paren_string[j] == ')'\n                    #@@@ if you find a closing parenthesis,\
    \ subtract 1 from the count @@@\n                    counter -= 1\n          \
    \      end\n                #@@@ break out of the loop if you reach a count of\
    \ 0 @@@\n                if counter == 0\n                    break\n        \
    \        end\n            end\n            #@@@ push back the maximum count of\
    \ the current group @@@\n            push!(deepest_nesting, counter)\n       \
    \     #@@@ j is the index of the end of the current group, so update i to the\
    \ end of the current group @@@\n            i = j\n        end\n        i += 1\n\
    \    end\n    return deepest_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwx4y2468.jl:44\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpwx4y2468.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwx4y2468.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwx4y2468.jl:43\ntest set:\
    \ Error During Test at /tmp/tmpwx4y2468.jl:45\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpwx4y2468.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwx4y2468.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwx4y2468.jl:43\ntest set:\
    \ Error During Test at /"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwx4y2468.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, \" \")\n    return vcat([(level(i) + 1) for\
    \ i in groups]...)\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp746xgi78.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ level not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(i::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp746xgi78.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp746xgi78.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp746xgi78.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp746xgi78.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: level\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(i::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmp746xgi78.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp746xgi78.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp746xgi78.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp746xgi78.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: level not defined\n \
    \ Stacktrace:\n   [1] (::var\"#1#2\")(i::SubString{String})\n     @ Main ./none:0\n\
    \   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"})\n     @ Base"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp746xgi78.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    res = []\n    for x in split(paren_string, \" \")\n        level = 0\n\
    \        max_level = 0\n        for char in x\n            if char == '('\n  \
    \              level += 1\n            elseif char == ')'\n                level\
    \ -= 1\n            end\n            if level > max_level\n                max_level\
    \ = level\n            end\n        end\n        push!(res, max_level)\n    end\n\
    \    return res\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    parse_nested_parens(paren_string) = split(paren_string) |> x -> x |> p\
    \ -> p |> q -> q\n    return(parse_nested_parens(paren_string))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpfa1gs1sq.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type SubString{String} to an object of type Int64\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::T) where T<:Number\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:6\n    convert(::Type{T},\
    \ !Matched::Number) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:7\n\
    \    convert(::Type{T}, !Matched::Base.TwicePrecision) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/twiceprecision.jl:262\n\
    \    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::SubString{String},\
    \ i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64},\
    \ doffs::Int64, src::Vector{SubString{String}}, soffs::Int64, n::Int64)\n    \
    \  @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n\
    \    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n  \
    \    @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n\
    \    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{SubString{String}})\n\
    \      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n\
    \   [10] parse_nested_parens(paren_string::String)\n      @ Main /tmp/tmpfa1gs1sq.jl:10\n\
    \   [11] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [12] macro expansion\n      @ /tmp/tmpfa1gs1sq.jl:17 [inlined]\n\
    \   [13] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [14] top-level scope\n      @ /tmp/tmpfa1gs1sq.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpfa1gs1sq.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: Cannot\
    \ `convert` an object of type SubString{String} to an object of type Int64\n \
    \ Closest candidates are:\n    convert(::Type{T}, !Matched::T) where "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfa1gs1sq.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_strings = split(paren_string, \" \")\n    n_paren_strings = length(paren_strings)\n\
    \    output = zeros(Int64, n_paren_strings)\n    for (i, paren_string) in enumerate(paren_strings)\n\
    \        paren_counter = 0\n        max_paren_counter = 0\n        for char in\
    \ paren_string\n            if char == '('\n                paren_counter += 1\n\
    \            elseif char == ')'\n                paren_counter -= 1\n        \
    \    end\n            if paren_counter > max_paren_counter\n                max_paren_counter\
    \ = paren_counter\n            end\n        end\n        output[i] = max_paren_counter\n\
    \    end\n    return output\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    depth_vec = Int64[]\n    # loop over the string\n    current_depth = 0\n\
    \    for char in paren_string\n        if char == '('\n            current_depth\
    \ += 1\n        elseif char == ')'\n            push!(depth_vec, current_depth)\n\
    \            current_depth -= 1\n        end\n    end\n    return depth_vec\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp1za64wn2.jl:27\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 2, 1, 3, 2,\
    \ 1, 1, 3, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp1za64wn2.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1za64wn2.jl:26\ntest set: Test\
    \ Failed at /tmp/tmp1za64wn2.jl:28\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 2, 1, 3, 2, 1, 4, 3, 2, 1] == [1, 2, 3, 4]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1za64wn2.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1za64wn2.jl:26\ntest set: Test\
    \ Failed at /tmp/tmp1za64wn2.jl:29\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [2, 3, 2, 4, 3, 2, 1] == [4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1za64wn2.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1za64wn2.jl:26\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1za64wn2.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # The length of the vector should be the same as the number of groups\
    \ in the input string\n    v = Vector{Int64}(undef, length(split(paren_string)))\n\
    \    idx = 1 # index in the vector v\n    for paren_group in split(paren_string)\n\
    \        level = 0\n        # Your code goes here\n        for paren in paren_group\n\
    \            if paren == '('\n                level += 1\n            elseif paren\
    \ == ')'\n                level -= 1\n            end\n        end\n        v[idx]\
    \ = level\n        idx += 1\n    end\n    return v\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgxwcs6c9.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgxwcs6c9.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgxwcs6c9.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpgxwcs6c9.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgxwcs6c9.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgxwcs6c9.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpgxwcs6c9.jl:34\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgxwcs6c9.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgxwcs6c9.jl:31\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgxwcs6c9.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_substrings = split(paren_string, \" \")\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp6deqpg09.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp6deqpg09.jl:1\n\
    in expression starting at /tmp/tmp6deqpg09.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, ' ')\n    max_levels = Vector{Int64}(undef,\
    \ length(groups))\n    for i in 1:length(groups)\n        max_levels[i] = parse_nested_parens_group(groups[i])\n\
    \    end\n    return max_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpko4wil4m.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_group not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpko4wil4m.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpko4wil4m.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpko4wil4m.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpko4wil4m.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_group\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpko4wil4m.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpko4wil4m.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpko4wil4m.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpko4wil4m.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_group\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpko4wil4m.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpko4wil4m.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpko4wil4m.jl:20\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpko4wil4m.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    max_level = 0\n    result = Vector{Int64}()\n    level = 0\n    for (i,\
    \ paren) in enumerate(paren_string)\n        if paren == '('\n            level\
    \ += 1\n        elseif paren == ')'\n            level -= 1\n        elseif paren\
    \ == ' '\n            result = [result; level]\n            level = 0\n      \
    \  end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp17qe5l15.jl:29\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp17qe5l15.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp17qe5l15.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp17qe5l15.jl:30\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp17qe5l15.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp17qe5l15.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp17qe5l15.jl:31\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp17qe5l15.jl:31 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp17qe5l15.jl:28\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp17qe5l15.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    tokens = split(paren_string, \" \")\n    max_nest = []\n    for i in 1:length(tokens)\n\
    \        token = tokens[i]\n        max_nest_i = 0\n        while(token[end] ==\
    \ ')')\n            max_nest_i += 1\n            token = token[1:end-1]\n    \
    \    end\n        push!(max_nest, max_nest_i)\n    end\n    return max_nest\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpgkdf9axg.jl:27\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 3, 1, 2] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgkdf9axg.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgkdf9axg.jl:26\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     1      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgkdf9axg.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    n_levels = []\n    for group in split(paren_string)\n        level = 0\n\
    \        max_level = 0\n        for paren in group\n            if paren == '('\n\
    \                level += 1\n            elseif paren == ')'\n               \
    \ level -= 1\n            end\n            max_level = max(max_level, level)\n\
    \        end\n        push!(n_levels, max_level)\n    end\n    return n_levels\n\
    end\n \nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    return paren_string |> each_char |> partition_by(is_paren) |>\n      \
    \      map(x -> Int64(sum(map(is_open, x)) - sum(map(is_close, x)))) |>\n    \
    \        vcat() |> max_nesting |> filter(!iszero, 1:end)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing last argument in \"1:\" range expression\
    \ \nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpeu1pq58b.jl:11\nin expression\
    \ starting at /tmp/tmpeu1pq58b.jl:11\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    level_vec = []\n    for group in split(paren_string, \" \")\n        level\
    \ = 0\n        max_level = 0\n        for paren in group\n            if paren\
    \ == '('\n                level += 1\n            elseif paren == ')'\n      \
    \          level -= 1\n            end\n            if level > max_level\n   \
    \             max_level = level\n            end\n        end\n        push!(level_vec,\
    \ max_level)\n    end\n    return level_vec\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # function parse_nested_parens(paren_string::String)::Vector{Int64}\n\
    \    # Don't forget that you can use the push!(output_array, value) to add values\
    \ to a vector.\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_7tiihlt.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_7tiihlt.jl:1\n\
    in expression starting at /tmp/tmp_7tiihlt.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    #start off with an empty stack\n    stack = []\n    max_depth = 0\n  \
    \  depth = 0\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwnbx057l.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwnbx057l.jl:1\n\
    in expression starting at /tmp/tmpwnbx057l.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    levels = []\n    for group in split(paren_string, \" \")\n        level\
    \ = 0\n        max_level = 0\n        for c in group\n            if c == '('\n\
    \                level += 1\n            elseif c == ')'\n                level\
    \ -= 1\n            end\n            max_level = max(max_level, level)\n     \
    \   end\n        push!(levels, max_level)\n    end\n    return levels\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    res = zeros(Int64, length(paren_groups))\n\
    \    for i in 1:length(paren_groups)\n        depth = 0\n        max_depth = 0\n\
    \        for j in 1:length(paren_groups[i])\n            if paren_groups[i][j]\
    \ == '('\n                depth += 1\n            elseif paren_groups[i][j] ==\
    \ ')'\n                depth -= 1\n            end\n            if depth > max_depth\n\
    \                max_depth = depth\n            end\n        end\n        res[i]\
    \ = max_depth\n    end\n    return res\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    tokens = split(paren_string, \" \")\n    deep_level = []\n    for token\
    \ in tokens\n        level = 0\n        max_level = 0\n        for letter in token\n\
    \            if letter == '('\n                level += 1\n            elseif\
    \ letter == ')'\n                level -= 1\n            end\n            if level\
    \ > max_level\n                max_level = level\n            end\n        end\n\
    \        push!(deep_level, max_level)\n    end\n    return deep_level\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \n    paren_groups = split(paren_string, \" \")\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpi3y4akfu.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpi3y4akfu.jl:1\n\
    in expression starting at /tmp/tmpi3y4akfu.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\" String to parse.\n    \"\"\"\n    paren_vec = split(paren_string)\
    \ # Vector of strings \n    return [parse_single_parens(x) for x in paren_vec]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp_qqp5unc.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_single_parens not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp_qqp5unc.jl:12\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp_qqp5unc.jl:19 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp_qqp5unc.jl:18\ntest set:\
    \ Error During Test at /tmp/tmp_qqp5unc.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_single_parens\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmp_qqp5unc.jl:12\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp_qqp5unc.jl:20 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp_qqp5unc.jl:18\ntest set:\
    \ Error During Test at /tmp/tmp_qqp5unc.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_single_parens not\
    \ defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n     @\
    \ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{S"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_qqp5unc.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    tokens = split(paren_string)\n    results = Vector{Int64}()\n    for token\
    \ in tokens\n        count = 0\n        max = 0\n        for char in token\n \
    \           if char == '('\n                count += 1\n            elseif char\
    \ == ')'\n                count -= 1\n            end\n            if count >\
    \ max\n                max = count\n            end\n        end\n        if count\
    \ != 0\n            throw(ErrorException(\"String did not have balanced parentheses\"\
    ))\n        end\n        push!(results, max)\n    end\n    return results\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \n    # Vector to store the number of levels of nesting for each group\n\
    \    levels = Int64[]\n    \n    # String split by spaces\n    paren_groups =\
    \ split(paren_string, \" \")\n    \n    # For each group, check the level of nesting\n\
    \    for group in paren_groups\n        level = 0\n        max_level = 0\n   \
    \     for symbol in group\n            if symbol == '('\n                level\
    \ += 1\n            elseif symbol == ')'\n                level -= 1\n       \
    \     end\n            if level > max_level\n                max_level = level\n\
    \            end\n        end\n        push!(levels, max_level)\n    end\n   \
    \ \n    return levels\nend\nparse_nested_parens('(()()) ((())) () ((())()())')\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpwqvud_sk.jl:35\nin expression\
    \ starting at /tmp/tmpwqvud_sk.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_arr = split(paren_string, \" \")\n    depth_arr = Vector{Int64}(length(paren_arr))\n\
    \    current_depth = 0\n    max_depth = 0\n    for i in 1:length(paren_arr)\n\
    \        current_depth = 0\n        paren_str = paren_arr[i]\n        for j in\
    \ 1:length(paren_str)\n            if paren_str[j] == '('\n                current_depth\
    \ += 1\n            elseif paren_str[j] == ')'\n                current_depth\
    \ -= 1\n            end\n            if current_depth > max_depth\n          \
    \      max_depth = current_depth\n            end\n        end\n        depth_arr[i]\
    \ = max_depth\n    end\n    return depth_arr\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp37vql30m.jl:35\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp37vql30m.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp37vql30m.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp37vql30m.jl:34\ntest set:\
    \ Error During Test at /tmp/tmp37vql30m.jl:36\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp37vql30m.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp37vql30m.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp37vql30m.jl:34\ntest set:\
    \ Error During Test at /"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp37vql30m.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Your code here\n    # Hint: You could use a stack to keep track of the\
    \ number of nested parentheses\nend\nparse_nested_parens('(()()) ((())) () ((())()())')\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpx1nbypy9.jl:12\nin expression\
    \ starting at /tmp/tmpx1nbypy9.jl:12\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    stack = 0\n    max_depth = 0\n    depths = []\n    for c in paren_string\n\
    \        if c == '('\n            stack += 1\n            max_depth = max(max_depth,\
    \ stack)\n        elseif c == ')'\n            stack -= 1\n        elseif c ==\
    \ ' '\n            push!(depths, max_depth)\n            max_depth = 0\n     \
    \   end\n    end\n    push!(depths, max_depth)\n    return depths\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Split string by spaces to get substrings for each group of nested parentheses\n\
    \    # Using a vector comprehension and map\n    return [maximum(map(x -> sum(x\
    \ == '(') - sum(x == ')'), strsplit(paren_string_group, \"\")))\n        for paren_string_group\
    \ in split(paren_string, \" \")]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpp7ooc_jd.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ strsplit not defined\n  Stacktrace:\n   [1] (::var\"#1#3\")(paren_string_group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#3\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpp7ooc_jd.jl:11\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpp7ooc_jd.jl:19 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpp7ooc_jd.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpp7ooc_jd.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: strsplit\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#3\")(paren_string_group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#3\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpp7ooc_jd.jl:11\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpp7ooc_jd.jl:20 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpp7ooc_jd.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpp7ooc_jd.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: strsplit not defined\n\
    \  Stacktrace:\n   [1] (::var\"#1#3\")(paren_string_group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp7ooc_jd.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Split the string on whitespace and remove spaces from the substrings\n\
    \    group_array = split(paren_string)\n    group_array = [strip(x) for x in group_array]\n\
    \    \n    level_array = []\n    for x in group_array\n        level_array = push!(level_array,\
    \ max_level(x))\n    end\n    return level_array\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpfagzkpb_.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ max_level not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpfagzkpb_.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfagzkpb_.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfagzkpb_.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpfagzkpb_.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: max_level\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpfagzkpb_.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfagzkpb_.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfagzkpb_.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpfagzkpb_.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: max_level not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpfagzkpb_.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfagzkpb_.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfagzkpb_.jl:23\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfagzkpb_.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    levels = Vector{Int64}()\n    max_level = 0\n    start_paren = \"(\"\n\
    \    end_paren = \")\"\n    for c in paren_string\n        if c == start_paren\n\
    \            max_level += 1\n        elseif c == end_paren\n            push!(levels,\
    \ max_level)\n            max_level -= 1\n        end\n    end\n    return levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmptoi3iu0m.jl:28\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: Int64[] == [2, 3,\
    \ 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptoi3iu0m.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptoi3iu0m.jl:27\ntest set: Test\
    \ Failed at /tmp/tmptoi3iu0m.jl:29\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: Int64[] == [1, 2, 3, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptoi3iu0m.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptoi3iu0m.jl:27\ntest set: Test\
    \ Failed at /tmp/tmptoi3iu0m.jl:30\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmptoi3iu0m.jl:30 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptoi3iu0m.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptoi3iu0m.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_strings = split(paren_string, \" \")\n    return [parse_nested_parens_helper(s)\
    \ for s in paren_strings]\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6_e4uzgr.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] (::var\"#1#2\"\
    )(s::SubString{String})\n     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47\
    \ [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"\
    #1#2\"})\n     @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp6_e4uzgr.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp6_e4uzgr.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp6_e4uzgr.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp6_e4uzgr.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(s::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmp6_e4uzgr.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp6_e4uzgr.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp6_e4uzgr.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp6_e4uzgr.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(s::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Ba"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6_e4uzgr.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"Returns the depths of the nested parentheses in each group of parentheses.\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpf6_1un2q.jl:1\nin expression starting at /tmp/tmpf6_1un2q.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    max_depth = 0\n    max_depth_vector = []\n    length_paren_string = length(paren_string)\n\
    \    temp_max_depth = 0\n    index = 1\n    while index <= length_paren_string\n\
    \        current_char = paren_string[index]\n        if current_char == '('\n\
    \            temp_max_depth += 1\n            if temp_max_depth > max_depth\n\
    \                max_depth = temp_max_depth\n            end\n        elseif current_char\
    \ == ')'\n            temp_max_depth -= 1\n        elseif current_char == ' '\n\
    \            push!(max_depth_vector, max_depth)\n            max_depth = 0\n \
    \           temp_max_depth = 0\n        end\n        index += 1\n    end\n   \
    \ push!(max_depth_vector, max_depth)\n    return max_depth_vector\nend\n# Your\
    \ function goes here:\n# Feel free to add more cells as you need\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpkkssza1d.jl:35\nin expression\
    \ starting at /tmp/tmpkkssza1d.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    out = Vector{Int64}()\n    for paren_group in split(paren_string, \" \"\
    )\n        push!(out, find_max_nested_parens(paren_group))\n    end\n    return\
    \ out\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp76_jia2v.jl:20\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ find_max_nested_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp76_jia2v.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp76_jia2v.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp76_jia2v.jl:19\ntest set:\
    \ Error During Test at /tmp/tmp76_jia2v.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: find_max_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp76_jia2v.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp76_jia2v.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp76_jia2v.jl:19\ntest set:\
    \ Error During Test at /tmp/tmp76_jia2v.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: find_max_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp76_jia2v.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp76_jia2v.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp76_jia2v.jl:19\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp76_jia2v.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    stack = []\n    levels = []\n    for (c, idx) in zip(paren_string, 1:length(paren_string))\n\
    \        if c == '('\n            push!(stack, idx)\n        elseif c == ')'\n\
    \            if length(stack) == 0\n                throw(OutOfBoundsError(\"\
    Not a well-formed paren string\"))\n            end\n            push!(levels,\
    \ idx - pop!(stack))\n        end\n    end\n    levels\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpo_l4hvgv.jl:28\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [1, 1, 5, 1, 3,\
    \ 5, 1, 1, 3, 1, 1, 9] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpo_l4hvgv.jl:28 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo_l4hvgv.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpo_l4hvgv.jl:29\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 1, 3, 1, 3, 5, 1, 3, 5, 7] == [1, 2, 3, 4]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo_l4hvgv.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo_l4hvgv.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpo_l4hvgv.jl:30\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [1, 1, 3, 1, 3, 5, 13] == [4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo_l4hvgv.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo_l4hvgv.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo_l4hvgv.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    par_levels = []\n    for p in split(paren_string, \" \")\n        stack\
    \ = []\n        max_level = 0\n        level = 0\n        for s in p\n       \
    \     if s == '('\n                push!(stack, 1)\n                level += 1\n\
    \                if level > max_level\n                    max_level = level\n\
    \                end\n            elseif s == ')'\n                pop!(stack)\n\
    \                level -= 1\n            end\n        end\n        push!(par_levels,\
    \ max_level)\n    end\n    return par_levels\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    result = Vector{Int64}()\n\
    \    start_pos = 1\n    for i in 1:length(paren_string)\n        if paren_string[i]\
    \ == ')'\n            push!(result, count_nested_parens(paren_string[start_pos:i]))\n\
    \            start_pos = i + 1\n        end\n    end\n    return result\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmphwuqff82.jl:25\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_nested_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmphwuqff82.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphwuqff82.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphwuqff82.jl:24\ntest set:\
    \ Error During Test at /tmp/tmphwuqff82.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmphwuqff82.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphwuqff82.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphwuqff82.jl:24\ntest set:\
    \ Error During Test at /tmp/tmphwuqff82.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: count_nested_parens not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n \
    \    @ Main /tmp/tmphwuqff82.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphwuqff82.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphwuqff82.jl:24\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphwuqff82.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Convert the string to an array of characters\n    paren_chars = collect(paren_string)\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp25flmyey.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp25flmyey.jl:1\n\
    in expression starting at /tmp/tmp25flmyey.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_stack = []\n    max_nesting = Int64[]\n    for c in paren_string\n\
    \        if c == '('\n            push!(paren_stack, '(')\n        elseif c ==\
    \ ')'\n            if isempty(paren_stack)\n                push!(max_nesting,\
    \ 0)\n            else\n                pop!(paren_stack)\n                push!(max_nesting,\
    \ length(paren_stack))\n            end\n        end\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp3l27yq_6.jl:30\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [1, 1, 0, 2, 1,\
    \ 0, 0, 2, 1, 1, 1, 0] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp3l27yq_6.jl:30 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3l27yq_6.jl:29\ntest set: Test\
    \ Failed at /tmp/tmp3l27yq_6.jl:31\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 1, 0, 2, 1, 0, 3, 2, 1, 0] == [1, 2, 3, 4]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3l27yq_6.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3l27yq_6.jl:29\ntest set: Test\
    \ Failed at /tmp/tmp3l27yq_6.jl:32\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [1, 2, 1, 3, 2, 1, 0] == [4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3l27yq_6.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3l27yq_6.jl:29\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3l27yq_6.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open_parens = 0\n    max_open_parens = 0\n    num_parens = 0\n    max_nesting\
    \ = []\n    for i = 1:length(paren_string)\n        if paren_string[i] == '('\n\
    \            open_parens += 1\n            num_parens += 1\n            if open_parens\
    \ > max_open_parens\n                max_open_parens = open_parens\n         \
    \   end\n        elseif paren_string[i] == ')'\n            open_parens -= 1\n\
    \        elseif paren_string[i] == ' '\n            push!(max_nesting, max_open_parens)\n\
    \            max_open_parens = 0\n            num_parens = 0\n        end\n  \
    \  end\n    push!(max_nesting, max_open_parens)\n    return max_nesting\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    levels = Vector{Int64}()\n    max_level = 0\n    for c in paren_string\n\
    \        if c == '('\n            max_level += 1\n        elseif c == ')'\n  \
    \          push!(levels, max_level)\n            max_level -= 1\n        end\n\
    \    end\n    return levels\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpt3c7b_r0.jl:26\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 2, 1, 3, 2,\
    \ 1, 1, 3, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpt3c7b_r0.jl:26 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt3c7b_r0.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpt3c7b_r0.jl:27\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 2, 1, 3, 2, 1, 4, 3, 2, 1] == [1, 2, 3, 4]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpt3c7b_r0.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt3c7b_r0.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpt3c7b_r0.jl:28\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [2, 3, 2, 4, 3, 2, 1] == [4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpt3c7b_r0.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt3c7b_r0.jl:25\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt3c7b_r0.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    #create an array of strings, each of which is a single group of nested\
    \ parentheses\n    paren_array = split(paren_string, \" \")\n    max_nesting =\
    \ []\n    for paren in paren_array\n        #count the left parenthesis in the\
    \ string\n        num_left_paren = sum(c -> c == '(' ? 1 : 0, paren)\n       \
    \ #count the right parenthesis in the string\n        num_right_paren = sum(c\
    \ -> c == ')' ? 1 : 0, paren)\n        #count the number of parentheses that are\
    \ in a valid nesting\n        num_nested_paren = sum(c -> (c == '(' || c == ')')\
    \ && num_left_paren > num_right_paren ? 1 : 0, paren)\n        #calculate the\
    \ remaining number of parentheses that are not in a valid nesting\n        num_remaining_paren\
    \ = (num_left_paren + num_right_paren) - num_nested_paren\n        #calculate\
    \ the maximum number of levels of nesting = the remaining number of parentheses\
    \ divided by 2\n        num_max_nesting = num_remaining_paren / 2\n        #append\
    \ the maximum number of levels of nesting for this group of nested parentheses\
    \ to an array\n        push!(max_nesting, num_max_nesting)\n    end\n    #return\
    \ the array of maximum numbers of levels of nesting for each group of nested parentheses\n\
    \    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprnmph8nc.jl:34\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [3, 3, 1, 5] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprnmph8nc.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprnmph8nc.jl:33\ntest set: Test\
    \ Failed at /tmp/tmprnmph8nc.jl:36\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [7] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprnmph8nc.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprnmph8nc.jl:33\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     2      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprnmph8nc.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    left_parens = 0\n    max_nesting = 0\n    current_nesting = 0\n    group_nesting\
    \ = []\n    for char in paren_string\n        if char == '('\n            left_parens\
    \ += 1\n            current_nesting += 1\n            if current_nesting > max_nesting\n\
    \                max_nesting = current_nesting\n            end\n        elseif\
    \ char == ')'\n            current_nesting -= 1\n        elseif char == ' '\n\
    \            if left_parens == 0\n                continue\n            end\n\
    \            append!(group_nesting, max_nesting)\n            max_nesting = 0\n\
    \            current_nesting = 0\n            left_parens = 0\n        end\n \
    \   end\n    if left_parens != 0\n        append!(group_nesting, max_nesting)\n\
    \    end\n    return group_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    num_parens = 0\n    paren_levels = Vector{Int64}()\n    for c in paren_string\n\
    \        if c == '('\n            num_parens += 1\n        elseif c == ')'\n \
    \           num_parens -= 1\n        elseif c == ' '\n            push!(paren_levels,\
    \ num_parens)\n        end\n    end\n    paren_levels\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1jz6kajw.jl:27\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1jz6kajw.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1jz6kajw.jl:26\ntest set: Test\
    \ Failed at /tmp/tmp1jz6kajw.jl:28\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1jz6kajw.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1jz6kajw.jl:26\ntest set: Test\
    \ Failed at /tmp/tmp1jz6kajw.jl:29\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp1jz6kajw.jl:29 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1jz6kajw.jl:26\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1jz6kajw.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, r\"[^()]\", \"\")\n    output = []\n\
    \    while length(paren_string) > 0\n        stack = []\n        count = 0\n \
    \       for i = 1:length(paren_string)\n            ch = paren_string[i]\n   \
    \         if ch == '('\n                push!(stack, ch)\n            elseif ch\
    \ == ')'\n                pop!(stack)\n                count += 1\n          \
    \  end\n        end\n        output = [output; count]\n        paren_string =\
    \ replace(paren_string, r\"\\([^()]*\\)\", \"\")\n    end\n    return output\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpir99gr5c.jl:33\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::Regex, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpir99gr5c.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpir99gr5c.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpir99gr5c.jl:32\ntest set:\
    \ Error During Test at /tmp/tmpir99gr5c.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::Regex, ::String)\n  Closest candidates are:\n \
    \   replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpir99gr5c.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpir99gr5c.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:12"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpir99gr5c.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    result = Int64[]\n    group_split = split(paren_string, ' ')\n    for\
    \ group in group_split\n        level = 0\n        paren_max = 0\n        for\
    \ paren in group\n            if paren == '('\n                level += 1\n  \
    \          elseif paren == ')'\n                level -= 1\n            end\n\
    \            paren_max = max(paren_max, level)\n        end\n        push!(result,\
    \ paren_max)\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    levels = Int64[]\n    current_level = 0\n    for c in paren_string\n \
    \       if c == '('\n            current_level += 1\n        elseif c == ')'\n\
    \            if current_level == 0\n                throw(ArgumentError(\"Input\
    \ not well formed\"))\n            end\n            push!(levels, current_level)\n\
    \            current_level -= 1\n        end\n    end\n    if current_level !=\
    \ 0\n        throw(ArgumentError(\"Input not well formed\"))\n    end\n    return\
    \ levels\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmph_ha6gd5.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 2, 1, 3, 2,\
    \ 1, 1, 3, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmph_ha6gd5.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph_ha6gd5.jl:31\ntest set: Test\
    \ Failed at /tmp/tmph_ha6gd5.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 2, 1, 3, 2, 1, 4, 3, 2, 1] == [1, 2, 3, 4]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph_ha6gd5.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph_ha6gd5.jl:31\ntest set: Test\
    \ Failed at /tmp/tmph_ha6gd5.jl:34\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [2, 3, 2, 4, 3, 2, 1] == [4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph_ha6gd5.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph_ha6gd5.jl:31\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph_ha6gd5.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_levels = Int64[]\n\
    \    for paren_group in paren_groups\n        paren_vec = collect(paren_group)\n\
    \        curr_count = 0\n        max_count = 0\n        for paren in paren_vec\n\
    \            if paren == '('\n                curr_count += 1\n            elseif\
    \ paren == ')'\n                curr_count -= 1\n            end\n           \
    \ if curr_count > max_count\n                max_count = curr_count\n        \
    \    end\n        end\n        push!(max_levels, max_count)\n    end\n    return\
    \ max_levels\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open_parens = 0\n    depths = []\n    for char in paren_string\n     \
    \   if char == '('\n            open_parens += 1\n        elseif char == ')'\n\
    \            push!(depths, open_parens)\n            open_parens -= 1\n      \
    \  end\n    end\n    return depths\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5_n6gcpp.jl:26\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 2, 1, 3, 2,\
    \ 1, 1, 3, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp5_n6gcpp.jl:26 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5_n6gcpp.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp5_n6gcpp.jl:27\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 2, 1, 3, 2, 1, 4, 3, 2, 1] == [1, 2, 3, 4]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5_n6gcpp.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5_n6gcpp.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp5_n6gcpp.jl:28\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [2, 3, 2, 4, 3, 2, 1] == [4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5_n6gcpp.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5_n6gcpp.jl:25\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5_n6gcpp.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    results = Vector{Int64}()\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpfj1l7y6x.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpfj1l7y6x.jl:1\n\
    in expression starting at /tmp/tmpfj1l7y6x.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = split(paren_string, ' ')\n    return [max_level_of_nesting(x)\
    \ for x in paren_string]\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpviz01dmp.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ max_level_of_nesting not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpviz01dmp.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpviz01dmp.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpviz01dmp.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpviz01dmp.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: max_level_of_nesting\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmpviz01dmp.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpviz01dmp.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpviz01dmp.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpviz01dmp.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: max_level_of_nesting\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vecto"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpviz01dmp.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, \" \")\n    deepest_paren_depth = Vector{Int64}(undef,\
    \ length(groups))\n    for (i, group) in enumerate(groups)\n        depth = 0\n\
    \        max_depth = 0\n        for paren in group\n            depth += paren\
    \ == '(' ? 1 : -1\n            max_depth = max(max_depth, depth)\n        end\n\
    \        deepest_paren_depth[i] = max_depth\n    end\n    return deepest_paren_depth\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, \" \")\n    max_depth = 0\n    depths = []\n\
    \    current_depth = 0\n    for group in groups\n        for char in group\n \
    \           if char == '('\n                current_depth += 1\n            elseif\
    \ char == ')'\n                current_depth -= 1\n            end\n        end\n\
    \        push!(depths, current_depth)\n        current_depth = 0\n    end\n  \
    \  return depths\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpo6vxgba2.jl:31\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo6vxgba2.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo6vxgba2.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpo6vxgba2.jl:32\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo6vxgba2.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo6vxgba2.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpo6vxgba2.jl:33\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo6vxgba2.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo6vxgba2.jl:30\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo6vxgba2.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_arr = split(paren_string)\n    num_parens = length(paren_arr)\n\
    \    max_levels = Vector{Int64}(undef, num_parens)\n    for i in 1:num_parens\n\
    \        max_level = 0\n        curr_paren_arr = [char for char in paren_arr[i]]\n\
    \        level = 0\n        for j in 1:length(curr_paren_arr)\n            if\
    \ curr_paren_arr[j] == '('\n                level += 1\n            elseif curr_paren_arr[j]\
    \ == ')'\n                level -= 1\n            end\n            if level >\
    \ max_level\n                max_level = level\n            end\n        end\n\
    \        max_levels[i] = max_level\n    end\n    return max_levels\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    curr_nest_level = 0\n    res = Int64[]\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp740scuiz.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp740scuiz.jl:1\n\
    in expression starting at /tmp/tmp740scuiz.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    output = []\n    for i in\
    \ 1:length(paren_list)\n        num_count = 0\n        for j in 1:length(paren_list[i])\n\
    \            if paren_list[i][j] == '('\n                num_count += 1\n    \
    \        elseif paren_list[i][j] == ')'\n                num_count -= 1\n    \
    \        end\n        end\n        push!(output, num_count)\n    end\n    return\
    \ output\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpb_m74pt0.jl:29\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb_m74pt0.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb_m74pt0.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpb_m74pt0.jl:30\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb_m74pt0.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb_m74pt0.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpb_m74pt0.jl:31\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb_m74pt0.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb_m74pt0.jl:28\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb_m74pt0.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    i = 1\n    n = length(paren_string)\n    max_levels = []\n    while i\
    \ <= n\n        while i <= n && !isalpha(paren_string[i])\n            i += 1\n\
    \        end\n        while i <= n && isalpha(paren_string[i])\n            i\
    \ += 1\n        end\n        # i points to \"(\" or \")\"\n        level = 0\n\
    \        max_level = 0\n        while i <= n && !isalpha(paren_string[i])\n  \
    \          if paren_string[i] == '('\n                level += 1\n           \
    \     max_level = max(max_level, level)\n            elseif paren_string[i] ==\
    \ ')'\n                level -= 1\n            end\n            i += 1\n     \
    \   end\n        push!(max_levels, max_level)\n    end\n    return max_levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp5dledwvr.jl:40\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ isalpha not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp5dledwvr.jl:13\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5dledwvr.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5dledwvr.jl:39\ntest set:\
    \ Error During Test at /tmp/tmp5dledwvr.jl:41\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: isalpha\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp5dledwvr.jl:13\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5dledwvr.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5dledwvr.jl:39\ntest set:\
    \ Error During Test at /tmp/tmp5dledwvr.jl:42\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: isalpha not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmp5dledwvr.jl:13\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5dledwvr.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5dledwvr.jl:39\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5dledwvr.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    count_op = Vector{Int64}()\n    paren_string_arr = split(paren_string,\
    \ ' ')\n    for paren_substring in paren_string_arr\n        count = 0\n     \
    \   max = 0\n        for c in paren_substring\n            if c == '('\n     \
    \           count += 1\n            elseif c == ')'\n                count -=\
    \ 1\n            end\n            if count > max\n                max = count\n\
    \            end\n        end\n        push!(count_op, max)\n    end\n    return\
    \ count_op\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    stack_count = Vector{Int64}() # Stack of number of open brackets yet to\
    \ be closed\n    for character in paren_string\n        if character == '(' \n\
    \            push!(stack_count, 1)\n        elseif character == ')'\n        \
    \    if endof(stack_count) > 0\n                pop!(stack_count)\n          \
    \  end\n        elseif character == ' '\n            # do nothing for space\n\
    \        else\n            # Throw error for invalid character\n            error(\"\
    Invalid character $character\")\n        end\n    end\n    stack_count\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpcxo9gfh4.jl:31\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ endof not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpcxo9gfh4.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcxo9gfh4.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcxo9gfh4.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpcxo9gfh4.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: endof\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpcxo9gfh4.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcxo9gfh4.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcxo9gfh4.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpcxo9gfh4.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: endof not defined\n \
    \ Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmpcxo9gfh4.jl:14\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcxo9gfh4.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcxo9gfh4.jl:30\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcxo9gfh4.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_levels = []\n    for\
    \ paren_group in paren_groups\n        max_level = 0\n        level = 0\n    \
    \    for c in paren_group\n            if c == '('\n                level += 1\n\
    \            elseif c == ')'\n                level -= 1\n            end\n  \
    \          if level > max_level\n                max_level = level\n         \
    \   end\n        end\n        push!(max_levels, max_level)\n    end\n    return\
    \ max_levels\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string_list = split(paren_string, \" \")\n    max_nesting_list =\
    \ []\n    for i in 1:length(paren_string_list)\n        count = 0\n        max_nesting\
    \ = 0\n        for j in 1:length(paren_string_list[i])\n            if paren_string_list[i][j]\
    \ == '('\n                count += 1\n                if count > max_nesting\n\
    \                    max_nesting = count\n                end\n            elseif\
    \ paren_string_list[i][j] == ')'\n                count -= 1\n            end\n\
    \        end\n        push!(max_nesting_list, max_nesting)\n    end\n    return\
    \ max_nesting_list\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open_paren = '('\n    close_paren = ')'\n    paren_stack = Stack{Char}()\n\
    \    max_depth = 0\n    paren_vec = Vector{Int64}()\n    for c in paren_string\n\
    \        if c == open_paren\n            push!(paren_stack, c)\n            max_depth\
    \ += 1\n        elseif c == close_paren\n            pop!(paren_stack)\n     \
    \       max_depth -= 1\n        elseif c == ' '\n            push!(paren_vec,\
    \ max_depth)\n            max_depth = 0\n        end\n    end\n    return paren_vec\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpa9fs4asq.jl:33\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ Stack not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpa9fs4asq.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpa9fs4asq.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpa9fs4asq.jl:32\ntest set:\
    \ Error During Test at /tmp/tmpa9fs4asq.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: Stack\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpa9fs4asq.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpa9fs4asq.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpa9fs4asq.jl:32\ntest set:\
    \ Error During Test at /tmp/tmpa9fs4asq.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: Stack not defined\n \
    \ Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmpa9fs4asq.jl:11\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpa9fs4asq.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpa9fs4asq.jl:32\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa9fs4asq.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # all the groups\n    groups = split(paren_string, \" \")\n    depth =\
    \ 0 # depth of current group\n    depths = Int64[] # depths of all groups\n  \
    \  for i in 1:length(groups)\n        # count num of close and open parentheses\n\
    \        num_open, num_close = count_parens(groups[i])\n        if num_open ==\
    \ num_close\n            # if depths are equal, current depth is the depth of\
    \ the group\n            push!(depths, depth)\n        else\n            # if\
    \ depths are not equal, update depth of current group\n            depth += num_open\
    \ - num_close\n            push!(depths, depth)\n        end\n    end\n    return\
    \ depths\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpf9jxgmc1.jl:32\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpf9jxgmc1.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpf9jxgmc1.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpf9jxgmc1.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpf9jxgmc1.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpf9jxgmc1.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpf9jxgmc1.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpf9jxgmc1.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpf9jxgmc1.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: count_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpf9jxgmc1.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpf9jxgmc1.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpf9jxgmc1.jl:31\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf9jxgmc1.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \n    open_parens = 0\n    max_depth = 0\n    depths = []\n    \n    for\
    \ ch in paren_string\n        if ch == '('\n            open_parens += 1\n   \
    \         max_depth = max(max_depth, open_parens)\n        elseif ch == ')'\n\
    \            open_parens -= 1\n        else\n            # Must be a space\n \
    \           push!(depths, max_depth)\n            max_depth = 0\n        end\n\
    \    end\n    \n    return depths\nend\n \n\"\"\" Input to this function is a\
    \ string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpj_tyixml.jl:30\nin expression starting at\
    \ /tmp/tmpj_tyixml.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    last_parens = 0 # stores the total number of open parentheses\n    max_parens\
    \ = 0 # stores the maximum number of open parentheses\n    paren_counts = [] #\
    \ stores the deepest level of nesting for each group of parentheses\n    for c\
    \ in paren_string\n        if c == '('\n            last_parens += 1\n       \
    \     max_parens = max(max_parens, last_parens)\n        elseif c == ')'\n   \
    \         last_parens -= 1\n        else\n            paren_counts = append!(paren_counts,\
    \ max_parens)\n            max_parens = 0\n            last_parens = 0\n     \
    \   end\n    end\n    return paren_counts\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_i0g6ks6.jl:31\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 3, 1] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_i0g6ks6.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_i0g6ks6.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp_i0g6ks6.jl:32\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 2, 3] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_i0g6ks6.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_i0g6ks6.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp_i0g6ks6.jl:33\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_i0g6ks6.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_i0g6ks6.jl:30\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_i0g6ks6.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    stack = []\n    max_depth = 0\n    depths = []\n    for c in paren_string\n\
    \        if c == '('\n            push!(stack, c)\n            max_depth += 1\n\
    \        elseif c == ')'\n            pop!(stack)\n            if length(stack)\
    \ == 0\n                push!(depths, max_depth)\n                max_depth =\
    \ 0\n            end\n        end\n    end\n    return depths\nend\n        \n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpl1aiexb7.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [3, 3, 1, 5] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpl1aiexb7.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpl1aiexb7.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpl1aiexb7.jl:34\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [7] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpl1aiexb7.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpl1aiexb7.jl:31\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     2      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl1aiexb7.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # define function count_depth(paren_str) that takes in one group and outputs\
    \ the count of nesting parens\n    # (1) split string into each group\n    # (2)\
    \ map count_depth() to each group\n    # (3) collect results into an Array\n \
    \   paren_groups = split(paren_string, \" \")\n    depth_array = [count_depth(group)\
    \ for group in paren_groups]\n    return depth_array\nend\n \nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp4r3j1yu5.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_depth not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp4r3j1yu5.jl:14\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp4r3j1yu5.jl:23 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp4r3j1yu5.jl:22\ntest set:\
    \ Error During Test at /tmp/tmp4r3j1yu5.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_depth\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp4r3j1yu5.jl:14\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp4r3j1yu5.jl:24 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp4r3j1yu5.jl:22\ntest set:\
    \ Error During Test at /tmp/tmp4r3j1yu5.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: count_depth not defined\n\
    \  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n     @ Main\
    \ ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{Str"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4r3j1yu5.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # ...\n    # ...\n    # ...\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpb99x73c3.jl:18\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpb99x73c3.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpb99x73c3.jl:18 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpb99x73c3.jl:17\ntest set:\
    \ Error During Test at /tmp/tmpb99x73c3.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Int64}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpb99x73c3.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [i"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb99x73c3.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    num_parens = 0\n    max_levels = Vector{Int64}()\n    push!(max_levels,\
    \ 0)\n    last_char = '0'\n    for paren in paren_string\n        if paren ==\
    \ '('\n            num_parens += 1\n            last_char = '('\n        elseif\
    \ paren == ')'\n            num_parens -= 1\n            last_char = ')'\n   \
    \     elseif paren == ' '\n            if last_char == ')'\n                push!(max_levels,\
    \ num_parens)\n            end\n        end\n    end\n    return max_levels\n\
    end\n@assert parse_nested_parens('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n\
    @assert parse_nested_parens('(()()) ((())) ()') == [2, 3, 1]\n@assert parse_nested_parens('()\
    \ ((())()())') == [1, 3]\n@assert parse_nested_parens('(()()) ((()))') == [2,\
    \ 3]\n@assert parse_nested_parens('(()())') == [2]\n@assert parse_nested_parens('((()))')\
    \ == [3]\n@assert parse_nested_parens('()') == [1]\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpveh07sz9.jl:28\nin expression\
    \ starting at /tmp/tmpveh07sz9.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # split the string into groups\n    paren_groups = split(paren_string)\n\
    \    return [parse_group(group) for group in paren_groups]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmph7fstf9m.jl:18\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_group not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmph7fstf9m.jl:11\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmph7fstf9m.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmph7fstf9m.jl:17\ntest set:\
    \ Error During Test at /tmp/tmph7fstf9m.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_group\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmph7fstf9m.jl:11\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmph7fstf9m.jl:19 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmph7fstf9m.jl:17\ntest set:\
    \ Error During Test at /tmp/tmph7fstf9m.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_group not defined\n\
    \  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n     @ Main\
    \ ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{Str"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph7fstf9m.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_vec = split(paren_string, ' ')\n    max_levels = Vector{Int64}(undef,\
    \ length(paren_vec))\n    for (i, paren) in enumerate(paren_vec)\n        level\
    \ = 0\n        max_level = 0\n        for char in paren\n            if char ==\
    \ '('\n                level += 1\n            elseif char == ')'\n          \
    \      level -= 1\n            end\n            if level > max_level\n       \
    \         max_level = level\n            end\n        end\n        max_levels[i]\
    \ = max_level\n    end\n    return max_levels\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    stack = []\n    level = []\n    paren_string = replace(paren_string, \"\
    \ \" => \"\")\n    for (i, char) in enumerate(paren_string)\n        if char ==\
    \ '('\n            push!(stack, i)\n        elseif char == ')'\n            level\
    \ = [0] if isempty(level)\n            if !isempty(stack)\n                pop!(stack)\n\
    \                depth = i - stack[end]\n                push!(level, depth)\n\
    \            end\n        end\n    end\n    return level\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: unexpected \"if\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpsh1v2f_p.jl:16\nin expression starting at /tmp/tmpsh1v2f_p.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Let us keep a stack to track the current level of nesting.\n    stack\
    \ = Int64[]\n    # We will use an integer to keep track of the current level of\
    \ nesting.\n    # We will initialize it to 0 to begin with.\n    curr_level =\
    \ 0\n    # Let us keep a vector to store the deepest level of nesting for each\
    \ of the groups.\n    deepest_levels = Int64[]\n    # We will loop through the\
    \ parentheses.\n    for paren in paren_string\n        # If we encounter an opening\
    \ parenthesis, we will update the current level of nesting and push it to the\
    \ stack.\n        if paren == '('\n            push!(stack, curr_level)\n    \
    \        curr_level += 1\n        # If we encounter a closing parenthesis, we\
    \ will pop the top element from the stack and update the current level of nesting.\n\
    \        elseif paren == ')'\n            curr_level = pop!(stack)\n        #\
    \ If we encounter a space, then we will add the current level of nesting to the\
    \ vector of deepest levels.\n        elseif paren == ' '\n            push!(deepest_levels,\
    \ curr_level)\n        end\n    end\n    # We will return the deepest level of\
    \ nesting.\n    return deepest_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1ofz8khr.jl:38\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1ofz8khr.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1ofz8khr.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp1ofz8khr.jl:39\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1ofz8khr.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1ofz8khr.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp1ofz8khr.jl:40\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp1ofz8khr.jl:40 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1ofz8khr.jl:37\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1ofz8khr.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    all_parens = split(paren_string, \" \")\n    paren_depth = Vector{Int64}(undef,\
    \ length(all_parens))\n    for (index, paren) in enumerate(all_parens)\n     \
    \   paren_depth[index] = count_nested_parens(paren)\n    end\n    return paren_depth\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpkp7czvot.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_nested_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpkp7czvot.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkp7czvot.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkp7czvot.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpkp7czvot.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpkp7czvot.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkp7czvot.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkp7czvot.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpkp7czvot.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: count_nested_parens not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n \
    \    @ Main /tmp/tmpkp7czvot.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkp7czvot.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkp7czvot.jl:20\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkp7czvot.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    num_parens = length(paren_string)\n    stack = [] # Store parens in a\
    \ stack\n    levels = [] # Store level of each group\n    level = 0 # Track the\
    \ current level \n    for i in 1:num_parens\n        if paren_string[i] == '('\n\
    \            push!(stack, i)\n            level += 1\n        elseif paren_string[i]\
    \ == ')'\n            pop!(stack)\n            level -= 1\n        elseif paren_string[i]\
    \ == ' '\n            if level > 0\n                throw(DomainError(\"Invalid\
    \ input: space in middle of parentheses\"))\n            end\n            push!(levels,\
    \ level)\n        else\n            throw(DomainError(\"Invalid input: only (,\
    \ ), and spaces allowed\"))\n        end\n    end\n    return levels\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpxh_i3u21.jl:36\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxh_i3u21.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxh_i3u21.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpxh_i3u21.jl:37\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxh_i3u21.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxh_i3u21.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpxh_i3u21.jl:38\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpxh_i3u21.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxh_i3u21.jl:35\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxh_i3u21.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    count_parens = []\n    paren_string = replace(paren_string, \" \", \"\"\
    )\n    for (i, paren) in enumerate(paren_string)\n        if paren == '('\n  \
    \          count_parens[i] = 1\n        elseif paren == ')'\n            count_parens[i]\
    \ = -1\n        end\n    end\n    return count_parens\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpj28rx5jx.jl:25\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpj28rx5jx.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpj28rx5jx.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpj28rx5jx.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpj28rx5jx.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpj28rx5jx.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpj28rx5jx.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.j"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj28rx5jx.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    num_parens = zeros(Int64,length(split(paren_string,\" \")))\n    for (i,paren_group)\
    \ in enumerate(split(paren_string,\" \"))\n        paren_stack = []\n        for\
    \ c in paren_group\n            if c == '('\n                push!(paren_stack,c)\n\
    \            elseif c == ')'\n                pop!(paren_stack)\n            end\n\
    \        end\n        num_parens[i] = length(paren_stack)\n    end\n    return\
    \ num_parens\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp05rpyqpb.jl:28\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp05rpyqpb.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp05rpyqpb.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp05rpyqpb.jl:29\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp05rpyqpb.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp05rpyqpb.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp05rpyqpb.jl:30\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp05rpyqpb.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp05rpyqpb.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp05rpyqpb.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    n = count(paren_string, ' ') + 1\n    paren_list = split(paren_string,\
    \ ' ')\n    levels = []\n    for j in 1:n\n        level = 0\n        max_level\
    \ = 0\n        for i in 1:length(paren_list[j])\n            if paren_list[j][i]\
    \ == '('\n                level += 1\n            elseif paren_list[j][i] == ')'\n\
    \                level -= 1\n            end\n            if level > max_level\n\
    \                max_level = level\n            end\n        end\n        push!(levels,\
    \ max_level)\n    end\n    return levels\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpffcpuyft.jl:34\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ objects of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpffcpuyft.jl:9\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpffcpuyft.jl:34 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpffcpuyft.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpffcpuyft.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpffcpuyft.jl:9\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpffcpuyft.jl:35 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpffcpuyft.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpffcpuyft.jl:36\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  MethodError: objects of type String\
    \ are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, i"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpffcpuyft.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    level_list = Int64[]\n    max_level = 0\n    for idx in eachindex(paren_string)\n\
    \        ch = paren_string[idx]\n        if ch == '('\n            max_level +=\
    \ 1\n        elseif ch == ')'\n            max_level -= 1\n        elseif ch ==\
    \ ' '\n            push!(level_list, max_level)\n            max_level = 0\n \
    \       end\n    end\n    if max_level != 0\n        throw(ArgumentError(\"Parentheses\
    \ mismatched.\"))\n    end\n    return level_list\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppgrsy7vz.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppgrsy7vz.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppgrsy7vz.jl:31\ntest set: Test\
    \ Failed at /tmp/tmppgrsy7vz.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppgrsy7vz.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppgrsy7vz.jl:31\ntest set: Test\
    \ Failed at /tmp/tmppgrsy7vz.jl:34\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmppgrsy7vz.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppgrsy7vz.jl:31\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppgrsy7vz.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    outer_vec = []\n    for paren_group in split(paren_string, \" \")\n  \
    \      inner_vec = []\n        for paren in paren_group\n            if paren\
    \ == '('\n                push!(inner_vec, 1)\n            elseif paren == ')'\n\
    \                if length(inner_vec) == 0\n                    println(\"Unmatched\
    \ parentheses\")\n                    break\n                else\n          \
    \          pop!(inner_vec)\n                end\n            end\n        end\n\
    \        push!(outer_vec, length(inner_vec))\n    end\n    return outer_vec\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp_pl7ru6g.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_pl7ru6g.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_pl7ru6g.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp_pl7ru6g.jl:34\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_pl7ru6g.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_pl7ru6g.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp_pl7ru6g.jl:35\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_pl7ru6g.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_pl7ru6g.jl:32\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_pl7ru6g.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    stack = []\n    levels = []\n    max_depth = 0\n    for char in paren_string\n\
    \        if char == '('\n            push!(stack, char)\n            max_depth\
    \ += 1\n        elseif char == ')'\n            pop!(stack)\n            max_depth\
    \ -= 1\n        else\n            push!(levels, max_depth)\n            max_depth\
    \ = 0\n        end\n    end\n    return levels\nend\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp9isfuyhj.jl:26\nin expression\
    \ starting at /tmp/tmp9isfuyhj.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_vec = split(paren_string, ' ')\n    num_parens = Vector{Int64}(undef,\
    \ length(paren_vec))\n    for j = 1:length(paren_vec)\n        count = 0\n   \
    \     paren = 0\n        for i = 1:length(paren_vec[j])\n            if paren_vec[j][i]\
    \ == '('\n                paren += 1\n                if paren > count\n     \
    \               count = paren\n                end\n            elseif paren_vec[j][i]\
    \ == ')'\n                paren -= 1\n            end\n        end\n        num_parens[j]\
    \ = count\n    end\n    return num_parens\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_vector =\
    \ split(paren_string, \"\")\n    paren_counter = zeros(Int64, length(paren_vector))\n\
    \    for i in 1:length(paren_vector)\n        if paren_vector[i] == \"(\"\n  \
    \          paren_counter[i] = 1\n        elseif paren_vector[i] == \")\"\n   \
    \         paren_counter[i] = -1\n        end\n    end\n    paren_counter = cumsum(paren_counter)\n\
    \    max_level = findmax(paren_counter)[1]\n    return max_level\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmplxfnjojb.jl:28\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmplxfnjojb.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmplxfnjojb.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmplxfnjojb.jl:27\ntest set:\
    \ Error During Test at /tmp/tmplxfnjojb.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmplxfnjojb.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmplxfnjojb.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplxfnjojb.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    results = Int64[]\n    for (i,ch) in enumerate(eachmatch(r\"\\(+\", paren_string))\n\
    \        if i == 1\n            continue\n        end\n        length = length(ch.match)\n\
    \        push!(results, length)\n    end\n    return results\nend\n#@show parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpije9p3nz.jl:26\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ length not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpije9p3nz.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpije9p3nz.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpije9p3nz.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpije9p3nz.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: length\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpije9p3nz.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpije9p3nz.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpije9p3nz.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpije9p3nz.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: length not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpije9p3nz.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpije9p3nz.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpije9p3nz.jl:25\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpije9p3nz.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open_parens = 0\n    max_open_parens = 0\n    deepest_level = Array{Int64}(undef,\
    \ 0)\n    for c in paren_string\n        if c == '('\n            open_parens\
    \ += 1\n            max_open_parens = max(max_open_parens, open_parens)\n    \
    \    elseif c == ')'\n            open_parens -= 1\n        elseif c == ' '\n\
    \            push!(deepest_level, max_open_parens)\n            max_open_parens\
    \ = 0\n        end\n    end\n    push!(deepest_level, max_open_parens)\n    return\
    \ deepest_level\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    all_parens = split(paren_string, \" \")\n    max_levels = zeros(Int64,\
    \ length(all_parens))\n    for (i, parens) in enumerate(all_parens)\n        curr_level\
    \ = 0\n        for p in parens\n            if p == '('\n                curr_level\
    \ += 1\n            elseif p == ')'\n                curr_level -= 1\n       \
    \     end\n            max_levels[i] = max(max_levels[i], curr_level)\n      \
    \  end\n    end\n    return max_levels\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    #Assume that paren_string has the following format: one or more groups\
    \ of nested parentheses separated by spaces.\n    paren_array = split(paren_string,\
    \ \" \")\n    result = zeros(Int64, length(paren_array))\n    for i = 1:length(paren_array)\n\
    \        @assert paren_array[i][1] == '('\n        @assert paren_array[i][end]\
    \ == ')'\n        paren_group = paren_array[i]\n        open_count = 0\n     \
    \   deep_level = 0\n        for paren in paren_group\n            if paren ==\
    \ '('\n                open_count += 1\n                deep_level = max(deep_level,\
    \ open_count)\n            elseif paren == ')'\n                open_count -=\
    \ 1\n            end\n        end\n        result[i] = deep_level\n    end\n \
    \   return result\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    depth = [0]\n    max_depth = [0]\n    for item in paren_string\n     \
    \   if item == '('\n            push!(depth, 0)\n        elseif item == ')'\n\
    \            max_depth = maximum(depth)\n            pop!(depth)\n        end\n\
    \    end\n    return max_depth\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpspt6fhgz.jl:26\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpspt6fhgz.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpspt6fhgz.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpspt6fhgz.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpspt6fhgz.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: Cannot\
    \ `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpspt6fhgz.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlin"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpspt6fhgz.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"count the level of nesting of parens at each group\"\n    # for each\
    \ group, count the max nesting level\n    levels = [0]\n    level = 0\n    for\
    \ c in paren_string\n        if c == '('\n            level += 1\n        elseif\
    \ c == ')'\n            level -= 1\n        elseif c == ' '\n            push!(levels,\
    \ level)\n            level = 0\n        end\n    end\n    return levels\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp0q9f_zym.jl:30\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0q9f_zym.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0q9f_zym.jl:29\ntest set: Test\
    \ Failed at /tmp/tmp0q9f_zym.jl:31\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0q9f_zym.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0q9f_zym.jl:29\ntest set: Test\
    \ Failed at /tmp/tmp0q9f_zym.jl:32\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0q9f_zym.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0q9f_zym.jl:29\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0q9f_zym.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    levels_of_parens = [0]\n    current_level = 0\n    # iterate over each\
    \ parenthesis in the string\n    for par in paren_string\n        # if the parenthesis\
    \ is an open paren, increase the current level\n        if par == '('\n      \
    \      current_level += 1\n        # otherwise it is a closed paren, decrease\
    \ the current level\n        elseif par == ')'\n            current_level -= 1\n\
    \        end\n        # the current level is the last element in the vector, so\
    \ we just check if the current level is greater\n        # and if so, store it\n\
    \        if current_level > levels_of_parens[end]\n            push!(levels_of_parens,\
    \ current_level)\n        end\n    end\n    # remove the first element in the\
    \ vector since we initialized it as 0\n    levels_of_parens = levels_of_parens[2:end]\n\
    \    return levels_of_parens\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxg8pw2l4.jl:35\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [1, 2, 3] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxg8pw2l4.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxg8pw2l4.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpxg8pw2l4.jl:37\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [1, 2, 3, 4] == [4]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxg8pw2l4.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxg8pw2l4.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     2      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxg8pw2l4.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    num_parens = length(filter(isalpha, paren_string))\n    all_parens = split(paren_string,\
    \ \" \")\n    return map(find_depth, all_parens)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9lsd9kr6.jl:18\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ isalpha not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp9lsd9kr6.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9lsd9kr6.jl:18 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9lsd9kr6.jl:17\ntest set:\
    \ Error During Test at /tmp/tmp9lsd9kr6.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: isalpha\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp9lsd9kr6.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9lsd9kr6.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9lsd9kr6.jl:17\ntest set:\
    \ Error During Test at /tmp/tmp9lsd9kr6.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: isalpha not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmp9lsd9kr6.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9lsd9kr6.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9lsd9kr6.jl:17\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9lsd9kr6.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    i = 0\n    level = 0\n    levels = Array{Int64}(undef, length(paren_string))\n\
    \    for paren in paren_string\n        if paren == '('\n            level +=\
    \ 1\n        elseif paren == ')'\n            level -= 1\n        else\n     \
    \       level = level\n        end\n        levels[i] = level\n        i += 1\n\
    \    end\n    return sort(unique(levels))[end:-1:1]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp4pczhb62.jl:30\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  BoundsError:\
    \ attempt to access 27-element Vector{Int64} at index [0]\n  Stacktrace:\n   [1]\
    \ setindex!\n     @ ./array.jl:903 [inlined]\n   [2] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp4pczhb62.jl:20\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp4pczhb62.jl:30 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp4pczhb62.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp4pczhb62.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  BoundsError: attempt\
    \ to access 23-element Vector{Int64} at index [0]\n  Stacktrace:\n   [1] setindex!\n\
    \     @ ./array.jl:903 [inlined]\n   [2] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp4pczhb62.jl:20\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp4pczhb62.jl:31 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp4pczhb62.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp4pczhb62.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  BoundsError: attempt to access 14-element\
    \ Vector{Int64} at index [0]\n  Stacktrace:\n   [1] setindex!\n     @ ./array.jl:903\
    \ [inlined]\n   [2] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmp4pczhb62.jl:20\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp4pczhb62.jl:32 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4pczhb62.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    max_so_far = 0\n    max_level = [0]\n    for paren in paren_string\n \
    \       if paren == '('\n            max_so_far += 1\n        elseif paren ==\
    \ ')'\n            max_so_far -= 1\n        end\n        if max_so_far > max_level[end]\n\
    \            push!(max_level, max_so_far)\n        end\n    end\n    return max_level[2:end]\n\
    end\nparse_nested_parens('(()()) ((())) () ((())()())')\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp2vz9l_ew.jl:23\nin expression\
    \ starting at /tmp/tmp2vz9l_ew.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    results = Int64[]\n    for paren_group in split(paren_string, \" \")\n\
    \        push!(results, get_max_depth(paren_group))\n    end\n    return results\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpupg5f7qa.jl:20\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ get_max_depth not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpupg5f7qa.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpupg5f7qa.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpupg5f7qa.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpupg5f7qa.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: get_max_depth\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpupg5f7qa.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpupg5f7qa.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpupg5f7qa.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpupg5f7qa.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: get_max_depth not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpupg5f7qa.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpupg5f7qa.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpupg5f7qa.jl:19\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpupg5f7qa.jl:17\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    input_vec = split(paren_string, ' ')\n    output_vec = zeros(length(input_vec))\n\
    \    # TODO: implement this\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnfko43xt.jl:18\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnfko43xt.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnfko43xt.jl:17\ntest set: Test\
    \ Failed at /tmp/tmpnfko43xt.jl:19\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnfko43xt.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnfko43xt.jl:17\ntest set: Test\
    \ Failed at /tmp/tmpnfko43xt.jl:20\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnfko43xt.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnfko43xt.jl:17\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnfko43xt.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8jfvypl0.jl:1\nin expression starting at /tmp/tmp8jfvypl0.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \n    # Create a vector to store the count of nested parens for each group\n\
    \    paren_count = Vector{Int64}()\n    \n    # Split the whole string by space\
    \ and loop through each group of parentheses\n    for paren_group in split(paren_string,\
    \ \" \")\n        \n        # Create a variable to store the current maximum depth\n\
    \        max_depth = 0\n        \n        # Create a variable to store the current\
    \ depth\n        depth = 0\n        \n        # Loop through each character in\
    \ the parentheses string\n        for paren in paren_group\n            \n   \
    \         # If the character is a \"(\", increment the depth\n            if paren\
    \ == '('\n                depth += 1\n                \n            # If the character\
    \ is a \")\", decrement the depth\n            elseif paren == ')'\n         \
    \       depth -= 1\n                \n            # Raise an error if an invalid\
    \ character is found\n            else\n                throw(ArgumentError(\"\
    Invalid character found\"))\n            end\n            \n            # Update\
    \ the max_depth if necessary\n            if depth > max_depth\n             \
    \   max_depth = depth\n            end\n        end\n        \n        # Add the\
    \ current max_depth to the end of the vector paren_count\n        push!(paren_count,\
    \ max_depth)\n    end\n    \n    # Output the vector paren_count\n    return paren_count\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_array = [matchall(r\"[\\(]+\", str) for str in split(paren_string)]\n\
    \    paren_sum = map(sum, paren_array)\n    return maximum.(paren_sum, 1)\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpnkaggcd7.jl:18\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ matchall not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(str::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpnkaggcd7.jl:9\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpnkaggcd7.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpnkaggcd7.jl:17\ntest set:\
    \ Error During Test at /tmp/tmpnkaggcd7.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: matchall\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(str::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpnkaggcd7.jl:9\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpnkaggcd7.jl:19 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpnkaggcd7.jl:17\ntest set:\
    \ Error During Test at /tmp/tmpnkaggcd7.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: matchall not defined\n\
    \  Stacktrace:\n   [1] (::var\"#1#2\")(str::SubString{String})\n     @ Main ./none:0\n\
    \   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"}"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnkaggcd7.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \n    result = []\n    # Iterate through each group\n    for group in\
    \ split(paren_string, \" \")\n        # Initialize number of left and right parentheses\
    \ encountered to zero\n        left = 0\n        right = 0\n        # Iterate\
    \ through each parenthesis in the group\n        for x in group\n            #\
    \ Increment number of left and right parentheses encountered\n            if x\
    \ == '('\n                left += 1\n            elseif x == ')'\n           \
    \     right += 1\n            end\n        end\n        # If number of left and\
    \ right parentheses encountered are not equal, the input is invalid\n        if\
    \ left != right\n            println(\"Invalid input!\")\n            return\n\
    \        end\n        # Append number of left parentheses encountered to the result\n\
    \        push!(result, left)\n    end\n    return result\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpj7i6fp97.jl:40\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [3, 3, 1, 5] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj7i6fp97.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj7i6fp97.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpj7i6fp97.jl:42\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [7] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj7i6fp97.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj7i6fp97.jl:39\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     2      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj7i6fp97.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # (1) Split paren_string on spaces\n    groups = split(paren_string, \"\
    \ \")\n    # (2) Determine the deepest level of nesting of parentheses\n    #\
    \     for each group\n    deepest_levels = zeros(length(groups))\n    for (i,\
    \ group) in enumerate(groups)\n        deepest_levels[i] = deepest_level(group)\n\
    \    end\n    # (3) Return the deepest levels\n    return deepest_levels\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpe3n6wl4d.jl:25\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ deepest_level not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpe3n6wl4d.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpe3n6wl4d.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpe3n6wl4d.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpe3n6wl4d.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: deepest_level\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpe3n6wl4d.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpe3n6wl4d.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpe3n6wl4d.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpe3n6wl4d.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: deepest_level not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpe3n6wl4d.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpe3n6wl4d.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpe3n6wl4d.jl:24\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe3n6wl4d.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    output = Int64[]\n    for\
    \ group in paren_groups\n        nest_level = 0\n        nest_max = 0\n      \
    \  for paren in group\n            if paren == '('\n                nest_level\
    \ += 1\n            elseif paren == ')'\n                nest_level -= 1\n   \
    \         end\n            if nest_level > nest_max\n                nest_max\
    \ = nest_level\n            end\n        end\n        push!(output, nest_max)\n\
    \    end\n    return output\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open_parens = 0\n    result = Vector{Int64}()\n    for paren in paren_string\n\
    \        open_parens += 1 if paren == '(' else 0\n        if paren == ')' \n \
    \           push!(result, open_parens)\n            open_parens -= 1\n       \
    \ end\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"for\" at /tmp/tmpxet_hdru.jl:11 expected \"\
    end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpxet_hdru.jl:12\n\
    in expression starting at /tmp/tmpxet_hdru.jl:12\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_vec = Vector{Int64}[]\n    paren_depth = 0\n    for ch in paren_string\n\
    \        if ch == '('\n            paren_depth += 1\n        elseif ch == ')'\n\
    \            paren_depth -= 1\n        elseif ch == ' '\n            push!(paren_vec,\
    \ paren_depth)\n            paren_depth = 0\n        end\n    end\n    return\
    \ paren_vec\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpnz18zshr.jl:28\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Int64 to an object of type Vector{Int64}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{Vector{Int64}}, item::Int64)\n\
    \     @ Base ./array.jl:994\n   [2] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpnz18zshr.jl:17\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpnz18zshr.jl:28 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpnz18zshr.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpnz18zshr.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: Cannot\
    \ `convert` an object of type Int64 to an object of type Vector{Int64}\n  Closest\
    \ candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{Vector{Int64}}, item::Int64)\n\
    \     @ Base ./array.jl:994\n   [2] parse_nested_parens(paren_st"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 1 failed, 2 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnz18zshr.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    res = []\n    all_groups = split(paren_string, \" \")\n    for group in\
    \ all_groups\n        n_open = 0\n        max_open = 0\n        for paren in group\n\
    \            if paren == '('\n                n_open += 1\n                max_open\
    \ = max(max_open, n_open)\n            elseif paren == ')'\n                n_open\
    \ -= 1\n            end\n        end\n        push!(res, max_open)\n    end\n\
    \    return res\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = split(paren_string, \" \")\n    output = []\n    for paren\
    \ in paren_string\n        depth = 1\n        max_depth = 1\n        for c in\
    \ paren\n            if c == '('\n                depth += 1\n               \
    \ if depth > max_depth\n                    max_depth = depth\n              \
    \  end\n            elseif c == ')'\n                depth -= 1\n            end\n\
    \        end\n        push!(output, max_depth)\n    end\n    return output\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpjxz1xrqx.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [3, 4, 2, 4] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjxz1xrqx.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjxz1xrqx.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpjxz1xrqx.jl:34\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [2, 3, 4, 5] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjxz1xrqx.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjxz1xrqx.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpjxz1xrqx.jl:35\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [5] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjxz1xrqx.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjxz1xrqx.jl:32\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjxz1xrqx.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    words = split(paren_string, \" \")\n    parsings = []\n    for word in\
    \ words\n        push!(parsings, parse_parens(word))\n    end\n    return parsings\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmphgljwbvp.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmphgljwbvp.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphgljwbvp.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphgljwbvp.jl:20\ntest set:\
    \ Error During Test at /tmp/tmphgljwbvp.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmphgljwbvp.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphgljwbvp.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphgljwbvp.jl:20\ntest set:\
    \ Error During Test at /tmp/tmphgljwbvp.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmphgljwbvp.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphgljwbvp.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphgljwbvp.jl:20\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphgljwbvp.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    return [count_nested_parens(group)\
    \ for group in paren_groups]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp827o146n.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_nested_parens not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp827o146n.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp827o146n.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp827o146n.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp827o146n.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp827o146n.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp827o146n.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp827o146n.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp827o146n.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: count_nested_parens not\
    \ defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Genera"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp827o146n.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_depth = []\n    for\
    \ group in paren_groups\n        depth = 0\n        depth_max = 0\n        for\
    \ char in group\n            if char == '('\n                depth += 1\n    \
    \        elseif char == ')'\n                depth -= 1\n            end\n   \
    \         if depth > depth_max\n                depth_max = depth\n          \
    \  end\n        end\n        push!(max_depth, depth_max)\n    end\n    return\
    \ max_depth\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    n = length(paren_string)\n    levels = zeros(Int64, n)\n    level = 0\n\
    \    for (i, ch) in enumerate(paren_string)\n        if ch == '('\n          \
    \  level += 1\n        elseif ch == ')'\n            level -= 1\n        end\n\
    \        levels[i] = level\n    end\n    diff = diff(levels)\n    paren_indices\
    \ = findall(x -> x == 1 || x == -1, diff)\n    tmp = paren_indices[1]\n    max_levels\
    \ = []\n    for i in 2:length(paren_indices)\n        if diff[paren_indices[i]]\
    \ == -1\n            push!(max_levels, levels[tmp:paren_indices[i]])\n       \
    \     tmp = paren_indices[i] + 1\n        end\n    end\n    return [maximum(x)\
    \ for x in max_levels]\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpe4_g5mhv.jl:37\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ diff not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpe4_g5mhv.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpe4_g5mhv.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpe4_g5mhv.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpe4_g5mhv.jl:38\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: diff\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpe4_g5mhv.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpe4_g5mhv.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpe4_g5mhv.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpe4_g5mhv.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: diff not defined\n  Stacktrace:\n\
    \   [1] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmpe4_g5mhv.jl:20\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpe4_g5mhv.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpe4_g5mhv.jl:36\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe4_g5mhv.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # split the input string into vector of strings each corresponding to\
    \ a group of parentheses\n    groups = split(paren_string, \" \")\n    N = length(groups)\n\
    \    depths = zeros(Int64, N)\n    for i in 1:N\n        # initialize the depth\
    \ to be zero\n        depth = 0\n        max_depth = 0\n        for c in groups[i]\n\
    \            if c == '('\n                # increment the depth when '(' is encountered\n\
    \                depth += 1\n            elseif c == ')'\n                # decrement\
    \ the depth when ')' is encountered\n                depth -= 1\n            end\n\
    \            # update the max_depth\n            max_depth = max(max_depth, depth)\n\
    \        end\n        depths[i] = max_depth\n    end\n    return depths\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    str_array = split(paren_string)\n    output = Vector{Int64}()\n    temp\
    \ = 0\n    for i in 1:length(str_array)\n        str = str_array[i]\n        temp\
    \ = 0\n        for j in 1:length(str)\n            if str[j] == '('\n        \
    \        temp += 1\n            elseif str[j] == ')'\n                temp -=\
    \ 1\n            end\n        end\n        push!(output, temp)\n    end\n    return\
    \ output\nend\n@test parse_nested_parens(\"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3]\n \nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @test not defined\nin expression starting\
    \ at /tmp/tmp17o75jrg.jl:26\nin expression starting at /tmp/tmp17o75jrg.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_array = split(paren_string, ' ')\n    max_levels = Int64[]\n   \
    \ # Tokenize the string, then loop through it. \n    # Every time we see a '('\
    \ store that parenthesis position in a stack.\n    # Every time we see a ')' pop\
    \ the stack and update the current level.\n    # Afterwards, push the current\
    \ position back into the stack.\n    # Finally, the length of the stack is the\
    \ deepest level of nesting.\n    for paren_group in paren_array\n        stack\
    \ = Int64[]\n        level = 0\n        for i in 1:length(paren_group)\n     \
    \       if paren_group[i] == '('\n                push!(stack, i)\n          \
    \  else\n                level = i - pop!(stack)\n                push!(stack,\
    \ i)\n            end\n        end\n        push!(max_levels, length(stack))\n\
    \    end\n    return max_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpl773rvg6.jl:36\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [3, 3, 1, 5] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpl773rvg6.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpl773rvg6.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpl773rvg6.jl:38\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [7] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpl773rvg6.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpl773rvg6.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     2      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl773rvg6.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_vec = split(paren_string, \" \")\n    res = []\n    for i = 1:length(paren_vec)\n\
    \        paren_count = 0\n        max_paren_count = 0\n        for j = 1:length(paren_vec[i])\n\
    \            if paren_vec[i][j] == '('\n                paren_count += 1\n   \
    \         elseif paren_vec[i][j] == ')'\n                paren_count -= 1\n  \
    \          end\n            if paren_count > max_paren_count\n               \
    \ max_paren_count = paren_count\n            end\n        end\n        push!(res,\
    \ max_paren_count)\n    end\n    return res\nend\n \nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpilceg4sc.jl:29\nin expression\
    \ starting at /tmp/tmpilceg4sc.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    deepest_level = Vector{Int64}()\n    for paren_group in split(paren_string,\
    \ \" \")\n        level = 0\n        max_level = 0\n        for i in 1:length(paren_group)\n\
    \            if paren_group[i] == '('\n                level += 1\n          \
    \  elseif paren_group[i] == ')'\n                level -= 1\n            end\n\
    \            if level > max_level\n                max_level = level\n       \
    \     end\n        end\n        push!(deepest_level, max_level)\n    end\n   \
    \ return deepest_level\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Search for a pattern of the form ()xxxx() where x is a nested\
    \ parenthesis and then count the number of groups.\n    \"\"\"\n    return map(n\
    \ -> count(match(r\"(?=\\()+\", n)), split(paren_string, \" \"))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpxjwwafp1.jl:19\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxjwwafp1.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxjwwafp1.jl:18\ntest set: Test\
    \ Failed at /tmp/tmpxjwwafp1.jl:20\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxjwwafp1.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxjwwafp1.jl:18\ntest set: Test\
    \ Failed at /tmp/tmpxjwwafp1.jl:21\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxjwwafp1.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxjwwafp1.jl:18\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxjwwafp1.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # a counter to track the deepest level of nesting of parentheses\n   \
    \ max_nesting_level = 0\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpuib9nalv.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpuib9nalv.jl:1\n\
    in expression starting at /tmp/tmpuib9nalv.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_vector = split(paren_string, ' ')\n    output = Int64[]\n    for\
    \ paren in paren_vector\n        count = 0\n        for char in paren\n      \
    \      if char == '('\n                count += 1\n            elseif char ==\
    \ ')'\n                count -= 1\n            end\n        end\n        push!(output,\
    \ count)\n    end\n    return output\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpma8gfjlj.jl:29\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpma8gfjlj.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpma8gfjlj.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpma8gfjlj.jl:30\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpma8gfjlj.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpma8gfjlj.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpma8gfjlj.jl:31\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpma8gfjlj.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpma8gfjlj.jl:28\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpma8gfjlj.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open_parens = [0]\n    max_depth = 0\n    max_depth_vec = []\n    for\
    \ paren in paren_string\n        if paren == '('\n            push!(open_parens,\
    \ 1)\n            max_depth += 1\n        elseif paren == ')'\n            pop!(open_parens)\n\
    \            max_depth -= 1\n        elseif paren == ' '\n            push!(max_depth_vec,\
    \ max_depth)\n        end\n    end\n    return max_depth_vec\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmph3awcjd9.jl:30\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph3awcjd9.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph3awcjd9.jl:29\ntest set: Test\
    \ Failed at /tmp/tmph3awcjd9.jl:31\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph3awcjd9.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph3awcjd9.jl:29\ntest set: Test\
    \ Failed at /tmp/tmph3awcjd9.jl:32\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmph3awcjd9.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph3awcjd9.jl:29\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph3awcjd9.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    max_levels = 0 #local variable that keeps track of maximum paren levels\n\
    \    levels = 0 #local variable that keeps track of the current paren level\n\
    \    max_levels_vec = [] #vector that keeps track of all the paren levels\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpeiz_tsw0.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpeiz_tsw0.jl:1\n\
    in expression starting at /tmp/tmpeiz_tsw0.jl:1\n"
  exit_code: 1
  status: SyntaxError
