name: HumanEval_123_get_odd_collatz
language: jl
results:
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # your code here\n    # check if n is a positive integer\n    #return\
    \ []\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpgl7g88s2.jl:27\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpgl7g88s2.jl:21\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpgl7g88s2.jl:27 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpgl7g88s2.jl:26\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    seq = [n]\n    while seq[end]\
    \ != 1\n        if iseven(seq[end])\n            push!(seq, div(seq[end], 2))\n\
    \        else\n            push!(seq, seq[end] * 3 + 1)\n        end\n    end\n\
    \    return sort(filter(isodd, seq))\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n  # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    seq = Any[]\n    while n !=\
    \ 1\n        push!(seq, n)\n        if n % 2 == 0\n            n = div(n, 2)\n\
    \        else\n            n = 3*n + 1\n        end\n    end\n    push!(seq, 1)\n\
    \    return sort(filter(x -> x % 2 != 0, seq))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    seq = Int64[]\n    while n\
    \ != 1\n        push!(seq, n)\n        if n % 2 == 0\n            n = div(n, 2)\n\
    \        else\n            n = n * 3 + 1\n        end\n    end\n    push!(seq,\
    \ 1)\n    return seq[seq .% 2 == 1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpw3otwxkp.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  ArgumentError:\
    \ invalid index: false of type Bool\\n  Stacktrace:\\n    [1] to_index(i::Bool)\\\
    n      @ Base ./indices.jl:293\\n    [2] to_index(A::Vector{Int64}, i::Bool)\\\
    n      @ Base ./indices.jl:277\\n    [3] to_indices\\n      @ ./indices.jl:333\
    \ [inlined]\\n    [4] to_indices\\n      @ ./indices.jl:330 [inlined]\\n    [5]\
    \ getindex\\n      @ ./abstractarray.jl:1221 [inlined]\\n    [6] get_odd_collatz(n::Int64)\\\
    n      @ Main /tmp/tmpw3otwxkp.jl:31\\n    [7] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n    [8] macro expansion\\n      @ /tmp/tmpw3otwxkp.jl:38 [inlined]\\\
    n    [9] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [10] top-level scope\\n      @ /tmp/tmpw3otwxkp.jl:37\\ntest\
    \ set: Error During Test at /tmp/tmpw3otwxkp.jl:39\\n  Test threw exception\\\
    n  Expression: candidate(5) == [1, 5]\\n  ArgumentError: invalid index: false\
    \ of type Bool\\n  Stacktrace:\\n    [1] to_index(i::Bool)\\n      @ Base ./indices.jl:293\\\
    n    [2] to_index(A::Vector{Int64}, i::Bool)\\n      @ Base ./indices.jl:277\\\
    n    [3] to_indices\\n      @ ./indices.jl:333 [inlined]\\n    [4] to_indices\\\
    n      @ ./indices.jl:330 [inlined]\\n    [5] getindex\\n      @ ./abstractarray.jl:1221\
    \ [inlined]\\n    [6] get_odd_collatz(n::Int64)\\n      @ Main /tmp/tmpw3otwxkp.jl:31\\\
    n    [7] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n    [8] macro expansion\\n      @ /tmp/tmpw3otwxkp.jl:39 [inlined]\\\
    n    [9] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [10] top-level scope\\n      @ /tmp/tmpw3otwxkp.jl:37\\ntest\
    \ set: Error During Test at /tmp/tmpw3otwxkp.jl:40\\n  Test threw exception\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n  ArgumentError: invalid index: false\
    \ of type Bool\\n  Stacktrace:"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_list = Int64[]\n    if n == 1\n        push!(odd_list, n)\n      \
    \  return odd_list\n    end\n    while n != 1\n        if n % 2 == 0\n       \
    \     n = n / 2\n        else\n            push!(odd_list, n)\n            n =\
    \ 3 * n + 1\n        end\n    end\n    odd_list\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpd1k58uq_.jl:38\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd1k58uq_.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd1k58uq_.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpd1k58uq_.jl:39\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd1k58uq_.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd1k58uq_.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpd1k58uq_.jl:40\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd1k58uq_.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd1k58uq_.jl:37\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd1k58uq_.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n \n    function collatz(x::Int64)::Vector{Int64}\n        res = []\n     \
    \   while x > 1\n            if x % 2 == 0\n                x = x/2\n        \
    \    else\n                x = 3*x + 1\n            end\n            push!(res,\
    \ x)\n        end\n        return res\n    end\n    \n    res = collatz(n)\n \
    \   odd_collatz = [1]\n    for i in res\n        if i % 2 != 0\n            push!(odd_collatz,\
    \ i)\n        end\n    end\n    sort!(odd_collatz)\n    return odd_collatz\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjd7yr556.jl:47\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 1, 5, 7, 11, 13, 17] == [1, 5, 7,\
    \ 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjd7yr556.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjd7yr556.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpjd7yr556.jl:48\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjd7yr556.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjd7yr556.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpjd7yr556.jl:49\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 1, 3, 5] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjd7yr556.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjd7yr556.jl:46\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjd7yr556.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    c = [n]\n    while c[end] != 1\n        push!(c, c[end] % 2 == 0 ? div(c[end],\
    \ 2) : 3*c[end] + 1)\n    end\n    return filter(isodd, c)\nend\nget_odd_collatz(5)\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1pdt_37i.jl:30\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1pdt_37i.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1pdt_37i.jl:29\ntest set: Test\
    \ Failed at /tmp/tmp1pdt_37i.jl:31\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1pdt_37i.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1pdt_37i.jl:29\ntest set: Test\
    \ Failed at /tmp/tmp1pdt_37i.jl:32\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp1pdt_37i.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1pdt_37i.jl:29\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1pdt_37i.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    l = [n]\n    while l[end] != 1\n        push!(l,nextcollatz(l[end]))\n\
    \    end\n    return(l[l .% 2 .== 1])\nend\n@test get_odd_collatz(5) == [1, 5]\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @test not defined\nin expression starting\
    \ at /tmp/tmpfm49q5h4.jl:24\nin expression starting at /tmp/tmpfm49q5h4.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n  l = []\n  if n == 1\n    return [1]\n  end\n  for i in 1:n\n    if i ==\
    \ 1\n      push!(l, 1)\n    else\n      push!(l, i)\n      while i != 1\n    \
    \    if i % 2 == 0\n          i = i/2\n        else\n          i = 3*i + 1\n \
    \       end\n        if i % 2 != 0\n          push!(l, i)\n        end\n     \
    \ end\n    end\n  end\n  return sort(l)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpczvlqmuk.jl:46\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026\
    \  13, 13, 13, 13, 13, 14, 17, 17, 17, 17] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpczvlqmuk.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpczvlqmuk.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpczvlqmuk.jl:47\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1, 1, 1, 1, 1, 2, 3, 4, 5, 5] == [1, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpczvlqmuk.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpczvlqmuk.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpczvlqmuk.jl:48\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  \u2026  11, 11, 11, 12, 13, 13,\
    \ 13, 17, 17, 17] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpczvlqmuk.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpczvlqmuk.jl:45\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpczvlqmuk.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpwbgrfq06.jl:25\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpwbgrfq06.jl:19\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpwbgrfq06.jl:25 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpwbgrfq06.jl:24\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_collatz = [1]\n    for i in n:n==1\n        if n%2 == 0\n        \
    \    n/2\n        else\n            3*n+1\n        end\n    end\n    return odd_collatz\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"==\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplph66tqf.jl:19\nin expression starting at\
    \ /tmp/tmplph66tqf.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    a = zeros(Int64,n); count = 0\n    for i in 1:n \n        if i == 1 \n\
    \            a[count] = i; count += 1\n        else \n            b = i; c = 0\n\
    \            while b != 1 \n                c += 1\n                if b % 2 ==\
    \ 0 \n                    b = b/2\n                else \n                   \
    \ b = 3*b + 1\n                end\n            end\n            if c % 2 == 1\n\
    \                a[count] = i; count += 1\n            end\n        end\n    end\n\
    \    a = a[1:count-1]\n    return sort(a)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpp4l4e7go.jl:45\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  BoundsError:\
    \ attempt to access 14-element Vector{Int64} at index [0]\\n  Stacktrace:\\n \
    \  [1] setindex!\\n     @ ./array.jl:903 [inlined]\\n   [2] get_odd_collatz(n::Int64)\\\
    n     @ Main /tmp/tmpp4l4e7go.jl:21\\n   [3] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmpp4l4e7go.jl:45 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmpp4l4e7go.jl:44\\ntest set:\
    \ Error During Test at /tmp/tmpp4l4e7go.jl:46\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  BoundsError: attempt to access 5-element Vector{Int64}\
    \ at index [0]\\n  Stacktrace:\\n   [1] setindex!\\n     @ ./array.jl:903 [inlined]\\\
    n   [2] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpp4l4e7go.jl:21\\n   [3]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmpp4l4e7go.jl:46 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmpp4l4e7go.jl:44\\ntest set:\
    \ Error During Test at /tmp/tmpp4l4e7go.jl:47\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  BoundsError: attempt to access 12-element Vector{Int64}\
    \ at index [0]\\n  Stacktrace:\\n   [1] setindex!\\n     @ ./array.jl:903 [inlined]\\\
    n   [2] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpp4l4e7go.jl:21\\n   [3]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmpp4l4e7go.jl:47 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmpp4l4e7go.jl:44\\"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp53mpdf4d.jl:25\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp53mpdf4d.jl:19\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp53mpdf4d.jl:25 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp53mpdf4d.jl:24\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return v\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpii_3q50o.jl:26\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ v not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main\
    \ /tmp/tmpii_3q50o.jl:19\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpii_3q50o.jl:26 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpii_3q50o.jl:25\\ntest set:\
    \ Error During Test at /tmp/tmpii_3q50o.jl:27\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: v not defined\\n  Stacktrace:\\n \
    \  [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpii_3q50o.jl:19\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpii_3q50o.jl:27 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpii_3q50o.jl:25\\ntest set:\
    \ Error During Test at /tmp/tmpii_3q50o.jl:28\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: v not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpii_3q50o.jl:19\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpii_3q50o.jl:28 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpii_3q50o.jl:25\\ntest set:\
    \ Error During Test at /tmp/tmpii_3q50o.jl:29\\n  Test threw exception\\n  Expression:\
    \ candidate(1) == [1]\\n  UndefVarError: v not defined\\n  Stacktrace:\\n   [1]\
    \ get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpii_3q50o.jl:19\\n   [2] macro\
    \ expansion\\n     @ /shared/c"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = []\n    while n\
    \ != 1\n        push!(collatz, n)\n        if n % 2 == 0\n            n = div(n,\
    \ 2)\n        else\n            n = 3 * n + 1\n        end\n    end\n    push!(collatz,\
    \ 1)\n    collatz = sort(collatz)\n    odd_collatz = []\n    for i in collatz\n\
    \        if i % 2 != 0\n            push!(odd_collatz, i)\n        end\n    end\n\
    \    return odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    res = []\n    push!(res, n)\n    if n == 1\n        return res\n    end\n\
    \    while n != 1\n        if n % 2 == 0\n            n = n/2\n        else\n\
    \            n = 3*n + 1\n        end\n        if n % 2 != 0\n            push!(res,\
    \ n)\n        end\n    end\n    return sort(res)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpoucyqli8.jl:40\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpoucyqli8.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpoucyqli8.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpoucyqli8.jl:42\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 3, 5, 12] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpoucyqli8.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpoucyqli8.jl:39\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoucyqli8.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz(number::Int64) = ( number % 2 == 0 ) ? number / 2 : 3 * number\
    \ + 1\n    this_list = []\n    while n != 1\n        push!(this_list, n)\n   \
    \     n = collatz(n)\n    end\n    push!(this_list, 1)\n    return [x for x in\
    \ this_list if x % 2 != 0]\nend\nget_odd_collatz(5)\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: None
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n < 1\n        return error(\"n must be positive.\")\n    end\n   \
    \ lst = [n]\n    while n != 1\n        if iseven(n)\n            n = div(n, 2)\n\
    \        else\n            n = 3n + 1\n        end\n        push!(lst, n)\n  \
    \  end\n    return sort(setdiff(lst, [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024,\
    \ 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152,\
    \ 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912,\
    \ 1073741824]))\nend\n \nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpow93zuuc.jl:38\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 10, 11, 13, 14, 17, 20, 22,\
    \ 26, 34, 40, 52] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpow93zuuc.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpow93zuuc.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpow93zuuc.jl:40\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 3, 5, 6, 10, 12] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpow93zuuc.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpow93zuuc.jl:37\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpow93zuuc.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n <= 0\n        error(\"Argument must be positive.\")\n    end\n  \
    \  xs = [n]\n    while n != 1\n        n = next(n)\n        push!(xs, n)\n   \
    \ end\n    sort(filter(x -> isodd(x), xs))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp3bz3wj27.jl:33\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ next not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @\
    \ Main /tmp/tmp3bz3wj27.jl:23\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp3bz3wj27.jl:33 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp3bz3wj27.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmp3bz3wj27.jl:34\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: next not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp3bz3wj27.jl:23\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp3bz3wj27.jl:34 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp3bz3wj27.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmp3bz3wj27.jl:35\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: next not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp3bz3wj27.jl:23\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp3bz3wj27.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp3bz3wj27.jl:32\\nTest Summary:\
    \ | Pass  Error  Total\\ntest set      |    1      3      4\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 3 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmp3bz3wj27.jl:30\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    end_number = n\n    result = Int64[]\n    while end_number != 1\n    \
    \    if end_number % 2 == 0 \n            end_number = Int64(end_number / 2)\n\
    \        else\n            end_number = end_number * 3 + 1\n            push!(result,\
    \ end_number)\n        end\n    end\n    sort(push!(result, 1))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdq4mltfk.jl:35\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 16, 22, 34, 40, 52] == [1, 5, 7,\
    \ 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdq4mltfk.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdq4mltfk.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpdq4mltfk.jl:36\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1, 16] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdq4mltfk.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdq4mltfk.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpdq4mltfk.jl:37\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 10, 16] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n \
    \  @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdq4mltfk.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdq4mltfk.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdq4mltfk.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # Your code here!\n    odd_numbers = []\n    while n != 1\n        if\
    \ n % 2 == 0\n            n = n/2\n        else\n            push!(odd_numbers,\
    \ n)\n            n = 3n + 1\n        end\n    end\n    push!(odd_numbers, 1)\n\
    \    return odd_numbers\nend\n \nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgottc1xv.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgottc1xv.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgottc1xv.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpgottc1xv.jl:38\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgottc1xv.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgottc1xv.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpgottc1xv.jl:39\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpgottc1xv.jl:39 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgottc1xv.jl:36\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgottc1xv.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    l = [n]\n    for i in 1:n-1\n\
    \        if l[i] == 1\n            return l\n        end\n        if l[i] % 2\
    \ == 0\n            push!(l, l[i]/2)\n        else\n            push!(l, 3*l[i]\
    \ + 1)\n        end\n    end\n    return l\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5ae3100t.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [14, 7, 22, 11, 34, 17, 52, 26, 13,\
    \ 40, 20, 10, 5, 16] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5ae3100t.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5ae3100t.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp5ae3100t.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 16, 8, 4, 2] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5ae3100t.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5ae3100t.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp5ae3100t.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [12, 6, 3, 10, 5, 16, 8, 4, 2, 1] == [1, 3, 5]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5ae3100t.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5ae3100t.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5ae3100t.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    v = [n]\n    while (n != 1)\n        if (n % 2 == 0)\n            n =\
    \ n / 2\n        else\n            n = 3 * n + 1\n        end\n        push!(v,\
    \ n)\n    end\n    return v[findall(x -> x % 2 != 0, v)]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpylqus705.jl:34\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpylqus705.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpylqus705.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpylqus705.jl:35\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpylqus705.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpylqus705.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpylqus705.jl:36\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpylqus705.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpylqus705.jl:33\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpylqus705.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # your code goes here\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp56nvj9c0.jl:25\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp56nvj9c0.jl:19\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp56nvj9c0.jl:25 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp56nvj9c0.jl:24\\ntest set:\
    \ Error During Test at /tmp/tmp56nvj9c0.jl:26\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp56nvj9c0.jl:19\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    ## Student code below.\n    oddCollatz = Int64[]\n    oddCollatz = [1]\n\
    \    if n == 1\n        return oddCollatz\n    end\n    while n != 1\n       \
    \ if n % 2 == 0\n            n = n / 2\n        else\n            n = (3 * n)\
    \ + 1\n            push!(oddCollatz, n)\n        end\n    end\n    return oddCollatz\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpiwxnqre5.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 22, 34, 52, 40, 16] == [1, 5, 7,\
    \ 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiwxnqre5.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiwxnqre5.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpiwxnqre5.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1, 16] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiwxnqre5.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiwxnqre5.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpiwxnqre5.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 10, 16] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n \
    \  @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiwxnqre5.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiwxnqre5.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiwxnqre5.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return Vector{Int64}([1])\n    end\n    sequence =\
    \ Vector{Int64}([n])\n    while sequence[end] != 1\n        if sequence[end] %\
    \ 2 == 0\n            push!(sequence, div(sequence[end], 2))\n        else\n \
    \           push!(sequence, 3*sequence[end] + 1)\n        end\n    end\n    return\
    \ sort(filter(x -> x % 2 != 0, sequence))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    return filter(x -> x % 2 != 0, get_collatz(n))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpplvxyawb.jl:25\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ get_collatz not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\\
    n     @ Main /tmp/tmpplvxyawb.jl:18\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpplvxyawb.jl:25 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpplvxyawb.jl:24\\ntest set:\
    \ Error During Test at /tmp/tmpplvxyawb.jl:26\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: get_collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpplvxyawb.jl:18\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpplvxyawb.jl:26 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpplvxyawb.jl:24\\ntest set:\
    \ Error During Test at /tmp/tmpplvxyawb.jl:27\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: get_collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpplvxyawb.jl:18\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpplvxyawb.jl:27 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpplvxyawb.jl:24\\ntest set:\
    \ Error During Test at /tmp/tmpplvxyawb.jl:28\\n  Test threw exception\\n  Expression:\
    \ candidate(1) == [1]\\n  UndefVarError: get_collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpplvxyawb.jl:18\\n"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \n    # Create an empty list of odd numbers.\n    odd_numbers = Int64[]\n\
    \    \n    # If n is 1, return 1 to the list.\n    if n == 1\n        push!(odd_numbers,\
    \ 1)\n        \n    # If n is not 1, go into while loop.\n    else\n        while\
    \ n != 1\n            \n            # If number is odd, push number to the list.\n\
    \            if n % 2 != 0\n                push!(odd_numbers, n)\n          \
    \      \n            # If number is even, divide by 2.\n            else\n   \
    \             n = n / 2\n            end\n        end\n    end\n    \n    # Sort\
    \ the list in increasing order.\n    return sort(odd_numbers)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    seq = Int64[]\n    while n != 1\n        if n % 2 == 1\n            push!(seq,\
    \ n)\n        end\n        n = next(n)\n    end\n    push!(seq, 1)\n    return\
    \ sort(seq)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp3h0i92to.jl:33\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ next not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @\
    \ Main /tmp/tmp3h0i92to.jl:23\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp3h0i92to.jl:33 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp3h0i92to.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmp3h0i92to.jl:34\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: next not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp3h0i92to.jl:23\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp3h0i92to.jl:34 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp3h0i92to.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmp3h0i92to.jl:35\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: next not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp3h0i92to.jl:23\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp3h0i92to.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp3h0i92to.jl:32\\nTest Summary:\
    \ | Pass  Error  Total\\ntest set      |    1      3      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz_seq = [n]\n    while\
    \ collatz_seq[end] != 1\n        if collatz_seq[end] % 2 == 0\n            collatz_seq\
    \ = [collatz_seq; collatz_seq[end]/2]\n        else\n            collatz_seq =\
    \ [collatz_seq; 3*collatz_seq[end] + 1]\n        end\n    end\n    return sort(setdiff(collatz_seq,\
    \ 2:2:collatz_seq[end]))\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpjko7wsky.jl:36\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: [1, 2, 4, 5, 7, 8, 10, 11, 13, 14,\
    \ 16, 17, 20, 22, 26, 34, 40, 52] == [1, 5, 7, 11, 13, 17]\\nStacktrace:\\n [1]\
    \ macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpjko7wsky.jl:36 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpjko7wsky.jl:35\\ntest set: Test\
    \ Failed at /tmp/tmpjko7wsky.jl:37\\n  Expression: candidate(5) == [1, 5]\\n \
    \  Evaluated: [1, 2, 4, 5, 8, 16] == [1, 5]\\nStacktrace:\\n [1] macro expansion\\\
    n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpjko7wsky.jl:37 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpjko7wsky.jl:35\\ntest set: Test\
    \ Failed at /tmp/tmpjko7wsky.jl:38\\n  Expression: candidate(12) == [1, 3, 5]\\\
    n   Evaluated: [1, 2, 3, 4, 5, 6, 8, 10, 12, 16] == [1, 3, 5]\\nStacktrace:\\\
    n [1] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpjko7wsky.jl:38 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpjko7wsky.jl:35\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    list = Int64[]\n    while n > 1\n        push!(list, n)\n        if n\
    \ % 2 == 0\n            n = div(n, 2)\n        else\n            n = 3 * n + 1\n\
    \        end\n    end\n    push!(list, 1)\n    list = filter(x -> x % 2 != 0,\
    \ list)\n    sort(list)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    # You can use any of the functions described in\
    \ chapter 2 of the\n    # manual.\n    # e.g.\n    # if isodd(n)\n    #     return\n\
    \    # else\n    #     return get_odd_collatz(div(n, 2))\n    # end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz_sequence = [n]\n    while n != 1\n        if iseven(n)\n     \
    \       n = div(n, 2)\n        else\n            n = 3*n + 1\n        end\n  \
    \      push!(collatz_sequence, n)\n    end\n    isodd.(collatz_sequence)\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjsyqvbqj.jl:34\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0,\
    \ 1, 0, 0, 0, 0, 1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjsyqvbqj.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjsyqvbqj.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpjsyqvbqj.jl:35\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1, 0, 0, 0, 0, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjsyqvbqj.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjsyqvbqj.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpjsyqvbqj.jl:36\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [0, 0, 1, 0, 1, 0, 0, 0, 0, 1] == [1, 3, 5]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjsyqvbqj.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjsyqvbqj.jl:33\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjsyqvbqj.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    result = [n]\n    while (n != 1)\n        if (n % 2 == 0)\n          \
    \  n = n/2\n        else\n            n = 3*n + 1\n        end\n        push!(result,\
    \ n)\n    end\n    return filter(result) do n\n        n % 2 != 0\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpg5fj5_em.jl:36\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg5fj5_em.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg5fj5_em.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpg5fj5_em.jl:37\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg5fj5_em.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg5fj5_em.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpg5fj5_em.jl:38\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpg5fj5_em.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg5fj5_em.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg5fj5_em.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    sequence = [n]\n    while n != 1\n        if n % 2 == 0\n            n\
    \ = n / 2\n        else\n            n = 3 * n + 1\n        end\n        push!(sequence,\
    \ n)\n    end\n    isodd.(sequence) .* sequence\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfwepel84.jl:34\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [0, 7, 0, 11, 0, 17, 0, 0, 13, 0, 0,\
    \ 0, 5, 0, 0, 0, 0, 1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfwepel84.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfwepel84.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpfwepel84.jl:35\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 0, 0, 0, 0, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfwepel84.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfwepel84.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpfwepel84.jl:36\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [0, 0, 3, 0, 5, 0, 0, 0, 0, 1] == [1, 3, 5]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfwepel84.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfwepel84.jl:33\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfwepel84.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    result = Int64[]\n    while n != 1\n        push!(result, n)\n       \
    \ if n % 2 == 0\n            n = n / 2\n        else\n            n = 3 * n +\
    \ 1\n        end\n    end\n    push!(result, 1)\n    return sort(result[result\
    \ % 2 != 0])\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # Implement this function.\n    collatz_sequence = Int64[]\n    push!(collatz_sequence,\
    \ n)\n    while collatz_sequence[end] != 1\n        if collatz_sequence[end] %\
    \ 2 == 0\n            push!(collatz_sequence, collatz_sequence[end] / 2)\n   \
    \     else\n            push!(collatz_sequence, collatz_sequence[end] * 3 + 1)\n\
    \        end\n    end\n    return collatz_sequence[filter(i -> i % 2 != 0, 1:length(collatz_sequence))]\n\
    end\n# Test function\n@test get_odd_collatz(5) == [1, 5]\n@test get_odd_collatz(1)\
    \ == [1]\n@test get_odd_collatz(4) == [1, 4]\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @test not defined\nin expression starting\
    \ at /tmp/tmpp5ok4ixb.jl:31\nin expression starting at /tmp/tmpp5ok4ixb.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # Fill in your code here\n    odd_numbers = []\n    collatz_sequence =\
    \ collatz(n)\n    for i in collatz_sequence\n        if isodd(i)\n           \
    \ push!(odd_numbers, i)\n        end\n    end\n    return odd_numbers\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpsgmx6y_7.jl:33\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ collatz not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n  \
    \   @ Main /tmp/tmpsgmx6y_7.jl:20\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpsgmx6y_7.jl:33 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpsgmx6y_7.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmpsgmx6y_7.jl:34\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpsgmx6y_7.jl:20\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpsgmx6y_7.jl:34 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpsgmx6y_7.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmpsgmx6y_7.jl:35\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpsgmx6y_7.jl:20\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpsgmx6y_7.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpsgmx6y_7.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmpsgmx6y_7.jl:36\\n  Test threw exception\\n  Expression:\
    \ candidate(1) == [1]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpsgmx6y_7.jl:20\\n   [2]\
    \ macro exp"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = []\n    while n\
    \ != 1\n        push!(collatz, n)\n        if n % 2 == 0\n            n = n/2\n\
    \        else\n            n = 3n + 1\n        end\n    end\n    push!(collatz,\
    \ 1)\n    filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp344mqocs.jl:38\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp344mqocs.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp344mqocs.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp344mqocs.jl:39\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp344mqocs.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp344mqocs.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp344mqocs.jl:40\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp344mqocs.jl:40 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp344mqocs.jl:37\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp344mqocs.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    sequence = Array(Int64, 0)\n    while n > 1\n        push!(sequence, n)\n\
    \        if n % 2 == 0\n            n = div(n, 2)\n        else\n            n\
    \ = 3*n + 1\n        end\n    end\n    push!(sequence, 1)\n    return sequence[1:2:end]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmptr7g09fp.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ no method matching Array(::Type{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    Array(!Matched::LinearAlgebra.UniformScaling, ::Integer, !Matched::Integer)\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:496\\\
    n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmptr7g09fp.jl:18\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmptr7g09fp.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmptr7g09fp.jl:34\\ntest set:\
    \ Error During Test at /tmp/tmptr7g09fp.jl:36\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  MethodError: no method matching Array(::Type{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    Array(!Matched::LinearAlgebra.UniformScaling,\
    \ ::Integer, !Matched::Integer) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:496\\\
    n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmptr7g09fp.jl:18\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmptr7g09fp.jl:36 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmptr7g09fp.jl:34\\ntest set:\
    \ Error During Test at /tmp/tmptr7g09fp.jl:37\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  MethodError: no method matching Array(::Type{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    Array(!Matched::LinearAlgebra.UniformScaling,\
    \ ::Integer, !Matched::Integer) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:496\\"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n   \n    v=Vector{Int64}(undef,0)\n    \n    # your code goes here\n    i=n\n\
    \    while i != 1\n        if i%2 != 0\n            push!(v,i)\n        end\n\
    \        if i%2 == 0\n            i=i/2\n        else\n            i=3*i+1\n \
    \       end\n    end\n    push!(v,1)\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpleezohl7.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpleezohl7.jl:1\n\
    in expression starting at /tmp/tmpleezohl7.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    myVector = [n]\n    while n != 1\n        if n % 2 == 0\n            n\
    \ = n/2\n        else\n            n = 3*n + 1\n        end\n        push!(myVector,\
    \ n)\n    end\n    myVector = myVector[myVector .% 2 .!= 0]\n    return myVector\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4korbcww.jl:35\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4korbcww.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4korbcww.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp4korbcww.jl:36\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4korbcww.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4korbcww.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp4korbcww.jl:37\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp4korbcww.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4korbcww.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4korbcww.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \n    # initialize return vector with n as first element\n    ret_vec\
    \ = [n]\n    \n    # loop until n is 1\n    while n != 1\n        \n        #\
    \ set n to be half of the previous term\n        if n % 2 == 0\n            n\
    \ = n/2\n        \n        # set n to be 3 times the previous term plus 1\n  \
    \      else\n            n = 3*n + 1\n        end\n        \n        # if n is\
    \ odd, push it onto the return vector\n        if n % 2 != 0\n            push!(ret_vec,\
    \ n)\n        end\n    end\n    \n    # sort ret_vec and return it\n    sort!(ret_vec)\n\
    \    return ret_vec\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3wtpcwxn.jl:49\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3wtpcwxn.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3wtpcwxn.jl:48\ntest set: Test\
    \ Failed at /tmp/tmp3wtpcwxn.jl:51\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 3, 5, 12] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3wtpcwxn.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3wtpcwxn.jl:48\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3wtpcwxn.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    odd_list = []\n    odd_list\
    \ = push!(odd_list, n)\n    while n != 1\n        if n % 2 == 0\n            n\
    \ = n \xF7 2\n        else\n            n = 3n + 1\n        end\n        if n\
    \ % 2 != 0\n            odd_list = push!(odd_list, n)\n        end\n    end\n\
    \    sort(odd_list)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6lx9q7pk.jl:40\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6lx9q7pk.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6lx9q7pk.jl:39\ntest set: Test\
    \ Failed at /tmp/tmp6lx9q7pk.jl:42\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 3, 5, 12] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6lx9q7pk.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6lx9q7pk.jl:39\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6lx9q7pk.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz = Int64[]\n    while n != 1\n        push!(collatz, n)\n     \
    \   if iseven(n)\n            n = n\xF72\n        else\n            n = 3*n +\
    \ 1\n        end\n    end\n    push!(collatz, n)\n    return collatz[collatz .%\
    \ 2 == 1]\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpsn8ou211.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  ArgumentError:\
    \ invalid index: false of type Bool\\n  Stacktrace:\\n    [1] to_index(i::Bool)\\\
    n      @ Base ./indices.jl:293\\n    [2] to_index(A::Vector{Int64}, i::Bool)\\\
    n      @ Base ./indices.jl:277\\n    [3] to_indices\\n      @ ./indices.jl:333\
    \ [inlined]\\n    [4] to_indices\\n      @ ./indices.jl:330 [inlined]\\n    [5]\
    \ getindex\\n      @ ./abstractarray.jl:1221 [inlined]\\n    [6] get_odd_collatz(n::Int64)\\\
    n      @ Main /tmp/tmpsn8ou211.jl:28\\n    [7] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n    [8] macro expansion\\n      @ /tmp/tmpsn8ou211.jl:35 [inlined]\\\
    n    [9] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [10] top-level scope\\n      @ /tmp/tmpsn8ou211.jl:34\\ntest\
    \ set: Error During Test at /tmp/tmpsn8ou211.jl:36\\n  Test threw exception\\\
    n  Expression: candidate(5) == [1, 5]\\n  ArgumentError: invalid index: false\
    \ of type Bool\\n  Stacktrace:\\n    [1] to_index(i::Bool)\\n      @ Base ./indices.jl:293\\\
    n    [2] to_index(A::Vector{Int64}, i::Bool)\\n      @ Base ./indices.jl:277\\\
    n    [3] to_indices\\n      @ ./indices.jl:333 [inlined]\\n    [4] to_indices\\\
    n      @ ./indices.jl:330 [inlined]\\n    [5] getindex\\n      @ ./abstractarray.jl:1221\
    \ [inlined]\\n    [6] get_odd_collatz(n::Int64)\\n      @ Main /tmp/tmpsn8ou211.jl:28\\\
    n    [7] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n    [8] macro expansion\\n      @ /tmp/tmpsn8ou211.jl:36 [inlined]\\\
    n    [9] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [10] top-level scope\\n      @ /tmp/tmpsn8ou211.jl:34\\ntest\
    \ set: Error During Test at /tmp/tmpsn8ou211.jl:37\\n  Test threw exception\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n  ArgumentError: invalid index: false\
    \ of type Bool\\n  Stacktrace:"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n <= 0\n        error(\"n must be a positive integer.\")\n    end\n\
    \    seq = []\n    while n != 1\n        push!(seq, n)\n        if n % 2 == 0\n\
    \            n = n / 2\n        else\n            n = 3 * n + 1\n        end\n\
    \    end\n    push!(seq, 1)\n    return seq[seq .% 2 == 1]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpsezj4fta.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  ArgumentError:\
    \ invalid index: false of type Bool\\n  Stacktrace:\\n    [1] to_index(i::Bool)\\\
    n      @ Base ./indices.jl:293\\n    [2] to_index(A::Vector{Any}, i::Bool)\\n\
    \      @ Base ./indices.jl:277\\n    [3] to_indices\\n      @ ./indices.jl:333\
    \ [inlined]\\n    [4] to_indices\\n      @ ./indices.jl:330 [inlined]\\n    [5]\
    \ getindex\\n      @ ./abstractarray.jl:1221 [inlined]\\n    [6] get_odd_collatz(n::Int64)\\\
    n      @ Main /tmp/tmpsezj4fta.jl:31\\n    [7] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n    [8] macro expansion\\n      @ /tmp/tmpsezj4fta.jl:38 [inlined]\\\
    n    [9] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [10] top-level scope\\n      @ /tmp/tmpsezj4fta.jl:37\\ntest\
    \ set: Error During Test at /tmp/tmpsezj4fta.jl:39\\n  Test threw exception\\\
    n  Expression: candidate(5) == [1, 5]\\n  ArgumentError: invalid index: false\
    \ of type Bool\\n  Stacktrace:\\n    [1] to_index(i::Bool)\\n      @ Base ./indices.jl:293\\\
    n    [2] to_index(A::Vector{Any}, i::Bool)\\n      @ Base ./indices.jl:277\\n\
    \    [3] to_indices\\n      @ ./indices.jl:333 [inlined]\\n    [4] to_indices\\\
    n      @ ./indices.jl:330 [inlined]\\n    [5] getindex\\n      @ ./abstractarray.jl:1221\
    \ [inlined]\\n    [6] get_odd_collatz(n::Int64)\\n      @ Main /tmp/tmpsezj4fta.jl:31\\\
    n    [7] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n    [8] macro expansion\\n      @ /tmp/tmpsezj4fta.jl:39 [inlined]\\\
    n    [9] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [10] top-level scope\\n      @ /tmp/tmpsezj4fta.jl:37\\ntest\
    \ set: Error During Test at /tmp/tmpsezj4fta.jl:40\\n  Test threw exception\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n  ArgumentError: invalid index: false\
    \ of type Bool\\n  Stacktrace:\\n  "
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n < 1\n        return []\n    end\n    v = Vector{Int64}()\n    function\
    \ collatz(n::Int64)::Vector{Int64}\n        #print(n)\n        push!(v, n)\n \
    \       if n == 1\n            return v\n        elseif n % 2 == 0\n         \
    \   collatz(n \xF7 2)\n        else\n            collatz(3n + 1)\n        end\n\
    \    end\n    collatz(n)\n    filter(x -> x % 2 == 1, v)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7iut0nx7.jl:41\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7iut0nx7.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7iut0nx7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp7iut0nx7.jl:42\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7iut0nx7.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7iut0nx7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp7iut0nx7.jl:43\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7iut0nx7.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7iut0nx7.jl:40\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7iut0nx7.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz(1) = [1]\n    collatz(n) = (if(n % 2 == 0) [n; collatz(n/2)] else\
    \ [n; collatz(3*n + 1)])\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space before \"[\" not allowed in \"((n % 2)\
    \ == 0) [\" at /tmp/tmp60j56s4m.jl:19\nStacktrace:\n [1] top-level scope\n   @\
    \ /tmp/tmp60j56s4m.jl:19\nin expression starting at /tmp/tmp60j56s4m.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n <= 0\n        error(\"n must be positive\")\n    end\n    result\
    \ = [n]\n    while n != 1\n        n = n%2 == 0 ? n/2 : 3*n + 1\n        push!(result,\
    \ n)\n    end\n    return sort(result[result .% 2 == 1])\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpztow8x_y.jl:33\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  ArgumentError:\
    \ invalid index: false of type Bool\\n  Stacktrace:\\n    [1] to_index(i::Bool)\\\
    n      @ Base ./indices.jl:293\\n    [2] to_index(A::Vector{Int64}, i::Bool)\\\
    n      @ Base ./indices.jl:277\\n    [3] to_indices\\n      @ ./indices.jl:333\
    \ [inlined]\\n    [4] to_indices\\n      @ ./indices.jl:330 [inlined]\\n    [5]\
    \ getindex\\n      @ ./abstractarray.jl:1221 [inlined]\\n    [6] get_odd_collatz(n::Int64)\\\
    n      @ Main /tmp/tmpztow8x_y.jl:26\\n    [7] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n    [8] macro expansion\\n      @ /tmp/tmpztow8x_y.jl:33 [inlined]\\\
    n    [9] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [10] top-level scope\\n      @ /tmp/tmpztow8x_y.jl:32\\ntest\
    \ set: Error During Test at /tmp/tmpztow8x_y.jl:34\\n  Test threw exception\\\
    n  Expression: candidate(5) == [1, 5]\\n  ArgumentError: invalid index: false\
    \ of type Bool\\n  Stacktrace:\\n    [1] to_index(i::Bool)\\n      @ Base ./indices.jl:293\\\
    n    [2] to_index(A::Vector{Int64}, i::Bool)\\n      @ Base ./indices.jl:277\\\
    n    [3] to_indices\\n      @ ./indices.jl:333 [inlined]\\n    [4] to_indices\\\
    n      @ ./indices.jl:330 [inlined]\\n    [5] getindex\\n      @ ./abstractarray.jl:1221\
    \ [inlined]\\n    [6] get_odd_collatz(n::Int64)\\n      @ Main /tmp/tmpztow8x_y.jl:26\\\
    n    [7] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n    [8] macro expansion\\n      @ /tmp/tmpztow8x_y.jl:34 [inlined]\\\
    n    [9] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [10] top-level scope\\n      @ /tmp/tmpztow8x_y.jl:32\\ntest\
    \ set: Error During Test at /tmp/tmpztow8x_y.jl:35\\n  Test threw exception\\\
    n  Expression: candidate(12) == [1, 3, 5]\\n  ArgumentError: invalid index: false\
    \ of type Bool\\n  Stacktrace:"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz_sequense = []\n    if n == 1\n        push!(collatz_sequense,\
    \ 1)\n        return collatz_sequense\n    end\n    while n != 1\n        if n\
    \ % 2 == 0\n            n = n / 2\n        else\n            push!(collatz_sequense,\
    \ n)\n            n = 3 * n + 1\n        end\n    end\n    push!(collatz_sequense,\
    \ 1)\n    sort(collatz_sequense)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    x = Int64[]\n    for i in 1:n\n        c = i\n        while c!=1\n   \
    \         if c%2 == 0\n                c = div(c,2)\n            else\n      \
    \          push!(x,c)\n                c = 3*c+1\n            end\n        end\n\
    \    end\n    sort(unique(x))\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpd_5n73q4.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [3, 5, 7, 9, 11, 13, 17] == [1, 5, 7,\
    \ 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd_5n73q4.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd_5n73q4.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpd_5n73q4.jl:38\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [3, 5] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd_5n73q4.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd_5n73q4.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpd_5n73q4.jl:39\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 7, 9, 11, 13, 17] == [1, 3, 5]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd_5n73q4.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd_5n73q4.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpd_5n73q4.jl:40\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd_5n73q4.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd_5n73q4.jl:36\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd_5n73q4.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   n = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ [x for x in collatz if x % 2 != 0]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp3nzuaac9.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3nzuaac9.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3nzuaac9.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp3nzuaac9.jl:38\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3nzuaac9.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3nzuaac9.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp3nzuaac9.jl:39\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp3nzuaac9.jl:39 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3nzuaac9.jl:36\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3nzuaac9.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # Your code here\n    x = n\n    tmp = 0\n    ans = []\n    while x !=\
    \ 1\n        if mod(x, 2) == 0\n            x = x / 2\n        else\n        \
    \    x = 3 * x + 1\n            push!(ans, x)\n        end\n    end\n    ans =\
    \ sort(ans)\n    push!(ans, 1)\n    return ans\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6z_2ia3w.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [16, 22, 34, 40, 52, 1] == [1, 5, 7,\
    \ 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6z_2ia3w.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6z_2ia3w.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp6z_2ia3w.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [16, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6z_2ia3w.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6z_2ia3w.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp6z_2ia3w.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [10, 16, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n \
    \  @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6z_2ia3w.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6z_2ia3w.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6z_2ia3w.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz(n::Int64) = [n]\n    while n != 1\n        if n % 2 == 0\n   \
    \         n = n \xF7 2\n        else\n            n = 3n + 1\n        end\n  \
    \      push!(collatz(n), n)\n    end\n    odds = filter(x -> x % 2 != 0, collatz(n))\n\
    \    return odds\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpecyzh4i_.jl:35\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpecyzh4i_.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpecyzh4i_.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpecyzh4i_.jl:36\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpecyzh4i_.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpecyzh4i_.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpecyzh4i_.jl:37\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpecyzh4i_.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpecyzh4i_.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpecyzh4i_.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    v = [n]\n    while n != 1\n        if n % 2 == 0\n            n = div(n,\
    \ 2)\n        else\n            n = 3 * n + 1\n        end\n        push!(v, n)\n\
    \    end\n    filter(x -> x % 2 != 0, v)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeq2zp5np.jl:34\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeq2zp5np.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeq2zp5np.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpeq2zp5np.jl:35\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeq2zp5np.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeq2zp5np.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpeq2zp5np.jl:36\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpeq2zp5np.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeq2zp5np.jl:33\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeq2zp5np.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    end\n    collatz = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n/2\n        else\n         \
    \   n = 3n + 1\n        end\n        push!(collatz, n)\n    end\n    return [x\
    \ for x in collatz if x % 2 != 0]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpxw894nou.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxw894nou.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxw894nou.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpxw894nou.jl:38\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxw894nou.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxw894nou.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpxw894nou.jl:39\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpxw894nou.jl:39 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxw894nou.jl:36\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxw894nou.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n < 1\n        return Int64[]\n    end\n    odds = Int64[]\n    push!(odds,\
    \ n)\n    while n != 1\n        if n % 2 == 0\n            n = n \xF7 2\n    \
    \    else\n            n = 3n + 1\n            push!(odds, n)\n        end\n \
    \   end\n    return odds\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmponhv_rcj.jl:38\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [14, 22, 34, 52, 40, 16] == [1, 5, 7,\
    \ 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmponhv_rcj.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmponhv_rcj.jl:37\ntest set: Test\
    \ Failed at /tmp/tmponhv_rcj.jl:39\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 16] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmponhv_rcj.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmponhv_rcj.jl:37\ntest set: Test\
    \ Failed at /tmp/tmponhv_rcj.jl:40\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [12, 10, 16] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmponhv_rcj.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmponhv_rcj.jl:37\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmponhv_rcj.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # checking for a positive integer\n    if n<1\n        println(\"Please\
    \ enter a positive integer\")\n        return []\n    end\n    odd_nums = Int64[]\n\
    \    # for the first term of Collatz sequence\n    if n%2==1\n        push!(odd_nums,\
    \ n)\n    end\n    # continue until it reaches 1\n    while n!=1\n        if n%2==0\n\
    \            n=n/2\n        else\n            n=3*n+1\n            push!(odd_nums,\
    \ n)\n        end\n    end\n    return sort(odd_nums)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpirj2z1pp.jl:44\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [16, 22, 34, 40, 52] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpirj2z1pp.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpirj2z1pp.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpirj2z1pp.jl:45\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 16] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpirj2z1pp.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpirj2z1pp.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpirj2z1pp.jl:46\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [10, 16] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpirj2z1pp.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpirj2z1pp.jl:43\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpirj2z1pp.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \n    j = 1\n    x = Array{Int64}(undef, 0)\n    while n > 0\n       \
    \ while n != 1\n            if n % 2 == 0\n                n = n/2\n         \
    \   else\n                n = 3*n + 1\n                push!(x, n)\n         \
    \   end\n        end\n    end\n    x = unique(x)\n    return x\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    vector = [n]\n    while(true)\n\
    \        if(n % 2 == 0)\n            n = n/2\n        else\n            n = 3*n\
    \ + 1\n        end\n        push!(vector, n)\n        if(n == 1)\n           \
    \ break\n        end\n    end\n    return filter(x -> x % 2 != 0, vector)\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8f92y74p.jl:40\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8f92y74p.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8f92y74p.jl:39\ntest set: Test\
    \ Failed at /tmp/tmp8f92y74p.jl:41\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8f92y74p.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8f92y74p.jl:39\ntest set: Test\
    \ Failed at /tmp/tmp8f92y74p.jl:42\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8f92y74p.jl:42 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8f92y74p.jl:39\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8f92y74p.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1 \n        return [1]\n    end \n    seq = []\n    while n !=\
    \ 1 \n        push!(seq, n)\n        if n % 2 == 0 \n            n = n / 2\n \
    \       else \n            n = 3 * n + 1\n        end \n    end \n    seq = [1]\n\
    \    for i in 2:length(seq)\n        if seq[i] % 2 != 0 \n            push!(seq,\
    \ seq[i])\n        end \n    end \n    sort(seq)\nend \nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpg2dk4lnk.jl:43\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg2dk4lnk.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg2dk4lnk.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpg2dk4lnk.jl:44\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg2dk4lnk.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg2dk4lnk.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpg2dk4lnk.jl:45\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg2dk4lnk.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg2dk4lnk.jl:42\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg2dk4lnk.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz = [n]\n    for i = n:1\n        if i % 2 == 0\n            push!(collatz,\
    \ i)\n            i /= 2\n        elseif i % 2 == 1\n            push!(collatz,\
    \ i)\n            i = 3*i + 1\n        end\n    end\n    return sort(filter(x\
    \ -> isodd(x), collatz))\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1roz6l32.jl:35\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1roz6l32.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1roz6l32.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp1roz6l32.jl:36\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1roz6l32.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1roz6l32.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp1roz6l32.jl:37\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1roz6l32.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1roz6l32.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp1roz6l32.jl:38\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ [1, 1] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1roz6l32.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1roz6l32.jl:34\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1roz6l32.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    seq = n \n    odd_seq = []\n    while seq != 1\n        push!(odd_seq,\
    \ seq)\n        if seq % 2 == 0 \n            seq = seq / 2\n        else \n \
    \           seq = 3 * seq + 1\n        end\n    end\n    push!(odd_seq, 1)\n \
    \   return odd_seq[odd_seq .% 2 .!= 0]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpm87dedfe.jl:36\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm87dedfe.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm87dedfe.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpm87dedfe.jl:37\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm87dedfe.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm87dedfe.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpm87dedfe.jl:38\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpm87dedfe.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm87dedfe.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm87dedfe.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    nums = collect(1:n)\n    odd\
    \ = Int64[]\n    for i in nums\n        if i % 2 == 1\n            push!(odd,\
    \ i)\n        end\n    end\n    odd\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpn19emx2k.jl:35\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 3, 5, 7, 9, 11, 13] == [1, 5, 7,\
    \ 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn19emx2k.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn19emx2k.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpn19emx2k.jl:36\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1, 3, 5] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn19emx2k.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn19emx2k.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpn19emx2k.jl:37\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 3, 5, 7, 9, 11] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn19emx2k.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn19emx2k.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn19emx2k.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    v = Int64[]\n    for i in collatz(n)\n        if isodd(i)\n          \
    \  push!(v, i)\n        end\n    end\n    return v\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpihdyoq5e.jl:31\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ collatz not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n  \
    \   @ Main /tmp/tmpihdyoq5e.jl:19\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpihdyoq5e.jl:31 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpihdyoq5e.jl:30\\ntest set:\
    \ Error During Test at /tmp/tmpihdyoq5e.jl:32\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpihdyoq5e.jl:19\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpihdyoq5e.jl:32 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpihdyoq5e.jl:30\\ntest set:\
    \ Error During Test at /tmp/tmpihdyoq5e.jl:33\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpihdyoq5e.jl:19\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpihdyoq5e.jl:33 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpihdyoq5e.jl:30\\ntest set:\
    \ Error During Test at /tmp/tmpihdyoq5e.jl:34\\n  Test threw exception\\n  Expression:\
    \ candidate(1) == [1]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpihdyoq5e.jl:19\\n   [2]\
    \ macro exp"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpama9f5bo.jl:25\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpama9f5bo.jl:19\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpama9f5bo.jl:25 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpama9f5bo.jl:24\\ntest set:\
    \ Error During Test at /tmp/tmpama9f5bo.jl:26\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpama9f5bo.jl:19\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp522a_rnf.jl:25\\n  Test threw\
    \ exception\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz = [n]\n    for num in n:collatz\n        # do not mod n here,\
    \ because n could be 1, and n%2==0.\n        if num%2 == 0\n            collatz\
    \ = push!(collatz, num/2)\n        else\n            collatz = push!(collatz,\
    \ 3*num+1)\n        end\n    end\n    # return vector of only odd numbers\n  \
    \  return collatz[collatz .% 2 .!= 0]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpdm36ohxx.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ no method matching (::Colon)(::Int64, ::Vector{Int64})\\n  Closest candidates\
    \ are:\\n    (::Colon)(::T, ::Any, !Matched::T) where T<:Real at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:41\\\
    n    (::Colon)(::A, ::Any, !Matched::C) where {A<:Real, C<:Real} at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:10\\\
    n    (::Colon)(::T, ::Any, !Matched::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:40\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpdm36ohxx.jl:19\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpdm36ohxx.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpdm36ohxx.jl:34\\ntest set:\
    \ Error During Test at /tmp/tmpdm36ohxx.jl:36\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  MethodError: no method matching (::Colon)(::Int64,\
    \ ::Vector{Int64})\\n  Closest candidates are:\\n    (::Colon)(::T, ::Any, !Matched::T)\
    \ where T<:Real at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:41\\\
    n    (::Colon)(::A, ::Any, !Matched::C) where {A<:Real, C<:Real} at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:10\\\
    n    (::Colon)(::T, ::Any, !Matched::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:40\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpdm36ohxx.jl:19\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpdm36ohxx.jl:36 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpdm36ohxx.jl:34\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    seq = Int64[]\n    if n == 1\n        return [1]\n    end\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n         \
    \   push!(seq, n)\n            n = 3*n + 1\n        end\n    end\n    sort(seq)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_nqxhxgc.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [5, 7, 11, 13, 17] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_nqxhxgc.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_nqxhxgc.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp_nqxhxgc.jl:38\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_nqxhxgc.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_nqxhxgc.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp_nqxhxgc.jl:39\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_nqxhxgc.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_nqxhxgc.jl:36\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_nqxhxgc.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    i = n\n    sequence = []\n    push!(sequence, i)\n    while i > 1\n  \
    \      if i % 2 == 0\n            i = i / 2\n        else\n            i = 3 *\
    \ i + 1\n        end\n        push!(sequence, i)\n    end\n    return(sort(filter(x\
    \ -> x % 2 != 0, sequence)))\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    seq = Collatz(n)\n    return [x for x in seq if x % 2 == 1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmple8z739i.jl:26\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ Collatz not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n  \
    \   @ Main /tmp/tmple8z739i.jl:18\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmple8z739i.jl:26 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmple8z739i.jl:25\\ntest set:\
    \ Error During Test at /tmp/tmple8z739i.jl:27\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: Collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmple8z739i.jl:18\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmple8z739i.jl:27 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmple8z739i.jl:25\\ntest set:\
    \ Error During Test at /tmp/tmple8z739i.jl:28\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: Collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmple8z739i.jl:18\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmple8z739i.jl:28 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmple8z739i.jl:25\\ntest set:\
    \ Error During Test at /tmp/tmple8z739i.jl:29\\n  Test threw exception\\n  Expression:\
    \ candidate(1) == [1]\\n  UndefVarError: Collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmple8z739i.jl:18\\n   [2]\
    \ macro exp"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    seq = []\n    i = 1\n    while i <= n\n        if is_odd(i)\n        \
    \    push!(seq,i)\n        end\n        i += 1\n    end\n    return seq\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpstnh17qb.jl:33\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ is_odd not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n   \
    \  @ Main /tmp/tmpstnh17qb.jl:21\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpstnh17qb.jl:33 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpstnh17qb.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmpstnh17qb.jl:34\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: is_odd not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpstnh17qb.jl:21\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpstnh17qb.jl:34 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpstnh17qb.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmpstnh17qb.jl:35\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: is_odd not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpstnh17qb.jl:21\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpstnh17qb.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpstnh17qb.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmpstnh17qb.jl:36\\n  Test threw exception\\n  Expression:\
    \ candidate(1) == [1]\\n  UndefVarError: is_odd not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpstnh17qb.jl:21\\n   [2]\
    \ macro expansi"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # I am going to build a table of known collatz sequences to make a more\
    \ efficient algo.\n    # This is an array of array. The length of each array is\
    \ the number of steps in its collatz sequence.\n    # (1, [1]) is added by default.\n\
    \    collatz_table = [(1, [1])]\n    # This is the vector of odd numbers in the\
    \ collatz sequence for n. \n    # This vector is returned. \n    odd_collatz =\
    \ []\n    # Remember n was given as an arg.\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp97nzyaz8.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp97nzyaz8.jl:1\n\
    in expression starting at /tmp/tmp97nzyaz8.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpqosjxe02.jl:24\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpqosjxe02.jl:18\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpqosjxe02.jl:24 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpqosjxe02.jl:23\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    vec = []\n    while n != 1\n        push!(vec, n)\n        if n % 2 ==\
    \ 0\n            n = n/2\n        else\n            n = 3n + 1\n        end\n\
    \    end\n    push!(vec, n)\n    return vec[vec.%2.!=0]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid syntax \"2.!\"; add space(s) to clarify\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmprr1ppxsc.jl:28\nin expression\
    \ starting at /tmp/tmprr1ppxsc.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \n    return []\nend\n \n \n \n \n\"\"\"\n    Given a vector of integers,\
    \ calculate a new vector where each entry is the product of all numbers in the\
    \ input vector except the number at the index of the new vector. \n    Do this\
    \ without using a for loop.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmpljp9fodz.jl:25\nin expression starting at /tmp/tmpljp9fodz.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    seq=[]\n    while n != 1\n        push!(seq,n)\n        if n%2==0\n  \
    \          n=n/2\n        else\n            n=3*n+1\n        end\n    end\n  \
    \  push!(seq,1)\n    odd_seq=[]\n    for i in seq\n        if i%2!=0\n       \
    \     push!(odd_seq,i)\n        end\n    end\n    return odd_seq\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps3kvfhs_.jl:41\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmps3kvfhs_.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps3kvfhs_.jl:40\ntest set: Test\
    \ Failed at /tmp/tmps3kvfhs_.jl:42\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmps3kvfhs_.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps3kvfhs_.jl:40\ntest set: Test\
    \ Failed at /tmp/tmps3kvfhs_.jl:43\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmps3kvfhs_.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps3kvfhs_.jl:40\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps3kvfhs_.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n <= 0\n        return [NaN]\n    end\n    if n == 1\n        return\
    \ [1]\n    end\n    odd_nums = Int64[]\n    push!(odd_nums, n)\n    while n !=\
    \ 1\n        if n % 2 == 0\n            n = n / 2\n        else\n            n\
    \ = (3 * n) + 1\n            push!(odd_nums, n)\n        end\n    end\n    sort(odd_nums)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxjgrdmhf.jl:41\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [14, 16, 22, 34, 40, 52] == [1, 5, 7,\
    \ 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxjgrdmhf.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxjgrdmhf.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpxjgrdmhf.jl:42\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 16] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxjgrdmhf.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxjgrdmhf.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpxjgrdmhf.jl:43\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [10, 12, 16] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxjgrdmhf.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxjgrdmhf.jl:40\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxjgrdmhf.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \"\"\"\n    Give a positive integer n, return a sorted list that has the\
    \ odd numbers in collatz sequence.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpnpz7pnba.jl:1\nin expression starting at /tmp/tmpnpz7pnba.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    odd_collatz = []\n    while n > 1\n        if n\
    \ % 2 == 1\n            push!(odd_collatz, n)\n        end\n        n = collatz(n)\n\
    \    end\n    push!(odd_collatz, 1)\n    return odd_collatz\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpat8ynfmk.jl:34\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ collatz not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n  \
    \   @ Main /tmp/tmpat8ynfmk.jl:24\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpat8ynfmk.jl:34 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpat8ynfmk.jl:33\\ntest set:\
    \ Error During Test at /tmp/tmpat8ynfmk.jl:35\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpat8ynfmk.jl:24\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpat8ynfmk.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpat8ynfmk.jl:33\\ntest set:\
    \ Error During Test at /tmp/tmpat8ynfmk.jl:36\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpat8ynfmk.jl:24\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpat8ynfmk.jl:36 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpat8ynfmk.jl:33\\nTest Summary:\
    \ | Pass  Error  Total\\ntest set      |    1      3      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_numbers = Int64[]\n    for i in collatz(n)\n        if i % 2 != 0\n\
    \            push!(odd_numbers, i)\n        end\n    end\n    return odd_numbers\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpbfqqnipw.jl:31\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ collatz not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n  \
    \   @ Main /tmp/tmpbfqqnipw.jl:19\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpbfqqnipw.jl:31 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpbfqqnipw.jl:30\\ntest set:\
    \ Error During Test at /tmp/tmpbfqqnipw.jl:32\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpbfqqnipw.jl:19\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpbfqqnipw.jl:32 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpbfqqnipw.jl:30\\ntest set:\
    \ Error During Test at /tmp/tmpbfqqnipw.jl:33\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpbfqqnipw.jl:19\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpbfqqnipw.jl:33 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpbfqqnipw.jl:30\\ntest set:\
    \ Error During Test at /tmp/tmpbfqqnipw.jl:34\\n  Test threw exception\\n  Expression:\
    \ candidate(1) == [1]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpbfqqnipw.jl:19\\n   [2]\
    \ macro exp"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    result=Int64[]\n    while n!=1\n        push!(result,n)\n        if n%2==0\n\
    \            n=n/2\n        else\n            n=3*n+1\n        end\n    end\n\
    \    push!(result,1)\n    return result[findall(result%2==1)]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpev4b6qf9.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ no method matching rem(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    rem(::Any, ::Any, !Matched::RoundingMode{:ToZero}) at /shared/centos7/julia/1.7.3/share/julia/base/div.jl:80\\\
    n    rem(::Any, ::Any, !Matched::RoundingMode{:Down}) at /shared/centos7/julia/1.7.3/share/julia/base/div.jl:81\\\
    n    rem(::Any, ::Any, !Matched::RoundingMode{:Up}) at /shared/centos7/julia/1.7.3/share/julia/base/div.jl:82\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpev4b6qf9.jl:28\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpev4b6qf9.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpev4b6qf9.jl:34\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    collatz_list = []\n    # loop through the n values,\
    \ and append it to collatz_list.\n    while n>=1\n        push!(collatz_list,n)\n\
    \        if n%2==0\n            n=n/2\n        else\n            n=(3*n)+1\n \
    \       end\n    end\n    odd_collatz_list = []\n    # loop through the list,\
    \ and only the odd values are appended to the odd_collatz_list.\n    for i=1:length(collatz_list)\n\
    \        if collatz_list[i]%2==1\n            push!(odd_collatz_list,collatz_list[i])\n\
    \        end\n    end\n    # sort the odd_collatz_list.\n    sort!(odd_collatz_list)\n\
    \    return odd_collatz_list\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz_seq = collatz(n)\n    return filter(x -> x % 2 != 0, collatz_seq)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpa3q6ysw0.jl:26\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ collatz not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n  \
    \   @ Main /tmp/tmpa3q6ysw0.jl:18\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpa3q6ysw0.jl:26 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpa3q6ysw0.jl:25\\ntest set:\
    \ Error During Test at /tmp/tmpa3q6ysw0.jl:27\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpa3q6ysw0.jl:18\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpa3q6ysw0.jl:27 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpa3q6ysw0.jl:25\\ntest set:\
    \ Error During Test at /tmp/tmpa3q6ysw0.jl:28\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpa3q6ysw0.jl:18\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpa3q6ysw0.jl:28 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpa3q6ysw0.jl:25\\ntest set:\
    \ Error During Test at /tmp/tmpa3q6ysw0.jl:29\\n  Test threw exception\\n  Expression:\
    \ candidate(1) == [1]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpa3q6ysw0.jl:18\\n   [2]\
    \ macro exp"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    @assert n > 0 \"Input must be a positive integer\"\n    a = [n]\n    while\
    \ n != 1\n        n = nextcollatz(n)\n        if isodd(n)\n            push!(a,\
    \ n)\n        end\n    end\n    return a\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmphb5fzheh.jl:33\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ nextcollatz not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\\
    n     @ Main /tmp/tmphb5fzheh.jl:21\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmphb5fzheh.jl:33 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmphb5fzheh.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmphb5fzheh.jl:34\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: nextcollatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmphb5fzheh.jl:21\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmphb5fzheh.jl:34 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmphb5fzheh.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmphb5fzheh.jl:35\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: nextcollatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmphb5fzheh.jl:21\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmphb5fzheh.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmphb5fzheh.jl:32\\nTest Summary:\
    \ | Pass  Error  Total\\ntest set      |    1      3      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n   \n    # Your code here...\n    \nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    curr = n\n    odd_collatz = Int64[]\n    while curr != 1\n        push!(odd_collatz,\
    \ curr)\n        if curr % 2 == 0\n            curr = curr/2\n        else\n \
    \           curr = 3*curr + 1\n        end\n    end\n    odd_collatz = unique(odd_collatz)\n\
    \    sort!(odd_collatz)\n    return odd_collatz\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpiuo92okd.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [2, 4, 5, 7, 8, 10, 11, 13, 14, 16,\
    \ 17, 20, 22, 26, 34, 40, 52] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiuo92okd.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiuo92okd.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpiuo92okd.jl:38\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [2, 4, 5, 8, 16] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiuo92okd.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiuo92okd.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpiuo92okd.jl:39\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [2, 3, 4, 5, 6, 8, 10, 12, 16] == [1, 3, 5]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiuo92okd.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiuo92okd.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpiuo92okd.jl:40\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiuo92okd.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiuo92okd.jl:36\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiuo92okd.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    #  HINT: \n    # 1. If a number is odd, then the\
    \ next term of the sequence is 3 times the previous term plus 1.\n    # 2. To\
    \ check if a number is odd, use x % 2 == 1\n    # 3. We want only the odd numbers\
    \ in the collatz sequence so exclude even numbers.\n    \n    # START ANSWER\n\
    \    # initialize empty array\n    odd_collatz = Int64[]\n    # iterate through\
    \ the collatz sequence\n    while n != 1\n        # store the odd numbers in the\
    \ array\n        if n % 2 == 1\n            push!(odd_collatz, n)\n        end\n\
    \        # move to the next term\n        if n % 2 == 0\n            n = n \xF7\
    \ 2\n        else\n            n = 3n + 1\n        end\n    end\n    # append\
    \ the last 1 to the array\n    push!(odd_collatz, 1)\n    # return the array\n\
    \    return odd_collatz\n    # END ANSWER\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnq7_qcii.jl:51\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnq7_qcii.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnq7_qcii.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpnq7_qcii.jl:52\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnq7_qcii.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnq7_qcii.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpnq7_qcii.jl:53\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnq7_qcii.jl:53 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnq7_qcii.jl:50\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnq7_qcii.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    res = Int64[]\n    cur = n\n    while true\n        res = push!(res, cur)\n\
    \        if cur == 1\n            break\n        end\n        if cur % 2 == 0\n\
    \            cur = div(cur, 2)\n        else\n            cur = 3 * cur + 1\n\
    \        end\n    end\n    return res\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpay6py5lv.jl:38\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [14, 7, 22, 11, 34, 17, 52, 26, 13,\
    \ 40, 20, 10, 5, 16, 8, 4, 2, 1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpay6py5lv.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpay6py5lv.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpay6py5lv.jl:39\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 16, 8, 4, 2, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpay6py5lv.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpay6py5lv.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpay6py5lv.jl:40\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [12, 6, 3, 10, 5, 16, 8, 4, 2, 1] == [1, 3, 5]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpay6py5lv.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpay6py5lv.jl:37\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpay6py5lv.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    seq = []\n    while n > 1\n        push!(seq, n)\n        if n % 2 ==\
    \ 0\n            n = n / 2\n        else\n            n = 3n + 1\n        end\n\
    \    end\n    push!(seq, 1)\n    sort(filter(x -> x % 2 != 0, seq))\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    n == 1 && return [1]\n    n % 2 == 0 && return get_odd_collatz(n/2)\n\
    \    return [n] + get_odd_collatz(3n+1)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp62zovdd_.jl:27\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ no method matching get_odd_collatz(::Float64)\\n  Closest candidates are:\\\
    n    get_odd_collatz(!Matched::Int64) at /tmp/tmp62zovdd_.jl:17\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp62zovdd_.jl:19\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp62zovdd_.jl:27 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp62zovdd_.jl:26\\ntest set:\
    \ Error During Test at /tmp/tmp62zovdd_.jl:28\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  MethodError: no method matching get_odd_collatz(::Float64)\\\
    n  Closest candidates are:\\n    get_odd_collatz(!Matched::Int64) at /tmp/tmp62zovdd_.jl:17\\\
    n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp62zovdd_.jl:19\\\
    n   [2] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp62zovdd_.jl:20\\n   [3]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmp62zovdd_.jl:28 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmp62zovdd_.jl:26\\ntest set:\
    \ Error During Test at /tmp/tmp62zovdd_.jl:29\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  MethodError: no method matching get_odd_collatz(::Float64)\\\
    n  Closest candidates are:\\n    get_odd_collatz(!Matched::Int64) at /tmp/tmp62zovdd_.jl:17\\\
    n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp62zovdd_.jl:19\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp62zovdd_.jl:29 [inlined]\\\
    n   [4] ma"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \n    odd_collatz = []\n    collatz = [n]\n    \n    while collatz[end]\
    \ != 1\n        if collatz[end] % 2 == 0\n            push!(collatz, div(collatz[end],\
    \ 2))\n        else\n            push!(collatz, 3*collatz[end] + 1)\n        end\n\
    \    end\n    \n    for x in collatz\n        if x % 2 != 0\n            push!(odd_collatz,\
    \ x)\n        end\n    end\n    \n    return odd_collatz\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp95kqem5w.jl:43\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp95kqem5w.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp95kqem5w.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp95kqem5w.jl:44\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp95kqem5w.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp95kqem5w.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp95kqem5w.jl:45\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp95kqem5w.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp95kqem5w.jl:42\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp95kqem5w.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz_seq = [n]\n    while n != 1\n        if n % 2 == 0\n         \
    \   n = n / 2\n        else\n            n = 3 * n + 1\n        end\n        push!(collatz_seq,\
    \ n)\n    end\n    return sort(filter(x -> x % 2 != 0, collatz_seq))\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    # Initialize a vector to hold all odd numbers in\
    \ collatz sequence\n    vector_of_odds = Int64[]\n    # Initialize a vector to\
    \ hold the collatz sequence\n    collatz_vector = Int64[]\n    # Append the first\
    \ value to collatz sequence\n    push!(collatz_vector, n)\n    while n > 1\n \
    \       # Check if n is even\n        if n % 2 == 0\n            # Update n\n\
    \            n = n / 2\n            # Append n to collatz sequence\n         \
    \   push!(collatz_vector, n)\n        else\n            # Update n\n         \
    \   n = 3 * n + 1\n            # Append n to collatz sequence\n            push!(collatz_vector,\
    \ n)\n        end\n    end\n    # Check if each element in collatz sequence is\
    \ odd\n    for i in collatz_vector\n        if i % 2 != 0\n            # Append\
    \ all odd elements to vector of odds\n            push!(vector_of_odds, i)\n \
    \       end\n    end\n    # Return a sorted list in increasing order\n    sort(vector_of_odds)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    odd_list = Int64[]\n    push!(odd_list,\
    \ n)\n    while n != 1\n        if n % 2 == 0\n            n = n / 2\n       \
    \ else\n            n = 3*n + 1\n        end\n        if n % 2 != 0\n        \
    \    push!(odd_list, n)\n        end\n    end\n    return sort(odd_list)\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphyvdu5fz.jl:40\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphyvdu5fz.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphyvdu5fz.jl:39\ntest set: Test\
    \ Failed at /tmp/tmphyvdu5fz.jl:42\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 3, 5, 12] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphyvdu5fz.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphyvdu5fz.jl:39\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphyvdu5fz.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    oddlist = []\n    while n != 1\n        if n % 2 == 1\n            push!(oddlist,\
    \ n)\n        end\n        n = n/2\n    end\n    push!(oddlist, 1)\n    sort(oddlist)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \n    list = Array{Int64}(undef,0)\n    for k in 0:n\n        \n     \
    \   if (k == 1)\n            list = append!(list,k)\n            break\n     \
    \   end\n            \n        if (k == 0)\n            next\n        end\n  \
    \      \n        if (k%2 == 0)\n            k = k/2\n            list = append!(list,k)\n\
    \        else\n            k = 3*k + 1\n            list = append!(list,k)\n \
    \       end\n        \n    end\n    list = sort(list)\n    return list\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmph7d6pp8j.jl:48\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ next not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @\
    \ Main /tmp/tmph7d6pp8j.jl:28\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmph7d6pp8j.jl:48 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmph7d6pp8j.jl:47\\ntest set:\
    \ Error During Test at /tmp/tmph7d6pp8j.jl:49\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: next not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmph7d6pp8j.jl:28\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmph7d6pp8j.jl:49 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmph7d6pp8j.jl:47\\ntest set:\
    \ Error During Test at /tmp/tmph7d6pp8j.jl:50\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: next not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmph7d6pp8j.jl:28\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmph7d6pp8j.jl:50 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmph7d6pp8j.jl:47\\ntest set:\
    \ Error During Test at /tmp/tmph7d6pp8j.jl:51\\n  Test threw exception\\n  Expression:\
    \ candidate(1) == [1]\\n  UndefVarError: next not defined\\n  Stacktrace:\\n \
    \  [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmph7d6pp8j.jl:28\\n   [2]\
    \ macro expansion\\n    "
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \n    # your code here\n    \n    return odd_collatz_numbers\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5it4r4nn.jl:28\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  UndefVarError: odd_collatz_numbers\
    \ not defined\n  Stacktrace:\n   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmp5it4r4nn.jl:21\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5it4r4nn.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5it4r4nn.jl:27\ntest set:\
    \ Error During Test at /tmp/tmp5it4r4nn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(5) == [1, 5]\n  UndefVarError: odd_collatz_numbers not defined\n \
    \ Stacktrace:\n   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmp5it4r4nn.jl:21\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5it4r4nn.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5it4r4nn.jl:27\ntest set:\
    \ Error During Test at /tmp/tmp5it4r4nn.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(12) == [1, 3, 5]\n  UndefVarError: odd_collatz_numbers not defined\n\
    \  Stacktrace:\n   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmp5it4r4nn.jl:21\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5it4r4nn.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5it4r4nn.jl:27\ntest set:\
    \ Error During Test at /tmp/tmp5it4r4nn.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(1) == [1]\n  UndefVarError: odd_collatz_numbers not defined\n  Stacktrace:\n\
    \   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmp5it4r4nn.jl:21\n   [2]\
    \ macro expansion"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5it4r4nn.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    v = []\n    while n != 1\n        if n % 2 == 1\n            push!(v,\
    \ n)\n        end\n        n = collatz(n)\n    end\n    push!(v, 1)\n    sort(v)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmplt1rd9_4.jl:33\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ collatz not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n  \
    \   @ Main /tmp/tmplt1rd9_4.jl:23\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmplt1rd9_4.jl:33 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmplt1rd9_4.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmplt1rd9_4.jl:34\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmplt1rd9_4.jl:23\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmplt1rd9_4.jl:34 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmplt1rd9_4.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmplt1rd9_4.jl:35\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmplt1rd9_4.jl:23\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmplt1rd9_4.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmplt1rd9_4.jl:32\\nTest Summary:\
    \ | Pass  Error  Total\\ntest set      |    1      3      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    sequence = [n]\n    while n != 1\n        n = (n % 2 == 0) ? n \xF7 2\
    \ : 3n + 1\n        push!(sequence, n)\n    end\n    return filter(x -> x % 2\
    \ != 0, sequence)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw3mfo8bf.jl:30\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw3mfo8bf.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw3mfo8bf.jl:29\ntest set: Test\
    \ Failed at /tmp/tmpw3mfo8bf.jl:31\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw3mfo8bf.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw3mfo8bf.jl:29\ntest set: Test\
    \ Failed at /tmp/tmpw3mfo8bf.jl:32\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpw3mfo8bf.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw3mfo8bf.jl:29\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw3mfo8bf.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    seq = [n]\n    while n != 1\n        if n % 2 == 0\n            n = div(n,\
    \ 2)\n        else\n            n = 3 * n + 1\n        end\n        push!(seq,\
    \ n)\n    end\n    return sort(filter(x -> x % 2 != 0, seq))\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \n    seq = [n]\n    while n != 1\n        if n % 2 == 0\n           \
    \ n = n / 2\n        else\n            n = 3 * n + 1\n        end\n        append!(seq,\
    \ n)\n    end\n    \n    seq_odd = [seq[i] for i in 1:length(seq) if i % 2 !=\
    \ 0]\n    return sort(seq_odd)\n    \nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpr8c82fp6.jl:38\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [2, 5, 8, 13, 14, 20, 22, 34, 52] ==\
    \ [1, 5, 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr8c82fp6.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr8c82fp6.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpr8c82fp6.jl:39\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [2, 5, 8] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr8c82fp6.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr8c82fp6.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpr8c82fp6.jl:40\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [2, 3, 5, 8, 12] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr8c82fp6.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr8c82fp6.jl:37\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr8c82fp6.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    out = [n]\n    while n != 1\n        n = n%2 ==\
    \ 0 ? n/2 : 3*n+1\n        push!(out, n)\n    end\n    out[out.%2.==1]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid syntax \"2.=\"; add space(s) to clarify\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpngkev_p5.jl:24\nin expression\
    \ starting at /tmp/tmpngkev_p5.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    collatz = [n]\n    while n != 1\n        if n %\
    \ 2 == 0\n            n = div(n, 2)\n        else\n            n = 3 * n + 1\n\
    \        end\n        push!(collatz, n)\n    end\n    odd_collatz = []\n    for\
    \ num in collatz\n        if num % 2 != 0\n            push!(odd_collatz, num)\n\
    \        end\n    end\n    return odd_collatz\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmjxj7khp.jl:41\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmjxj7khp.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmjxj7khp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmjxj7khp.jl:42\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmjxj7khp.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmjxj7khp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmjxj7khp.jl:43\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpmjxj7khp.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmjxj7khp.jl:40\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmjxj7khp.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    sequence = Collatz(n)\n  \
    \  odd_numbers = []\n    for number in sequence\n        if number % 2 != 0\n\
    \            push!(odd_numbers, number)\n        end\n    end\n    return odd_numbers\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp871joqr7.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ Collatz not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n  \
    \   @ Main /tmp/tmp871joqr7.jl:21\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp871joqr7.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp871joqr7.jl:34\\ntest set:\
    \ Error During Test at /tmp/tmp871joqr7.jl:36\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: Collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp871joqr7.jl:21\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp871joqr7.jl:36 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp871joqr7.jl:34\\ntest set:\
    \ Error During Test at /tmp/tmp871joqr7.jl:37\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: Collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp871joqr7.jl:21\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp871joqr7.jl:37 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp871joqr7.jl:34\\nTest Summary:\
    \ | Pass  Error  Total\\ntest set      |    1      3      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    list_collatz = []\n    list_odd = []\n    x = n\n    while x != 1\n  \
    \      push!(list_collatz, x)\n        if iseven(x)\n            x = x/2\n   \
    \     else\n            x = (3*x)+1\n        end\n    end\n    push!(list_collatz,\
    \ 1)\n    for y in list_collatz\n        if isodd(y)\n            push!(list_odd,\
    \ y)\n        end\n    end\n    return sort(list_odd)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz_odds = Int64[]\n    for i = 1:n\n        collatz = collatz_sequence(i)\n\
    \        for j = 1:length(collatz)\n            if collatz[j] % 2 != 0 && !(collatz[j]\
    \ in collatz_odds)\n                push!(collatz_odds, collatz[j])\n        \
    \    end\n        end\n    end\n    return sort(collatz_odds)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpelwlrkvw.jl:34\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ collatz_sequence not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\\
    n     @ Main /tmp/tmpelwlrkvw.jl:20\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpelwlrkvw.jl:34 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpelwlrkvw.jl:33\\ntest set:\
    \ Error During Test at /tmp/tmpelwlrkvw.jl:35\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: collatz_sequence not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpelwlrkvw.jl:20\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpelwlrkvw.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpelwlrkvw.jl:33\\ntest set:\
    \ Error During Test at /tmp/tmpelwlrkvw.jl:36\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: collatz_sequence not defined\\\
    n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpelwlrkvw.jl:20\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpelwlrkvw.jl:36 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpelwlrkvw.jl:33\\ntest set:\
    \ Error During Test at /tmp/tmpelwlrkvw.jl:37\\n  Test threw exception\\n  Expression:\
    \ candidate(1) == [1]\\n  UndefVarError: collatz_sequence not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    # Hint: use the function isodd(x) to check if x\
    \ is odd\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpnpr74y4_.jl:26\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpnpr74y4_.jl:20\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpnpr74y4_.jl:26 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpnpr74y4_.jl:25\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz_seq = [n]\n    while collatz_seq[end] != 1\n        if collatz_seq[end]\
    \ % 2 == 0\n            push!(collatz_seq, collatz_seq[end]/2)\n        else\n\
    \            push!(collatz_seq, 3*collatz_seq[end] + 1)\n        end\n    end\n\
    \    return sort(collatz_seq[collatz_seq .% 2 .!= 0])\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    path = []\n    while true\n\
    \        if n % 2 == 0\n            n = n/2\n        else\n            n = 3*n\
    \ + 1\n        end\n        if n == 1\n            return sort(unique(push!(path,1)))\n\
    \        end\n        push!(path,n)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4qhwjvj4.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 2, 4, 5, 7, 8, 10, 11, 13, 16, 17,\
    \ 20, 22, 26, 34, 40, 52] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4qhwjvj4.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4qhwjvj4.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp4qhwjvj4.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1, 2, 4, 8, 16] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4qhwjvj4.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4qhwjvj4.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp4qhwjvj4.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 2, 3, 4, 5, 6, 8, 10, 16] == [1, 3, 5]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4qhwjvj4.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4qhwjvj4.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4qhwjvj4.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz = [n]\n    while n != 1\n        if n % 2 == 0\n            n\
    \ = n \xF7 2\n        else\n            n = 3n + 1\n        end\n        push!(collatz,\
    \ n)\n    end\n    return filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7ao2mx9k.jl:34\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7ao2mx9k.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7ao2mx9k.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp7ao2mx9k.jl:35\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7ao2mx9k.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7ao2mx9k.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp7ao2mx9k.jl:36\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7ao2mx9k.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7ao2mx9k.jl:33\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7ao2mx9k.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \n    # YOUR CODE HERE\n    \nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpmxcyjfpa.jl:27\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpmxcyjfpa.jl:21\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpmxcyjfpa.jl:27 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpmxcyjfpa.jl:26\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    sequence = []\n    while n != 1\n        push!(sequence, n)\n        if\
    \ n % 2 == 0\n            n = div(n, 2)\n        else\n            n = 3 * n +\
    \ 1\n        end\n    end\n    push!(sequence, 1)\n    return sort(setdiff(sequence,\
    \ [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536,\
    \ 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432,\
    \ 67108864, 134217728, 268435456, 536870912, 1073741824]))\nend\n@testset \"Random\
    \ Tests\" begin\n    @testset \"Random Tests 1 to 20\" for i=1:20\n        collatz_n\
    \ = rand(1:20)\n        @test get_odd_collatz(collatz_n) == [1, 3, 7, 9, 15, 21,\
    \ 27, 31, 51, 73, 81, 85, 87, 93, 105, 113, 115, 125, 151, 165, 175, 195, 201,\
    \ 211, 231, 235, 255, 265, 285, 319, 327, 329, 335, 361, 375, 385, 407, 425, 435,\
    \ 465, 473, 485, 491, 513, 519, 523, 545, 553, 565, 577, 595, 615, 621, 627, 629,\
    \ 633, 645, 651, 669, 675, 677, 683, 693, 713, 719, 723, 727, 729, 739, 753, 755,\
    \ 765, 769, 775, 779, 787, 793, 803, 809, 811, 817, 821, 823, 829, 833, 835, 851,\
    \ 857, 865, 875, 885, 895, 901, 905, 915, 921, 923, 927, 929, 935, 941, 945, 949,\
    \ 955, 965, 975\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing separator in array expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpl7mbgact.jl:34\nin expression starting at\
    \ /tmp/tmpl7mbgact.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # your code here\n    l = Int64[]\n    push!(l, n)\n    while (n != 1)\n\
    \        if (n % 2 == 0)\n            n = n / 2\n        else\n            n =\
    \ 3 * n + 1\n        end\n        push!(l, n)\n    end\n    #println(l)\n    odd_l\
    \ = Int64[]\n    for i in l\n        if (i % 2 != 0)\n            push!(odd_l,\
    \ i)\n        end\n    end\n    return odd_l\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpf3x81scx.jl:43\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf3x81scx.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf3x81scx.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf3x81scx.jl:44\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf3x81scx.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf3x81scx.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf3x81scx.jl:45\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf3x81scx.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf3x81scx.jl:42\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf3x81scx.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # TODO: Implement\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpbmkoc2n3.jl:25\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    res = [n] # initialize with n as the first value in the collatz sequence\n\
    \    while n != 1\n        if mod(n, 2) == 0 # if even\n            n = n\xF7\
    2\n        else # if odd\n            n = 3*n + 1\n        end\n        if mod(n,\
    \ 2) != 0 # if odd\n            push!(res, n)\n        end\n    end\n    return\
    \ res\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3i5x71f9.jl:36\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [14, 7, 11, 17, 13, 5, 1] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3i5x71f9.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3i5x71f9.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp3i5x71f9.jl:37\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3i5x71f9.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3i5x71f9.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp3i5x71f9.jl:38\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [12, 3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3i5x71f9.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3i5x71f9.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3i5x71f9.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    evens = [2]\n    odds = [1]\n    for i in 3:n\n        if i % 2 == 0\n\
    \            push!(evens, i)\n        else\n            push!(odds, i)\n     \
    \   end\n    end\n    return odds\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmps6te9flu.jl:34\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 3, 5, 7, 9, 11, 13] == [1, 5, 7,\
    \ 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmps6te9flu.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps6te9flu.jl:33\ntest set: Test\
    \ Failed at /tmp/tmps6te9flu.jl:35\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1, 3, 5] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmps6te9flu.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps6te9flu.jl:33\ntest set: Test\
    \ Failed at /tmp/tmps6te9flu.jl:36\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 3, 5, 7, 9, 11] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmps6te9flu.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps6te9flu.jl:33\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps6te9flu.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    num = BigInt(n)\n    lst = BigInt[]\n    while num != 1\n        num %\
    \ 2 == 0 ? (num = num / 2) : (num = 3*num + 1)\n        if num % 2 != 0\n    \
    \        push!(lst, num)\n        end\n    end\n    sort(lst)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp4yakxhue.jl:34\\n  Expression: candidate(5)\
    \ == [1, 5]\\n   Evaluated: [1] == [1, 5]\\nStacktrace:\\n [1] macro expansion\\\
    n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmp4yakxhue.jl:34 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmp4yakxhue.jl:32\\ntest set: Test\
    \ Failed at /tmp/tmp4yakxhue.jl:36\\n  Expression: candidate(1) == [1]\\n   Evaluated:\
    \ Int64[] == [1]\\nStacktrace:\\n [1] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmp4yakxhue.jl:36 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmp4yakxhue.jl:32\\nTest Summary:\
    \ | Pass  Fail  Total\\ntest set      |    2     2      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n  # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpcu5xmmmy.jl:25\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type Vector{Int64}\\\
    n  Closest candidates are:\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpcu5xmmmy.jl:19\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpcu5xmmmy.jl:25 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpcu5xmmmy.jl:24\\ntest set:\
    \ Error During Test at /tmp/tmpcu5xmmmy.jl:26\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{Int64}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpcu5xmmmy.jl:19\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n < 1\n        throw(ArgumentError(\"n cannot be negative\"))\n   \
    \ end\n    odd_seq = []\n    while n != 1\n        push!(odd_seq, n)\n       \
    \ if n % 2 == 0\n            n = div(n, 2)\n        else\n            n = 3 *\
    \ n + 1\n        end\n    end\n    sort(odd_seq)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcsit4bf5.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [2, 4, 5, 7, 8, 10, 11, 13, 14, 16,\
    \ 17, 20, 22, 26, 34, 40, 52] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcsit4bf5.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcsit4bf5.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpcsit4bf5.jl:38\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [2, 4, 5, 8, 16] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcsit4bf5.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcsit4bf5.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpcsit4bf5.jl:39\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [2, 3, 4, 5, 6, 8, 10, 12, 16] == [1, 3, 5]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcsit4bf5.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcsit4bf5.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpcsit4bf5.jl:40\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcsit4bf5.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcsit4bf5.jl:36\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcsit4bf5.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    v = Vector{Int64}()\n    push!(v, n)\n    while n != 1\n        if n %\
    \ 2 == 0\n            n = n \xF7 2\n        else\n            n = 3n + 1\n   \
    \     end\n        push!(v, n)\n    end\n    filter(x -> x % 2 != 0, v)\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2g7c1cf0.jl:35\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2g7c1cf0.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2g7c1cf0.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp2g7c1cf0.jl:36\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2g7c1cf0.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2g7c1cf0.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp2g7c1cf0.jl:37\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2g7c1cf0.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2g7c1cf0.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2g7c1cf0.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    while n != 1\n        n = n % 2 == 0 ? n / 2 : n * 3 + 1\n    end\n  \
    \  return [1]\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpajhd4o0r.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpajhd4o0r.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpajhd4o0r.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpajhd4o0r.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpajhd4o0r.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpajhd4o0r.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpajhd4o0r.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpajhd4o0r.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpajhd4o0r.jl:27\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpajhd4o0r.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz_seq = []\n    collatz_odd = []\n    push!(collatz_seq, n)\n  \
    \  while n != 1\n        if n % 2 == 0\n            n = n/2\n        else \n \
    \           n = (3*n) + 1\n        end\n        push!(collatz_seq, n)\n    end\n\
    \    for i in collatz_seq\n        if i % 2 != 0\n            push!(collatz_odd,\
    \ i)\n        end\n    end\n    return collatz_odd\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw6reubcc.jl:41\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw6reubcc.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw6reubcc.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpw6reubcc.jl:42\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw6reubcc.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw6reubcc.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpw6reubcc.jl:43\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpw6reubcc.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw6reubcc.jl:40\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw6reubcc.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_numbers = [n]\n    if n == 1\n        return odd_numbers\n    end\n\
    \    if n % 2 == 0\n        n = n/2\n    else\n        n = (3*n)+1\n    end\n\
    \    push!(odd_numbers, get_odd_collatz(n))\n    return odd_numbers\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmplnd016bl.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ no method matching get_odd_collatz(::Float64)\\n  Closest candidates are:\\\
    n    get_odd_collatz(!Matched::Int64) at /tmp/tmplnd016bl.jl:17\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmplnd016bl.jl:27\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmplnd016bl.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmplnd016bl.jl:34\\ntest set:\
    \ Error During Test at /tmp/tmplnd016bl.jl:36\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  MethodError: no method matching get_odd_collatz(::Float64)\\\
    n  Closest candidates are:\\n    get_odd_collatz(!Matched::Int64) at /tmp/tmplnd016bl.jl:17\\\
    n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64) (repeats 2 times)\\n     @ Main\
    \ /tmp/tmplnd016bl.jl:27\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmplnd016bl.jl:36 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmplnd016bl.jl:34\\ntest set:\
    \ Error During Test at /tmp/tmplnd016bl.jl:37\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  MethodError: no method matching get_odd_collatz(::Float64)\\\
    n  Closest candidates are:\\n    get_odd_collatz(!Matched::Int64) at /tmp/tmplnd016bl.jl:17\\\
    n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmplnd016bl.jl:27\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmplnd016bl.jl:37 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/sh"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \n    # create the empty list\n    result = []\n    \n    # get collatz\
    \ sequence\n    sequence = collatz(n)\n    \n    # filter odd numbers in sequence\n\
    \    for i in sequence\n        if i % 2 != 0\n            push!(result, i)\n\
    \        end\n    end\n    \n    # sort result in increasing order\n    sort!(result)\n\
    \    \n    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpk00lbihb.jl:42\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ collatz not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n  \
    \   @ Main /tmp/tmpk00lbihb.jl:23\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpk00lbihb.jl:42 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpk00lbihb.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmpk00lbihb.jl:43\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpk00lbihb.jl:23\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpk00lbihb.jl:43 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpk00lbihb.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmpk00lbihb.jl:44\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpk00lbihb.jl:23\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpk00lbihb.jl:44 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpk00lbihb.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmpk00lbihb.jl:45\\n  Test threw exception\\n  Expression:\
    \ candidate(1) == [1]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpk00lbihb.jl:23\\n   [2]\
    \ macro exp"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n \n    seq = [n]\n    while n > 1\n        if n % 2 == 0\n            n =\
    \ div(n, 2)\n        else\n            n = 3n + 1\n        end\n        push!(seq,\
    \ n)\n    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpncjckn8u.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpncjckn8u.jl:1\n\
    in expression starting at /tmp/tmpncjckn8u.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    t = n\n    l = zeros(Int64,0)\n    while t != 1\n        if t % 2 == 1\n\
    \            push!(l,t)\n        end\n        t = next_collatz(t)\n    end\n \
    \   push!(l,1)\n    sort(l)\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp6sbmi_bk.jl:34\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  UndefVarError: next_collatz\
    \ not defined\n  Stacktrace:\n   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmp6sbmi_bk.jl:24\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6sbmi_bk.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6sbmi_bk.jl:33\ntest set:\
    \ Error During Test at /tmp/tmp6sbmi_bk.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(5) == [1, 5]\n  UndefVarError: next_collatz not defined\n  Stacktrace:\n\
    \   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmp6sbmi_bk.jl:24\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6sbmi_bk.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6sbmi_bk.jl:33\ntest set:\
    \ Error During Test at /tmp/tmp6sbmi_bk.jl:36\n  Test threw exception\n  Expression:\
    \ candidate(12) == [1, 3, 5]\n  UndefVarError: next_collatz not defined\n  Stacktrace:\n\
    \   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmp6sbmi_bk.jl:24\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6sbmi_bk.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6sbmi_bk.jl:33\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    1      3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6sbmi_bk.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    odd_nums = []\n    while n > 1\n        push!(odd_nums,\
    \ n)\n        if n % 2 == 0\n            n = n/2\n        else\n            n\
    \ = 3*n + 1\n        end\n    end\n    push!(odd_nums, n)\n    return odd_nums\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpow2tenjj.jl:36\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [14, 7, 22, 11, 34, 17, 52, 26, 13,\
    \ 40, 20, 10, 5, 16, 8, 4, 2, 1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpow2tenjj.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpow2tenjj.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpow2tenjj.jl:37\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 16, 8, 4, 2, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpow2tenjj.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpow2tenjj.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpow2tenjj.jl:38\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [12, 6, 3, 10, 5, 16, 8, 4, 2, 1] == [1, 3, 5]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpow2tenjj.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpow2tenjj.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpow2tenjj.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\n \n@test get_odd_collatz(5) == [1, 5]\n \nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @test not defined\nin expression starting\
    \ at /tmp/tmp9x4wsfof.jl:21\nin expression starting at /tmp/tmp9x4wsfof.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    counter = 0\n    result = []\n    collatz_sequence = Int64[]\n    for\
    \ i in 1:n\n        if isodd(i)\n            counter += 1\n            push!(collatz_sequence,\
    \ i)\n        end\n    end\n    for j in collatz_sequence\n        push!(result,\
    \ collatz(j))\n    end\n    sort(unique(flatten(result)))\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpj15__4u5.jl:37\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ collatz not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n  \
    \   @ Main /tmp/tmpj15__4u5.jl:28\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpj15__4u5.jl:37 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpj15__4u5.jl:36\\ntest set:\
    \ Error During Test at /tmp/tmpj15__4u5.jl:38\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpj15__4u5.jl:28\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpj15__4u5.jl:38 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpj15__4u5.jl:36\\ntest set:\
    \ Error During Test at /tmp/tmpj15__4u5.jl:39\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpj15__4u5.jl:28\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpj15__4u5.jl:39 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpj15__4u5.jl:36\\ntest set:\
    \ Error During Test at /tmp/tmpj15__4u5.jl:40\\n  Test threw exception\\n  Expression:\
    \ candidate(1) == [1]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpj15__4u5.jl:28\\n   [2]\
    \ macro exp"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz = [n]\n    while collatz[end] != 1\n        if collatz[end] %\
    \ 2 == 0\n            collatz = [collatz; collatz[end] / 2]\n        else\n  \
    \          collatz = [collatz; 3 * collatz[end] + 1]\n        end\n    end\n \
    \   return [x for x in collatz if x % 2 != 0]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpw1s54e_3.jl:33\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7,\
    \ 11, 13, 17]\\nStacktrace:\\n [1] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpw1s54e_3.jl:33 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpw1s54e_3.jl:32\\ntest set: Test\
    \ Failed at /tmp/tmpw1s54e_3.jl:34\\n  Expression: candidate(5) == [1, 5]\\n \
    \  Evaluated: [5, 1] == [1, 5]\\nStacktrace:\\n [1] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpw1s54e_3.jl:34 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpw1s54e_3.jl:32\\ntest set: Test\
    \ Failed at /tmp/tmpw1s54e_3.jl:35\\n  Expression: candidate(12) == [1, 3, 5]\\\
    n   Evaluated: [3, 5, 1] == [1, 3, 5]\\nStacktrace:\\n [1] macro expansion\\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpw1s54e_3.jl:35 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpw1s54e_3.jl:32\\nTest Summary:\
    \ | Pass  Fail  Total\\ntest set      |    1     3      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    seq = []\n    while n > 1\n        if n % 2 == 1\n            push!(seq,\
    \ n)\n        end\n        n = (n % 2 == 0) ? (n/2) : (3*n + 1)\n    end\n   \
    \ push!(seq, 1)\n    sort(seq)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # base case \n    if n == 1\n        return [1]\n    end\n    \n    #\
    \ odd\n    if n % 2 == 1\n        return [n]\n    else\n        return get_odd_collatz(n/2)\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpg755a2le.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ no method matching get_odd_collatz(::Float64)\\n  Closest candidates are:\\\
    n    get_odd_collatz(!Matched::Int64) at /tmp/tmpg755a2le.jl:17\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpg755a2le.jl:27\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpg755a2le.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpg755a2le.jl:34\\ntest set:\
    \ Test Failed at /tmp/tmpg755a2le.jl:36\\n  Expression: candidate(5) == [1, 5]\\\
    n   Evaluated: [5] == [1, 5]'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    end\n \nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpamp461tp.jl:25\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz(x) = x == 1 ? [] : [x] * push!(collatz(x % 2 == 0 ? x \xF7 2 :\
    \ 3x + 1), x)\n    return sort(get_odd_collatz(n))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    res = Array(Int64,0)\n    while n > 1\n        push!(res,n)\n        if\
    \ mod(n,2) == 0\n            n = div(n,2)\n        else\n            n = 3*n +\
    \ 1\n        end\n    end\n    push!(res,1)\n    return sort(res[res .% 2 .!=\
    \ 0])\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpqj_5lmlg.jl:35\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ no method matching Array(::Type{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    Array(!Matched::LinearAlgebra.UniformScaling, ::Integer, !Matched::Integer)\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:496\\\
    n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpqj_5lmlg.jl:18\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpqj_5lmlg.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpqj_5lmlg.jl:34\\ntest set:\
    \ Error During Test at /tmp/tmpqj_5lmlg.jl:36\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  MethodError: no method matching Array(::Type{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    Array(!Matched::LinearAlgebra.UniformScaling,\
    \ ::Integer, !Matched::Integer) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:496\\\
    n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpqj_5lmlg.jl:18\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpqj_5lmlg.jl:36 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpqj_5lmlg.jl:34\\ntest set:\
    \ Error During Test at /tmp/tmpqj_5lmlg.jl:37\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  MethodError: no method matching Array(::Type{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    Array(!Matched::LinearAlgebra.UniformScaling,\
    \ ::Integer, !Matched::Integer) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:496\\"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz_list = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = Int64(n/2)\n        else\n  \
    \          n = Int64(3*n + 1)\n        end\n        push!(collatz_list, n)\n \
    \   end\n    return filter(x -> x % 2 != 0, collatz_list)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnxwz8ww5.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnxwz8ww5.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnxwz8ww5.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpnxwz8ww5.jl:38\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnxwz8ww5.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnxwz8ww5.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpnxwz8ww5.jl:39\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnxwz8ww5.jl:39 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnxwz8ww5.jl:36\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnxwz8ww5.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    odd_sequence = []\n    while\
    \ n != 1\n        isodd(n) && push!(odd_sequence, n)\n        n % 2 == 0 && (n\
    \ = n \xF7 2) || (n = 3n + 1)\n    end\n    return sort(odd_sequence)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp1wyaipvz.jl:33\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  TypeError:\
    \ non-boolean (Int64) used in boolean context\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\\
    n     @ Main /tmp/tmp1wyaipvz.jl:24\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp1wyaipvz.jl:33 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp1wyaipvz.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmp1wyaipvz.jl:34\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  TypeError: non-boolean (Int64) used in boolean context\\\
    n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp1wyaipvz.jl:24\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp1wyaipvz.jl:34 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp1wyaipvz.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmp1wyaipvz.jl:35\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  TypeError: non-boolean (Int64) used in boolean\
    \ context\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp1wyaipvz.jl:24\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp1wyaipvz.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp1wyaipvz.jl:32\\nTest Summary:\
    \ | Pass  Error  Total\\ntest set      |    1      3      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    CollatzSeq = [n]\n    while n > 1\n        n = n%2 == 0 ? n/2 : 3*n +\
    \ 1\n        push!(CollatzSeq, n)\n    end\n    @assert 1 in CollatzSeq[end]\n\
    \    filter(x -> x%2 != 0, CollatzSeq)\nend\n@assert get_odd_collatz(5) == [1,\
    \ 5]\n@assert get_odd_collatz(6) == [1]\n@assert get_odd_collatz(14) == [1, 7]\n\
    \ \nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: AssertionError: get_odd_collatz(5) == [1, 5]\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpkmu6ek1v.jl:26\nin expression starting at\
    \ /tmp/tmpkmu6ek1v.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp6jxkhgc4.jl:25\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n==1\n        return [1]\n    end\n    if n%2==0\n        return get_odd_collatz(n/2)\n\
    \    else\n        return vcat(get_odd_collatz(3*n+1),[n])\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp9xde8vgu.jl:32\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ no method matching get_odd_collatz(::Float64)\\n  Closest candidates are:\\\
    n    get_odd_collatz(!Matched::Int64) at /tmp/tmp9xde8vgu.jl:17\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp9xde8vgu.jl:22\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp9xde8vgu.jl:32 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp9xde8vgu.jl:31\\ntest set:\
    \ Error During Test at /tmp/tmp9xde8vgu.jl:33\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  MethodError: no method matching get_odd_collatz(::Float64)\\\
    n  Closest candidates are:\\n    get_odd_collatz(!Matched::Int64) at /tmp/tmp9xde8vgu.jl:17\\\
    n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp9xde8vgu.jl:22\\\
    n   [2] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp9xde8vgu.jl:24\\n   [3]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmp9xde8vgu.jl:33 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmp9xde8vgu.jl:31\\ntest set:\
    \ Error During Test at /tmp/tmp9xde8vgu.jl:34\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  MethodError: no method matching get_odd_collatz(::Float64)\\\
    n  Closest candidates are:\\n    get_odd_collatz(!Matched::Int64) at /tmp/tmp9xde8vgu.jl:17\\\
    n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp9xde8vgu.jl:22\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp9xde8vgu.jl:34 [inlined]\\\
    n   [4] ma"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    list = Vector{Int64}()\n    push!(list,n)\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else \n      \
    \      n = 3 * n + 1\n        end\n        if n % 2 != 0\n            push!(list,n)\n\
    \        end\n    end\n    return list\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3umx91ey.jl:38\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [14, 7, 11, 17, 13, 5, 1] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3umx91ey.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3umx91ey.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp3umx91ey.jl:39\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3umx91ey.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3umx91ey.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp3umx91ey.jl:40\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [12, 3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3umx91ey.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3umx91ey.jl:37\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3umx91ey.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    seq = Vector{Int64}(undef,\
    \ 0)\n    while n != 1\n        push!(seq, n)\n        if n % 2 == 0\n       \
    \     n = n / 2\n        else\n            n = 3 * n + 1\n        end\n    end\n\
    \    push!(seq, 1)\n    filter(x -> x % 2 != 0, seq)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjkd7dn2r.jl:38\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjkd7dn2r.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjkd7dn2r.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpjkd7dn2r.jl:39\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjkd7dn2r.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjkd7dn2r.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpjkd7dn2r.jl:40\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpjkd7dn2r.jl:40 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjkd7dn2r.jl:37\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjkd7dn2r.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n  # start with any positive integer n\n  vals = [n]\n  # calculate the collatz\
    \ of each consecutive number and add to vector\n  while (n != 1)\n    n = collatz(n)\n\
    \    push!(vals, n)\n  end\n  #filter out even numbers\n  return filter(x -> x\
    \ % 2 != 0, vals)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpoo5fxqkn.jl:33\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ collatz not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n  \
    \   @ Main /tmp/tmpoo5fxqkn.jl:22\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpoo5fxqkn.jl:33 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpoo5fxqkn.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmpoo5fxqkn.jl:34\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpoo5fxqkn.jl:22\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpoo5fxqkn.jl:34 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpoo5fxqkn.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmpoo5fxqkn.jl:35\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpoo5fxqkn.jl:22\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpoo5fxqkn.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpoo5fxqkn.jl:32\\nTest Summary:\
    \ | Pass  Error  Total\\ntest set      |    1      3      4\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    c = collatz(n)\n    remove = Set(c[c .% 2 .== 0])\n    return setdiff(c,\
    \ remove)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpz62s_c2i.jl:27\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ collatz not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n  \
    \   @ Main /tmp/tmpz62s_c2i.jl:18\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpz62s_c2i.jl:27 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpz62s_c2i.jl:26\\ntest set:\
    \ Error During Test at /tmp/tmpz62s_c2i.jl:28\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpz62s_c2i.jl:18\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpz62s_c2i.jl:28 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpz62s_c2i.jl:26\\ntest set:\
    \ Error During Test at /tmp/tmpz62s_c2i.jl:29\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpz62s_c2i.jl:18\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpz62s_c2i.jl:29 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpz62s_c2i.jl:26\\ntest set:\
    \ Error During Test at /tmp/tmpz62s_c2i.jl:30\\n  Test threw exception\\n  Expression:\
    \ candidate(1) == [1]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmpz62s_c2i.jl:18\\n   [2]\
    \ macro exp"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\n@assert get_odd_collatz(1) == [1]\n@assert get_odd_collatz(5)\
    \ == [1, 5]\n@assert get_odd_collatz(7) == [1, 7]\n@assert get_odd_collatz(8)\
    \ == [1]\n@assert get_odd_collatz(10) == [1, 5]\n@assert get_odd_collatz(11) ==\
    \ [1, 11]\n@assert get_odd_collatz(50000000) == [1, 50000000]\n \nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: None
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    seq = [n]\n    while n != 1\n        n = (n % 2 == 0) ? n / 2 : 3 * n\
    \ + 1\n        push!(seq, n)\n    end\n    return sort(filter(x -> x % 2 != 0,\
    \ seq))\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n\
    \ != 1\n        if n % 2 == 0\n            n = div(n, 2)\n        else\n     \
    \       n = 3*n + 1\n        end\n        push!(collatz, n)\n    end\n    return\
    \ collatz[collatz .% 2 .!= 0]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpeiezlab8.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeiezlab8.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeiezlab8.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpeiezlab8.jl:38\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeiezlab8.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeiezlab8.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpeiezlab8.jl:39\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpeiezlab8.jl:39 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeiezlab8.jl:36\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeiezlab8.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    a = []\n    while n != 1\n        push!(a, n)\n        if n % 2 == 0\n\
    \            n = div(n, 2)\n        else\n            n = 3*n + 1\n        end\n\
    \    end\n    push!(a, n)\n    return a[a .% 2 .!= 0]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpou170tmn.jl:35\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpou170tmn.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpou170tmn.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpou170tmn.jl:36\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpou170tmn.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpou170tmn.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpou170tmn.jl:37\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpou170tmn.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpou170tmn.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpou170tmn.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmps7_15y4b.jl:26\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    l = [n]\n    while n != 1\n        push!(l, n = (n % 2 == 0 ? div(n, 2)\
    \ : 3n + 1))\n    end\n    [odd for odd in l if odd % 2 != 0]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0mcywvw1.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0mcywvw1.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0mcywvw1.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp0mcywvw1.jl:27\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0mcywvw1.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0mcywvw1.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp0mcywvw1.jl:28\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0mcywvw1.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0mcywvw1.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp0mcywvw1.jl:29\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0mcywvw1.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0mcywvw1.jl:25\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0mcywvw1.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \"\"\"\n    There is a problem with the descrition of the problem and\
    \ the solution given by me. This solution gets all the odd numbers, not just the\
    \ first one.\n    \"\"\"\n    # using a vector is the fastest solution, because\
    \ the length of the list can be guessed in advance.\n    odd_numbers = Vector{Int64}(n)\n\
    \    odd_index = 1\n    odd_numbers[odd_index] = n\n    while n != 1\n       \
    \ # The Collatz function is not a function, but more of a constructor\n      \
    \  n = collatz(n)\n        # If the n is odd, push it to the list\n        if\
    \ n % 2 != 0\n            odd_index += 1\n            odd_numbers[odd_index] =\
    \ n\n        end\n    end\n    return odd_numbers[1:odd_index]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp1w73rmho.jl:41\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ no method matching Vector{Int64}(::Int64)\\n  Closest candidates are:\\n   \
    \ Vector{T}() where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\\\
    n    Array{T, N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\\\
    n    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp1w73rmho.jl:22\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp1w73rmho.jl:41 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp1w73rmho.jl:40\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \"\"\"\n    Input:\n        n: a positive integer\n    Output:\n     \
    \   A sorted list that has the odd numbers in collatz sequence.\n    \"\"\"\n\
    \    # YOUR CODE HERE\n    collatz = 0\n    result = Array{Int64}(0)\n    while\
    \ collatz != 1\n        if collatz == 0\n            collatz = n\n        end\n\
    \        if collatz % 2 == 0\n            collatz = collatz / 2\n        else\n\
    \            collatz = 3 * collatz + 1\n        end\n        if collatz % 2 !=\
    \ 0\n            push!(result, collatz)\n        end\n    end\n    push!(result,\
    \ collatz)\n    sort(result)\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp3lyjoh_w.jl:48\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ no method matching (Array{Int64})(::Int64)\\n  Closest candidates are:\\n  \
    \  (Array{T})(!Matched::LinearAlgebra.AbstractQ) where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/qr.jl:563\\\
    n    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Tuple{Int64,\
    \ Int64}) where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:494\\\
    n    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Integer, !Matched::Integer)\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:495\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp3lyjoh_w.jl:26\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp3lyjoh_w.jl:48 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp3lyjoh_w.jl:47\\ntest set:\
    \ Error During Test at /tmp/tmp3lyjoh_w.jl:49\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  MethodError: no method matching (Array{Int64})(::Int64)\\\
    n  Closest candidates are:\\n    (Array{T})(!Matched::LinearAlgebra.AbstractQ)\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/qr.jl:563\\\
    n    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Tuple{Int64,\
    \ Int64}) where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:494\\\
    n    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Integer, !Matched::Integer)\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:495\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmp3lyjoh_w.jl:26\\\
    n   [2] macro expansion\\n   "
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n < 1\n        error(\"n must be positive\")\n    end\n    list = []\n\
    \    while n != 1\n        isodd(n) && push!(list, n)\n        n = collatz(n)\n\
    \    end\n    push!(list, 1)\n    sort(list)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmph2amfjro.jl:34\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  UndefVarError:\
    \ collatz not defined\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n  \
    \   @ Main /tmp/tmph2amfjro.jl:24\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmph2amfjro.jl:34 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmph2amfjro.jl:33\\ntest set:\
    \ Error During Test at /tmp/tmph2amfjro.jl:35\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmph2amfjro.jl:24\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmph2amfjro.jl:35 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmph2amfjro.jl:33\\ntest set:\
    \ Error During Test at /tmp/tmph2amfjro.jl:36\\n  Test threw exception\\n  Expression:\
    \ candidate(12) == [1, 3, 5]\\n  UndefVarError: collatz not defined\\n  Stacktrace:\\\
    n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmph2amfjro.jl:24\\n   [2]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmph2amfjro.jl:36 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmph2amfjro.jl:33\\nTest Summary:\
    \ | Pass  Error  Total\\ntest set      |    1      3      4\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 3 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmph2amfjro.jl:31\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # Your code here\nend\n# Test Case\n@testset \"Collatz Test Cases\" begin\n\
    \    @test get_odd_collatz(3) == [1, 3]\n    @test get_odd_collatz(5) == [1, 5]\n\
    \    @test get_odd_collatz(100) == [1, 3, 5, 17, 19, 41, 95, 97]\nend\n \nusing\
    \ Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @testset not defined\nin expression starting\
    \ at /tmp/tmpyal0uwsv.jl:21\nin expression starting at /tmp/tmpyal0uwsv.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n < 1\n        return throw(ArgumentError(\"n should be positive integer\"\
    ))\n    end\n    odds = Int64[]\n    while n != 1\n        push!(odds, n)\n  \
    \      if n % 2 == 0\n            n = div(n, 2)\n        else\n            n =\
    \ n * 3 + 1\n        end\n    end\n    push!(odds, 1)\n    return odds\nend\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpchqfjde4.jl:38\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [14, 7, 22, 11, 34, 17, 52, 26, 13,\
    \ 40, 20, 10, 5, 16, 8, 4, 2, 1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpchqfjde4.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpchqfjde4.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpchqfjde4.jl:39\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 16, 8, 4, 2, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpchqfjde4.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpchqfjde4.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpchqfjde4.jl:40\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [12, 6, 3, 10, 5, 16, 8, 4, 2, 1] == [1, 3, 5]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpchqfjde4.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpchqfjde4.jl:37\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpchqfjde4.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    sequence = Int64[]\n    while n != 1\n        if n%2 == 1\n          \
    \  push!(sequence, n)\n        end\n        n = collatz(n)\n    end\n    push!(sequence,\
    \ n)\n    return sort(sequence)\nend\n@testset \"get_odd_collatz\" begin\n   \
    \ @test get_odd_collatz(5) == [1, 5]\n    @test get_odd_collatz(9) == [1, 9]\n\
    \    @test get_odd_collatz(11) == [1, 11]\n    @test get_odd_collatz(29) == [1,\
    \ 29]\n    @test get_odd_collatz(3) == [1, 3]\n    @test get_odd_collatz(2) ==\
    \ [1]\n    @test get_odd_collatz(1) == [1]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @testset not defined\nin expression starting\
    \ at /tmp/tmpjzjzbsxw.jl:28\nin expression starting at /tmp/tmpjzjzbsxw.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # start with any positive integer n. Then each term is obtained from the\
    \ previous term as follows: \n    # if the previous term is even, the next term\
    \ is one half of the previous term. \n    # If the previous term is odd, the next\
    \ term is 3 times the previous term plus 1.\n    # The conjecture is that no matter\
    \ what value of n, the sequence will always reach 1.\n    # n = positive integer\n\
    \    # function to return the odd numbers in collatz sequence.\n    # Note: returned\
    \ list sorted in increasing order.\n    # Example:\n    # get_odd_collatz(5) returns\
    \ [1, 5] \n    # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\n    odd_list = []\n    while n != 1\n        if\
    \ n % 2 == 0\n            n = n \xF7 2\n        else\n            n = 3n + 1\n\
    \            push!(odd_list, n)\n        end\n    end\n    push!(odd_list, 1)\n\
    \    sort(odd_list)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0pp3yvlu.jl:45\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 16, 22, 34, 40, 52] == [1, 5, 7,\
    \ 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0pp3yvlu.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0pp3yvlu.jl:44\ntest set: Test\
    \ Failed at /tmp/tmp0pp3yvlu.jl:46\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1, 16] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0pp3yvlu.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0pp3yvlu.jl:44\ntest set: Test\
    \ Failed at /tmp/tmp0pp3yvlu.jl:47\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 10, 16] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n \
    \  @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0pp3yvlu.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0pp3yvlu.jl:44\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0pp3yvlu.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    A = Int64[]\n    while n > 1\n        push!(A, n)\n        if n % 2 ==\
    \ 0\n            n = n \xF7 2\n        else\n            n = 3n + 1\n        end\n\
    \    end\n    push!(A, 1)\n    return A[A .% 2 .!= 0]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpl52u46bh.jl:35\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpl52u46bh.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpl52u46bh.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpl52u46bh.jl:36\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpl52u46bh.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpl52u46bh.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpl52u46bh.jl:37\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpl52u46bh.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpl52u46bh.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl52u46bh.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    ######################################################################\n\
    \    # TODO: create a result list                                         #\n\
    \    ######################################################################\n\
    \    result = []\n    ######################################################################\n\
    \    # TODO:                                                              #\n\
    \    ######################################################################\n\
    \    push!(result, n)\n    while n != 1\n        if n % 2 == 0\n            n\
    \ = n/2\n        else\n            n = 3*n + 1\n        end\n        if n % 2\
    \ != 0\n            push!(result, n)\n        end\n    end\n    ######################################################################\n\
    \    #                          END OF YOUR CODE                          #\n\
    \    ######################################################################\n\
    \    return result\nend\n \nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw2kjfy7a.jl:47\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [14, 7, 11, 17, 13, 5, 1] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw2kjfy7a.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw2kjfy7a.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpw2kjfy7a.jl:48\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw2kjfy7a.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw2kjfy7a.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpw2kjfy7a.jl:49\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [12, 3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw2kjfy7a.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw2kjfy7a.jl:46\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw2kjfy7a.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    list = []\n    push!(list, n)\n    while n > 1\n        if n % 2 == 0\n\
    \            n = n/2\n        else\n            n = 3n + 1\n        end\n    \
    \    push!(list, n)\n    end\n    odd_list = []\n    for num in list\n       \
    \ if num % 2 != 0\n            push!(odd_list, num)\n        end\n    end\n  \
    \  sort(odd_list)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n < 1 throw(DomainError()) end\n    v = Array{Int64}(0)\n    while\
    \ n != 1\n        if isodd(n)\n            push!(v, n)\n        end\n        n\
    \ = n/2\n    end\n    return sort(v)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmppwjuazar.jl:33\\n  Test threw\
    \ exception\\n  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\\n  MethodError:\
    \ no method matching (Array{Int64})(::Int64)\\n  Closest candidates are:\\n  \
    \  (Array{T})(!Matched::LinearAlgebra.AbstractQ) where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/qr.jl:563\\\
    n    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Tuple{Int64,\
    \ Int64}) where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:494\\\
    n    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Integer, !Matched::Integer)\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:495\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmppwjuazar.jl:19\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmppwjuazar.jl:33 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmppwjuazar.jl:32\\ntest set:\
    \ Error During Test at /tmp/tmppwjuazar.jl:34\\n  Test threw exception\\n  Expression:\
    \ candidate(5) == [1, 5]\\n  MethodError: no method matching (Array{Int64})(::Int64)\\\
    n  Closest candidates are:\\n    (Array{T})(!Matched::LinearAlgebra.AbstractQ)\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/qr.jl:563\\\
    n    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Tuple{Int64,\
    \ Int64}) where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:494\\\
    n    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Integer, !Matched::Integer)\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:495\\\
    n    ...\\n  Stacktrace:\\n   [1] get_odd_collatz(n::Int64)\\n     @ Main /tmp/tmppwjuazar.jl:19\\\
    n   [2] macro expansion\\n   "
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_numbers = Vector{Int64}()\n    collatz_sequence = Vector{Int64}()\n\
    \    push!(collatz_sequence, n)\n    while n != 1\n        if n % 2 == 0\n   \
    \         n = n / 2\n        else\n            n = 3 * n + 1\n        end\n  \
    \      push!(collatz_sequence, n)\n    end\n    for i in collatz_sequence\n  \
    \      if i % 2 != 0\n            push!(odd_numbers, i)\n        end\n    end\n\
    \    return odd_numbers\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbqu7vlqh.jl:41\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbqu7vlqh.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbqu7vlqh.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbqu7vlqh.jl:42\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbqu7vlqh.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbqu7vlqh.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbqu7vlqh.jl:43\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbqu7vlqh.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbqu7vlqh.jl:40\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbqu7vlqh.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \n    # Check whether input is valid.\n    if n <= 0\n        println(\"\
    Error! Input is not a positive integer!\")\n        return []\n    end\n    \n\
    \    num = n\n    odd_collatz = Int64[]\n    while num != 1\n        if isodd(num)\n\
    \            push!(odd_collatz, num)\n        end\n        if iseven(num)\n  \
    \          num = num/2\n        elseif isodd(num)\n            num = 3*num + 1\n\
    \        end\n    end\n    push!(odd_collatz, 1)\n    return sort(odd_collatz)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    sequence = []\n    while n != 1\n        push!(sequence, n)\n        if\
    \ iseven(n)\n            n = n / 2\n        else\n            n = 3 * n + 1\n\
    \        end\n    end\n    push!(sequence, 1)\n    return filter(!iseven, sequence)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqfu5ujr_.jl:35\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqfu5ujr_.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqfu5ujr_.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpqfu5ujr_.jl:36\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqfu5ujr_.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqfu5ujr_.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpqfu5ujr_.jl:37\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqfu5ujr_.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqfu5ujr_.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqfu5ujr_.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpneuhy_7x.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpneuhy_7x.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpneuhy_7x.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpneuhy_7x.jl:27\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpneuhy_7x.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpneuhy_7x.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpneuhy_7x.jl:28\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpneuhy_7x.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpneuhy_7x.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpneuhy_7x.jl:29\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpneuhy_7x.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpneuhy_7x.jl:25\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpneuhy_7x.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz_sequence = [n]\n    i = 1\n    while n != 1\n        if n % 2\
    \ == 0\n            n = n / 2\n        else\n            n = 3 * n + 1\n     \
    \   end\n        collatz_sequence = [collatz_sequence; n]\n    end\n    odd_numbers\
    \ = [collatz_sequence[i] for i in 1:length(collatz_sequence) if isodd(collatz_sequence[i])]\n\
    \    return odd_numbers\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpqk3cj6se.jl:36\\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7,\
    \ 11, 13, 17]\\nStacktrace:\\n [1] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpqk3cj6se.jl:36 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpqk3cj6se.jl:35\\ntest set: Test\
    \ Failed at /tmp/tmpqk3cj6se.jl:37\\n  Expression: candidate(5) == [1, 5]\\n \
    \  Evaluated: [5, 1] == [1, 5]\\nStacktrace:\\n [1] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpqk3cj6se.jl:37 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpqk3cj6se.jl:35\\ntest set: Test\
    \ Failed at /tmp/tmpqk3cj6se.jl:38\\n  Expression: candidate(12) == [1, 3, 5]\\\
    n   Evaluated: [3, 5, 1] == [1, 3, 5]\\nStacktrace:\\n [1] macro expansion\\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpqk3cj6se.jl:38 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpqk3cj6se.jl:35\\nTest Summary:\
    \ | Pass  Fail  Total\\ntest set      |    1     3      4\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \n    result = [1]\n    next_num = n\n    \n    while next_num != 1 \n\
    \        if next_num % 2 == 0\n            next_num = Int64(next_num / 2)\n  \
    \      else\n            next_num = 3 * next_num + 1\n            push!(result,\
    \ next_num)\n        end\n    end\n    return sort(result)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5,\
    \ 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1,\
    \ 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0bpxqdfw.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 16, 22, 34, 40, 52] == [1, 5, 7,\
    \ 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0bpxqdfw.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0bpxqdfw.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp0bpxqdfw.jl:38\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1, 16] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0bpxqdfw.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0bpxqdfw.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp0bpxqdfw.jl:39\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 10, 16] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n \
    \  @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0bpxqdfw.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0bpxqdfw.jl:36\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0bpxqdfw.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    odd_collatz = [n]\n    while n > 1\n        if n % 2 == 0\n          \
    \  n = n/2\n        else\n            n = 3n + 1\n        end\n        if n %\
    \ 2 != 0\n            push!(odd_collatz, n)\n        end\n    end\n    return\
    \ odd_collatz\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwbrwev3q.jl:36\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [14, 7, 11, 17, 13, 5, 1] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwbrwev3q.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwbrwev3q.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpwbrwev3q.jl:37\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwbrwev3q.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwbrwev3q.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpwbrwev3q.jl:38\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [12, 3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwbrwev3q.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwbrwev3q.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwbrwev3q.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # Your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmper0r__mc.jl:26\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmper0r__mc.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmper0r__mc.jl:25\ntest set: Test\
    \ Failed at /tmp/tmper0r__mc.jl:27\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmper0r__mc.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmper0r__mc.jl:25\ntest set: Test\
    \ Failed at /tmp/tmper0r__mc.jl:28\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmper0r__mc.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmper0r__mc.jl:25\ntest set: Test\
    \ Failed at /tmp/tmper0r__mc.jl:29\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmper0r__mc.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmper0r__mc.jl:25\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmper0r__mc.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \n    if n < 1\n        println(\"n must be a positive integer.\")\n \
    \       return 0\n    end\n    seq = [n]\n    while seq[end] != 1\n        if\
    \ seq[end] % 2 == 0\n            push!(seq, seq[end]/2)\n        else\n      \
    \      push!(seq, 3*seq[end] + 1)\n        end\n    end\n    return [x for x in\
    \ seq if x % 2 != 0]\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpd85uny6_.jl:38\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd85uny6_.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd85uny6_.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpd85uny6_.jl:39\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd85uny6_.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd85uny6_.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpd85uny6_.jl:40\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpd85uny6_.jl:40 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd85uny6_.jl:37\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd85uny6_.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \n    if n == 1\n        return [1]\n    end\n    \n    # start with a\
    \ vector containing the number n\n    collatz_list = [n]\n    \n    while n !=\
    \ 1\n        if n % 2 == 0\n            n = div(n, 2)\n        else\n        \
    \    n = 3*n + 1\n        end\n        push!(collatz_list, n)\n    end\n    \n\
    \    # remove all even numbers from the list\n    collatz_list = filter(x -> x\
    \ % 2 != 0, collatz_list)\n    \n    # sort and return the list\n    sort(collatz_list)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    l=[]\n    while n!=1\n        push!(l,n)\n        if iseven(n)\n     \
    \       n=n/2\n        else\n            n=3*n+1\n        end\n    end\n    l=collect(Set(l))\n\
    \    sort!(l)\n    return l\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmptc88siax.jl:36\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [2, 4, 5, 7, 8, 10, 11, 13, 14, 16,\
    \ 17, 20, 22, 26, 34, 40, 52] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptc88siax.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptc88siax.jl:35\ntest set: Test\
    \ Failed at /tmp/tmptc88siax.jl:37\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [2, 4, 5, 8, 16] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptc88siax.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptc88siax.jl:35\ntest set: Test\
    \ Failed at /tmp/tmptc88siax.jl:38\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [2, 3, 4, 5, 6, 8, 10, 12, 16] == [1, 3, 5]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptc88siax.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptc88siax.jl:35\ntest set: Test\
    \ Failed at /tmp/tmptc88siax.jl:39\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptc88siax.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptc88siax.jl:35\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptc88siax.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n <= 0\n        throw(ArgumentError(\"Input should be a positive integer.\"\
    ))\n    end\n    v = [n]\n    while n != 1\n        if n % 2 == 0\n          \
    \  n = div(n, 2)\n        else\n            n = 3*n + 1\n        end\n       \
    \ push!(v, n)\n    end\n    filter(x -> x % 2 != 0, v)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsdzw2o_2.jl:37\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsdzw2o_2.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsdzw2o_2.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpsdzw2o_2.jl:38\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsdzw2o_2.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsdzw2o_2.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpsdzw2o_2.jl:39\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpsdzw2o_2.jl:39 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsdzw2o_2.jl:36\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsdzw2o_2.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    seq = [n]\n    if n == 1\n        return [1]\n    end\n    while n !=\
    \ 1\n        if n % 2 == 0\n            n = n / 2\n        else\n            n\
    \ = n * 3 + 1\n        end\n        push!(seq, n)\n    end\n    return sort(filter(x\
    \ -> x % 2 != 0, seq))\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz=[] # Initialize collatz list\n    while n != 1 # Because Collatz(1)\
    \ is [1]\n        push!(collatz,n) # Push the value of n to collatz list\n   \
    \     if n%2==0 # If the value of n is even, divide by 2\n            n=n/2\n\
    \        else # Else, multiply by 3 and add 1\n            n=3*n+1\n        end\n\
    \    end\n    push!(collatz,1) # Because Collatz(1) is [1]\n    odd_collatz=collatz[collatz.%2.!=0]\
    \ # Make a new list that only has odd numbers\n    sort(odd_collatz) # Sort the\
    \ list\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t\
    @test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid syntax \"2.!\"; add space(s) to clarify\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpsz_n08z4.jl:28\nin expression\
    \ starting at /tmp/tmpsz_n08z4.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz = []\n    while n != 1\n        push!(collatz, n)\n        if\
    \ n % 2 == 0\n            n = n/2\n        else\n            n = 3*n + 1\n   \
    \     end\n    end\n    push!(collatz, n)\n    return filter(x -> x % 2 != 0,\
    \ collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpe6zybi70.jl:35\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpe6zybi70.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpe6zybi70.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpe6zybi70.jl:36\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpe6zybi70.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpe6zybi70.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpe6zybi70.jl:37\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpe6zybi70.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpe6zybi70.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe6zybi70.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    nums = Array{Int64}(undef,0)\n    while n != 1\n        push!(nums,n)\n\
    \        if n % 2 == 0\n            n = n / 2\n        else\n            n = 3\
    \ * n + 1\n        end\n    end\n    return nums\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8dgpn0eu.jl:34\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [14, 7, 22, 11, 34, 17, 52, 26, 13,\
    \ 40, 20, 10, 5, 16, 8, 4, 2] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8dgpn0eu.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8dgpn0eu.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp8dgpn0eu.jl:35\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 16, 8, 4, 2] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8dgpn0eu.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8dgpn0eu.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp8dgpn0eu.jl:36\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [12, 6, 3, 10, 5, 16, 8, 4, 2] == [1, 3, 5]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8dgpn0eu.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8dgpn0eu.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp8dgpn0eu.jl:37\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8dgpn0eu.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8dgpn0eu.jl:33\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8dgpn0eu.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    seq = get_collatz(n)\n   \
    \ return filter(x -> x % 2 != 0, seq)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpx5ar_m0r.jl:29\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  UndefVarError: get_collatz\
    \ not defined\n  Stacktrace:\n   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpx5ar_m0r.jl:21\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5ar_m0r.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5ar_m0r.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpx5ar_m0r.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(5) == [1, 5]\n  UndefVarError: get_collatz not defined\n  Stacktrace:\n\
    \   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpx5ar_m0r.jl:21\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5ar_m0r.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5ar_m0r.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpx5ar_m0r.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(12) == [1, 3, 5]\n  UndefVarError: get_collatz not defined\n  Stacktrace:\n\
    \   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpx5ar_m0r.jl:21\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5ar_m0r.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5ar_m0r.jl:28\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    1      3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpx5ar_m0r.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n<=0 error(\"n should be positive\") end\n    if n==1 return [1] end\n\
    using Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2w8xr_a5.jl:17\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2w8xr_a5.jl:1\n\
    in expression starting at /tmp/tmp2w8xr_a5.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \n    if n < 1\n        throw(ArgumentError(\"n must be a positive integer\"\
    ))\n    end\n    \n    arr = [n]\n    while n != 1\n        if n % 2 == 0\n  \
    \          n = n/2\n        else\n            n = 3*n + 1\n        end\n     \
    \   push!(arr, n)\n    end\n    \n    even_arr = [1]\n    for i in arr\n     \
    \   if i % 2 != 0\n            push!(even_arr, i)\n        end\n    end\n    \n\
    \    even_arr\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6kiese70.jl:47\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 7, 11, 17, 13, 5, 1] == [1, 5, 7,\
    \ 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6kiese70.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6kiese70.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp6kiese70.jl:48\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [1, 5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6kiese70.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6kiese70.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp6kiese70.jl:49\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6kiese70.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6kiese70.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp6kiese70.jl:50\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ [1, 1] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6kiese70.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6kiese70.jl:46\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6kiese70.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n <= 0\n        return []\n    end\n    seq = [n]\n    while n != 1\n\
    \        n = n%2 == 0 ? n/2 : 3*n + 1\n        push!(seq, n)\n    end\n    return\
    \ filter(i -> i%2 != 0, seq)\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpp5cbrpw8.jl:33\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpp5cbrpw8.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpp5cbrpw8.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpp5cbrpw8.jl:34\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpp5cbrpw8.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpp5cbrpw8.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpp5cbrpw8.jl:35\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpp5cbrpw8.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpp5cbrpw8.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp5cbrpw8.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \n    if n == 1\n        return [1]\n    end\n    \n    output = Int64[]\n\
    \    push!(output, n)\n    \n    while true\n        if n % 2 == 0\n         \
    \   n = n / 2\n        else\n            n = 3 * n + 1\n        end\n        \n\
    \        if n % 2 != 0\n            push!(output, n)\n        end\n        \n\
    \        if n == 1\n            break\n        end\n    end\n    \n    return\
    \ sort(output)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfzp99rtl.jl:49\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfzp99rtl.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfzp99rtl.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpfzp99rtl.jl:51\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 3, 5, 12] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfzp99rtl.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfzp99rtl.jl:48\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfzp99rtl.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while collatz[end]\
    \ != 1\n        if collatz[end] % 2 == 0\n            collatz = [collatz; collatz[end]/2]\n\
    \        else\n            collatz = [collatz; 3*collatz[end] + 1]\n        end\n\
    \    end\n    return collatz[collatz .% 2 .!= 0]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxd5e9a2f.jl:36\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxd5e9a2f.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxd5e9a2f.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpxd5e9a2f.jl:37\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxd5e9a2f.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxd5e9a2f.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpxd5e9a2f.jl:38\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpxd5e9a2f.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxd5e9a2f.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxd5e9a2f.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    even_numbers = Array{Int64}(undef, 0)\n    while n > 1\n        if n %\
    \ 2 == 0\n            push!(even_numbers, n)\n            n = n/2\n        else\n\
    \            push!(even_numbers, n)\n            n = 3*n + 1\n        end\n  \
    \  end\n    push!(even_numbers, 1)\n    return even_numbers\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqfi2ekz0.jl:36\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [14, 7, 22, 11, 34, 17, 52, 26, 13,\
    \ 40, 20, 10, 5, 16, 8, 4, 2, 1] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqfi2ekz0.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqfi2ekz0.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpqfi2ekz0.jl:37\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 16, 8, 4, 2, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqfi2ekz0.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqfi2ekz0.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpqfi2ekz0.jl:38\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [12, 6, 3, 10, 5, 16, 8, 4, 2, 1] == [1, 3, 5]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqfi2ekz0.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqfi2ekz0.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqfi2ekz0.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    res = Int64[]\n    while n\
    \ != 1\n        if n % 2 == 1\n            push!(res, n)\n        end\n      \
    \  n = n % 2 == 0 ? n / 2 : 3n + 1\n    end\n    push!(res, 1)\n    return sort(res)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    res = []\n    while n != 1\n        if n % 2 == 1\n            push!(res,\
    \ n)\n        end\n        n = collatz(n)\n    end\n    push!(res, 1)\n    return\
    \ sort(res)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpeapll60p.jl:33\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  UndefVarError: collatz\
    \ not defined\n  Stacktrace:\n   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpeapll60p.jl:23\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeapll60p.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeapll60p.jl:32\ntest set:\
    \ Error During Test at /tmp/tmpeapll60p.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(5) == [1, 5]\n  UndefVarError: collatz not defined\n  Stacktrace:\n\
    \   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpeapll60p.jl:23\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeapll60p.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeapll60p.jl:32\ntest set:\
    \ Error During Test at /tmp/tmpeapll60p.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(12) == [1, 3, 5]\n  UndefVarError: collatz not defined\n  Stacktrace:\n\
    \   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpeapll60p.jl:23\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeapll60p.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeapll60p.jl:32\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    1      3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeapll60p.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz = [n]\n    while n > 1\n        if n % 2 == 0\n            n =\
    \ n / 2\n        else\n            n = 3 * n + 1\n        end\n        push!(collatz,\
    \ n)\n    end\n    collatz = filter(x -> x % 2 != 0, collatz)\n    return collatz\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqm7svk1m.jl:35\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqm7svk1m.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqm7svk1m.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpqm7svk1m.jl:36\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqm7svk1m.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqm7svk1m.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpqm7svk1m.jl:37\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqm7svk1m.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqm7svk1m.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqm7svk1m.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    v = []\n    while n != 1\n        isodd(n) && push!(v, n)\n        iseven(n)\
    \ && (n = n / 2)\n        isodd(n) && (n = 3n + 1)\n    end\n    push!(v, n)\n\
    \    return sort(v)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    collatz_seq = Int64[]\n    while n != 1\n        push!(collatz_seq, n)\n\
    \        if n % 2 == 0\n            n = n / 2\n        else\n            n = 3*n\
    \ + 1\n        end\n    end\n    push!(collatz_seq, 1)\n    return filter(isodd,\
    \ collatz_seq)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpthraiyz5.jl:35\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpthraiyz5.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpthraiyz5.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpthraiyz5.jl:36\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpthraiyz5.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpthraiyz5.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpthraiyz5.jl:37\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpthraiyz5.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpthraiyz5.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpthraiyz5.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    list = zeros(Int64, 0)\n    tmp = n\n    push!(list, tmp)\n    while tmp\
    \ != 1\n        if tmp % 2 == 0\n            tmp = tmp / 2\n        else\n   \
    \         tmp = tmp * 3 + 1\n        end\n        if tmp % 2 != 0\n          \
    \  push!(list, tmp)\n        end\n    end\n    return sort(list)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw6dn4ibu.jl:38\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw6dn4ibu.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw6dn4ibu.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpw6dn4ibu.jl:40\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 3, 5, 12] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw6dn4ibu.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw6dn4ibu.jl:37\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     2      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw6dn4ibu.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n < 1\n        return \"Please enter a positive integer!\"\n    end\n\
    \    list = Int64[]\n    while n != 1\n        push!(list, n)\n        if n %\
    \ 2 == 0\n            n = n/2\n        else\n            n = 3*n + 1\n       \
    \ end\n    end\n    push!(list, 1)\n    odds = Int64[]\n    for i in list\n  \
    \      if i % 2 != 0\n            push!(odds, i)\n        end\n    end\n    sort(odds)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    if n == 1\n        return [1]\n    end\n    collatz = Any[]\n    push!(collatz,\
    \ n)\n    while n != 1\n        if n % 2 == 0\n            n = n/2\n        else\n\
    \            n = 3*n + 1\n        end\n        push!(collatz, n)\n    end\n  \
    \  odd_list = Any[]\n    for i in collatz\n        if i % 2 != 0\n           \
    \ push!(odd_list, i)\n        end\n    end\n    return odd_list\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpq5w_nqvb.jl:44\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpq5w_nqvb.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq5w_nqvb.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpq5w_nqvb.jl:45\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpq5w_nqvb.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq5w_nqvb.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpq5w_nqvb.jl:46\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpq5w_nqvb.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq5w_nqvb.jl:43\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq5w_nqvb.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    ...\nend\n@testset \"Testing get_odd_collatz()\"\
    \ begin\n    @test get_odd_collatz(1) == [1]\n    @test get_odd_collatz(3) ==\
    \ [1, 3]\n    @test get_odd_collatz(5) == [1, 5]\n    @test get_odd_collatz(8)\
    \ == [1, 3, 7]\n    @test get_odd_collatz(10) == [1, 3, 7, 9]\n    @test get_odd_collatz(100)\
    \ == [1, 3, 7, 9, 15, 21, 27, 31, 33, 39, 45, 51, 57, 63, 69, 73, 75, 81, 87,\
    \ 93, 99]\nend\n \nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: invalid identifier name \"...\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpxwtns1wm.jl:19\nin expression starting at\
    \ /tmp/tmpxwtns1wm.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    \"\"\" \n    Converts an Int to a Vector of Ints\n    \"\"\"\n    return\
    \ [ i for i in int_to_digits(n) ]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpah0as2lp.jl:28\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  UndefVarError: int_to_digits\
    \ not defined\n  Stacktrace:\n   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpah0as2lp.jl:21\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpah0as2lp.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpah0as2lp.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpah0as2lp.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(5) == [1, 5]\n  UndefVarError: int_to_digits not defined\n  Stacktrace:\n\
    \   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpah0as2lp.jl:21\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpah0as2lp.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpah0as2lp.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpah0as2lp.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(12) == [1, 3, 5]\n  UndefVarError: int_to_digits not defined\n  Stacktrace:\n\
    \   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpah0as2lp.jl:21\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpah0as2lp.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpah0as2lp.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpah0as2lp.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(1) == [1]\n  UndefVarError: int_to_digits not defined\n  Stacktrace:\n\
    \   [1] get_odd_collatz(n::Int64)\n     @ Main /tmp/tmpah0as2lp.jl:21\n   [2]\
    \ macro expansion\n     @ /shared/centos7/"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpah0as2lp.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64}\
    \ \n    result = [n]\n    # your code here\n    while n != 1\n        if n % 2\
    \ == 0\n            n = n / 2\n        else\n            n = 3 * n + 1\n     \
    \   end\n        push!(result, n)\n    end\n    return result[result .% 2 == 1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjz5ybkm8.jl:35\n  Test threw exception\n\
    \  Expression: candidate(14) == [1, 5, 7, 11, 13, 17]\n  ArgumentError: invalid\
    \ index: false of type Bool\n  Stacktrace:\n    [1] to_index(i::Bool)\n      @\
    \ Base ./indices.jl:293\n    [2] to_index(A::Vector{Int64}, i::Bool)\n      @\
    \ Base ./indices.jl:277\n    [3] to_indices\n      @ ./indices.jl:333 [inlined]\n\
    \    [4] to_indices\n      @ ./indices.jl:330 [inlined]\n    [5] getindex\n  \
    \    @ ./abstractarray.jl:1221 [inlined]\n    [6] get_odd_collatz(n::Int64)\n\
    \      @ Main /tmp/tmpjz5ybkm8.jl:28\n    [7] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpjz5ybkm8.jl:35 [inlined]\n\
    \    [9] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [10] top-level scope\n      @ /tmp/tmpjz5ybkm8.jl:34\ntest set:\
    \ Error During Test at /tmp/tmpjz5ybkm8.jl:36\n  Test threw exception\n  Expression:\
    \ candidate(5) == [1, 5]\n  ArgumentError: invalid index: false of type Bool\n\
    \  Stacktrace:\n    [1] to_index(i::Bool)\n      @ Base ./indices.jl:293\n   \
    \ [2] to_index(A::Vector{Int64}, i::Bool)\n      @ Base ./indices.jl:277\n   \
    \ [3] to_indices\n      @ ./indices.jl:333 [inlined]\n    [4] to_indices\n   \
    \   @ ./indices.jl:330 [inlined]\n    [5] getindex\n      @ ./abstractarray.jl:1221\
    \ [inlined]\n    [6] get_odd_collatz(n::Int64)\n      @ Main /tmp/tmpjz5ybkm8.jl:28\n\
    \    [7] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpjz5ybkm8.jl:36 [inlined]\n\
    \    [9] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [10] top-level scope\n      @ /tmp/tmpjz5ybkm8.jl:34\ntest set:\
    \ Error During Test at /tmp/tmpjz5ybkm8.jl:37\n  Test threw exception\n  Expression:\
    \ candidate(12) == [1, 3, 5]\n  ArgumentError: invalid index: false of type Bool\n\
    \  Stacktrace:\n    [1] to_index(i::Bool)\n      @ Base ./indices.jl:293"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjz5ybkm8.jl:32\n"
  exit_code: 1
  status: SyntaxError
