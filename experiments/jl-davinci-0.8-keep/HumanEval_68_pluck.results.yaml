name: HumanEval_68_pluck
language: jl
results:
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    nums = []\n    for i in eachindex(arr)\n        if iseven(arr[i])\n  \
    \          push!(nums, [arr[i], i])\n        end\n    end\n    if isempty(nums)\n\
    \        return []\n    end\n    return minimum(nums)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpm5986i1m.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm5986i1m.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm5986i1m.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpm5986i1m.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpm5986i1m.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm5986i1m.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpm5986i1m.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm5986i1m.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm5986i1m.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpm5986i1m.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm5986i1m.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm5986i1m.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpm5986i1m.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm5986i1m.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_arr = []\n    even_idx = []\n    for i in 1:length(arr)\n       \
    \ if iseven(arr[i]) == true\n            push!(even_arr, arr[i])\n           \
    \ push!(even_idx, i)\n        end\n    end\n    if isempty(even_arr) == true\n\
    \        return []\n    else\n        min_value = minimum(even_arr)\n        for\
    \ j in 1:length(even_arr)\n            if even_arr[j] == min_value\n         \
    \       min_idx = even_idx[j]\n                break\n            end\n      \
    \  end\n        return [min_value, min_idx]\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpqkvg9bkh.jl:61\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: min_idx not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqkvg9bkh.jl:53\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqkvg9bkh.jl:61 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqkvg9bkh.jl:60\ntest set:\
    \ Error During Test at /tmp/tmpqkvg9bkh.jl:62\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: min_idx not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqkvg9bkh.jl:53\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqkvg9bkh.jl:62 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqkvg9bkh.jl:60\ntest set:\
    \ Error During Test at /tmp/tmpqkvg9bkh.jl:64\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: min_idx not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqkvg9bkh.jl:53\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqkvg9bkh.jl:64 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqkvg9bkh.jl:60\ntest set:\
    \ Error During Test at /tmp/tmpqkvg9bkh.jl:65\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: min_idx not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqkvg9bkh.jl:53\n\
    \   [2] macro expansion\n     @ /shared"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqkvg9bkh.jl:58\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # if the array is empty, return empty\n    if length(arr) == 0\n     \
    \   return []\n    end\n    # create a vector of even values\n    evens = filter(i\
    \ -> i % 2 == 0, arr)\n    # if the vector is empty, return empty\n    if length(evens)\
    \ == 0\n        return []\n    end\n    # return the min even value and its index\
    \ from the original array\n    return [minimum(evens), findfirst(arr, minimum(evens))]\n\
    end\n\"\"\"\n    \"Given a string s, return a list of integer values that is the\
    \ result of running \n    the Smith-Waterman algorithm on it.\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpu1_qxfs5.jl:48\nin expression starting at\
    \ /tmp/tmpu1_qxfs5.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = [i for i in arr if i % 2 == 0]\n    if length(evens) == 0\n  \
    \      return []\n    end\n    index_min_even = findmin(evens)[2]\n    return\
    \ [evens[index_min_even], index_min_even]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpn5jfipr2.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn5jfipr2.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn5jfipr2.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpn5jfipr2.jl:51\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn5jfipr2.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn5jfipr2.jl:46\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn5jfipr2.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    d = Dict()\n    for (i, x) in enumerate(arr)\n        @show x, i\n   \
    \     if x % 2 == 0\n            if haskey(d, x)\n                d[x] = min(d[x],\
    \ i)\n            else\n                d[x] = i\n            end\n        end\n\
    \    end\n    @show d\n    res = []\n    if length(d) == 0\n        return res\n\
    \    end\n    first_key = first(keys(d))\n    res = [first_key, d[first_key]]\n\
    \    for k in keys(d)\n        if k < res[1]\n            res = [k, d[k]]\n  \
    \      end\n    end\n    return res\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "(x, i) = (4, 1)\n(x, i) = (2, 2)\n(x, i) = (3, 3)\nd = Dict{Any, Any}(4\
    \ => 1, 2 => 2)\ntest set: Test Failed at /tmp/tmp43vwr090.jl:65\n  Expression:\
    \ candidate([4, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp43vwr090.jl:65 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp43vwr090.jl:64\n(x, i) = (1, 1)\n\
    (x, i) = (2, 2)\n(x, i) = (3, 3)\nd = Dict{Any, Any}(2 => 2)\ntest set: Test Failed\
    \ at /tmp/tmp43vwr090.jl:66\n  Expression: candidate([1, 2, 3]) == [2, 1]\n  \
    \ Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp43vwr090.jl:66 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp43vwr090.jl:64\nd = Dict{Any,\
    \ Any}()\n(x, i) = (5, 1)\n(x, i) = (0, 2)\n(x, i) = (3, 3)\n(x, i) = (0, 4)\n\
    (x, i) = (4, 5)\n(x, i) = (2, 6)\nd = Dict{Any, Any}(0 => 2, 4 => 5, 2 => 6)\n\
    test set: Test Failed at /tmp/tmp43vwr090.jl:68\n  Expression: candidate([5, 0,\
    \ 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp43vwr090.jl:68 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp43vwr090.jl:64\n(x, i) = (1, 1)\n\
    (x, i) = (2, 2)\n(x, i) = (3, 3)\n(x, i) = (0, 4)\n(x, i) = (5, 5)\n(x, i) = (3,\
    \ 6)\nd = Dict{Any, Any}(0 => 4, 2 => 2)\ntest set: Test Failed at /tmp/tmp43vwr090.jl:69\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/sh"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp43vwr090.jl:62\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # edge case: no even numbers in the array\n    evens = [x for x in arr\
    \ if iseven(x)]\n    if length(evens) == 0\n        return []\n    end\n    #\
    \ otherwise\n    return [minimum(evens), findfirst(arr, minimum(evens))]\nend\n\
    \"\"\"\n    \"Given a string containing only the characters '(', ')', '{', '}',\
    \ '[' and ']', \n    determine if the input string is valid.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpr1py33yx.jl:43\nin expression starting at\
    \ /tmp/tmpr1py33yx.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    if minimum(arr) % 2 ==\
    \ 0\n        return [minimum(arr), findfirst(arr, minimum(arr))]\n    else\n \
    \       return []\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp87gk222_.jl:49\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\\
    n    findfirst(::AbstractArray) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\\
    n    findfirst(::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\\
    n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp87gk222_.jl:39\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmp87gk222_.jl:49 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmp87gk222_.jl:48\\ntest set:\
    \ Test Failed at /tmp/tmp87gk222_.jl:50\\n  Expression: candidate([1, 2, 3]) ==\
    \ [2, 1]\\n   Evaluated: Int64[] == [2, 1]\\nStacktrace:\\n [1] macro expansion\\\
    n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmp87gk222_.jl:50 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmp87gk222_.jl:48\\ntest set: Error\
    \ During Test at /tmp/tmp87gk222_.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\n  Stacktrace:\\\
    n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp87gk222_.jl:39\\n   [2]\
    \ macro expansion\\n     @"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"\"\"\n    Function that plucks smallest even value from a vector of\
    \ non-negative integer nodes\n    \"\"\"\n    # Create filter for even values\n\
    \    evenfilter(x) = rem(x, 2) == 0\n    # Create filter for minimum value\n \
    \   minfilter(a, b) = a < b ? a : b\n    # Check if vector is not empty\n    if\
    \ length(arr) == 0\n        return []\n    end\n    # Filter vector for even values\
    \ only\n    filteredarr = filter(evenfilter, arr)\n    # Check if no even values\
    \ found\n    if length(filteredarr) == 0\n        return []\n    end\n    # Find\
    \ minimum value in even values\n    minval = reduce(minfilter, filteredarr)\n\
    \    # Find index of minimum value\n    minindex = findfirst(arr, minval)\n  \
    \  # Return plucked node\n    return [minval, minindex]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmptx7dj40r.jl:64\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmptx7dj40r.jl:55\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmptx7dj40r.jl:64 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmptx7dj40r.jl:63\ntest set:\
    \ Error During Test at /tmp/tmptx7dj40r.jl:65\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmptx7dj40r.jl:55\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmptx7dj40r.jl:65 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmptx7dj40r.jl:63\ntest set:\
    \ Error During Test at /tmp/tmptx7dj40r.jl:67\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptx7dj40r.jl:61\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = []\n    even_indicies = []\n    for i in 1:length(arr)\n\
    \        if mod(arr[i], 2) == 0\n            push!(even_values, arr[i])\n    \
    \        push!(even_indicies, i)\n        end\n    end\n    if length(even_values)\
    \ == 0\n        return []\n    end\n    return [minimum(even_values), minimum(even_indicies)]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp50t5ym_c.jl:54\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp50t5ym_c.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp50t5ym_c.jl:52\ntest set: Test\
    \ Failed at /tmp/tmp50t5ym_c.jl:56\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp50t5ym_c.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp50t5ym_c.jl:52\ntest set: Test\
    \ Failed at /tmp/tmp50t5ym_c.jl:57\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp50t5ym_c.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp50t5ym_c.jl:52\ntest set: Test\
    \ Failed at /tmp/tmp50t5ym_c.jl:58\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp50t5ym_c.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp50t5ym_c.jl:52\ntest set: Test\
    \ Failed at /tmp/tmp50t5ym_c.jl:59\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp50t5ym_c.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr) || isempty(arr[arr .% 2 .== 0])\n        return Vector{Int64}()\n\
    \    end\n    value, index = sort(arr[arr .% 2 .== 0], rev=true)\n    return [value[end],\
    \ index[end]]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppdvrsl1o.jl:46\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [4, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppdvrsl1o.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppdvrsl1o.jl:45\ntest set: Error\
    \ During Test at /tmp/tmppdvrsl1o.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  BoundsError: attempt to access 1-element Vector{Int64}\
    \ at index [2]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861 [inlined]\n\
    \   [2] indexed_iterate\n     @ ./tuple.jl:90 [inlined]\n   [3] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmppdvrsl1o.jl:38\n   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmppdvrsl1o.jl:47 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmppdvrsl1o.jl:45\ntest set:\
    \ Test Failed at /tmp/tmppdvrsl1o.jl:49\n  Expression: candidate([5, 0, 3, 0,\
    \ 4, 2]) == [0, 1]\n   Evaluated: [4, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppdvrsl1o.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppdvrsl1o.jl:45\ntest set: Test\
    \ Failed at /tmp/tmppdvrsl1o.jl:50\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 0] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppdvrsl1o.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Tes"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 4 failed, 2 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppdvrsl1o.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # get all even numbers from the vector\n    # and find the index of the\
    \ smallest element from the list of even numbers\n    # return the smallest even\
    \ number from the vector as the first element\n    # and the index of that number\
    \ as the second element\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpt1hpc86x.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpt1hpc86x.jl:1\n\
    in expression starting at /tmp/tmpt1hpc86x.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # sort the array\n    # return the smallest even element (or -1 if not\
    \ found)\n    # while we're at it, let's calculate the index\n    tmp = sort(arr)\n\
    \    idx = -1\n    if(length(tmp) == 0)\n        return [0,0]\n    end\n    for\
    \ i in 1:length(tmp)\n        if(tmp[i] % 2 == 0)\n            idx = i\n     \
    \       break\n        end\n    end\n    return [tmp[idx], idx]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8nilprov.jl:57\n  Expression: candidate([1,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8nilprov.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8nilprov.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp8nilprov.jl:58\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8nilprov.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8nilprov.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp8nilprov.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 1] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8nilprov.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8nilprov.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp8nilprov.jl:62\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8nilprov.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8nilprov.jl:55\ntest set: Error\
    \ During Test at /tmp/tmp8nilprov.jl:63\n  Test threw exception\n  Expression:\
    \ candidate([7, 9, 7, 1]) == Vector{Int64}([])\n  BoundsError: attempt to ac"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 4 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8nilprov.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return Vector{Int64}()\n    end\n    indexes\
    \ = findall(x -> x % 2 == 0, arr)\n    if isempty(indexes)\n        return Vector{Int64}()\n\
    \    end\n    minimum_index = indexes[argmin(arr[indexes])]\n    return [arr[minimum_index],\
    \ minimum_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmptg33swxy.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptg33swxy.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptg33swxy.jl:49\ntest set: Test\
    \ Failed at /tmp/tmptg33swxy.jl:51\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmptg33swxy.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptg33swxy.jl:49\ntest set: Test\
    \ Failed at /tmp/tmptg33swxy.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptg33swxy.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptg33swxy.jl:49\ntest set: Test\
    \ Failed at /tmp/tmptg33swxy.jl:54\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptg33swxy.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptg33swxy.jl:49\ntest set: Test\
    \ Failed at /tmp/tmptg33swxy.jl:55\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptg33swxy.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code goes here\n    return []\nend\n\"\"\"\n    \"Given a big integer\
    \ array and a number k, find the first k elements with the highest absolute value.\n\
    \    Return the list of elements in increasing order.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfxbqvayv.jl:38\nin expression starting at\
    \ /tmp/tmpfxbqvayv.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = [arr[i] for i in 1:length(arr) if arr[i] % 2 == 0]\n    return\
    \ [evens[1], findfirst(arr, evens[1])]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpr4pkxz4p.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpr4pkxz4p.jl:36\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr4pkxz4p.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr4pkxz4p.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpr4pkxz4p.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpr4pkxz4p.jl:36\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr4pkxz4p.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr4pkxz4p.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpr4pkxz4p.jl:45\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Int64} at ind"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr4pkxz4p.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    return [i for i in arr if i % 2 == 0]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp0j7n56zl.jl:42\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [4, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0j7n56zl.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0j7n56zl.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp0j7n56zl.jl:43\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0j7n56zl.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0j7n56zl.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp0j7n56zl.jl:45\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0, 4, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0j7n56zl.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0j7n56zl.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp0j7n56zl.jl:46\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 0] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0j7n56zl.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0j7n56zl.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp0j7n56zl.jl:47\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 8, 4, 8] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0j7n56zl.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"TODO\"\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzphwlpwh.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type String to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpzphwlpwh.jl:35\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzphwlpwh.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzphwlpwh.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpzphwlpwh.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type String to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpzphwlpwh.jl:35\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzphwlpwh.jl:43 [inlined]\n\
    \   [4] macr"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzphwlpwh.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    if length(arr) ==\
    \ 1\n        if arr[1] % 2 == 0\n            return [arr[1], 1]\n        else\n\
    \            return []\n        end\n    end\n    d = Dict()\n    min = Inf\n\
    \    min_index = 0\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n \
    \           if haskey(d, arr[i])\n                if i < d[arr[i]]\n         \
    \           d[arr[i]] = i\n                end\n            else\n           \
    \     d[arr[i]] = i\n            end\n            if arr[i] < min\n          \
    \      min = arr[i]\n                min_index = i\n            end\n        end\n\
    \    end\n    return [min, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmppputzrki.jl:70\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppputzrki.jl:70 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppputzrki.jl:69\ntest set: Test\
    \ Failed at /tmp/tmppputzrki.jl:71\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmppputzrki.jl:71 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppputzrki.jl:69\ntest set: Test\
    \ Failed at /tmp/tmppputzrki.jl:73\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppputzrki.jl:73 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppputzrki.jl:69\ntest set: Test\
    \ Failed at /tmp/tmppputzrki.jl:74\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppputzrki.jl:74 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppputzrki.jl:69\ntest set: Test\
    \ Failed at /tmp/tmppputzrki.jl:75\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 6 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppputzrki.jl:67\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    if arr[end] % 2 ==\
    \ 0\n        return [arr[end], length(arr)]\n    end\n    return pluck(arr[1:end-1])\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmperhg7a6o.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmperhg7a6o.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmperhg7a6o.jl:47\ntest set: Test\
    \ Failed at /tmp/tmperhg7a6o.jl:49\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmperhg7a6o.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmperhg7a6o.jl:47\ntest set: Test\
    \ Failed at /tmp/tmperhg7a6o.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmperhg7a6o.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmperhg7a6o.jl:47\ntest set: Test\
    \ Failed at /tmp/tmperhg7a6o.jl:52\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmperhg7a6o.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmperhg7a6o.jl:47\ntest set: Test\
    \ Failed at /tmp/tmperhg7a6o.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [8, 5] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmperhg7a6o.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    return [2, 1]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpixei_pa8.jl:48\n  Expression: candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n   Evaluated: [2, 1] == [0, 1]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpixei_pa8.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpixei_pa8.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpixei_pa8.jl:49\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 1] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpixei_pa8.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpixei_pa8.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpixei_pa8.jl:50\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [2, 1] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpixei_pa8.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpixei_pa8.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpixei_pa8.jl:51\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [2, 1] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpixei_pa8.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpixei_pa8.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpixei_pa8.jl:52\n  Expression: candidate([7, 9, 7, 1]) == Vector{Int64}([])\n\
    \   Evaluated: [2, 1] == Int64[]\nStacktrace:\n [1] macro expansi"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpixei_pa8.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return Vector{Int64}()\n    end\n    even_indices\
    \ = findall(x -> x % 2 == 0, arr)\n    if length(even_indices) == 0\n        return\
    \ Vector{Int64}()\n    end\n    min_even_index = minimum(even_indices)\n    return\
    \ [arr[min_even_index], min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpju9ue_9h.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [4, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpju9ue_9h.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpju9ue_9h.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpju9ue_9h.jl:51\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpju9ue_9h.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpju9ue_9h.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpju9ue_9h.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpju9ue_9h.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpju9ue_9h.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpju9ue_9h.jl:54\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpju9ue_9h.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpju9ue_9h.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpju9ue_9h.jl:55\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpju9ue_9h.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest_even_value = -1\n    node_index = -1\n    for i in 1:length(arr)\n\
    \        if iseven(arr[i]) && (arr[i] < smallest_even_value || smallest_even_value\
    \ == -1)\n            smallest_even_value = arr[i]\n            node_index = i\n\
    \        end\n    end\n    if smallest_even_value == -1\n        return []\n \
    \   else\n        return [smallest_even_value, node_index]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmptwwhpx8b.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptwwhpx8b.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptwwhpx8b.jl:53\ntest set: Test\
    \ Failed at /tmp/tmptwwhpx8b.jl:55\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmptwwhpx8b.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptwwhpx8b.jl:53\ntest set: Test\
    \ Failed at /tmp/tmptwwhpx8b.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptwwhpx8b.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptwwhpx8b.jl:53\ntest set: Test\
    \ Failed at /tmp/tmptwwhpx8b.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptwwhpx8b.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptwwhpx8b.jl:53\ntest set: Test\
    \ Failed at /tmp/tmptwwhpx8b.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptwwhpx8b.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    return Vector{Int64}()\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmphuhona7n.jl:42\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphuhona7n.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphuhona7n.jl:41\ntest set: Test\
    \ Failed at /tmp/tmphuhona7n.jl:43\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmphuhona7n.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphuhona7n.jl:41\ntest set: Test\
    \ Failed at /tmp/tmphuhona7n.jl:45\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphuhona7n.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphuhona7n.jl:41\ntest set: Test\
    \ Failed at /tmp/tmphuhona7n.jl:46\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphuhona7n.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphuhona7n.jl:41\ntest set: Test\
    \ Failed at /tmp/tmphuhona7n.jl:47\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shar"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphuhona7n.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # get even\n    evens = [e for e in arr if e % 2 == 0]\n    # if no evens\n\
    \    if evens == []\n        return []\n    end\n    smallest = sort(evens)[1]\n\
    \    # find the index with the smallest even value and return it\n    return [smallest,\
    \ findfirst(arr .== smallest)[1]]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpa2jv5ozz.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa2jv5ozz.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa2jv5ozz.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpa2jv5ozz.jl:51\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpa2jv5ozz.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa2jv5ozz.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpa2jv5ozz.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa2jv5ozz.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa2jv5ozz.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpa2jv5ozz.jl:54\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa2jv5ozz.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa2jv5ozz.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpa2jv5ozz.jl:55\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa2jv5ozz.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    arr_min\
    \ = arr[1]\n    for i in arr\n        if i%2 == 0\n            push!(evens, i)\n\
    \        end\n        if i < arr_min\n            arr_min = i\n        end\n \
    \   end\n    if length(evens) == 0\n        return []\n    end\n    evens_min\
    \ = evens[1]\n    for e in evens\n        if e < evens_min\n            evens_min\
    \ = e\n        end\n    end\n    indices = findall(x -> x == evens_min, arr)\n\
    \    if length(indices) == 1\n        return [evens_min, indices[1]]\n    else\n\
    \        min_indices = findall(x -> x == arr_min, arr)\n        return [evens_min,\
    \ min_indices[1]]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbhoy0cjx.jl:70\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbhoy0cjx.jl:70 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbhoy0cjx.jl:69\ntest set: Test\
    \ Failed at /tmp/tmpbhoy0cjx.jl:71\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbhoy0cjx.jl:71 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbhoy0cjx.jl:69\ntest set: Test\
    \ Failed at /tmp/tmpbhoy0cjx.jl:73\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbhoy0cjx.jl:73 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbhoy0cjx.jl:69\ntest set: Test\
    \ Failed at /tmp/tmpbhoy0cjx.jl:74\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbhoy0cjx.jl:74 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbhoy0cjx.jl:69\ntest set: Test\
    \ Failed at /tmp/tmpbhoy0cjx.jl:75\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbhoy0cjx.jl:67\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(n -> n % 2 == 0, arr)\n    if isempty(evens)\n        return\
    \ []\n    end\n    idx = findall(arr .== minimum(evens))[1]\n    return [minimum(evens),\
    \ idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpz3h11ku3.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz3h11ku3.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz3h11ku3.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpz3h11ku3.jl:48\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpz3h11ku3.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz3h11ku3.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpz3h11ku3.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz3h11ku3.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz3h11ku3.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpz3h11ku3.jl:51\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz3h11ku3.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz3h11ku3.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpz3h11ku3.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz3h11ku3.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_idx = findall(arr .> 0, x -> x % 2 == 0)\n    if length(even_idx)\
    \ > 0\n        min_idx = indmin(arr[even_idx])\n        return [arr[even_idx[min_idx]],\
    \ even_idx[min_idx]]\n    else\n        return []\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzl6_gcvi.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findall(::BitVector, ::var\"#1#2\")\n  Closest candidates are:\n    findall(::BitArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:1682\n    findall(::AbstractArray{Bool})\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:2303\n    findall(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:2253\n    ...\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpzl6_gcvi.jl:35\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzl6_gcvi.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzl6_gcvi.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpzl6_gcvi.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findall(::BitVector,\
    \ ::var\"#1#2\")\n  Closest candidates are:\n    findall(::BitArray) at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:1682\n\
    \    findall(::AbstractArray{Bool}) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:2303\n\
    \    findall(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:2253\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpzl6_gcvi.jl:35\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzl6_gcvi.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzl6_gcvi.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpzl6_gcvi.jl:50\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching f"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzl6_gcvi.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr) || all(isodd, arr)\n        return []\n    end\n    return\
    \ [findmin(x -> x[1], sort(map(i -> [i, arr[i]], filter(iseven, arr)))),\n   \
    \         first(filter(i -> arr[i] == findmin(x -> x[1], sort(map(i -> [i, arr[i]],\
    \ filter(isodd, arr)))), arr))]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp1qeqpzi2.jl:46\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  BoundsError: attempt to access\
    \ 3-element Vector{Int64} at index [4]\n  Stacktrace:\n    [1] getindex\n    \
    \  @ ./array.jl:861 [inlined]\n    [2] #2\n      @ /tmp/tmp1qeqpzi2.jl:38 [inlined]\n\
    \    [3] iterate\n      @ ./generator.jl:47 [inlined]\n    [4] _collect(c::Vector{Int64},\
    \ itr::Base.Generator{Vector{Int64}, var\"#2#7\"{Vector{Int64}}}, #unused#::Base.EltypeUnknown,\
    \ isz::Base.HasShape{1})\n      @ Base ./array.jl:744\n    [5] collect_similar\n\
    \      @ ./array.jl:653 [inlined]\n    [6] map\n      @ ./abstractarray.jl:2867\
    \ [inlined]\n    [7] pluck(arr::Vector{Int64})\n      @ Main /tmp/tmp1qeqpzi2.jl:38\n\
    \    [8] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [9] macro expansion\n      @ /tmp/tmp1qeqpzi2.jl:46 [inlined]\n\
    \   [10] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [11] top-level scope\n      @ /tmp/tmp1qeqpzi2.jl:45\ntest set:\
    \ Error During Test at /tmp/tmp1qeqpzi2.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  BoundsError: attempt to access 0-element Vector{Int64}\
    \ at index [1]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861 [inlined]\n\
    \   [2] first\n     @ ./abstractarray.jl:398 [inlined]\n   [3] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp1qeqpzi2.jl:38\n   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmp1qeqpzi2.jl:47 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmp1qeqpzi2.jl:45\ntest set:\
    \ Error During Test at /tmp/tmp1qeqpzi2.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  BoundsError: attempt to access 6-element\
    \ Vector{Int64} at index [0]\n  Stacktrace:\n    [1] getindex\n      @ ./array.jl:861\
    \ [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1qeqpzi2.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n   \n    if isempty(arr)\n        return []\n    end\n    \n    idx = -1\n\
    \    min_value = -1\n    even = []\n    for i = 1:length(arr)\n        if mod(arr[i],\
    \ 2) == 0\n            push!(even, arr[i])\n        end\n    end\n    \n    if\
    \ isempty(even)\n        return []\n    end\n    \n    min_value = minimum(even)\n\
    \    idx = findall(arr .== min_value)[1]\n    \n    return [min_value, idx]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3653m0nb.jl:63\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3653m0nb.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3653m0nb.jl:62\ntest set: Test\
    \ Failed at /tmp/tmp3653m0nb.jl:64\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp3653m0nb.jl:64 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3653m0nb.jl:62\ntest set: Test\
    \ Failed at /tmp/tmp3653m0nb.jl:66\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3653m0nb.jl:66 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3653m0nb.jl:62\ntest set: Test\
    \ Failed at /tmp/tmp3653m0nb.jl:67\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3653m0nb.jl:67 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3653m0nb.jl:62\ntest set: Test\
    \ Failed at /tmp/tmp3653m0nb.jl:68\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3653m0nb.jl:60\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    #find the smallest even\n    min_even = -1\n    index = -1\n    for i\
    \ in 1:length(arr)\n        #for i in arr\n        if arr[i]%2 == 0\n        \
    \    if min_even == -1\n                min_even = arr[i]\n                index\
    \ = i\n            elseif arr[i] < min_even\n                min_even = arr[i]\n\
    \                index = i\n            end\n        end\n    end\n    #return\
    \ the smallest even and its index\n    if min_even != -1\n        return [min_even,\
    \ index]\n    else\n        return []\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpuhsqep1e.jl:62\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpuhsqep1e.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuhsqep1e.jl:61\ntest set: Test\
    \ Failed at /tmp/tmpuhsqep1e.jl:63\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpuhsqep1e.jl:63 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuhsqep1e.jl:61\ntest set: Test\
    \ Failed at /tmp/tmpuhsqep1e.jl:65\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpuhsqep1e.jl:65 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuhsqep1e.jl:61\ntest set: Test\
    \ Failed at /tmp/tmpuhsqep1e.jl:66\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpuhsqep1e.jl:66 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuhsqep1e.jl:61\ntest set: Test\
    \ Failed at /tmp/tmpuhsqep1e.jl:67\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuhsqep1e.jl:59\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    nodes = sort(filter(x -> x % 2 == 0, arr))\n    if length(nodes) != 0\n\
    \        idx = findfirst(arr .== nodes[1])\n        return [nodes[1], idx]\n \
    \   else\n        return []\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmprr2kbke0.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprr2kbke0.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprr2kbke0.jl:47\ntest set: Test\
    \ Failed at /tmp/tmprr2kbke0.jl:49\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprr2kbke0.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprr2kbke0.jl:47\ntest set: Test\
    \ Failed at /tmp/tmprr2kbke0.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprr2kbke0.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprr2kbke0.jl:47\ntest set: Test\
    \ Failed at /tmp/tmprr2kbke0.jl:52\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprr2kbke0.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprr2kbke0.jl:47\ntest set: Test\
    \ Failed at /tmp/tmprr2kbke0.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprr2kbke0.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = Int64[]\n\
    \    for i = 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_arr,\
    \ i)\n        end\n    end\n    if isempty(even_arr)\n        return []\n    end\n\
    \    min_idx = minimum(even_arr)\n    min_val = arr[min_idx]\n    return [min_val,\
    \ min_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdeuqejt5.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [4, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdeuqejt5.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdeuqejt5.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpdeuqejt5.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdeuqejt5.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdeuqejt5.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpdeuqejt5.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdeuqejt5.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdeuqejt5.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpdeuqejt5.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdeuqejt5.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdeuqejt5.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpdeuqejt5.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdeuqejt5.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    # A vector of zeros, to store the first even number and its index\n\
    \    # Ex.:\n    #     arr = [5,0,3,0,4,2]\n    #     result = [0, 1]\n    result\
    \ = fill(0, 2)\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpa69ol_dl.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpa69ol_dl.jl:1\n\
    in expression starting at /tmp/tmpa69ol_dl.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_nums = [ num for num in arr if num % 2 == 0 ]\n    if length(even_nums)\
    \ == 0\n        return []\n    end\n    even_min = minimum(even_nums)\n    index\
    \ = findall(arr .== even_min)[1]\n    return [even_min, index]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpr_8byldo.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr_8byldo.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr_8byldo.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpr_8byldo.jl:49\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpr_8byldo.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr_8byldo.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpr_8byldo.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr_8byldo.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr_8byldo.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpr_8byldo.jl:52\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr_8byldo.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr_8byldo.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpr_8byldo.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr_8byldo.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_nums = []\n    for (i, v) in enumerate(arr)\n        if v % 2 ==\
    \ 0\n            push!(even_nums, (v, i))\n        end\n    end\n    sort!(even_nums)\n\
    \    if length(even_nums) != 0\n        return even_nums[1]\n    else\n      \
    \  return []\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpcbi84j0b.jl:53\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Tuple{Int64, Int64} to an object of type Vector{Int64}\n \
    \ Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpcbi84j0b.jl:43\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcbi84j0b.jl:53 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcbi84j0b.jl:52\ntest set:\
    \ Error During Test at /tmp/tmpcbi84j0b.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Tuple{Int64, Int64} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpcbi84j0b.jl:43\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcbi84j0b.j"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcbi84j0b.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    iseven(n) = n % 2 == 0\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpbwkt5iqk.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpbwkt5iqk.jl:1\n\
    in expression starting at /tmp/tmpbwkt5iqk.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens_less_than_min = []\n    min_even = Inf\n    for i in 1:length(arr)\n\
    \        node = arr[i]\n        if node % 2 == 0 && node < min_even\n        \
    \    evens_less_than_min = []\n            push!(evens_less_than_min, [node, i])\n\
    \            min_even = node\n        elseif node % 2 == 0 && node == min_even\n\
    \            push!(evens_less_than_min, [node, i])\n        end\n    end\n   \
    \ if length(evens_less_than_min) > 0\n        return minimum(evens_less_than_min)\n\
    \    else\n        return []\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp_43tq1w8.jl:58\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_43tq1w8.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_43tq1w8.jl:57\ntest set: Test\
    \ Failed at /tmp/tmp_43tq1w8.jl:59\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_43tq1w8.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_43tq1w8.jl:57\ntest set: Test\
    \ Failed at /tmp/tmp_43tq1w8.jl:61\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_43tq1w8.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_43tq1w8.jl:57\ntest set: Test\
    \ Failed at /tmp/tmp_43tq1w8.jl:62\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_43tq1w8.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_43tq1w8.jl:57\ntest set: Test\
    \ Failed at /tmp/tmp_43tq1w8.jl:63\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_43tq1w8.jl:55\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr) return [:] end\n    even_arr = arr[arr .% 2 .== 0]\n \
    \   even_arr == nothing && return [:]\n    even_arr = sort(even_arr)\n    minimum_even\
    \ = even_arr[1]\n    mini_idx = findall(minimum_even .== arr)[1]\n    [minimum_even,\
    \ mini_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpaktz7oc2.jl:48\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] macro\
    \ expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpaktz7oc2.jl:48 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpaktz7oc2.jl:47\\ntest set: Test\
    \ Failed at /tmp/tmpaktz7oc2.jl:49\\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] macro expansion\\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpaktz7oc2.jl:49 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpaktz7oc2.jl:47\\ntest set: Error\
    \ During Test at /tmp/tmpaktz7oc2.jl:50\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\\n  MethodError: Cannot `convert`\
    \ an object of type Colon to an object of type Int64\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::T) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:7\\\
    n    convert(::Type{T}, !Matched::Base.TwicePrecision) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/twiceprecision.jl:262\\\
    n    ...\\n  Stacktrace:\\n    [1] setindex!(A::Vector{Int64}, x::Function, i1::Int64)\\\
    n      @ Base ./array.jl:903\\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64,\
    \ src::Vector{Colon}, soffs::Int64, n::Int64)\\n      @ Base ./array.jl:253\\\
    n    [3] unsafe_copyto!\\n      @ ./array.jl:307 [inlined]\\n    [4] _copyto_impl!\\\
    n      @ ./array.jl:331 [inlined]\\n    [5] copyto!\\n      @ ./array.jl:317 [inlined]\\\
    n    [6] copyto!\\n      @ ./array.jl:343 [inlined]\\n    ["
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    if length(evens) > 0\n     \
    \   min_val = minimum(evens)\n        min_idx = findall(==(min_val), arr)[1]\n\
    \        return [min_val, min_idx]\n    else\n        return []\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp50u1jjil.jl:49\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp50u1jjil.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp50u1jjil.jl:48\ntest set: Test\
    \ Failed at /tmp/tmp50u1jjil.jl:50\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp50u1jjil.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp50u1jjil.jl:48\ntest set: Test\
    \ Failed at /tmp/tmp50u1jjil.jl:52\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp50u1jjil.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp50u1jjil.jl:48\ntest set: Test\
    \ Failed at /tmp/tmp50u1jjil.jl:53\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp50u1jjil.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp50u1jjil.jl:48\ntest set: Test\
    \ Failed at /tmp/tmp50u1jjil.jl:54\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp50u1jjil.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_filter = arr .% 2 .== 0\n    if sum(even_filter) == 0 return [] end\n\
    \    evens = arr[even_filter]\n    indx = findfirst(even_filter, true)\n    return\
    \ [minimum(evens), indx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpcxwdsxsz.jl:46\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::BitVector, ::Bool)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpcxwdsxsz.jl:38\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcxwdsxsz.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcxwdsxsz.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpcxwdsxsz.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::BitVector,\
    \ ::Bool)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpcxwdsxsz.jl:38\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcxwdsxsz.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcxwdsxsz.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpcxwdsxsz.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::BitVector,\
    \ ::Bool)\n  Closest candidat"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcxwdsxsz.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_nodes = Int64[]\n    even_indexes = Int64[]\n    for i in 1:length(arr)\n\
    \        node = arr[i]\n        if node % 2 == 0\n            push!(even_nodes,\
    \ node)\n            push!(even_indexes, i)\n        end\n    end\n    if length(even_nodes)\
    \ == 0\n        return Int64[]\n    end\n    min_val = minimum(even_nodes)\n \
    \   smallest_index = findfirst(even_nodes, min_val)\n    return [min_val, even_indexes[smallest_index]]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpusqf39kp.jl:56\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpusqf39kp.jl:48\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpusqf39kp.jl:56 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpusqf39kp.jl:55\ntest set:\
    \ Error During Test at /tmp/tmpusqf39kp.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpusqf39kp.jl:48\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpusqf39kp.jl:57 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpusqf39kp.jl:55\ntest set:\
    \ Error During Test at /tmp/tmpusqf39kp.jl:59\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpusqf39kp.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if arr == []\n        return [ ]\n    end\n    min_value = 10001\n   \
    \ min_index = 0\n    even_nodes = [ ]\n    for n in 1:length(arr)\n        if\
    \ arr[n] % 2 == 0 && arr[n] < min_value\n            min_value = arr[n]\n    \
    \        min_index = n\n        end\n    end\n    if min_value == 10001\n    \
    \    return [ ]\n    end\n    return [ min_value, min_index ]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvgtuwx74.jl:57\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvgtuwx74.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvgtuwx74.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpvgtuwx74.jl:58\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvgtuwx74.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvgtuwx74.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpvgtuwx74.jl:60\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvgtuwx74.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvgtuwx74.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpvgtuwx74.jl:61\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvgtuwx74.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvgtuwx74.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpvgtuwx74.jl:62\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvgtuwx74.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    index = -1\n    value = -1\n    for (i, v) in enumerate(arr)\n       \
    \ if v == 0\n            if index == -1\n                index = i\n         \
    \       value = v\n            end\n        elseif mod(v, 2) == 0\n          \
    \  if index == -1\n                index = i\n                value = v\n    \
    \        elseif value > v\n                index = i\n                value =\
    \ v\n            end\n        end\n    end\n    if index == -1\n        return\
    \ []\n    else\n        return [value, index]\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpqgw0j9z0.jl:64\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqgw0j9z0.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqgw0j9z0.jl:63\ntest set: Test\
    \ Failed at /tmp/tmpqgw0j9z0.jl:65\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqgw0j9z0.jl:65 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqgw0j9z0.jl:63\ntest set: Test\
    \ Failed at /tmp/tmpqgw0j9z0.jl:67\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqgw0j9z0.jl:67 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqgw0j9z0.jl:63\ntest set: Test\
    \ Failed at /tmp/tmpqgw0j9z0.jl:68\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqgw0j9z0.jl:68 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqgw0j9z0.jl:63\ntest set: Test\
    \ Failed at /tmp/tmpqgw0j9z0.jl:69\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqgw0j9z0.jl:61\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    @test size(arr) >= 1\n    @test size(arr) <= 10000\n    @test all(i ->\
    \ i >= 0, arr)\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @test not defined\nStacktrace:\n [1] top-level\
    \ scope\n   @ :0\n [2] #macroexpand#51\n   @ ./expr.jl:115 [inlined]\n [3] macroexpand\n\
    \   @ ./expr.jl:114 [inlined]\n [4] docm(source::LineNumberNode, mod::Module,\
    \ meta::Any, ex::Any, define::Bool) (repeats 2 times)\n   @ Base.Docs ./docs/Docs.jl:537\n\
    \ [5] var\"@doc\"(::LineNumberNode, ::Module, ::String, ::Vararg{Any})\n   @ Core\
    \ ./boot.jl:517\nin expression starting at /tmp/tmp5l3axcd2.jl:1\nin expression\
    \ starting at /tmp/tmp5l3axcd2.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(even)\n        return []\n    end\n    even_min\
    \ = minimum(even)\n    index = findall(arr .== even_min)[1]\n    return [even_min,\
    \ index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzv7hkonl.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzv7hkonl.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzv7hkonl.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpzv7hkonl.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpzv7hkonl.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzv7hkonl.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpzv7hkonl.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzv7hkonl.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzv7hkonl.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpzv7hkonl.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzv7hkonl.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzv7hkonl.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpzv7hkonl.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzv7hkonl.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_even = nothing\n    min_idx = nothing\n    for (i, e) in enumerate(arr)\n\
    \        if iseven(e)\n            if min_even === nothing || e < min_even\n \
    \               min_even = e\n                min_idx = i\n            end\n \
    \       end\n    end\n    if min_even === nothing\n        return []\n    else\n\
    \        return [min_even, min_idx]\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp0be50keh.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0be50keh.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0be50keh.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp0be50keh.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0be50keh.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0be50keh.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp0be50keh.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0be50keh.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0be50keh.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp0be50keh.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0be50keh.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0be50keh.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp0be50keh.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0be50keh.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"\"\"Function to return the node with the smallest even value and its\
    \ index.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9itvyu4g.jl:1\nin expression starting at /tmp/tmp9itvyu4g.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0 \n        return []\n    end\n    min::Int64 = -1\n\
    \    min_idx::Int64 = -1\n    i::Int64 = 1\n    while i <= length(arr)\n     \
    \   if arr[i] % 2 == 0 && arr[i] < min\n            min = arr[i]\n           \
    \ min_idx = i\n        end\n        i += 1\n    end\n    if min_idx == -1\n  \
    \      return []\n    end\n    return [min, min_idx]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmppvt7uwbv.jl:58\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppvt7uwbv.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppvt7uwbv.jl:57\ntest set: Test\
    \ Failed at /tmp/tmppvt7uwbv.jl:59\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmppvt7uwbv.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppvt7uwbv.jl:57\ntest set: Test\
    \ Failed at /tmp/tmppvt7uwbv.jl:61\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppvt7uwbv.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppvt7uwbv.jl:57\ntest set: Test\
    \ Failed at /tmp/tmppvt7uwbv.jl:62\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppvt7uwbv.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppvt7uwbv.jl:57\ntest set: Test\
    \ Failed at /tmp/tmppvt7uwbv.jl:63\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shar"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppvt7uwbv.jl:55\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = [arr[i] for i in 1:length(arr) if iseven(arr[i])]\n    if isempty(evens)\n\
    \        return []\n    else\n        i = findfirst(arr .== minimum(evens))\n\
    \        return [arr[i], i]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpjwhjsgz2.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjwhjsgz2.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjwhjsgz2.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpjwhjsgz2.jl:49\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpjwhjsgz2.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjwhjsgz2.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpjwhjsgz2.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjwhjsgz2.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjwhjsgz2.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpjwhjsgz2.jl:52\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjwhjsgz2.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjwhjsgz2.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpjwhjsgz2.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjwhjsgz2.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [arr[i] for i\
    \ in 1:length(arr) if iseven(arr[i])]\n    if isempty(evens)\n        return []\n\
    \    end\n    min_even = minimum(evens)\n    min_index = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpucai2gnz.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpucai2gnz.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpucai2gnz.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpucai2gnz.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpucai2gnz.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpucai2gnz.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpucai2gnz.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpucai2gnz.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpucai2gnz.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpucai2gnz.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpucai2gnz.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpucai2gnz.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpucai2gnz.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpucai2gnz.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    if isempty(arr)\n        return []\n    end\n    \n    plucked =\
    \ [maximum(Int64), maximum(Int64)]\n    for i = 1:length(arr)\n        if arr[i]\
    \ % 2 == 0\n            if arr[i] < plucked[1]\n                plucked = [arr[i],\
    \ i]\n            end\n        end\n    end\n    \n    if plucked[1] == maximum(Int64)\n\
    \        return []\n    end\n    \n    return plucked\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp9ako2k30.jl:60\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ iterate(::Type{Int64})\n  Closest candidates are:\n    iterate(!Matched::Union{LinRange,\
    \ StepRangeLen}) at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:826\n\
    \    iterate(!Matched::Union{LinRange, StepRangeLen}, !Matched::Integer) at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:826\n\
    \    iterate(!Matched::T) where T<:Union{Base.KeySet{<:Any, <:Dict}, Base.ValueIterator{<:Dict}}\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/dict.jl:695\n    ...\n  Stacktrace:\n\
    \    [1] _foldl_impl(op::Base.BottomRF{typeof(max)}, init::Base._InitialValue,\
    \ itr::Type)\n      @ Base ./reduce.jl:56\n    [2] foldl_impl(op::Base.BottomRF{typeof(max)},\
    \ nt::Base._InitialValue, itr::Type)\n      @ Base ./reduce.jl:48\n    [3] mapfoldl_impl(f::typeof(identity),\
    \ op::typeof(max), nt::Base._InitialValue, itr::Type)\n      @ Base ./reduce.jl:44\n\
    \    [4] #mapfoldl#244\n      @ ./reduce.jl:162 [inlined]\n    [5] mapfoldl\n\
    \      @ ./reduce.jl:162 [inlined]\n    [6] #mapreduce#248\n      @ ./reduce.jl:289\
    \ [inlined]\n    [7] mapreduce\n      @ ./reduce.jl:289 [inlined]\n    [8] #maximum#258\n\
    \      @ ./reduce.jl:737 [inlined]\n    [9] maximum(a::Type)\n      @ Base ./reduce.jl:737\n\
    \   [10] pluck(arr::Vector{Int64})\n      @ Main /tmp/tmp9ako2k30.jl:40\n   [11]\
    \ macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [12] macro expansion\n      @ /tmp/tmp9ako2k30.jl:60 [inlined]\n\
    \   [13] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [14] top-level scope\n      @ /tmp/tmp9ako2k30.jl:59\ntest set:\
    \ Error During Test at /tmp/tmp9ako2k30.jl:61\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching iterate(::Type{Int64})\n\
    \  Closest candidates are:\n    iterate(!Matched::Union{LinRange, StepRangeLen})\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:826"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9ako2k30.jl:57\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    # Array is empty\n    if length(arr) == 0\n        return []\n \
    \   end\n    \n    # Initialize array with smallest even value and index\n   \
    \ res = [0,0]\n    \n    # Iterate through the array\n    for i = 1:length(arr)\n\
    \        # If node is even and smaller than previous even value\n        if arr[i]\
    \ % 2 == 0 && (arr[i] < res[1] || res[1] == 0)\n            res = [arr[i], i]\n\
    \        end\n    end\n    \n    # If there is an even value\n    if res[1] !=\
    \ 0\n        return res\n    end\n    \n    # If no even value return empty array\n\
    \    return []\n    \nend\n \n# Test cases\narr1 = [4,2,3]\narr2 = [1,2,3]\narr3\
    \ = []\narr4 = [5, 0, 3, 0, 4, 2]\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkim5f510.jl:72\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkim5f510.jl:72 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkim5f510.jl:71\ntest set: Test\
    \ Failed at /tmp/tmpkim5f510.jl:73\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkim5f510.jl:73 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkim5f510.jl:71\ntest set: Test\
    \ Failed at /tmp/tmpkim5f510.jl:75\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkim5f510.jl:75 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkim5f510.jl:71\ntest set: Test\
    \ Failed at /tmp/tmpkim5f510.jl:76\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkim5f510.jl:76 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkim5f510.jl:71\ntest set: Test\
    \ Failed at /tmp/tmpkim5f510.jl:77\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/c"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkim5f510.jl:69\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    return [0, 0]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpj0c261ky.jl:42\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj0c261ky.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj0c261ky.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpj0c261ky.jl:43\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpj0c261ky.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj0c261ky.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpj0c261ky.jl:44\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj0c261ky.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj0c261ky.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpj0c261ky.jl:45\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj0c261ky.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj0c261ky.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpj0c261ky.jl:46\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 0] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \ "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj0c261ky.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    small_index, small_value = nothing, nothing\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpdf4syboo.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpdf4syboo.jl:1\n\
    in expression starting at /tmp/tmpdf4syboo.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # check if arr is empty \n    if isempty(arr)\n        return []\n   \
    \ end\n    # check if all elements are odd\n    all_odd = true\n    for i in arr\n\
    \        if iseven(i)\n            all_odd = false\n            break\n      \
    \  end\n    end\n    if all_odd\n        return []\n    end\n    # find smallest\
    \ even number\n    even_nums = arr[iseven.(arr)]\n    return [minimum(even_nums),\
    \ argmin(even_nums) + 1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp19a7wrs_.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 3] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp19a7wrs_.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp19a7wrs_.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp19a7wrs_.jl:60\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp19a7wrs_.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp19a7wrs_.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp19a7wrs_.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp19a7wrs_.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp19a7wrs_.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp19a7wrs_.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp19a7wrs_.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp19a7wrs_.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp19a7wrs_.jl:65\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp19a7wrs_.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(isodd, arr)\n    if isempty(evens)\n        return []\n\
    \    end\n    evens = [arr[i] for i in evens]\n    sorted_evens = sort(evens)\n\
    \    min_even = sorted_evens[1]\n    [min_even, findall(==min_even, arr)[1]]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"==\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpyoax1ru_.jl:42\nin expression starting at\
    \ /tmp/tmpyoax1ru_.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = nothing\n\
    \    min_even_idx = nothing\n    for i in 1:length(arr)\n        if (arr[i] %\
    \ 2 == 0) && (min_even == nothing || arr[i] < min_even)\n            min_even\
    \ = arr[i]\n            min_even_idx = i\n        end\n    end\n    if min_even\
    \ == nothing\n        return []\n    end\n    return [min_even, min_even_idx]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp584b4rfw.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp584b4rfw.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp584b4rfw.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp584b4rfw.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp584b4rfw.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp584b4rfw.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp584b4rfw.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp584b4rfw.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp584b4rfw.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp584b4rfw.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp584b4rfw.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp584b4rfw.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp584b4rfw.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp584b4rfw.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    n = length(arr)\n    i, v = 0, 0\n    if n == 0\n        return [0, 0]\n\
    \    end\n    for j in 1:n\n        if (arr[j] % 2 == 0) && (arr[j] < v || v ==\
    \ 0)\n            i, v = j, arr[j]\n        end\n    end\n    if v == 0\n    \
    \    return [0, 0]\n    end\n    return [v, i]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpn5qagv83.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn5qagv83.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn5qagv83.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpn5qagv83.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpn5qagv83.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn5qagv83.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpn5qagv83.jl:57\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn5qagv83.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn5qagv83.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpn5qagv83.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn5qagv83.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn5qagv83.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpn5qagv83.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 0] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \ "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn5qagv83.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"\"\"\n    Returns the smallest even node in a given array of nodes.\n\
    \    If a node with the same smallest even value is found, return the node that\
    \ has smallest index.\n    If no even values or the given array is empty, return\
    \ [].\n    \"\"\"\n    if isempty(arr)\n        return []\n    end\n    smallest_even\
    \ = [i for i in arr if i % 2 == 0]\n    smallest_even = minimum(smallest_even)\n\
    \    index = findfirst(arr, smallest_even)\n    return [smallest_even, index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpvhn6unfe.jl:53\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvhn6unfe.jl:45\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvhn6unfe.jl:53 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvhn6unfe.jl:52\ntest set:\
    \ Error During Test at /tmp/tmpvhn6unfe.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvhn6unfe.jl:45\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvhn6unfe.jl:54 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvhn6unfe.jl:52\ntest set:\
    \ Error During Test at /tmp/tmpvhn6unfe.jl:56\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvhn6unfe.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    nodes = any(i -> iseven(i), arr)\n    if isempty(nodes)\n        return\
    \ []\n    end\n    smallest = minimum(collect(filter(iseven, arr)))\n    return\
    \ [smallest, findfirst(isequal(smallest), arr)]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp8izf1om0.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8izf1om0.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8izf1om0.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp8izf1om0.jl:48\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8izf1om0.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8izf1om0.jl:46\ntest set: Error\
    \ During Test at /tmp/tmp8izf1om0.jl:49\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError: reducing\
    \ over an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] reduce_empty(op::Function, #unused#::Type{Int64})\n\
    \      @ Base ./reduce.jl:311\n    [3] mapreduce_empty(#unused#::typeof(identity),\
    \ op::Function, T::Type)\n      @ Base ./reduce.jl:345\n    [4] reduce_empty(op::Base.MappingRF{typeof(identity),\
    \ typeof(min)}, #unused#::Type{Int64})\n      @ Base ./reduce.jl:331\n    [5]\
    \ reduce_empty_iter\n      @ ./reduce.jl:357 [inlined]\n    [6] mapreduce_empty_iter(f::Function,\
    \ op::Function, itr::Vector{Int64}, ItrEltype::Base.HasEltype)\n      @ Base ./reduce.jl:353\n\
    \    [7] _mapreduce\n      @ ./reduce.jl:402 [inlined]\n    [8] _mapreduce_dim\n\
    \      @ ./reducedim.jl:330 [inlined]\n    [9] #mapreduce#731\n      @ ./reducedim.jl:322\
    \ [inlined]\n   [10] mapreduce\n      @ ./reducedim.jl:322 [inlined]\n   [11]\
    \ #_minimum#753\n      @ ./reducedim.jl:894 [inlined]\n   [12] _minimum\n    \
    \  @ ./reducedim.jl:894 [inl"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 2 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8izf1om0.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # initial values for min_value, min_index and flag\n    min_value = maximum(arr)\
    \ + 1\n    min_index = length(arr) + 1\n    flag = false\n    # iterate through\
    \ the array\n    for i = 1:length(arr)\n        # check if current value is even\
    \ and smaller than min_value\n        if arr[i] % 2 == 0 && arr[i] < min_value\n\
    \            # we found new min_value, update min_value and min_index\n      \
    \      min_value = arr[i]\n            min_index = i\n            # we found an\
    \ even value\n            flag = true\n        end\n    end\n    # if there are\
    \ no even values\n    if !flag\n        return []\n    else\n        return [min_value,\
    \ min_index]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkvt1gq0k.jl:62\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkvt1gq0k.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkvt1gq0k.jl:61\ntest set: Test\
    \ Failed at /tmp/tmpkvt1gq0k.jl:63\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkvt1gq0k.jl:63 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkvt1gq0k.jl:61\ntest set: Error\
    \ During Test at /tmp/tmpkvt1gq0k.jl:64\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError: reducing\
    \ over an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] reduce_empty(op::Function, #unused#::Type{Int64})\n\
    \      @ Base ./reduce.jl:311\n    [3] mapreduce_empty(#unused#::typeof(identity),\
    \ op::Function, T::Type)\n      @ Base ./reduce.jl:345\n    [4] reduce_empty(op::Base.MappingRF{typeof(identity),\
    \ typeof(max)}, #unused#::Type{Int64})\n      @ Base ./reduce.jl:331\n    [5]\
    \ reduce_empty_iter\n      @ ./reduce.jl:357 [inlined]\n    [6] mapreduce_empty_iter(f::Function,\
    \ op::Function, itr::Vector{Int64}, ItrEltype::Base.HasEltype)\n      @ Base ./reduce.jl:353\n\
    \    [7] _mapreduce\n      @ ./reduce.jl:402 [inlined]\n    [8] _mapreduce_dim\n\
    \      @ ./reducedim.jl:330 [inlined]\n    [9] #mapreduce#731\n      @ ./reducedim.jl:322\
    \ [inlined]\n   [10] mapreduce\n      @ ./reducedim.jl:322 [inlined]\n   [11]\
    \ #_maximum#749\n      @ ./reducedim.jl:894 [inlined]\n   [12] _maximum\n    \
    \  @ ./reducedim.jl:894 [inl"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 6 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkvt1gq0k.jl:59\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"\"\"\n    Takes an array of integers representing a branch of a tree\n\
    \    and returns the smallest even value and its index.\n    If there are no even\
    \ numbers in the array returns [].\n    \"\"\"\n    return findall(x -> x % 2\
    \ == 0, arr)\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdl6ysc76.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [1, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdl6ysc76.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdl6ysc76.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpdl6ysc76.jl:48\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdl6ysc76.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdl6ysc76.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpdl6ysc76.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 4, 5, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdl6ysc76.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdl6ysc76.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpdl6ysc76.jl:51\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdl6ysc76.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdl6ysc76.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpdl6ysc76.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [2, 3, 4, 5] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdl6ysc76.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    @show arr\n    smallest_value = minimum(filter(value -> iseven(value),\
    \ arr))\n    smallest_index = findall(arr .== smallest_value)[1]\n    return [smallest_value,\
    \ smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "arr = [4, 2, 3]\ntest set: Test Failed at /tmp/tmp7j5ttlel.jl:45\n  Expression:\
    \ candidate([4, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7j5ttlel.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7j5ttlel.jl:44\narr = [1, 2, 3]\n\
    test set: Test Failed at /tmp/tmp7j5ttlel.jl:46\n  Expression: candidate([1, 2,\
    \ 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7j5ttlel.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7j5ttlel.jl:44\narr = Int64[]\n\
    test set: Error During Test at /tmp/tmp7j5ttlel.jl:47\n  Test threw exception\n\
    \  Expression: candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError:\
    \ reducing over an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] reduce_empty(op::Function, #unused#::Type{Int64})\n\
    \      @ Base ./reduce.jl:311\n    [3] mapreduce_empty(#unused#::typeof(identity),\
    \ op::Function, T::Type)\n      @ Base ./reduce.jl:345\n    [4] reduce_empty(op::Base.MappingRF{typeof(identity),\
    \ typeof(min)}, #unused#::Type{Int64})\n      @ Base ./reduce.jl:331\n    [5]\
    \ reduce_empty_iter\n      @ ./reduce.jl:357 [inlined]\n    [6] mapreduce_empty_iter(f::Function,\
    \ op::Function, itr::Vector{Int64}, ItrEltype::Base.HasEltype)\n      @ Base ./reduce.jl:353\n\
    \    [7] _mapreduce\n      @ ./reduce.jl:402 [inlined]\n    [8] _mapreduce_dim\n\
    \      @ ./reducedim.jl:330 [inlined]\n    [9] #mapreduce#731\n      @ ./reducedim.jl:322\
    \ [inlined]\n   [10] mapreduce\n      @ ./reducedim.jl:322 [inlined]\n   [11]\
    \ #_minimum#753\n      @ ./reducedim.jl:894 [inlined]\n  "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 2 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7j5ttlel.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_even_value, min_even_value_index = nothing, nothing\n    if !isempty(arr)\n\
    \        i = 1\n        while i <= length(arr)\n            if iseven(arr[i])\n\
    \                if min_even_value == nothing || arr[i] < min_even_value\n   \
    \                 min_even_value = arr[i]\n                    min_even_value_index\
    \ = i\n                end\n            end\n            i += 1\n        end\n\
    \    end\n    return [min_even_value, min_even_value_index]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpp7_h0n8b.jl:55\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] macro\
    \ expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpp7_h0n8b.jl:55 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpp7_h0n8b.jl:54\\ntest set: Test\
    \ Failed at /tmp/tmpp7_h0n8b.jl:56\\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] macro expansion\\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpp7_h0n8b.jl:56 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmpp7_h0n8b.jl:54\\ntest set: Error\
    \ During Test at /tmp/tmpp7_h0n8b.jl:57\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Int64\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:7\\\
    n    convert(::Type{T}, !Matched::Base.TwicePrecision) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/twiceprecision.jl:262\\\
    n    ...\\n  Stacktrace:\\n    [1] setindex!(A::Vector{Int64}, x::Nothing, i1::Int64)\\\
    n      @ Base ./array.jl:903\\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64,\
    \ src::Vector{Nothing}, soffs::Int64, n::Int64)\\n      @ Base ./array.jl:253\\\
    n    [3] unsafe_copyto!\\n      @ ./array.jl:307 [inlined]\\n    [4] _copyto_impl!\\\
    n      @ ./array.jl:331 [inlined]\\n    [5] copyto!\\n      @ ./array.jl:317 [inlined]\\\
    n    [6] copyto!\\n      @ ./array.jl:343 [inlined]\\n  "
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    return [0, 0]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpy8gg8qw2.jl:42\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy8gg8qw2.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy8gg8qw2.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpy8gg8qw2.jl:43\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy8gg8qw2.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy8gg8qw2.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpy8gg8qw2.jl:44\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy8gg8qw2.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy8gg8qw2.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpy8gg8qw2.jl:45\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy8gg8qw2.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy8gg8qw2.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpy8gg8qw2.jl:46\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 0] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \ "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy8gg8qw2.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    smallest = Inf\n    smallestIndex\
    \ = 0\n    for (index, value) in enumerate(arr)\n        if (mod(value, 2) ==\
    \ 0) && (value < smallest)\n            smallest = value\n            smallestIndex\
    \ = index\n        end\n    end\n    if smallest == Inf\n        return []\n \
    \   end\n    return [smallest, smallestIndex]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpu5gf9zr6.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu5gf9zr6.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu5gf9zr6.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpu5gf9zr6.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpu5gf9zr6.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu5gf9zr6.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpu5gf9zr6.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu5gf9zr6.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu5gf9zr6.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpu5gf9zr6.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu5gf9zr6.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu5gf9zr6.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpu5gf9zr6.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu5gf9zr6.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    first_even = nothing\n\
    \    first_even_index = nothing\n    for (i, n) in enumerate(arr)\n        if\
    \ n % 2 == 0 && (first_even == nothing || n < first_even)\n            first_even\
    \ = n\n            first_even_index = i\n        end\n    end\n    if first_even\
    \ == nothing\n        return []\n    end\n    return [first_even, first_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw7qbdyr7.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw7qbdyr7.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw7qbdyr7.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpw7qbdyr7.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpw7qbdyr7.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw7qbdyr7.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpw7qbdyr7.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw7qbdyr7.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw7qbdyr7.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpw7qbdyr7.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw7qbdyr7.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw7qbdyr7.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpw7qbdyr7.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw7qbdyr7.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min = Int64(typemax(Int64))\n\
    \    minidx = 0\n    for i in eachindex(arr)\n        if arr[i] % 2 == 0 && arr[i]\
    \ < min\n            min = arr[i]\n            minidx = i\n        end\n    end\n\
    \    if min == typemax(Int64)\n        return []\n    end\n    return [min, minidx]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeq73ruex.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeq73ruex.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeq73ruex.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpeq73ruex.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpeq73ruex.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeq73ruex.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpeq73ruex.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeq73ruex.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeq73ruex.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpeq73ruex.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeq73ruex.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeq73ruex.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpeq73ruex.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeq73ruex.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    plucked_value::Int64 = -1\n    plucked_index::Int64 = -1\n    for (index,\
    \ value) in enumerate(arr)\n        if (value % 2 == 0) && (plucked_value == -1\
    \ || value < plucked_value)\n            plucked_value = value\n            plucked_index\
    \ = index\n        end\n    end\n    return [plucked_value, plucked_index]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1pebe_t9.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1pebe_t9.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1pebe_t9.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp1pebe_t9.jl:51\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp1pebe_t9.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1pebe_t9.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp1pebe_t9.jl:52\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [-1, -1] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1pebe_t9.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1pebe_t9.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp1pebe_t9.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1pebe_t9.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1pebe_t9.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp1pebe_t9.jl:54\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1pebe_t9.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return [0,0]\n    end\n    lowestEven = (arr[1]\
    \ % 2 == 0) ? arr[1] : Inf\n    evenIndex = 1\n    for i in 2:length(arr)\n  \
    \      if (arr[i] % 2 == 0) && (arr[i] < lowestEven)\n            lowestEven =\
    \ arr[i]\n            evenIndex = i\n        end\n    end\n    if lowestEven ==\
    \ Inf\n        return [0,0]\n    end\n    return [lowestEven, evenIndex]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpauz71ika.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpauz71ika.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpauz71ika.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpauz71ika.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpauz71ika.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpauz71ika.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpauz71ika.jl:58\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpauz71ika.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpauz71ika.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpauz71ika.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpauz71ika.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpauz71ika.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpauz71ika.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \ "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpauz71ika.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_index = []\n   \
    \ for i = 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_index,\
    \ i)\n        end\n    end\n    if isempty(even_index)\n        return []\n  \
    \  end\n    even_value = minimum(even_index)\n    ans = [arr[even_value], even_value]\n\
    \    return ans\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7aa6ijzl.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [4, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7aa6ijzl.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7aa6ijzl.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp7aa6ijzl.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7aa6ijzl.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7aa6ijzl.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp7aa6ijzl.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7aa6ijzl.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7aa6ijzl.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp7aa6ijzl.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7aa6ijzl.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7aa6ijzl.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp7aa6ijzl.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7aa6ijzl.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_idx = 0\n    min_val = 0\n    seen_zero = false\n    for i = 1:length(arr)\n\
    \        if arr[i] % 2 == 0\n            if arr[i] == 0 && !seen_zero\n      \
    \          min_idx = i\n                min_val = arr[i]\n                seen_zero\
    \ = true\n            elseif arr[i] < min_val\n                min_idx = i\n \
    \               min_val = arr[i]\n            end\n        end\n    end\n    if\
    \ min_idx == 0 || min_val == 0\n        return [min_val, min_idx]\n    else\n\
    \        return []\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkfbzzoyy.jl:61\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkfbzzoyy.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkfbzzoyy.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpkfbzzoyy.jl:62\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkfbzzoyy.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkfbzzoyy.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpkfbzzoyy.jl:63\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkfbzzoyy.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkfbzzoyy.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpkfbzzoyy.jl:64\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkfbzzoyy.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkfbzzoyy.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpkfbzzoyy.jl:65\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \ "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkfbzzoyy.jl:58\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    smallest_value = Inf\n\
    \    smallest_index = Inf\n    for (idx, item) in enumerate(arr)\n        if item\
    \ % 2 == 0\n            if item < smallest_value\n                smallest_value\
    \ = item\n                smallest_index = idx\n            end\n        end\n\
    \    end\n    if smallest_value == Inf\n        return []\n    end\n    return\
    \ [smallest_value, smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp69hzffnh.jl:58\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp69hzffnh.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp69hzffnh.jl:57\ntest set: Test\
    \ Failed at /tmp/tmp69hzffnh.jl:59\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp69hzffnh.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp69hzffnh.jl:57\ntest set: Test\
    \ Failed at /tmp/tmp69hzffnh.jl:61\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp69hzffnh.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp69hzffnh.jl:57\ntest set: Test\
    \ Failed at /tmp/tmp69hzffnh.jl:62\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp69hzffnh.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp69hzffnh.jl:57\ntest set: Test\
    \ Failed at /tmp/tmp69hzffnh.jl:63\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp69hzffnh.jl:55\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Create a minimum variable\n    minimum = Inf\n    # Create a second\
    \ minimum variable\n    second_minimum = Inf\n    # Create the index variable\n\
    \    index = -1\n    # Create the second index variable\n    second_index = -1\n\
    \    # Create the array that we'll be returning\n    output = [minimum, index]\n\
    \    # Loop through the array\n    for i in 1:length(arr)\n        # Check if\
    \ the current number is even\n        if (rem(arr[i], 2) == 0) && (arr[i] < minimum)\n\
    \            # We have a new minimum\n            second_minimum = minimum\n \
    \           # Change the minimum to the new minimum\n            minimum = arr[i]\n\
    \            # We have a new index\n            second_index = index\n       \
    \     # Change the index to the new index\n            index = i\n        elseif\
    \ (rem(arr[i], 2) == 0) && (arr[i] < second_minimum)\n            # We have a\
    \ new second minimum\n            second_minimum = arr[i]\n            # Change\
    \ the second index to the new index\n            second_index = i\n        end\n\
    \    end\n    # Check if the minimum is not the same as the input\n    if (minimum\
    \ != Inf)\n        # If it's not, change the output to the new values\n      \
    \  output = [minimum, index]\n    elseif (second_minimum != Inf)\n        # If\
    \ the minimum is the same as the input, check if the second minimum is not the\
    \ same as the input\n        # If it's not, change the output to the new values\n\
    \        output = [second_minimum, second_index]\n    end\n    # Return the output\n\
    \    return output\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdlzbjyd2.jl:81\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdlzbjyd2.jl:81 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdlzbjyd2.jl:80\ntest set: Test\
    \ Failed at /tmp/tmpdlzbjyd2.jl:82\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdlzbjyd2.jl:82 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdlzbjyd2.jl:80\ntest set: Error\
    \ During Test at /tmp/tmpdlzbjyd2.jl:83\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  InexactError: Int64(Inf)\n\
    \  Stacktrace:\n    [1] Int64\n      @ ./float.jl:812 [inlined]\n    [2] convert\n\
    \      @ ./number.jl:7 [inlined]\n    [3] setindex!\n      @ ./array.jl:903 [inlined]\n\
    \    [4] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64, src::Vector{Float64},\
    \ soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n    [5] unsafe_copyto!\n\
    \      @ ./array.jl:307 [inlined]\n    [6] _copyto_impl!\n      @ ./array.jl:331\
    \ [inlined]\n    [7] copyto!\n      @ ./array.jl:317 [inlined]\n    [8] copyto!\n\
    \      @ ./array.jl:343 [inlined]\n    [9] copyto_axcheck!\n      @ ./abstractarray.jl:1104\
    \ [inlined]\n   [10] Vector{Int64}(x::Vector{Float64})\n      @ Base ./array.jl:563\n\
    \   [11] convert\n      @ ./array.jl:554 [inlined]\n   [12] pluck(arr::Vector{Int64})\n\
    \      @ Main /tmp/tmpdlzbjyd2.jl:74\n   [13] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [14] macro expansion\n      @ /tmp/tmpdlzbjyd2.jl:83 [inlined]\n\
    \   [15] macro exp"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 2 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdlzbjyd2.jl:78\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0 || all(mod.(arr, 2) .!= 0)\n        return Vector{Int64}()\n\
    \    end\n    even_array = arr[mod.(arr, 2) .== 0]\n    least_value = minimum(even_array)\n\
    \    least_index = findfirst(arr, least_value)\n    return [least_value, least_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp185al2n5.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp185al2n5.jl:40\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp185al2n5.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp185al2n5.jl:47\ntest set:\
    \ Error During Test at /tmp/tmp185al2n5.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp185al2n5.jl:40\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp185al2n5.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp185al2n5.jl:47\ntest set:\
    \ Error During Test at /tmp/tmp185al2n5.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp185al2n5.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    @assert(1 <= length(arr) <= 10000, \"nodes.length is not in the allowed\
    \ range\")\n    @assert(all(0 <= i <= 10000 for i in arr), \"node.value is not\
    \ in the allowed range\")\n    if isempty(arr)\n        return []\n    end\n \
    \   num_arr = filter(x -> x % 2 == 0, arr)\n    if isempty(num_arr)\n        return\
    \ []\n    end\n    smallest_num = minimum(num_arr)\n    smallest_ind = findall(arr\
    \ .== smallest_num)[1]\n    return [smallest_num, smallest_ind]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpv2_44xbg.jl:53\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv2_44xbg.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv2_44xbg.jl:52\ntest set: Test\
    \ Failed at /tmp/tmpv2_44xbg.jl:54\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpv2_44xbg.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv2_44xbg.jl:52\ntest set: Error\
    \ During Test at /tmp/tmpv2_44xbg.jl:55\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  AssertionError: nodes.length\
    \ is not in the allowed range\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpv2_44xbg.jl:35\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpv2_44xbg.jl:55 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpv2_44xbg.jl:52\ntest set:\
    \ Test Failed at /tmp/tmpv2_44xbg.jl:56\n  Expression: candidate([5, 0, 3, 0,\
    \ 4, 2]) == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv2_44xbg.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv2_44xbg.jl:52\ntest set: Test\
    \ Failed at "
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 6 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv2_44xbg.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0 \n        return []\n    end\n    smallest_index =\
    \ length(arr) + 1\n    smallest_value = typemax(Int64)\n    for i in 1:length(arr)\n\
    \        if arr[i] < smallest_value && arr[i] % 2 == 0\n            smallest_value\
    \ = arr[i]\n            smallest_index = i\n        end\n    end\n    if smallest_index\
    \ == length(arr) + 1\n        return []\n    end\n    return [smallest_value,\
    \ smallest_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpa0qsxezo.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa0qsxezo.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa0qsxezo.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpa0qsxezo.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpa0qsxezo.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa0qsxezo.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpa0qsxezo.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa0qsxezo.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa0qsxezo.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpa0qsxezo.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa0qsxezo.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa0qsxezo.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpa0qsxezo.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa0qsxezo.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = []\n    for (idx, val) in enumerate(arr)\n        if(val % 2 ==\
    \ 0)\n            push!(even, [val, idx])\n        end\n    end\n    return sort!(even)[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0n4n40z9.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0n4n40z9.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0n4n40z9.jl:47\ntest set: Test\
    \ Failed at /tmp/tmp0n4n40z9.jl:49\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0n4n40z9.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0n4n40z9.jl:47\ntest set: Error\
    \ During Test at /tmp/tmp0n4n40z9.jl:50\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Any} at index [1]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp0n4n40z9.jl:41\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp0n4n40z9.jl:50 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp0n4n40z9.jl:47\ntest set:\
    \ Test Failed at /tmp/tmp0n4n40z9.jl:51\n  Expression: candidate([5, 0, 3, 0,\
    \ 4, 2]) == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0n4n40z9.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level sc"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 2 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0n4n40z9.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # find first even\n    first_even_idx = findfirst(x -> x % 2 == 0, arr)\n\
    \    return first_even_idx > 0 ? Vector{Int64}([arr[first_even_idx], first_even_idx])\
    \ : Vector{Int64}()\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyznoljws.jl:44\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [4, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyznoljws.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyznoljws.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpyznoljws.jl:45\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpyznoljws.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyznoljws.jl:43\ntest set: Error\
    \ During Test at /tmp/tmpyznoljws.jl:46\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  MethodError: no method\
    \ matching isless(::Int64, ::Nothing)\n  Closest candidates are:\n    isless(::Real,\
    \ !Matched::AbstractFloat) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:185\n\
    \    isless(::Real, !Matched::Real) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:430\n\
    \    isless(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:88\n\
    \    ...\n  Stacktrace:\n   [1] <(x::Int64, y::Nothing)\n     @ Base ./operators.jl:352\n\
    \   [2] >(x::Nothing, y::Int64)\n     @ Base ./operators.jl:378\n   [3] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpyznoljws.jl:37\n   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpyznoljws.jl:46 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpyznoljws.jl:43\ntest set:\
    \ Test Failed at /tmp"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 2 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyznoljws.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if arr == []\n        return []\n    end\n    smallestValue = arr[1]\n\
    \    smallestIndex = 1\n    for (idx, value) in enumerate(arr)\n        if value\
    \ < smallestValue && value % 2 == 0\n            smallestValue = value\n     \
    \       smallestIndex = idx\n        end\n    end\n    return [smallestValue,\
    \ smallestIndex]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp10xj44x8.jl:53\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp10xj44x8.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp10xj44x8.jl:52\ntest set: Test\
    \ Failed at /tmp/tmp10xj44x8.jl:54\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [1, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp10xj44x8.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp10xj44x8.jl:52\ntest set: Test\
    \ Failed at /tmp/tmp10xj44x8.jl:56\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp10xj44x8.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp10xj44x8.jl:52\ntest set: Test\
    \ Failed at /tmp/tmp10xj44x8.jl:57\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp10xj44x8.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp10xj44x8.jl:52\ntest set: Test\
    \ Failed at /tmp/tmp10xj44x8.jl:58\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp10xj44x8.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    low = findall(i -> i%2 == 0, arr)\n    if length(low) == 0\n        return\
    \ []\n    end\n    return [minimum(low), indmin(low)]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpekvn7ieb.jl:46\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: indmin not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpekvn7ieb.jl:39\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpekvn7ieb.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpekvn7ieb.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpekvn7ieb.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: indmin not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpekvn7ieb.jl:39\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpekvn7ieb.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpekvn7ieb.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpekvn7ieb.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: indmin not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpekvn7ieb.jl:39\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpekvn7ieb.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpekvn7ieb.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpekvn7ieb.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: indmin not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpekvn7ieb.jl:39\n\
    \   [2] macro expansion\n     @ /shared/cen"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpekvn7ieb.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = findall(isodd, arr)\n    arr = arr[evens]\n    idx = minimum(evens)\n\
    \    if length(arr) == 0\n        return [0]\n    else\n        return [minimum(arr),\
    \ idx]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_3j60fv9.jl:49\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [3, 3] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_3j60fv9.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_3j60fv9.jl:48\ntest set: Test\
    \ Failed at /tmp/tmp_3j60fv9.jl:50\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [1, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_3j60fv9.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_3j60fv9.jl:48\ntest set: Error\
    \ During Test at /tmp/tmp_3j60fv9.jl:51\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError: reducing\
    \ over an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] reduce_empty(op::Function, #unused#::Type{Int64})\n\
    \      @ Base ./reduce.jl:311\n    [3] mapreduce_empty(#unused#::typeof(identity),\
    \ op::Function, T::Type)\n      @ Base ./reduce.jl:345\n    [4] reduce_empty(op::Base.MappingRF{typeof(identity),\
    \ typeof(min)}, #unused#::Type{Int64})\n      @ Base ./reduce.jl:331\n    [5]\
    \ reduce_empty_iter\n      @ ./reduce.jl:357 [inlined]\n    [6] mapreduce_empty_iter(f::Function,\
    \ op::Function, itr::Vector{Int64}, ItrEltype::Base.HasEltype)\n      @ Base ./reduce.jl:353\n\
    \    [7] _mapreduce\n      @ ./reduce.jl:402 [inlined]\n    [8] _mapreduce_dim\n\
    \      @ ./reducedim.jl:330 [inlined]\n    [9] #mapreduce#731\n      @ ./reducedim.jl:322\
    \ [inlined]\n   [10] mapreduce\n      @ ./reducedim.jl:322 [inlined]\n   [11]\
    \ #_minimum#753\n      @ ./reducedim.jl:894 [inlined]\n   [12] _minimum\n    \
    \  @ ./reducedim.jl:894 [inl"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 7 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_3j60fv9.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_arr = filter(x -> x % 2 == 0, arr)\n    return [minimum(even_arr),\
    \ indexin(even_arr, minimum(even_arr))]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpdsrot4gn.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ indexin(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    indexin(::Any,\
    \ !Matched::AbstractArray) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:2352\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpdsrot4gn.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdsrot4gn.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdsrot4gn.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpdsrot4gn.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching indexin(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    indexin(::Any, !Matched::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:2352\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpdsrot4gn.jl:36\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdsrot4gn.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdsrot4gn.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpdsrot4gn.jl:45\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError: reducing\
    \ over an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] reduce_empty(op::Function, #unused#::Type{Int64})\n\
    \      @ Base ./reduce.jl:311\n    [3] mapreduce_empty(#unused#::typeof(identity),\
    \ op::Function, T::Type)\n      @ Base ./reduce.jl:345\n    [4] reduce_empty(op::Base.MappingRF{typeof(identity),\
    \ typeof(min)}, #unused#::T"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdsrot4gn.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_index = Inf\n    for i in eachindex(arr)\n        if arr[i] == 0\n  \
    \          if i < min_index\n                min_index = i\n                min_even\
    \ = 0\n            end\n        elseif arr[i]%2 == 0 && arr[i] < min_even\n  \
    \          min_even = arr[i]\n            min_index = i\n        end\n    end\n\
    \    if min_even == Inf\n        return []\n    end\n    return [min_even, min_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpccqan7rg.jl:61\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpccqan7rg.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpccqan7rg.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpccqan7rg.jl:62\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpccqan7rg.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpccqan7rg.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpccqan7rg.jl:64\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpccqan7rg.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpccqan7rg.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpccqan7rg.jl:65\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpccqan7rg.jl:65 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpccqan7rg.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpccqan7rg.jl:66\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpccqan7rg.jl:58\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    # check if vector is empty\n    if isempty(arr)\n        return\
    \ []\n    end\n    \n    # create a array that stores the even numbers index\n\
    \    even_index = []\n    \n    # create a array that stores the even numbers\n\
    \    even_numbers = []\n    \n    # loop through each element in the given array\n\
    \    for i in eachindex(arr)\n        \n        # check if current element is\
    \ even\n        if iseven(arr[i])\n            \n            # append current\
    \ element index\n            push!(even_index, i)\n            \n            #\
    \ append current element value\n            push!(even_numbers, arr[i])\n    \
    \    end\n    end\n    \n    # check if the even_numbers array is empty\n    if\
    \ isempty(even_numbers)\n        return []\n    end\n    \n    # find the index\
    \ of the minimum value\n    min_index = argmin(even_numbers)\n    \n    # return\
    \ the smallest even value and its index\n    return [even_numbers[min_index],\
    \ even_index[min_index]]\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqy8rma7b.jl:78\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqy8rma7b.jl:78 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqy8rma7b.jl:77\ntest set: Test\
    \ Failed at /tmp/tmpqy8rma7b.jl:79\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqy8rma7b.jl:79 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqy8rma7b.jl:77\ntest set: Test\
    \ Failed at /tmp/tmpqy8rma7b.jl:81\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqy8rma7b.jl:81 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqy8rma7b.jl:77\ntest set: Test\
    \ Failed at /tmp/tmpqy8rma7b.jl:82\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqy8rma7b.jl:82 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqy8rma7b.jl:77\ntest set: Test\
    \ Failed at /tmp/tmpqy8rma7b.jl:83\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqy8rma7b.jl:75\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nums = Int64[]\n\
    \    indexes = Int64[]\n    for i in 1:length(arr)\n        if rem(arr[i], 2)\
    \ == 0\n            push!(even_nums, arr[i])\n            push!(indexes, i)\n\
    \        end\n    end\n    if isempty(even_nums)\n        return []\n    end\n\
    \    min_index = findmin(even_nums)[2]\n    return [even_nums[min_index], indexes[min_index]]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphrwdvi_p.jl:57\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphrwdvi_p.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphrwdvi_p.jl:56\ntest set: Test\
    \ Failed at /tmp/tmphrwdvi_p.jl:58\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmphrwdvi_p.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphrwdvi_p.jl:56\ntest set: Test\
    \ Failed at /tmp/tmphrwdvi_p.jl:60\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphrwdvi_p.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphrwdvi_p.jl:56\ntest set: Test\
    \ Failed at /tmp/tmphrwdvi_p.jl:61\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphrwdvi_p.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphrwdvi_p.jl:56\ntest set: Test\
    \ Failed at /tmp/tmphrwdvi_p.jl:62\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphrwdvi_p.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    result = []\n    even_values = []\n    even_values_positions = []\n  \
    \  if isempty(arr) || !(any(x -> x % 2 == 0, arr))\n        return result\n  \
    \  end\n    # get positions of even elements\n    for (i, v) in enumerate(arr)\n\
    \        if v % 2 == 0\n            push!(even_values, v)\n            push!(even_values_positions,\
    \ i)\n        end\n    end\n    # get position of minimum even element\n    result_position\
    \ = even_values_positions[indmin(even_values)]\n    push!(result, arr[result_position])\n\
    \    push!(result, result_position)\n    return result\nend\n# Test cases\n@testset\
    \ \"Example 1\" begin\n    @test pluck([4,2,3]) == [2, 1]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @testset not defined\nin expression starting\
    \ at /tmp/tmpl1yshtqb.jl:55\nin expression starting at /tmp/tmpl1yshtqb.jl:55\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr) || length(arr) == 0\n        return []\n    end\n    if\
    \ length(arr) > 10000\n        return []\n    end\n    # check if array contains\
    \ non-negative elements\n    for num in arr\n        if num < 0\n            return\
    \ []\n        end\n    end\n    evens = []\n    for num in arr\n        if num\
    \ % 2 == 0\n            push!(evens, num)\n        end\n    end\n    if isempty(evens)\n\
    \        return []\n    end\n    min_even = minimum(evens)\n    return [min_even,\
    \ findfirst(arr, min_even)]\nend\n \nprintln(pluck([4,2,3])) # [2, 1]\nprintln(pluck([1,2,3]))\
    \ # [2, 1]\nprintln(pluck([])) # []\nprintln(pluck([5, 0, 3, 0, 4, 2])) # [0,\
    \ 1]\nprintln(pluck([-3,2,3])) # []\nprintln(pluck([4,2,3, 4,2,3, 4,2,3, 4,2,3,\
    \ 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3,\
    \ 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3,\
    \ 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3,\
    \ 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,3, 4,2,\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: None
  stderr: "b'ERROR: LoadError: MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\nClosest candidates are:\\n  findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\\n  findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\\n  findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\\nStacktrace:\\\
    n [1] pluck(arr::Vector{Int64})\\n   @ '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # (1) find the minimum even number \n    is_even(n) = n % 2 == 0\n   \
    \ min_even_value = minimum(filter(is_even, arr))\n    if(min_even_value == Inf)\n\
    \        return []\n    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwflmzcbw.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwflmzcbw.jl:1\n\
    in expression starting at /tmp/tmpwflmzcbw.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr) || length(arr) == 0\n        return []\n    end\n    min_val\
    \ = Inf\n    result = []\n    for (i, v) in enumerate(arr)\n        if v % 2 ==\
    \ 0 && v < min_val\n            min_val = v\n            result = [min_val, i]\n\
    \        end\n    end\n    if min_val == Inf\n        return []\n    end\n   \
    \ return result\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmuleaguq.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmuleaguq.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmuleaguq.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpmuleaguq.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpmuleaguq.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmuleaguq.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpmuleaguq.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmuleaguq.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmuleaguq.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpmuleaguq.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmuleaguq.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmuleaguq.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpmuleaguq.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmuleaguq.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    return pluck_node(arr,\
    \ 1, (arr[1], 1))\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpd_wrk_z6.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: pluck_node not\
    \ defined\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpd_wrk_z6.jl:38\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_wrk_z6.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd_wrk_z6.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpd_wrk_z6.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: pluck_node not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpd_wrk_z6.jl:38\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_wrk_z6.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd_wrk_z6.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpd_wrk_z6.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: pluck_node not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpd_wrk_z6.jl:38\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_wrk_z6.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd_wrk_z6.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpd_wrk_z6.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: pluck_node not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpd_wrk_z6.jl:38\n\
    \   [2] macro expansion\n  "
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd_wrk_z6.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"\"\"Function that given an array representing a branch of a tree with\
    \ non-negative integer nodes\n    returns the node with the smallest even value\
    \ and its index. If there are no even values or the \n    given array is empty,\
    \ return [].\n    \"\"\"\n    is_not_empty = size(arr)[1] > 0\n    is_not_all_odd\
    \ = length(findall(isodd, arr)) < length(arr)\n    if is_not_empty && is_not_all_odd\n\
    \        evens = arr[findall(iseven, arr)]\n        min_even = minimum(evens)\n\
    \        min_even_index = findfirst(isequal(min_even), arr)\n        return [min_even,\
    \ min_even_index]\n    else\n        return []\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmps7stynyo.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmps7stynyo.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps7stynyo.jl:54\ntest set: Test\
    \ Failed at /tmp/tmps7stynyo.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmps7stynyo.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps7stynyo.jl:54\ntest set: Test\
    \ Failed at /tmp/tmps7stynyo.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmps7stynyo.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps7stynyo.jl:54\ntest set: Test\
    \ Failed at /tmp/tmps7stynyo.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmps7stynyo.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps7stynyo.jl:54\ntest set: Test\
    \ Failed at /tmp/tmps7stynyo.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps7stynyo.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = filter(x -> iseven(x), arr)\n    if length(even) == 0\n       \
    \ return []\n    end\n    return [minimum(even), findall(x -> x == minimum(even),\
    \ arr)[1]]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpes5jnyco.jl:46\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpes5jnyco.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpes5jnyco.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpes5jnyco.jl:47\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpes5jnyco.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpes5jnyco.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpes5jnyco.jl:49\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpes5jnyco.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpes5jnyco.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpes5jnyco.jl:50\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpes5jnyco.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpes5jnyco.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpes5jnyco.jl:51\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpes5jnyco.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    return vec([])\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvbs96c5g.jl:42\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvbs96c5g.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvbs96c5g.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpvbs96c5g.jl:43\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvbs96c5g.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvbs96c5g.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpvbs96c5g.jl:45\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvbs96c5g.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvbs96c5g.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpvbs96c5g.jl:46\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvbs96c5g.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvbs96c5g.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpvbs96c5g.jl:47\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shar"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvbs96c5g.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    return [i for i in arr if i%2==0]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpqcwe1mc1.jl:42\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [4, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqcwe1mc1.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqcwe1mc1.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpqcwe1mc1.jl:43\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqcwe1mc1.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqcwe1mc1.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpqcwe1mc1.jl:45\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0, 4, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqcwe1mc1.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqcwe1mc1.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpqcwe1mc1.jl:46\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 0] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqcwe1mc1.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqcwe1mc1.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpqcwe1mc1.jl:47\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 8, 4, 8] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqcwe1mc1.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(n -> iseven(n), arr)\n    evens == [] && return []\n  \
    \  min_n = minimum(evens)\n    min_index = findall(arr .== min_n)[1]\n    [min_n,\
    \ min_index]\nend\n@testset \"Example 1\" begin\n    @test pluck([4,2,3]) == [2,\
    \ 1]\nend\n@testset \"Example 2\" begin\n    @test pluck([1,2,3]) == [2, 1]\n\
    end\n@testset \"Example 3\" begin\n    @test pluck([]) == []\nend\n@testset \"\
    Example 4\" begin\n    @test pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\nend\n@testset\
    \ \"More tests\" begin\n    @test pluck([0, 1, 2, 4, 4, 6, 6, 8, 9, 10]) == [0,\
    \ 1]\n    @test pluck([4, 4, 4, 4, 4, 4, 4, 4, 4, 4]) == [4, 1]\n    @test pluck([4,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9]) == [2, 3]\n    @test pluck([4, 4, 4, 4, 4, 4, 4,\
    \ 4, 4, 0]) == [0, 10]\n    @test pluck([5, 5, 5, 5, 5, 5, 5, 5, 5, 0]) == [0,\
    \ 10]\n    @test pluck([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == [0, 1]\n    @test pluck([5,\
    \ 4, 3, 2, 1, 0, 7, 8, 9, 10]) == [0, 6]\n    @test pluck([0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9]) == [0, 1]\n    @test pluck([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == [0,\
    \ 1]\n    @test pluck([1, 3, 5, 7, 9, 1, 3, 5\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @testset not defined\nin expression starting\
    \ at /tmp/tmpe9lec2du.jl:41\nin expression starting at /tmp/tmpe9lec2du.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"\"\"\n    Args:\n        arr: Array representing a branch of a tree\n\
    \    \n    Returns:\n        An array containing the smallest even value in the\
    \ array, and its index.\n        If there are no even values or the given array\
    \ is empty, return [].\n    \"\"\"\n    if !isempty(arr)\n        min = 0\n  \
    \      min_i = 0\n        for i in eachindex(arr)\n            if mod(arr[i],\
    \ 2) == 0 && (min == 0 || arr[i] < min)\n                min = arr[i]\n      \
    \          min_i = i\n            end\n        end\n        if min != 0\n    \
    \        return [min, min_i]\n        end\n    end\n    return []\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppftjfic3.jl:63\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppftjfic3.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppftjfic3.jl:62\ntest set: Test\
    \ Failed at /tmp/tmppftjfic3.jl:64\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmppftjfic3.jl:64 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppftjfic3.jl:62\ntest set: Test\
    \ Failed at /tmp/tmppftjfic3.jl:66\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppftjfic3.jl:66 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppftjfic3.jl:62\ntest set: Test\
    \ Failed at /tmp/tmppftjfic3.jl:67\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppftjfic3.jl:67 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppftjfic3.jl:62\ntest set: Test\
    \ Failed at /tmp/tmppftjfic3.jl:68\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/c"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppftjfic3.jl:60\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    # If the array is empty, we return an empty array\n    if length(arr)\
    \ == 0\n        return []\n    end\n    \n    # Get the minimum even element in\
    \ the array.\n    smallest_value::Int64 = minimum(filter(is_even, arr))\n    \n\
    \    # We only have to find the first index of the element of interest.\n    smallest_index::Int64\
    \ = findfirst(arr .== smallest_value)[1]\n    \n    # And return the smallest\
    \ value in a list.\n    return [smallest_value, smallest_index]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp28nr38b2.jl:55\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: is_even not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp28nr38b2.jl:42\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp28nr38b2.jl:55 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp28nr38b2.jl:54\ntest set:\
    \ Error During Test at /tmp/tmp28nr38b2.jl:56\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: is_even not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp28nr38b2.jl:42\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp28nr38b2.jl:56 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp28nr38b2.jl:54\ntest set:\
    \ Error During Test at /tmp/tmp28nr38b2.jl:58\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: is_even not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp28nr38b2.jl:42\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp28nr38b2.jl:58 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp28nr38b2.jl:54\ntest set:\
    \ Error During Test at /tmp/tmp28nr38b2.jl:59\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: is_even not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp28nr38b2.jl:42\n\
    \   [2] macro expansion\n     @ /shared"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp28nr38b2.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    sort(filter(isEven, arr))[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxkkud7j_.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: isEven not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxkkud7j_.jl:38\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxkkud7j_.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxkkud7j_.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpxkkud7j_.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: isEven not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxkkud7j_.jl:38\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxkkud7j_.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxkkud7j_.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpxkkud7j_.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: isEven not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxkkud7j_.jl:38\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxkkud7j_.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxkkud7j_.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpxkkud7j_.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: isEven not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxkkud7j_.jl:38\n\
    \   [2] macro expansion\n     @ /shared/cen"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxkkud7j_.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    arr_evens = [v for v in arr if iseven(v)]\n    if isempty(arr_evens)\n\
    \        return []\n    end\n    smallest_value = minimum(arr_evens)\n    return\
    \ [smallest_value, findfirst(arr, smallest_value)]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp5843j6d1.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp5843j6d1.jl:40\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5843j6d1.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5843j6d1.jl:46\ntest set:\
    \ Error During Test at /tmp/tmp5843j6d1.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp5843j6d1.jl:40\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5843j6d1.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5843j6d1.jl:46\ntest set:\
    \ Error During Test at /tmp/tmp5843j6d1.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5843j6d1.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr) || !any(x -> iseven(x), arr)\n        return Vector{Int64}()\n\
    \    end\n    min_even = Array{Int64, 1}(undef, 1)\n    min_even[1] = maximum(Int64)\n\
    \    min_index = Array{Int64, 1}(undef, 1)\n    index = 0\n    for i in arr\n\
    \        index += 1\n        if iseven(i) && i < min_even[1]\n            min_even[1]\
    \ = i\n            min_index[1] = index\n        end\n    end\n    return [min_even[1],\
    \ min_index[1]]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6acequ2j.jl:56\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ iterate(::Type{Int64})\n  Closest candidates are:\n    iterate(!Matched::Union{LinRange,\
    \ StepRangeLen}) at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:826\n\
    \    iterate(!Matched::Union{LinRange, StepRangeLen}, !Matched::Integer) at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:826\n\
    \    iterate(!Matched::T) where T<:Union{Base.KeySet{<:Any, <:Dict}, Base.ValueIterator{<:Dict}}\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/dict.jl:695\n    ...\n  Stacktrace:\n\
    \    [1] _foldl_impl(op::Base.BottomRF{typeof(max)}, init::Base._InitialValue,\
    \ itr::Type)\n      @ Base ./reduce.jl:56\n    [2] foldl_impl(op::Base.BottomRF{typeof(max)},\
    \ nt::Base._InitialValue, itr::Type)\n      @ Base ./reduce.jl:48\n    [3] mapfoldl_impl(f::typeof(identity),\
    \ op::typeof(max), nt::Base._InitialValue, itr::Type)\n      @ Base ./reduce.jl:44\n\
    \    [4] #mapfoldl#244\n      @ ./reduce.jl:162 [inlined]\n    [5] mapfoldl\n\
    \      @ ./reduce.jl:162 [inlined]\n    [6] #mapreduce#248\n      @ ./reduce.jl:289\
    \ [inlined]\n    [7] mapreduce\n      @ ./reduce.jl:289 [inlined]\n    [8] #maximum#258\n\
    \      @ ./reduce.jl:737 [inlined]\n    [9] maximum(a::Type)\n      @ Base ./reduce.jl:737\n\
    \   [10] pluck(arr::Vector{Int64})\n      @ Main /tmp/tmp6acequ2j.jl:39\n   [11]\
    \ macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [12] macro expansion\n      @ /tmp/tmp6acequ2j.jl:56 [inlined]\n\
    \   [13] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [14] top-level scope\n      @ /tmp/tmp6acequ2j.jl:55\ntest set:\
    \ Error During Test at /tmp/tmp6acequ2j.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching iterate(::Type{Int64})\n\
    \  Closest candidates are:\n    iterate(!Matched::Union{LinRange, StepRangeLen})\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:826"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6acequ2j.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_even = MAX_INT64\n    min_idx = 0\n    if length(arr) > 0\n      \
    \  for (i, val) in enumerate(arr)\n            if val % 2 == 0 && val < min_even\n\
    \                min_even = val\n                min_idx = i\n            end\n\
    \        end\n    end\n    if min_even == MAX_INT64\n        return []\n    else\n\
    \        return [min_even, min_idx + 1]\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp4mkwgjxa.jl:56\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: MAX_INT64 not\
    \ defined\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp4mkwgjxa.jl:35\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4mkwgjxa.jl:56 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4mkwgjxa.jl:55\ntest set:\
    \ Error During Test at /tmp/tmp4mkwgjxa.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: MAX_INT64 not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp4mkwgjxa.jl:35\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4mkwgjxa.jl:57 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4mkwgjxa.jl:55\ntest set:\
    \ Error During Test at /tmp/tmp4mkwgjxa.jl:58\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError: MAX_INT64\
    \ not defined\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp4mkwgjxa.jl:35\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4mkwgjxa.jl:58 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4mkwgjxa.jl:55\ntest set:\
    \ Error During Test at /tmp/tmp4mkwgjxa.jl:59\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: MAX_INT64 not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp4mkwgjxa.jl:35\n\
    \   [2] macro expans"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4mkwgjxa.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Array checking\n    if length(arr) == 0 return [] end\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpx09ucrlm.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpx09ucrlm.jl:1\n\
    in expression starting at /tmp/tmpx09ucrlm.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [arr[i] for i\
    \ in 1:length(arr) if rem(arr[i], 2) == 0]\n    if isempty(evens)\n        return\
    \ []\n    end\n    return [minimum(evens), findfirst(x -> x == minimum(evens),\
    \ arr)]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpz2i1dznq.jl:49\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz2i1dznq.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz2i1dznq.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpz2i1dznq.jl:50\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpz2i1dznq.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz2i1dznq.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpz2i1dznq.jl:52\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz2i1dznq.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz2i1dznq.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpz2i1dznq.jl:53\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz2i1dznq.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz2i1dznq.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpz2i1dznq.jl:54\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz2i1dznq.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    n = size(arr, 1)\n    if n == 0\n        return []\n    end\n    mins\
    \ = Int64[]\n    for i in 1:n\n        if rem(arr[i], 2) == 0\n            push!(mins,\
    \ arr[i])\n        end\n    end\n    for i in 1:n\n        if (rem(arr[i], 2)\
    \ == 0) && (arr[i] == minimum(mins))\n            return [arr[i], i]\n       \
    \ end\n    end\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpmogfv01o.jl:57\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmogfv01o.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmogfv01o.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpmogfv01o.jl:58\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpmogfv01o.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmogfv01o.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpmogfv01o.jl:60\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmogfv01o.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmogfv01o.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpmogfv01o.jl:61\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmogfv01o.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmogfv01o.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpmogfv01o.jl:62\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmogfv01o.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    i = 0\n    min_even = 10000\n    min_even_index = 0\n    while i <= length(arr)\n\
    \        if arr[i] < min_even && arr[i] % 2 == 0\n            min_even = arr[i]\n\
    \            min_even_index = i\n        end\n        i += 1\n    end\n    if\
    \ min_even != 10000\n        return [min_even, min_even_index]\n    else\n   \
    \     return []\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpysvzxik5.jl:56\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  BoundsError: attempt to access\
    \ 3-element Vector{Int64} at index [0]\n  Stacktrace:\n   [1] getindex\n     @\
    \ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpysvzxik5.jl:39\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpysvzxik5.jl:56 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpysvzxik5.jl:55\ntest set:\
    \ Error During Test at /tmp/tmpysvzxik5.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  BoundsError: attempt to access 3-element Vector{Int64}\
    \ at index [0]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861 [inlined]\n\
    \   [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpysvzxik5.jl:39\n   [3]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpysvzxik5.jl:57 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpysvzxik5.jl:55\ntest set:\
    \ Error During Test at /tmp/tmpysvzxik5.jl:58\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  BoundsError: attempt to\
    \ access 0-element Vector{Int64} at index [0]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpysvzxik5.jl:39\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpysvzxik5.jl:58 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpysvzxik5.jl:55\ntest set:\
    \ Error During Test at /tm"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpysvzxik5.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr) || (isempty(findall(arr->arr % 2 == 0, arr)))\n      \
    \  return []\n    end\n    evens = findall(arr->arr % 2 == 0, arr)\n    min_even\
    \ = minimum(evens)\n    idx = findfirst(arr, min_even)\n    return [min_even,\
    \ idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzmfnekdv.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpzmfnekdv.jl:40\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzmfnekdv.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzmfnekdv.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpzmfnekdv.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpzmfnekdv.jl:40\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzmfnekdv.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzmfnekdv.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpzmfnekdv.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzmfnekdv.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # remove all odd numbers\n    arr_evens = arr[ arr .% 2 .== 0 ]\n    return\
    \ [minimum(arr_evens), findall(x -> x == minimum(arr_evens), arr)[1]]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpidh8u3hc.jl:44\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpidh8u3hc.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpidh8u3hc.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpidh8u3hc.jl:45\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpidh8u3hc.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpidh8u3hc.jl:43\ntest set: Error\
    \ During Test at /tmp/tmpidh8u3hc.jl:46\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError: reducing\
    \ over an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] reduce_empty(op::Function, #unused#::Type{Int64})\n\
    \      @ Base ./reduce.jl:311\n    [3] mapreduce_empty(#unused#::typeof(identity),\
    \ op::Function, T::Type)\n      @ Base ./reduce.jl:345\n    [4] reduce_empty(op::Base.MappingRF{typeof(identity),\
    \ typeof(min)}, #unused#::Type{Int64})\n      @ Base ./reduce.jl:331\n    [5]\
    \ reduce_empty_iter\n      @ ./reduce.jl:357 [inlined]\n    [6] mapreduce_empty_iter(f::Function,\
    \ op::Function, itr::Vector{Int64}, ItrEltype::Base.HasEltype)\n      @ Base ./reduce.jl:353\n\
    \    [7] _mapreduce\n      @ ./reduce.jl:402 [inlined]\n    [8] _mapreduce_dim\n\
    \      @ ./reducedim.jl:330 [inlined]\n    [9] #mapreduce#731\n      @ ./reducedim.jl:322\
    \ [inlined]\n   [10] mapreduce\n      @ ./reducedim.jl:322 [inlined]\n   [11]\
    \ #_minimum#753\n      @ ./reducedim.jl:894 [inlined]\n   [12] _minimum\n    \
    \  @ ./reducedim.jl:894 [inl"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 2 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpidh8u3hc.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_val, min_idx = Int64(0),\
    \ Int64(0)\n    min_idx = 0\n    for i in eachindex(arr)\n        if iseven(arr[i])\n\
    \            if arr[i] < min_val\n                min_val = arr[i]\n         \
    \       min_idx = i\n            end\n        end\n    end\n    if min_val ==\
    \ 0\n        return []\n    end\n    return [min_val, min_idx]\nend\n@testset\
    \ \"Example Tests\" begin\n    @test pluck([4,2,3]) == [2, 1]\n    @test pluck([1,2,3])\
    \ == [2, 1]\n    @test pluck([]) == []\n    @test pluck([5, 0, 3, 0, 4, 2]) ==\
    \ [0, 1]\nend\n@testset \"Test 1\" begin\n    @test pluck([1,2,3,4,5,6,7,8,9,10])\
    \ == [2, 1]\nend\n@testset \"Test 2\" begin\n    @test pluck([1,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @testset not defined\nin expression starting\
    \ at /tmp/tmprptu64x_.jl:53\nin expression starting at /tmp/tmprptu64x_.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nums = []\n    for\
    \ index in 1:length(arr)\n        if (arr[index] % 2 == 0)\n            push!(even_nums,\
    \ [arr[index], index])\n        end\n    end\n    if isempty(even_nums)\n    \
    \    return []\n    end\n    lowest_even = even_nums[1]\n    for index in 2:length(even_nums)\n\
    \        if even_nums[index][1] < lowest_even[1]\n            lowest_even = even_nums[index]\n\
    \        end\n    end\n    return lowest_even\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp0c7s1lwg.jl:60\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0c7s1lwg.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0c7s1lwg.jl:59\ntest set: Test\
    \ Failed at /tmp/tmp0c7s1lwg.jl:61\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0c7s1lwg.jl:61 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0c7s1lwg.jl:59\ntest set: Test\
    \ Failed at /tmp/tmp0c7s1lwg.jl:63\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0c7s1lwg.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0c7s1lwg.jl:59\ntest set: Test\
    \ Failed at /tmp/tmp0c7s1lwg.jl:64\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0c7s1lwg.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0c7s1lwg.jl:59\ntest set: Test\
    \ Failed at /tmp/tmp0c7s1lwg.jl:65\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0c7s1lwg.jl:57\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    if length(arr) ==\
    \ 1\n        if arr[1] % 2 == 0\n            return [arr[1], 1]\n        else\n\
    \            return []\n        end\n    end\n    even_nums = Int64[]\n    for\
    \ i in arr\n        if i % 2 == 0\n            push!(even_nums, i)\n        end\n\
    \    end\n    if length(even_nums) == 0\n        return []\n    end\n    smallest_even\
    \ = minimum(even_nums)\n    idx = argmin(even_nums)\n    return [smallest_even,\
    \ idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp72o9hwpa.jl:63\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp72o9hwpa.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp72o9hwpa.jl:62\ntest set: Test\
    \ Failed at /tmp/tmp72o9hwpa.jl:67\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp72o9hwpa.jl:67 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp72o9hwpa.jl:62\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    6     2      8\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp72o9hwpa.jl:60\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_value = nothing\n    min_index = nothing\n    for i = 1:length(arr)\n\
    \        if (arr[i] % 2 == 0) & (min_value isa Nothing)\n            min_value\
    \ = arr[i]\n            min_index = i\n        elseif (arr[i] % 2 == 0) & (arr[i]\
    \ < min_value)\n            min_value = arr[i]\n            min_index = i\n  \
    \      end\n    end\n    if min_value isa Nothing\n        return []\n    else\n\
    \        return [min_value, min_index]\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Test Failed at /tmp/tmppicp87jd.jl:57\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] macro\
    \ expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmppicp87jd.jl:57 [inlined]\\n\
    \ [3] macro expansion\\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n [4] top-level scope\\n   @ /tmp/tmppicp87jd.jl:56\\ntest set: Error\
    \ During Test at /tmp/tmppicp87jd.jl:58\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching isless(::Int64,\
    \ ::Nothing)\\n  Closest candidates are:\\n    isless(::Real, !Matched::AbstractFloat)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:185\\n    isless(::Real,\
    \ !Matched::Real) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:430\\\
    n    isless(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:88\\\
    n    ...\\n  Stacktrace:\\n   [1] <(x::Int64, y::Nothing)\\n     @ Base ./operators.jl:352\\\
    n   [2] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmppicp87jd.jl:41\\n   [3]\
    \ macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmppicp87jd.jl:58 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmppicp87jd.jl:56\\ntest set:\
    \ Error During Test at /tmp/tmppicp87jd.jl:60\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ isless(::Int64, ::Nothing)\\n  Closest candidates are:\\n    isless(::Real,\
    \ !Matched::AbstractFloat) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:185\\\
    n    isless(::Real, !Matched::Real) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:430\\\
    n    isless(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:88\\\
    n   "
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_vals = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_vals) == 0\n        return []\n    end\n\
    \    min_even = minimum(even_vals)\n    min_idx = findfirst(x -> x == min_even,\
    \ arr)\n    return [min_even, min_idx]\nend\n@testset \"Example 1\" begin\n  \
    \  @test pluck([4,2,3]) == [2, 1]\nend\n@testset \"Example 2\" begin\n    @test\
    \ pluck([1,2,3]) == [2, 1]\nend\n@testset \"Example 3\" begin\n    @test pluck([])\
    \ == []\nend\n@testset \"Example 4\" begin\n    @test pluck([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @testset not defined\nin expression starting\
    \ at /tmp/tmpxl6x137c.jl:46\nin expression starting at /tmp/tmpxl6x137c.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_val = 0\n    index = 0\n    min_val = 0\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvd67lgq6.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvd67lgq6.jl:1\n\
    in expression starting at /tmp/tmpvd67lgq6.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"\"\"\n    Returns the plucked node as [even_value, index]\n    \"\"\"\
    \n    if isempty(arr)\n        return []\n    end\n    # Find min even, and its\
    \ index\n    smallest_even = Inf\n    smallest_even_index = 0\n    for (i, node)\
    \ in enumerate(arr)\n        if node % 2 == 0 && node < smallest_even\n      \
    \      smallest_even = node\n            smallest_even_index = i\n        end\n\
    \    end\n    #return nothing if there is no even number\n    if smallest_even\
    \ == Inf\n        return []\n    end\n    return [smallest_even, smallest_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpaca6_ab0.jl:61\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpaca6_ab0.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpaca6_ab0.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpaca6_ab0.jl:62\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpaca6_ab0.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpaca6_ab0.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpaca6_ab0.jl:64\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpaca6_ab0.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpaca6_ab0.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpaca6_ab0.jl:65\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpaca6_ab0.jl:65 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpaca6_ab0.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpaca6_ab0.jl:66\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpaca6_ab0.jl:58\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest = zero(Int64)\n    index = zero(Int64)\n    for (i, element)\
    \ in enumerate(arr)\n        isEven = element % 2 == 0\n        isSmaller = element\
    \ < smallest\n        isFirst = smallest == zero(Int64)\n        if (isEven &&\
    \ (isSmaller || isFirst))\n            smallest = element\n            index =\
    \ i\n        end\n    end\n    if (smallest == zero(Int64))\n        return []\n\
    \    end\n    return [smallest, index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp87m3r762.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp87m3r762.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp87m3r762.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp87m3r762.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp87m3r762.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp87m3r762.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp87m3r762.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp87m3r762.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp87m3r762.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp87m3r762.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp87m3r762.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp87m3r762.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp87m3r762.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/c"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp87m3r762.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    n = length(arr)\n    @inbounds for i in 1:n\n        if arr[i] % 2 ==\
    \ 0\n            return [arr[i], i]\n        end\n    end\n    return []\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcl82kj0w.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [4, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcl82kj0w.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcl82kj0w.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpcl82kj0w.jl:49\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpcl82kj0w.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcl82kj0w.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpcl82kj0w.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcl82kj0w.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcl82kj0w.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpcl82kj0w.jl:52\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcl82kj0w.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcl82kj0w.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpcl82kj0w.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcl82kj0w.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if arr == []\n        return []\n    end\n    min_index = -1\n    min_value\
    \ = -1\n    for i = 1:length(arr)\n        if (arr[i] % 2 == 0) && (min_value\
    \ == -1 || arr[i] < min_value)\n            min_value = arr[i]\n            min_index\
    \ = i\n        end\n    end\n    if min_index == -1\n        return []\n    end\n\
    \    return [min_value, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmptszgs4cr.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptszgs4cr.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptszgs4cr.jl:55\ntest set: Test\
    \ Failed at /tmp/tmptszgs4cr.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmptszgs4cr.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptszgs4cr.jl:55\ntest set: Test\
    \ Failed at /tmp/tmptszgs4cr.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptszgs4cr.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptszgs4cr.jl:55\ntest set: Test\
    \ Failed at /tmp/tmptszgs4cr.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptszgs4cr.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptszgs4cr.jl:55\ntest set: Test\
    \ Failed at /tmp/tmptszgs4cr.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptszgs4cr.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Your code here\nend\n\"\"\"\n    \"Given an array representing a tree\
    \ that has non-negative integer nodes\n    your task is to find the largest value\
    \ in the array and return it.\n    If there are multiple values with the same\
    \ largest value return the value that has the smallest index.\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpsgi9rw6m.jl:37\nin expression starting at\
    \ /tmp/tmpsgi9rw6m.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    if isempty(evens)\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpx2c4rvlw.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx2c4rvlw.jl:40\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx2c4rvlw.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx2c4rvlw.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpx2c4rvlw.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx2c4rvlw.jl:40\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx2c4rvlw.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx2c4rvlw.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpx2c4rvlw.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpx2c4rvlw.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    # Split all nodes into even and odd (1-3, 5-7, ...)\n    even_nodes\
    \ = [node for node in arr if node % 2 == 0]\n    odd_nodes = [node for node in\
    \ arr if node % 2 != 0]\n    \n    if(!isempty(even_nodes))\n        # Find minimum\
    \ number and location of that number\n        min_even_node = minimum(even_nodes)\n\
    \        min_even_node_index = findfirst(arr .== min_even_node)\n        \n  \
    \      # If there is a duplicate of minimum number,\n        # choose the index\
    \ where minimum number is located at in the\n        # original array\n      \
    \  for i in 2:length(even_nodes)\n            if(even_nodes[i] == min_even_node)\n\
    \                min_even_node_index = findfirst(arr .== min_even_node)\n    \
    \        end\n        end\n    else\n        return []\n    end\n    \n    return\
    \ [min_even_node, min_even_node_index]\nend\n\"\"\"\n    \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n    your task is to\
    \ pluck one of the nodes and return it.\n    The plucked node should be the node\
    \ with the smallest even value.\n    If multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpps_h_jgz.jl:59\nin expression starting at\
    \ /tmp/tmpps_h_jgz.jl:59\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest_even = nothing\n    smallest_even_idx = nothing\n    for (i,\
    \ n) in enumerate(arr)\n        if iseven(n)\n            if !haskey(smallest_even,\
    \ 1)\n                smallest_even = n\n                smallest_even_idx = i\n\
    \            elseif n < smallest_even\n                smallest_even = n\n   \
    \             smallest_even_idx = i\n            end\n        end\n    end\n \
    \   return isempty(smallest_even) ? [] : [smallest_even, smallest_even_idx + 1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzyww9t3b.jl:55\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ haskey(::Nothing, ::Int64)\n  Closest candidates are:\n    haskey(!Matched::Base.ImmutableDict,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/dict.jl:789\n    haskey(!Matched::WeakKeyDict{K},\
    \ ::Any) where K at /shared/centos7/julia/1.7.3/share/julia/base/weakkeydict.jl:179\n\
    \    haskey(!Matched::IOContext, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/show.jl:339\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpzyww9t3b.jl:39\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzyww9t3b.jl:55 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzyww9t3b.jl:54\ntest set:\
    \ Error During Test at /tmp/tmpzyww9t3b.jl:56\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching haskey(::Nothing,\
    \ ::Int64)\n  Closest candidates are:\n    haskey(!Matched::Base.ImmutableDict,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/dict.jl:789\n    haskey(!Matched::WeakKeyDict{K},\
    \ ::Any) where K at /shared/centos7/julia/1.7.3/share/julia/base/weakkeydict.jl:179\n\
    \    haskey(!Matched::IOContext, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/show.jl:339\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpzyww9t3b.jl:39\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzyww9t3b.jl:56 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzyww9t3b.jl:54\ntest set:\
    \ Error During Test at /tmp/tmpzyww9t3b.jl:57\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int6"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzyww9t3b.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest_index = 0\n    smallest_value = 0\n    for (index, value) in\
    \ enumerate(arr)\n        if value % 2 == 0\n            if smallest_value ==\
    \ 0 || value < smallest_value\n                smallest_value = value\n      \
    \          smallest_index = index\n            end\n        end\n    end\n   \
    \ return [smallest_value, smallest_index]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp9t7op7s5.jl:52\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9t7op7s5.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9t7op7s5.jl:51\ntest set: Test\
    \ Failed at /tmp/tmp9t7op7s5.jl:53\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9t7op7s5.jl:53 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9t7op7s5.jl:51\ntest set: Test\
    \ Failed at /tmp/tmp9t7op7s5.jl:54\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9t7op7s5.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9t7op7s5.jl:51\ntest set: Test\
    \ Failed at /tmp/tmp9t7op7s5.jl:55\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9t7op7s5.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9t7op7s5.jl:51\ntest set: Test\
    \ Failed at /tmp/tmp9t7op7s5.jl:56\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \ "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9t7op7s5.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(i -> i\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(i -> i == min_even, arr)]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvyyopu95.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvyyopu95.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvyyopu95.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpvyyopu95.jl:51\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvyyopu95.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvyyopu95.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpvyyopu95.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvyyopu95.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvyyopu95.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpvyyopu95.jl:54\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvyyopu95.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvyyopu95.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpvyyopu95.jl:55\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvyyopu95.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here \nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp00iexitl.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp00iexitl.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp00iexitl.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp00iexitl.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp00iexitl.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp00iexitl.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp00iexitl.jl:43 [inlined]\n\
    \   [4] ma"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp00iexitl.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    return [x for x in arr if iseven(x)]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpwj0ssve0.jl:42\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [4, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwj0ssve0.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwj0ssve0.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpwj0ssve0.jl:43\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwj0ssve0.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwj0ssve0.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpwj0ssve0.jl:45\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0, 4, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwj0ssve0.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwj0ssve0.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpwj0ssve0.jl:46\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 0] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwj0ssve0.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwj0ssve0.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpwj0ssve0.jl:47\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 8, 4, 8] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwj0ssve0.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    length(arr) == 0 && return []\n    min_index, min_val = size(arr)[1],\
    \ maximum(arr)\n    for i in 1:length(arr)\n        val = arr[i]\n        if val\
    \ % 2 == 0 && val < min_val\n            min_index, min_val = i, val\n       \
    \ end\n    end\n    if min_val == maximum(arr)\n        return []\n    else\n\
    \        return [min_val, min_index]\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpv3umtbag.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv3umtbag.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv3umtbag.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpv3umtbag.jl:55\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpv3umtbag.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv3umtbag.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpv3umtbag.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv3umtbag.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv3umtbag.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpv3umtbag.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv3umtbag.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv3umtbag.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpv3umtbag.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv3umtbag.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    arr_evens = filter(x -> iseven(x), arr)\n    if length(arr_evens) == 0\n\
    \        return []\n    end\n    return [minimum(arr_evens), findfirst(arr, minimum(arr_evens))]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpo4gmerbg.jl:46\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpo4gmerbg.jl:39\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpo4gmerbg.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpo4gmerbg.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpo4gmerbg.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpo4gmerbg.jl:39\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpo4gmerbg.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpo4gmerbg.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpo4gmerbg.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo4gmerbg.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    values = filter(x -> x % 2 == 0, arr)\n    if length(values) == 0\n  \
    \      return []\n    end\n    values = sort(values)\n    indexes = findall(arr\
    \ -> arr == values[1], arr)\n    return [values[1], indexes[1]]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdbbz57nw.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdbbz57nw.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdbbz57nw.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpdbbz57nw.jl:49\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdbbz57nw.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdbbz57nw.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpdbbz57nw.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdbbz57nw.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdbbz57nw.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpdbbz57nw.jl:52\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdbbz57nw.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdbbz57nw.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpdbbz57nw.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdbbz57nw.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    i = 1\n    val = 0\n    for j = 1:length(arr)\n        if mod(arr[j],\
    \ 2) == 0\n            if (arr[j] < val) || (val == 0)\n                val =\
    \ arr[j]\n                i = j\n            end\n        end\n    end\n    return\
    \ [val, i]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbzsvpgd5.jl:52\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbzsvpgd5.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbzsvpgd5.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpbzsvpgd5.jl:53\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbzsvpgd5.jl:53 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbzsvpgd5.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpbzsvpgd5.jl:54\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 1] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbzsvpgd5.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbzsvpgd5.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpbzsvpgd5.jl:55\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbzsvpgd5.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbzsvpgd5.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpbzsvpgd5.jl:56\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \ "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbzsvpgd5.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Write your solution here\nend\n \n \n@testset \"Test Cases\" begin\n\
    \    @test pluck([]) == []\n    @test pluck([1,2,3]) == [2, 1]\n    @test pluck([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1]\n    @test pluck([4,2,3]) == [2, 1]\nend\n\"\"\"\n\
    \    Plotting the function:\n    f(x,y) = x^2 + 2*y^2 - 1\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @testset not defined\nin expression starting\
    \ at /tmp/tmp1l6s3wvc.jl:39\nin expression starting at /tmp/tmp1l6s3wvc.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = [x for\
    \ x in arr if x % 2 == 0]\n    if length(even_arr) == 0\n        return []\n \
    \   end\n    min_even = minimum(even_arr)\n    return [min_even, findall(arr,\
    \ min_even)[1]]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpi7juc0_p.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findall(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findall(!Matched::Base.Fix2{typeof(in)},\
    \ ::Number) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:2318\n  \
    \  findall(!Matched::Function, ::Number) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:2317\n\
    \    findall(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:2253\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpi7juc0_p.jl:43\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpi7juc0_p.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpi7juc0_p.jl:49\ntest set:\
    \ Error During Test at /tmp/tmpi7juc0_p.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findall(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findall(!Matched::Base.Fix2{typeof(in)},\
    \ ::Number) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:2318\n  \
    \  findall(!Matched::Function, ::Number) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:2317\n\
    \    findall(!Matched::Function, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:2253\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpi7juc0_p.jl:43\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpi7juc0_p.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpi7juc0_p.jl:49\ntest set:\
    \ Error During Test at /tmp/tmpi7juc0_p.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([5, 0"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi7juc0_p.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    minimum(filter(n -> rem(n, 2) == 0, arr))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpcg7e3g65.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Int64 to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpcg7e3g65.jl:35\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcg7e3g65.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcg7e3g65.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpcg7e3g65.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Int64 to an object of type Vector{Int64}\n  Closest candidates are:\n \
    \   convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpcg7e3g65.jl:35\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcg7e3g65.jl:43 [inlined]\n\
    \   [4] macro "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcg7e3g65.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    smallest = [findall(x -> x % 2 == 0, arr)]\n    if !isempty(smallest)\n\
    \        [findmin(smallest[1]), findall(x -> x == findmin(smallest[1]), arr)[1]]\n\
    \    else\n        [0,0]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpur0snuk6.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  BoundsError: attempt to access\
    \ 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1] getindex\n     @\
    \ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpur0snuk6.jl:37\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpur0snuk6.jl:47 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpur0snuk6.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpur0snuk6.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  BoundsError: attempt to access 0-element Vector{Int64}\
    \ at index [1]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861 [inlined]\n\
    \   [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpur0snuk6.jl:37\n   [3]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpur0snuk6.jl:48 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpur0snuk6.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpur0snuk6.jl:49\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError: reducing\
    \ over an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] mapreduce_empty(f::Function, op::Base.BottomRF{typeof(Base._rf_findmin)},\
    \ T::Type)\n      @ Base ./reduce.jl:344\n    [3] reduce_empty(op::Base.MappingRF{Base.var\"\
    #262#263\"{typeof(identity)}, Base.BottomRF{typeof(Base._rf_findmin)}}, #unused#::Type{Pair{Int64,\
    \ Int64}})\n      @ Base ./reduce.jl:331\n    [4] reduce_empty_iter\n      @ ./reduce.jl:357\
    \ [inlined]\n    [5] reduce_empty_iter\n      @ ./reduce.jl:356 [inlined]\n  \
    \  [6] foldl"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpur0snuk6.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_index = Int[]\n    even_value = Int[]\n    #exception\n    if length(arr)\
    \ == 0\n        return []\n    end\n    #get even index and value\n    for i =\
    \ 1:length(arr)\n        if (arr[i] % 2 == 0) && (arr[i] != 0)\n            push!(even_index,\
    \ i)\n            push!(even_value, arr[i])\n        end\n    end\n    #exception\n\
    \    if length(even_index) == 0\n        return []\n    end\n    #get index and\
    \ value of the smallest even number\n    min_value = even_value[1]\n    min_index\
    \ = even_index[1]\n    for i = 2:length(even_value)\n        if even_value[i]\
    \ < min_value\n            min_value = even_value[i]\n            min_index =\
    \ even_index[i]\n        end\n    end\n    return [min_value, min_index]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmlubc18n.jl:68\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmlubc18n.jl:68 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmlubc18n.jl:67\ntest set: Test\
    \ Failed at /tmp/tmpmlubc18n.jl:69\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpmlubc18n.jl:69 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmlubc18n.jl:67\ntest set: Test\
    \ Failed at /tmp/tmpmlubc18n.jl:71\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmlubc18n.jl:71 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmlubc18n.jl:67\ntest set: Test\
    \ Failed at /tmp/tmpmlubc18n.jl:72\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmlubc18n.jl:72 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmlubc18n.jl:67\ntest set: Test\
    \ Failed at /tmp/tmpmlubc18n.jl:73\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmlubc18n.jl:65\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    idx_min, val_min\
    \ = findmin(arr)\n    if (val_min % 2 == 0)\n        return [val_min, idx_min]\n\
    \    end\n    return pluck(deleteat!(arr, idx_min))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpzp_b_wsp.jl:49\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzp_b_wsp.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzp_b_wsp.jl:48\ntest set: Error\
    \ During Test at /tmp/tmpzp_b_wsp.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  BoundsError: attempt to access 1-element Vector{Int64}\
    \ at index [2]\n  Stacktrace:\n   [1] _deleteat!\n     @ ./array.jl:959 [inlined]\n\
    \   [2] deleteat!\n     @ ./array.jl:1423 [inlined]\n   [3] pluck(arr::Vector{Int64})\
    \ (repeats 3 times)\n     @ Main /tmp/tmpzp_b_wsp.jl:42\n   [4] macro expansion\n\
    \     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpzp_b_wsp.jl:50 [inlined]\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpzp_b_wsp.jl:48\ntest set:\
    \ Test Failed at /tmp/tmpzp_b_wsp.jl:52\n  Expression: candidate([5, 0, 3, 0,\
    \ 4, 2]) == [0, 1]\n   Evaluated: [2, 0] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzp_b_wsp.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzp_b_wsp.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpzp_b_wsp.jl:53\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [4, 0] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzp_b_wsp.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 6 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzp_b_wsp.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = findall(x -> (x % 2 == 0), arr)\n    if length(evens) == 0\n \
    \       return []\n    end\n    min_even = minimum(evens)\n    return [min_even,\
    \ findall(x -> (x == min_even), arr)[1]]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpuwpswobf.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  BoundsError: attempt to access\
    \ 0-element Vector{Int64} at index [1]\n  Stacktrace:\n   [1] getindex\n     @\
    \ ./array.jl:861 [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpuwpswobf.jl:40\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpuwpswobf.jl:47 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpuwpswobf.jl:46\ntest set:\
    \ Test Failed at /tmp/tmpuwpswobf.jl:48\n  Expression: candidate([1, 2, 3]) ==\
    \ [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpuwpswobf.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuwpswobf.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpuwpswobf.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpuwpswobf.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuwpswobf.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpuwpswobf.jl:51\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpuwpswobf.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuwpswobf.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    result = []\n   \
    \ min = Inf\n    index = 0\n    for i in 1:length(arr)\n        if arr[i] % 2\
    \ == 0 && arr[i] < min\n            min = arr[i]\n            index = i\n    \
    \    end\n    end\n    if length(result) == 0\n        return []\n    end\n  \
    \  return [min, index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps504el92.jl:57\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmps504el92.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps504el92.jl:56\ntest set: Test\
    \ Failed at /tmp/tmps504el92.jl:58\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmps504el92.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps504el92.jl:56\ntest set: Test\
    \ Failed at /tmp/tmps504el92.jl:60\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmps504el92.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps504el92.jl:56\ntest set: Test\
    \ Failed at /tmp/tmps504el92.jl:61\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmps504el92.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps504el92.jl:56\ntest set: Test\
    \ Failed at /tmp/tmps504el92.jl:62\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shar"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps504el92.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_even = (Int64, 0) # (min_even_value, min_even_index)\n    arr_size\
    \ = length(arr)\n    for index in 1:arr_size\n        if iseven(arr[index])\n\
    \            if min_even[1] == 0 || arr[index] < min_even[1]\n               \
    \ min_even = (arr[index], index)\n            end\n        end\n    end\n    return\
    \ min_even\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp8pkewyde.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ isless(::Int64, ::Type{Int64})\n  Closest candidates are:\n    isless(::Real,\
    \ !Matched::AbstractFloat) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:185\n\
    \    isless(::Real, !Matched::Real) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:430\n\
    \    isless(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:88\n\
    \    ...\n  Stacktrace:\n   [1] <(x::Int64, y::Type)\n     @ Base ./operators.jl:352\n\
    \   [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8pkewyde.jl:39\n   [3]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp8pkewyde.jl:51 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp8pkewyde.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp8pkewyde.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching isless(::Int64,\
    \ ::Type{Int64})\n  Closest candidates are:\n    isless(::Real, !Matched::AbstractFloat)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:185\n    isless(::Real,\
    \ !Matched::Real) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:430\n\
    \    isless(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:88\n\
    \    ...\n  Stacktrace:\n   [1] <(x::Int64, y::Type)\n     @ Base ./operators.jl:352\n\
    \   [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8pkewyde.jl:39\n   [3]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp8pkewyde.jl:52 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp8pkewyde.jl:50\ntest set:\
    \ Error During"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8pkewyde.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    l = length(arr)\n    if l == 0\n        return []\n    end\n    minimum\
    \ = 1e6\n    idx = 0\n    for i = 1:l\n        if arr[i] < minimum && mod(arr[i],\
    \ 2) == 0\n            minimum = arr[i]\n            idx = i\n        end\n  \
    \  end\n    if idx == 0\n        return []\n    end\n    return [minimum, idx]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpddaerj_i.jl:57\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpddaerj_i.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpddaerj_i.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpddaerj_i.jl:58\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpddaerj_i.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpddaerj_i.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpddaerj_i.jl:60\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpddaerj_i.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpddaerj_i.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpddaerj_i.jl:61\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpddaerj_i.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpddaerj_i.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpddaerj_i.jl:62\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpddaerj_i.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"\"\"\n    Solve a given equation and return the value of x in the form\
    \ of string \"x=#value\".\n    The equation contains only '+', '-' operation,\
    \ the variable x and its coefficient.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp_r6n2bu1.jl:1\nin expression starting at /tmp/tmp_r6n2bu1.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    N = length(arr)\n    even_idx = [ idx for idx in 1:N if arr[idx] % 2 ==\
    \ 0 ]\n    if length(even_idx) == 0\n        return [0, 0]\n    end\n    min_idx\
    \ = even_idx[ argmin( arr[ even_idx ] ) ]\n    return [ arr[min_idx], min_idx\
    \ ]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcvv12c1w.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcvv12c1w.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcvv12c1w.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpcvv12c1w.jl:49\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpcvv12c1w.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcvv12c1w.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpcvv12c1w.jl:50\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcvv12c1w.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcvv12c1w.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpcvv12c1w.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcvv12c1w.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcvv12c1w.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpcvv12c1w.jl:52\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \ "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcvv12c1w.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evenArr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(evenArr)\n        return []\n    end\n    val\
    \ = minimum(evenArr)\n    for i in 1:length(arr)\n        if arr[i] == val\n \
    \           return [val, i]\n        end\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp2j2i2h6o.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2j2i2h6o.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2j2i2h6o.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp2j2i2h6o.jl:55\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2j2i2h6o.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2j2i2h6o.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp2j2i2h6o.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2j2i2h6o.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2j2i2h6o.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp2j2i2h6o.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2j2i2h6o.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2j2i2h6o.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp2j2i2h6o.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2j2i2h6o.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    length(arr) < 1 && return []\n    arr[arr .% 2 .== 0] == minimum(arr[arr\
    \ .% 2 .== 0]) ?\n        [minimum(arr[arr .% 2 .== 0]), findall(arr .== minimum(arr[arr\
    \ .% 2 .== 0]))[1]] :\n        []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpb7kh3vxn.jl:45\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb7kh3vxn.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb7kh3vxn.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpb7kh3vxn.jl:46\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpb7kh3vxn.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb7kh3vxn.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpb7kh3vxn.jl:48\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb7kh3vxn.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb7kh3vxn.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpb7kh3vxn.jl:49\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb7kh3vxn.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb7kh3vxn.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpb7kh3vxn.jl:50\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shar"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 6 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb7kh3vxn.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    # Find the minimum even value\n    min_even = minimum(filter(n ->\
    \ iseven(n), arr))\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvom2tos1.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvom2tos1.jl:1\n\
    in expression starting at /tmp/tmpvom2tos1.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even = filter(x ->\
    \ x%2 == 0, arr)\n    min_even = minimum(even)\n    if min_even == Inf\n     \
    \   return []\n    end\n    idx = findall(arr .== min_even)[1]\n    return [min_even,\
    \ idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp55l0qllp.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp55l0qllp.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp55l0qllp.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp55l0qllp.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp55l0qllp.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp55l0qllp.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp55l0qllp.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp55l0qllp.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp55l0qllp.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp55l0qllp.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp55l0qllp.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp55l0qllp.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp55l0qllp.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 6 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp55l0qllp.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_even_value = 0\n    min_even_value_idx = 0\n    for (idx, value) in\
    \ enumerate(arr)\n        if value < min_even_value && value % 2 == 0\n      \
    \      min_even_value = value\n            min_even_value_idx = idx\n        end\n\
    \    end\n    return [min_even_value, min_even_value_idx]\nend\n \nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2z5725ob.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2z5725ob.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2z5725ob.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp2z5725ob.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2z5725ob.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2z5725ob.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp2z5725ob.jl:53\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2z5725ob.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2z5725ob.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp2z5725ob.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2z5725ob.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2z5725ob.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp2z5725ob.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 0] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \ "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2z5725ob.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = []\n    for i = 1:length(arr)\n        if arr[i] % 2 == 0\n   \
    \         push!(even, i)\n        end\n    end\n    if length(even) == 0\n   \
    \     return []\n    end\n    return [arr[indmin(even)], indmin(even)]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpq1gpjxs6.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: indmin not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpq1gpjxs6.jl:44\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq1gpjxs6.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq1gpjxs6.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpq1gpjxs6.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: indmin not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpq1gpjxs6.jl:44\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq1gpjxs6.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq1gpjxs6.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpq1gpjxs6.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: indmin not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpq1gpjxs6.jl:44\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq1gpjxs6.jl:54 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq1gpjxs6.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpq1gpjxs6.jl:55\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  UndefVarError: indmin not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpq1gpjxs6.jl:44\n\
    \   [2] macro expansion\n     @ /shared/cen"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq1gpjxs6.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if !any(arr .% 2 .== 0)\n        return []\n    end\n    arr_evens = arr[arr\
    \ .% 2 .== 0]\n    minimum_value = minimum(arr_evens)\n    position = searchsortedlast(arr,\
    \ minimum_value)\n    return [minimum_value, position]\nend\n\"\"\"\n    Run tests:\n\
    \        julia test.jl\n\"\"\"\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmpmzxiwi6l.jl:43\nin expression starting at /tmp/tmpmzxiwi6l.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    @assert length(arr) >= 1\n    @assert all(isodd, arr)\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpeebgpk6g.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpeebgpk6g.jl:1\n\
    in expression starting at /tmp/tmpeebgpk6g.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = []\n    positions = []\n    for (index, val) in enumerate(arr)\n\
    \        if val % 2 == 0\n            push!(evens, val)\n            push!(positions,\
    \ index)\n        end\n    end\n    if length(evens) == 0\n        return []\n\
    \    end\n    min = evens[1]\n    min_index = positions[1]\n    min_index_pos\
    \ = 1\n    for (index, val) in enumerate(evens)\n        if val < min\n      \
    \      min = val\n            min_index = positions[index]\n            min_index_pos\
    \ = index\n        end\n    end\n    return [min, min_index]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpi9d323ft.jl:63\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi9d323ft.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi9d323ft.jl:62\ntest set: Test\
    \ Failed at /tmp/tmpi9d323ft.jl:64\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpi9d323ft.jl:64 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi9d323ft.jl:62\ntest set: Test\
    \ Failed at /tmp/tmpi9d323ft.jl:66\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi9d323ft.jl:66 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi9d323ft.jl:62\ntest set: Test\
    \ Failed at /tmp/tmpi9d323ft.jl:67\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi9d323ft.jl:67 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi9d323ft.jl:62\ntest set: Test\
    \ Failed at /tmp/tmpi9d323ft.jl:68\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi9d323ft.jl:60\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    empty_list = []\n    if isempty(arr)\n        return empty_list\n    end\n\
    \    smallest_even = Inf\n    smallest_even_index = Inf\n    for node in eachindex(arr)\n\
    \        if arr[node] % 2 == 0 && arr[node] < smallest_even\n            smallest_even\
    \ = arr[node]\n            smallest_even_index = node\n        end\n    end\n\
    \    if smallest_even == Inf\n        return empty_list\n    end\n    return [smallest_even,\
    \ smallest_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyedgh_p8.jl:57\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyedgh_p8.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyedgh_p8.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpyedgh_p8.jl:58\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpyedgh_p8.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyedgh_p8.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpyedgh_p8.jl:60\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyedgh_p8.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyedgh_p8.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpyedgh_p8.jl:61\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyedgh_p8.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyedgh_p8.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpyedgh_p8.jl:62\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyedgh_p8.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_nums = []\n    for (i, el) in enumerate(arr)\n        if el % 2 ==\
    \ 0\n            push!(even_nums, (el, i))\n        end\n    end\n    if length(even_nums)\
    \ == 0\n        return []\n    end\n    return sort!(even_nums)[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpstx85hr8.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Tuple{Int64, Int64} to an object of type Vector{Int64}\n \
    \ Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpstx85hr8.jl:44\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpstx85hr8.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpstx85hr8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpstx85hr8.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Tuple{Int64, Int64} to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpstx85hr8.jl:44\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpstx85hr8.j"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpstx85hr8.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = filter(x -> x % 2 == 0, arr)\n    if isempty(even_values)\n\
    \        return []\n    end\n    minimal_even_value = even_values[1]\n    for\
    \ value in even_values\n        if value < minimal_even_value\n            minimal_even_value\
    \ = value\n        end\n    end\n    for (i, element) in enumerate(arr)\n    \
    \    if element == minimal_even_value\n            return [element, i]\n     \
    \   end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpr62cd5ny.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr62cd5ny.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr62cd5ny.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpr62cd5ny.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpr62cd5ny.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr62cd5ny.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpr62cd5ny.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr62cd5ny.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr62cd5ny.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpr62cd5ny.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr62cd5ny.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr62cd5ny.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpr62cd5ny.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr62cd5ny.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # do something\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpnm4acduw.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpnm4acduw.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnm4acduw.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnm4acduw.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpnm4acduw.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpnm4acduw.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnm4acduw.jl:43 [inlined]\n\
    \   [4] ma"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnm4acduw.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    result = []\n    for i = 1:length(arr)\n        if arr[i] % 2 == 0\n \
    \           push!(result, i)\n        end\n    end\n    sort!(result)\n    isempty(result)\
    \ ? [] : [arr[result[1]], result[1]]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp67wd6rf_.jl:49\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [4, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp67wd6rf_.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp67wd6rf_.jl:48\ntest set: Test\
    \ Failed at /tmp/tmp67wd6rf_.jl:50\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp67wd6rf_.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp67wd6rf_.jl:48\ntest set: Test\
    \ Failed at /tmp/tmp67wd6rf_.jl:52\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp67wd6rf_.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp67wd6rf_.jl:48\ntest set: Test\
    \ Failed at /tmp/tmp67wd6rf_.jl:53\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp67wd6rf_.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp67wd6rf_.jl:48\ntest set: Test\
    \ Failed at /tmp/tmp67wd6rf_.jl:54\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp67wd6rf_.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    # check empty array\n    if length(arr) == 0\n        return []\n\
    \    end\n    \n    # keep track of the smallest even value\n    sm_even = Inf\n\
    \    \n    # keep track of first index of smallest even value\n    sm_index =\
    \ -1\n    \n    # go through array and if number is even and less than sm_even\n\
    \    # update sm_even and sm_index\n    for i in 1:length(arr)\n        if arr[i]\
    \ % 2 == 0 && arr[i] < sm_even\n            sm_even = arr[i]\n            sm_index\
    \ = i\n        end\n    end\n    \n    # if sm_even is still Inf, then no even\
    \ numbers, so return empty array\n    if sm_even == Inf\n        return []\n \
    \   end\n    \n    # return list containing the smallest even value and its index\n\
    \    return [sm_even, sm_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpxfveyvln.jl:69\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxfveyvln.jl:69 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxfveyvln.jl:68\ntest set: Test\
    \ Failed at /tmp/tmpxfveyvln.jl:70\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpxfveyvln.jl:70 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxfveyvln.jl:68\ntest set: Test\
    \ Failed at /tmp/tmpxfveyvln.jl:72\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxfveyvln.jl:72 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxfveyvln.jl:68\ntest set: Test\
    \ Failed at /tmp/tmpxfveyvln.jl:73\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxfveyvln.jl:73 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxfveyvln.jl:68\ntest set: Test\
    \ Failed at /tmp/tmpxfveyvln.jl:74\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxfveyvln.jl:66\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_idx = Int64[]\n\
    \    even_arr = Int64[]\n    for i in 1:length(arr)\n        if iseven(arr[i])\n\
    \            push!(even_idx, i)\n            push!(even_arr, arr[i])\n       \
    \ end\n    end\n    if length(even_arr) == 0\n        return []\n    end\n   \
    \ min_idx = even_idx[argmin(even_arr)]\n    return [arr[min_idx], min_idx]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppfm9h2iz.jl:57\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppfm9h2iz.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppfm9h2iz.jl:56\ntest set: Test\
    \ Failed at /tmp/tmppfm9h2iz.jl:58\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmppfm9h2iz.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppfm9h2iz.jl:56\ntest set: Test\
    \ Failed at /tmp/tmppfm9h2iz.jl:60\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppfm9h2iz.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppfm9h2iz.jl:56\ntest set: Test\
    \ Failed at /tmp/tmppfm9h2iz.jl:61\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppfm9h2iz.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppfm9h2iz.jl:56\ntest set: Test\
    \ Failed at /tmp/tmppfm9h2iz.jl:62\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppfm9h2iz.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    least:Int64 = 0\n    index:Int64 = 0\n    for i in 1:length(arr)\n   \
    \     if arr[i] % 2 == 0\n            if (least == 0) || (arr[i] < least)\n  \
    \              least = arr[i]\n                index = i\n            end\n  \
    \      end\n    end\n    if least == 0\n        return []\n    else\n        return\
    \ [least, index]\n    end\nend\n@testset \"Basic tests\" begin\n    @test pluck([4,2,3])\
    \ == [2, 1]\n    @test pluck([1,2,3]) == [2, 1]\n    @test pluck([]) == []\n \
    \   @test pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\nend\n@testset \"Random tests\"\
    \ begin\n    @testset \"Run 25 random tests\" begin\n        for i in 1:25\n \
    \           s = rand(1:10000)\n            l = [rand(0:10000) for i in 1:s]\n\
    \            p = pluck(l)\n            if !isempty(p)\n                @test 0\
    \ <= p[1] <= 10000\n                @test p[2] in 1:length(l)\n              \
    \  @test 2p[1] == l[p[2]]\n            else\n                @test all(x -> x\
    \ % 2 != 0, l)\n            end\n        end\n    end\nend\n \nend\n \n \n \n\"\
    \"\"\n    Given a string of characters, return the character that appears the\
    \ most often.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "WARNING: Method definition :(Any, Any) in module Main at /tmp/tmp947mikn3.jl:35\
    \ overwritten at /tmp/tmp947mikn3.jl:36.\nERROR: LoadError: UndefVarError: @testset\
    \ not defined\nin expression starting at /tmp/tmp947mikn3.jl:51\nin expression\
    \ starting at /tmp/tmp947mikn3.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    ans = findall(arr\
    \ .== minimum(arr[arr .== 0]));\n    if length(ans) == 0\n        return []\n\
    \    end\n    return [arr[ans[1]], ans[1]]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp0vn729cu.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  ArgumentError: reducing over\
    \ an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] reduce_empty(op::Function, #unused#::Type{Int64})\n\
    \      @ Base ./reduce.jl:311\n    [3] mapreduce_empty(#unused#::typeof(identity),\
    \ op::Function, T::Type)\n      @ Base ./reduce.jl:345\n    [4] reduce_empty(op::Base.MappingRF{typeof(identity),\
    \ typeof(min)}, #unused#::Type{Int64})\n      @ Base ./reduce.jl:331\n    [5]\
    \ reduce_empty_iter\n      @ ./reduce.jl:357 [inlined]\n    [6] mapreduce_empty_iter(f::Function,\
    \ op::Function, itr::Vector{Int64}, ItrEltype::Base.HasEltype)\n      @ Base ./reduce.jl:353\n\
    \    [7] _mapreduce\n      @ ./reduce.jl:402 [inlined]\n    [8] _mapreduce_dim\n\
    \      @ ./reducedim.jl:330 [inlined]\n    [9] #mapreduce#731\n      @ ./reducedim.jl:322\
    \ [inlined]\n   [10] mapreduce\n      @ ./reducedim.jl:322 [inlined]\n   [11]\
    \ #_minimum#753\n      @ ./reducedim.jl:894 [inlined]\n   [12] _minimum\n    \
    \  @ ./reducedim.jl:894 [inlined]\n   [13] #_minimum#752\n      @ ./reducedim.jl:893\
    \ [inlined]\n   [14] _minimum\n      @ ./reducedim.jl:893 [inlined]\n   [15] #minimum#750\n\
    \      @ ./reducedim.jl:889 [inlined]\n   [16] minimum\n      @ ./reducedim.jl:889\
    \ [inlined]\n   [17] pluck(arr::Vector{Int64})\n      @ Main /tmp/tmp0vn729cu.jl:38\n\
    \   [18] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [19] macro expansion\n      @ /tmp/tmp0vn729cu.jl:49 [inlined]\n\
    \   [20] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [21] top-level scope\n      @ /tmp/tmp0vn729cu.jl:48\ntest set:\
    \ Error During Test at /tmp/tmp0vn729cu.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  ArgumentError: reducing over an empty collection\
    \ is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n      @ Base ./reduce.jl:301\n\
    \    [2] reduce_empty(op::Function"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 2 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0vn729cu.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Your solution here\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5axye8dd.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp5axye8dd.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5axye8dd.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5axye8dd.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp5axye8dd.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp5axye8dd.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5axye8dd.jl:43 [inlined]\n\
    \   [4] ma"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5axye8dd.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = findall(x -> x % 2 == 0, arr)\n    if isempty(evens)\n       \
    \ return Vector{Int64}()\n    end\n    return [minimum(evens), findfirst(arr .==\
    \ minimum(evens))]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpimqhzzpo.jl:46\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Int64\\n  Closest candidates\
    \ are:\\n    convert(::Type{T}, !Matched::T) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:6\\\
    n    convert(::Type{T}, !Matched::Number) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/number.jl:7\\\
    n    convert(::Type{T}, !Matched::Base.TwicePrecision) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/twiceprecision.jl:262\\\
    n    ...\\n  Stacktrace:\\n    [1] setindex!(A::Vector{Int64}, x::Nothing, i1::Int64)\\\
    n      @ Base ./array.jl:903\\n    [2] _unsafe_copyto!(dest::Vector{Int64}, doffs::Int64,\
    \ src::Vector{Union{Nothing, Int64}}, soffs::Int64, n::Int64)\\n      @ Base ./array.jl:253\\\
    n    [3] unsafe_copyto!\\n      @ ./array.jl:307 [inlined]\\n    [4] _copyto_impl!\\\
    n      @ ./array.jl:331 [inlined]\\n    [5] copyto!\\n      @ ./array.jl:317 [inlined]\\\
    n    [6] copyto!\\n      @ ./array.jl:343 [inlined]\\n    [7] copyto_axcheck!\\\
    n      @ ./abstractarray.jl:1104 [inlined]\\n    [8] Vector{Int64}(x::Vector{Union{Nothing,\
    \ Int64}})\\n      @ Base ./array.jl:563\\n    [9] convert\\n      @ ./array.jl:554\
    \ [inlined]\\n   [10] pluck(arr::Vector{Int64})\\n      @ Main /tmp/tmpimqhzzpo.jl:39\\\
    n   [11] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [12] macro expansion\\n      @ /tmp/tmpimqhzzpo.jl:46 [inlined]\\\
    n   [13] macro expansion\\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [14] top-level scope\\n      @ /tmp/tmpimqhzzpo.jl:45\\ntest\
    \ set: Test Failed at /tmp/tmpimqhzzpo.jl:47\\n  Expression: candidate([1, 2,\
    \ 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] macro expansion\\\
    n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n [2] macro expansion\\n   @ /tmp/tmpimqhzzpo.jl:47 [inlined]\\n\
    \ [3] macr"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_value = nothing\n    min_index = nothing\n    for (index, value) in\
    \ enumerate(arr)\n        if value % 2 == 0\n            if isnothing(min_value)\
    \ || value < min_value\n                min_value = value\n                min_index\
    \ = index\n            end\n        end\n    end\n    return isnothing(min_value)\
    \ ? [] : [min_value, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp_qix411h.jl:52\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_qix411h.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_qix411h.jl:51\ntest set: Test\
    \ Failed at /tmp/tmp_qix411h.jl:53\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_qix411h.jl:53 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_qix411h.jl:51\ntest set: Test\
    \ Failed at /tmp/tmp_qix411h.jl:55\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_qix411h.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_qix411h.jl:51\ntest set: Test\
    \ Failed at /tmp/tmp_qix411h.jl:56\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_qix411h.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_qix411h.jl:51\ntest set: Test\
    \ Failed at /tmp/tmp_qix411h.jl:57\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_qix411h.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    ret = []\n    minval\
    \ = 9999999\n    minidx = 9999999\n    for (idx, val) in enumerate(arr)\n    \
    \    if mod(val, 2) == 0 && val < minval\n            minval = val\n         \
    \   minidx = idx\n        end\n    end\n    if minval != 9999999\n        return\
    \ [minval, minidx + 1]\n    else\n        return []\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzaej05on.jl:58\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 3] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzaej05on.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzaej05on.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpzaej05on.jl:59\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 3] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpzaej05on.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzaej05on.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpzaej05on.jl:61\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 3] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzaej05on.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzaej05on.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpzaej05on.jl:62\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 5] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzaej05on.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzaej05on.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpzaej05on.jl:63\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 3] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzaej05on.jl:55\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = [arr[i] for i in 1:length(arr) if rem(arr[i], 2) == 0]\n    if\
    \ isempty(evens)\n        return []\n    else\n        smallest = minimum(evens)\n\
    \        return [smallest, findall(arr .== smallest)[1]]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkbtn26xz.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkbtn26xz.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkbtn26xz.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpkbtn26xz.jl:49\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkbtn26xz.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkbtn26xz.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpkbtn26xz.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkbtn26xz.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkbtn26xz.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpkbtn26xz.jl:52\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkbtn26xz.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkbtn26xz.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpkbtn26xz.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkbtn26xz.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    index = -1\n    value = -1\n   \n    for i in 1:length(arr)\n        if\
    \ rem(arr[i], 2) == 0\n            if value == -1\n                value = arr[i]\n\
    \                index = i\n            elseif arr[i] < value\n              \
    \  value = arr[i]\n                index = i\n            end\n        end\n \
    \   end\n    if index == -1\n        return Vector{Int64}()\n    end\n    return\
    \ [value, index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjknd18n5.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjknd18n5.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjknd18n5.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpjknd18n5.jl:60\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpjknd18n5.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjknd18n5.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpjknd18n5.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjknd18n5.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjknd18n5.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpjknd18n5.jl:63\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjknd18n5.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjknd18n5.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpjknd18n5.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjknd18n5.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # filter and reduce to find lowest even number, if any, and its index\
    \ in the input array\n    return reduce(findmin, [(i, arr[i]) for i in 1:length(arr)\
    \ if iseven(arr[i])], (NaN, NaN))[1] # this is a poor man's form of pattern matching,\
    \ but it works!\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjz_t2jsj.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ reduce(::typeof(findmin), ::Vector{Tuple{Int64, Int64}}, ::Tuple{Float64, Float64})\n\
    \  Closest candidates are:\n    reduce(::Any, ::AbstractArray; kw...) at /shared/centos7/julia/1.7.3/share/julia/base/reducedim.jl:371\n\
    \    reduce(::Any, ::Any; kw...) at /shared/centos7/julia/1.7.3/share/julia/base/reduce.jl:458\n\
    \    reduce(::Any, !Matched::Number) at /shared/centos7/julia/1.7.3/share/julia/base/reduce.jl:460\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpjz_t2jsj.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjz_t2jsj.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjz_t2jsj.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpjz_t2jsj.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching reduce(::typeof(findmin),\
    \ ::Vector{Tuple{Int64, Int64}}, ::Tuple{Float64, Float64})\n  Closest candidates\
    \ are:\n    reduce(::Any, ::AbstractArray; kw...) at /shared/centos7/julia/1.7.3/share/julia/base/reducedim.jl:371\n\
    \    reduce(::Any, ::Any; kw...) at /shared/centos7/julia/1.7.3/share/julia/base/reduce.jl:458\n\
    \    reduce(::Any, !Matched::Number) at /shared/centos7/julia/1.7.3/share/julia/base/reduce.jl:460\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpjz_t2jsj.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjz_t2jsj.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjz_t2jsj.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpjz_t2jsj.jl:4"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjz_t2jsj.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    zero_values = findall(x -> x == 0, arr) # Gets all the zero values' index\n\
    \    if isempty(zero_values)\n        zero_values = 0\n    end\n    even_values\
    \ = findall(x -> x % 2 == 0, arr) # Gets all the even values' index\n    if isempty(even_values)\n\
    \        even_values = 0\n    end\n    if isempty(zero_values) && isempty(even_values)\n\
    \        return []\n    end\n    if length(zero_values) >= length(even_values)\n\
    \        return [0, zero_values[1]]\n    else\n        return [arr[even_values[1]],\
    \ even_values[1]]\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp17cuzkf2.jl:57\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [4, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp17cuzkf2.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp17cuzkf2.jl:56\ntest set: Test\
    \ Failed at /tmp/tmp17cuzkf2.jl:58\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp17cuzkf2.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp17cuzkf2.jl:56\ntest set: Test\
    \ Failed at /tmp/tmp17cuzkf2.jl:59\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp17cuzkf2.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp17cuzkf2.jl:56\ntest set: Test\
    \ Failed at /tmp/tmp17cuzkf2.jl:60\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp17cuzkf2.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp17cuzkf2.jl:56\ntest set: Test\
    \ Failed at /tmp/tmp17cuzkf2.jl:61\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \ "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp17cuzkf2.jl:54\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \n    # Find all the even elements\n    even_elements = findall(x -> x\
    \ % 2 == 0, arr)\n    \n    # If there are no even elements, return empty Vector.\n\
    \    if length(even_elements) == 0\n        return []\n    end\n    \n    # Find\
    \ the index of the smallest even element\n    even_index = findfirst(arr .== minimum(even_elements))\n\
    \    \n    # Return a Vector with the smallest even element and its index.\n \
    \   return [arr[even_index], even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmphzectoe5.jl:55\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  ArgumentError: invalid index:\
    \ nothing of type Nothing\n  Stacktrace:\n    [1] to_index(i::Nothing)\n     \
    \ @ Base ./indices.jl:300\n    [2] to_index(A::Vector{Int64}, i::Nothing)\n  \
    \    @ Base ./indices.jl:277\n    [3] to_indices\n      @ ./indices.jl:333 [inlined]\n\
    \    [4] to_indices\n      @ ./indices.jl:325 [inlined]\n    [5] getindex\n  \
    \    @ ./abstractarray.jl:1218 [inlined]\n    [6] pluck(arr::Vector{Int64})\n\
    \      @ Main /tmp/tmphzectoe5.jl:48\n    [7] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmphzectoe5.jl:55 [inlined]\n\
    \    [9] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [10] top-level scope\n      @ /tmp/tmphzectoe5.jl:54\ntest set:\
    \ Test Failed at /tmp/tmphzectoe5.jl:56\n  Expression: candidate([1, 2, 3]) ==\
    \ [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphzectoe5.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphzectoe5.jl:54\ntest set: Test\
    \ Failed at /tmp/tmphzectoe5.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphzectoe5.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphzectoe5.jl:54\ntest set: Test\
    \ Failed at /tmp/tmphzectoe5.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7."
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphzectoe5.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evenNodes = filter(x -> x % 2 == 0, arr)\n    if length(evenNodes) ==\
    \ 0\n        return []\n    end\n    values = map(x -> [x, findfirst(==(x), arr)],\
    \ evenNodes)\n    min(values, by = x -> x[1])[1]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp3vis1v18.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ min(::Vector{Vector{Int64}}; by=var\"#3#6\"())\n  Closest candidates are:\n\
    \    min(::Any, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134\
    \ got unsupported keyword argument \"by\"\n    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\
    \ got unsupported keyword argument \"by\"\n    min(::Any, !Matched::Any, !Matched::Any,\
    \ !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\
    \ got unsupported keyword argument \"by\"\n    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp3vis1v18.jl:40\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3vis1v18.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3vis1v18.jl:46\ntest set:\
    \ Error During Test at /tmp/tmp3vis1v18.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching min(::Vector{Vector{Int64}};\
    \ by=var\"#3#6\"())\n  Closest candidates are:\n    min(::Any, !Matched::Missing)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:134 got unsupported\
    \ keyword argument \"by\"\n    min(::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:506\
    \ got unsupported keyword argument \"by\"\n    min(::Any, !Matched::Any, !Matched::Any,\
    \ !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\
    \ got unsupported keyword argument \"by\"\n    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp3vis1v18.jl:40\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3vis1v18.jl:48 [inlined]\n\
    \   [4] macro expansion\n    "
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3vis1v18.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    r = []\n    idx = 0\n    for (i,v) in enumerate(arr)\n        if v % 2\
    \ == 0 && v < r[1]\n            r = [v, i]\n        end\n    end\n    return r\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmznnzfzv.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  BoundsError: attempt to access\
    \ 0-element Vector{Any} at index [1]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861\
    \ [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpmznnzfzv.jl:38\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpmznnzfzv.jl:49 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpmznnzfzv.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpmznnzfzv.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  BoundsError: attempt to access 0-element Vector{Any}\
    \ at index [1]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861 [inlined]\n\
    \   [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpmznnzfzv.jl:38\n   [3]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpmznnzfzv.jl:50 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpmznnzfzv.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpmznnzfzv.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  BoundsError: attempt to access 0-element\
    \ Vector{Any} at index [1]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861\
    \ [inlined]\n   [2] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpmznnzfzv.jl:38\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpmznnzfzv.jl:52 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpmznnzfzv.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpmznnzfzv.jl"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmznnzfzv.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # base cases\n    if length(arr) == 0 return [] end\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvcxn23n2.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvcxn23n2.jl:1\n\
    in expression starting at /tmp/tmpvcxn23n2.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    values = []\n    indexes = []\n    for (i, v) in enumerate(arr)\n    \
    \    if v % 2 == 0\n            push!(values, v)\n            push!(indexes, i)\n\
    \        end\n    end\n    if isempty(values)\n        return []\n    end\n  \
    \  min_v = minimum(values)\n    min_i = minimum(indexes[values .== min_v])\n \
    \   return [min_v, min_i]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_dinhut6.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_dinhut6.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_dinhut6.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp_dinhut6.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_dinhut6.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_dinhut6.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp_dinhut6.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_dinhut6.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_dinhut6.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp_dinhut6.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_dinhut6.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_dinhut6.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp_dinhut6.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_dinhut6.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # 1) find even elements\n    even_elements = [x for x in arr if mod(x,\
    \ 2) == 0]\n    # 2) find minumum\n    min_even = minimum(even_elements)\n   \
    \ # 3) find index of minimum\n    min_even_index = indmin(even_elements)\n   \
    \ return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpueh6a366.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: indmin not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpueh6a366.jl:40\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpueh6a366.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpueh6a366.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpueh6a366.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: indmin not defined\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpueh6a366.jl:40\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpueh6a366.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpueh6a366.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpueh6a366.jl:50\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError: reducing\
    \ over an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] reduce_empty(op::Function, #unused#::Type{Int64})\n\
    \      @ Base ./reduce.jl:311\n    [3] mapreduce_empty(#unused#::typeof(identity),\
    \ op::Function, T::Type)\n      @ Base ./reduce.jl:345\n    [4] reduce_empty(op::Base.MappingRF{typeof(identity),\
    \ typeof(min)}, #unused#::Type{Int64})\n      @ Base ./reduce.jl:331\n    [5]\
    \ reduce_empty_iter\n      @ ./reduce.jl:357 [inlined]\n    [6] mapreduce_empty_iter(f::Function,\
    \ op::Function, itr::Vector{Int64}, ItrEltype::Base.HasEltype)\n      @ Base ./reduce.jl:353\n\
    \    [7] _mapreduce\n      @ ./reduce.jl:402 [inlined]\n    [8] _mapreduce_dim\n\
    \      @ ./reducedim"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpueh6a366.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min = 10000\n    min_index = -1\n    for (index, element) in enumerate(arr)\n\
    \        if element < min && element % 2 == 0\n            min = element\n   \
    \         min_index = index\n        end\n    end\n    if min == 10000\n     \
    \   return []\n    end\n    return [min, min_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmppcdii471.jl:53\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppcdii471.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppcdii471.jl:52\ntest set: Test\
    \ Failed at /tmp/tmppcdii471.jl:54\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmppcdii471.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppcdii471.jl:52\ntest set: Test\
    \ Failed at /tmp/tmppcdii471.jl:56\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppcdii471.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppcdii471.jl:52\ntest set: Test\
    \ Failed at /tmp/tmppcdii471.jl:57\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppcdii471.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppcdii471.jl:52\ntest set: Test\
    \ Failed at /tmp/tmppcdii471.jl:58\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppcdii471.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # declarations\n    if arr == []\n        return []\n    end\n    index\
    \ = 0\n    evens = []\n    for i in 1:length(arr)\n        if iseven(arr[i])\n\
    \            index = i\n            push!(evens, arr[i])\n        end\n    end\n\
    \    if evens == []\n        return []\n    end\n    # sort evens \n    evens\
    \ = sort(evens)\n    # find index of evens[1]\n    for i in 1:length(arr)\n  \
    \      if arr[i] == evens[1]\n            index = i\n            break\n     \
    \   end\n    end\n    return [evens[1], index]\nend\n# test vectors\na1 = [4,2,3]\n\
    a2 = [1,2,3]\na3 = []\na4 = [5, 0, 3, 0, 4, 2]\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmprg1t5ji1.jl:71\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprg1t5ji1.jl:71 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprg1t5ji1.jl:70\ntest set: Test\
    \ Failed at /tmp/tmprg1t5ji1.jl:72\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprg1t5ji1.jl:72 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprg1t5ji1.jl:70\ntest set: Test\
    \ Failed at /tmp/tmprg1t5ji1.jl:74\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprg1t5ji1.jl:74 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprg1t5ji1.jl:70\ntest set: Test\
    \ Failed at /tmp/tmprg1t5ji1.jl:75\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprg1t5ji1.jl:75 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprg1t5ji1.jl:70\ntest set: Test\
    \ Failed at /tmp/tmprg1t5ji1.jl:76\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprg1t5ji1.jl:68\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_entries = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_entries,\
    \ arr[i])\n        end\n    end\n    if length(even_entries) == 0\n        return\
    \ []\n    end\n    min_even = minimum(even_entries)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_even\n            return [min_even, i]\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_acjprso.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_acjprso.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_acjprso.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp_acjprso.jl:60\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_acjprso.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_acjprso.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp_acjprso.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_acjprso.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_acjprso.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp_acjprso.jl:63\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_acjprso.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_acjprso.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp_acjprso.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_acjprso.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_even = minimum(filter(x -> iseven(x), arr))\n    min_idx = findfirst(arr,\
    \ min_even)\n    return [min_even, min_idx]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpunzj44h9.jl:44\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpunzj44h9.jl:36\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpunzj44h9.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpunzj44h9.jl:43\ntest set:\
    \ Error During Test at /tmp/tmpunzj44h9.jl:45\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpunzj44h9.jl:36\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpunzj44h9.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpunzj44h9.jl:43\ntest set:\
    \ Error During Test at /tmp/tmpunzj44h9.jl:46\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError: reducing\
    \ over an empty collection is not allow"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpunzj44h9.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n\"\"\"\n    Bonus Points:\n    Rewrite the same\
    \ function that it runs faster, but with a time complexity of O(n).\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8i6qlutz.jl:37\nin expression starting at\
    \ /tmp/tmp8i6qlutz.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    # filter all the\
    \ even numbers\n    filtered_even_numbers = filter(x -> x % 2 == 0, arr)\n   \
    \ # get the smallest number\n    minimum_even_number = minimum(filtered_even_numbers)\n\
    \    # get the index of minimum even number\n    index_of_minimum_even_number\
    \ = findall(arr .== minimum_even_number)[1]\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp_kx1_qd0.jl:34\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_kx1_qd0.jl:1\n\
    in expression starting at /tmp/tmp_kx1_qd0.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even = []\n    for(i,a) in enumerate(arr)\n        if(a % 2 == 0)\n  \
    \          push!(even, a)\n        end\n    end\n    if(isempty(even))\n     \
    \   return []\n    end\n    index = findall(x -> x == minimum(even), even)[1]\n\
    \    return [arr[index], index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpmmqlntt2.jl:52\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmmqlntt2.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmmqlntt2.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpmmqlntt2.jl:53\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [1, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpmmqlntt2.jl:53 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmmqlntt2.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpmmqlntt2.jl:55\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [5, 1] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmmqlntt2.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmmqlntt2.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpmmqlntt2.jl:56\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmmqlntt2.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmmqlntt2.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpmmqlntt2.jl:57\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [5, 1] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmmqlntt2.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return Vector{Int64}([])\n    end\n    min =\
    \ 10001\n    min_ind = -1\n    for i in 1:length(arr)\n        if arr[i]%2 ==\
    \ 0\n            if arr[i] < min\n                min = arr[i]\n             \
    \   min_ind = i\n            end\n        end\n    end\n    if min == 10001\n\
    \        return Vector{Int64}([])\n    end\n    return Vector{Int64}([min, min_ind])\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpm0_uguuh.jl:58\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm0_uguuh.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm0_uguuh.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpm0_uguuh.jl:59\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpm0_uguuh.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm0_uguuh.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpm0_uguuh.jl:61\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm0_uguuh.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm0_uguuh.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpm0_uguuh.jl:62\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm0_uguuh.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm0_uguuh.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpm0_uguuh.jl:63\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm0_uguuh.jl:55\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"\"\"\"\n    Time: O(n)\n    Space: O(1)\n    \"\"\"\n    # Find the\
    \ smallest even value\n    min_even = nothing\n    min_even_idx = nothing\n  \
    \  for (i, item) in enumerate(arr)\n        if iseven(item)\n            if min_even\
    \ == nothing || item < min_even\n                min_even = item\n           \
    \     min_even_idx = i\n            end\n        end\n    end\n    if min_even\
    \ == nothing\n        return []\n    end\n    return [min_even, min_even_idx]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpd1y0w_4b.jl:60\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd1y0w_4b.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd1y0w_4b.jl:59\ntest set: Test\
    \ Failed at /tmp/tmpd1y0w_4b.jl:61\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpd1y0w_4b.jl:61 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd1y0w_4b.jl:59\ntest set: Test\
    \ Failed at /tmp/tmpd1y0w_4b.jl:63\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd1y0w_4b.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd1y0w_4b.jl:59\ntest set: Test\
    \ Failed at /tmp/tmpd1y0w_4b.jl:64\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd1y0w_4b.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd1y0w_4b.jl:59\ntest set: Test\
    \ Failed at /tmp/tmpd1y0w_4b.jl:65\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd1y0w_4b.jl:57\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_arr = arr[findall(x -> iseven(x), arr)]\n    min_even = minimum(even_arr)\n\
    \    indices = findall(arr .== min_even)\n    return [min_even, minimum(indices)]\n\
    end\npluck([4,2,3])\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpswu5_hkl.jl:46\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpswu5_hkl.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpswu5_hkl.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpswu5_hkl.jl:47\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpswu5_hkl.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpswu5_hkl.jl:45\ntest set: Error\
    \ During Test at /tmp/tmpswu5_hkl.jl:48\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  ArgumentError: reducing\
    \ over an empty collection is not allowed\n  Stacktrace:\n    [1] _empty_reduce_error()\n\
    \      @ Base ./reduce.jl:301\n    [2] reduce_empty(op::Function, #unused#::Type{Int64})\n\
    \      @ Base ./reduce.jl:311\n    [3] mapreduce_empty(#unused#::typeof(identity),\
    \ op::Function, T::Type)\n      @ Base ./reduce.jl:345\n    [4] reduce_empty(op::Base.MappingRF{typeof(identity),\
    \ typeof(min)}, #unused#::Type{Int64})\n      @ Base ./reduce.jl:331\n    [5]\
    \ reduce_empty_iter\n      @ ./reduce.jl:357 [inlined]\n    [6] mapreduce_empty_iter(f::Function,\
    \ op::Function, itr::Vector{Int64}, ItrEltype::Base.HasEltype)\n      @ Base ./reduce.jl:353\n\
    \    [7] _mapreduce\n      @ ./reduce.jl:402 [inlined]\n    [8] _mapreduce_dim\n\
    \      @ ./reducedim.jl:330 [inlined]\n    [9] #mapreduce#731\n      @ ./reducedim.jl:322\
    \ [inlined]\n   [10] mapreduce\n      @ ./reducedim.jl:322 [inlined]\n   [11]\
    \ #_minimum#753\n      @ ./reducedim.jl:894 [inlined]\n   [12] _minimum\n    \
    \  @ ./reducedim.jl:894 [inl"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 2 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpswu5_hkl.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Your code here\nend\n\"\"\"\n    \"Given an array of integers, return\
    \ an array of the same length and with\n    each element equal to the product\
    \ of all elements of the array EXCEPT the element at that index.\n    Your solution\
    \ must be able to handle zeros properly.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp75p06xww.jl:37\nin expression starting at\
    \ /tmp/tmp75p06xww.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    res_val = 0\n   \
    \ res_index = 0\n    for (i, val) in enumerate(arr)\n        if val % 2 == 0\n\
    \            if res_val == 0\n                res_val = val\n                res_index\
    \ = i\n            elseif val < res_val\n                res_val = val\n     \
    \           res_index = i\n            end\n        end\n    end\n    if res_val\
    \ == 0\n        return []\n    end\n    return [res_val, res_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprrrroku1.jl:61\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprrrroku1.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprrrroku1.jl:60\ntest set: Test\
    \ Failed at /tmp/tmprrrroku1.jl:62\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprrrroku1.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprrrroku1.jl:60\ntest set: Test\
    \ Failed at /tmp/tmprrrroku1.jl:64\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprrrroku1.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprrrroku1.jl:60\ntest set: Test\
    \ Failed at /tmp/tmprrrroku1.jl:65\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprrrroku1.jl:65 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprrrroku1.jl:60\ntest set: Test\
    \ Failed at /tmp/tmprrrroku1.jl:66\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/c"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprrrroku1.jl:58\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    for (index, item) in enumerate(arr)\n        if iseven(item) && index\
    \ == 1\n            return [item, index]\n        elseif iseven(item) && item\
    \ < arr[1]\n            return [item, index]\n        end\n    end\n    \n   \
    \ return []\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp95hztgt6.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [4, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp95hztgt6.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp95hztgt6.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp95hztgt6.jl:51\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp95hztgt6.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp95hztgt6.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp95hztgt6.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp95hztgt6.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp95hztgt6.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp95hztgt6.jl:54\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp95hztgt6.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp95hztgt6.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp95hztgt6.jl:55\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/c"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp95hztgt6.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_even_value, min_even_index = 0, 0\n    for i in 1:length(arr)\n  \
    \      if arr[i] % 2 == 0\n            if min_even_value == 0 || arr[i] < min_even_value\n\
    \                min_even_value = arr[i]\n                min_even_index = i\n\
    \            end\n        end\n    end\n    if min_even_value == 0\n        return\
    \ Vector{Int64}(undef,0)\n    else\n        return [min_even_value, min_even_index]\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkw72q92a.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkw72q92a.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkw72q92a.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpkw72q92a.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkw72q92a.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkw72q92a.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpkw72q92a.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkw72q92a.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkw72q92a.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpkw72q92a.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkw72q92a.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkw72q92a.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpkw72q92a.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/c"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkw72q92a.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_even = [0, 0]\n    for i in 1:length(arr)\n        if (isodd(arr[i])\
    \ == false) & (min_even[1] == 0)\n            min_even = [arr[i], i]\n       \
    \ elseif (isodd(arr[i]) == false) & (arr[i] < min_even[1])\n            min_even\
    \ = [arr[i], i]\n        end\n    end\n    return min_even\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpq7582v7l.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpq7582v7l.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq7582v7l.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpq7582v7l.jl:51\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpq7582v7l.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq7582v7l.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpq7582v7l.jl:52\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpq7582v7l.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq7582v7l.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpq7582v7l.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpq7582v7l.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq7582v7l.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpq7582v7l.jl:54\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \ "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq7582v7l.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = 0\n    for\
    \ i in arr\n        if i%2 == 0 && (min_even == 0 || i < min_even)\n         \
    \   min_even = i\n        end\n    end\n    if min_even == 0\n        return []\n\
    \    end\n    return [min_even, findfirst(arr .== min_even)[1]]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp172531x8.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp172531x8.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp172531x8.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp172531x8.jl:55\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp172531x8.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp172531x8.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp172531x8.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp172531x8.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp172531x8.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp172531x8.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp172531x8.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp172531x8.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp172531x8.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/c"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp172531x8.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # TODO: complete function pluck and pass the tests\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpot08qbxu.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpot08qbxu.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpot08qbxu.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpot08qbxu.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpot08qbxu.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpot08qbxu.jl:36\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpot08qbxu.jl:43 [inlined]\n\
    \   [4] ma"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpot08qbxu.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    isempty(arr) && return Vector{Int64}()\n    evens = filter(x -> x % 2\
    \ == 0, arr)\n    minimum(evens) == maximum(evens) && return Vector{Int64}()\n\
    \    val, idx = minimum(evens), findfirst(arr, minimum(evens))\n    [val, idx]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxv56mvt_.jl:46\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxv56mvt_.jl:38\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxv56mvt_.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxv56mvt_.jl:45\ntest set:\
    \ Test Failed at /tmp/tmpxv56mvt_.jl:47\n  Expression: candidate([1, 2, 3]) ==\
    \ [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxv56mvt_.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxv56mvt_.jl:45\ntest set: Error\
    \ During Test at /tmp/tmpxv56mvt_.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxv56mvt_.jl:38\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdl"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 2 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxv56mvt_.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min = 10001\n   \
    \ idx = 0\n    for i in 1:length(arr)\n        if arr[i] == 0 && idx == 0\n  \
    \          idx = i\n        end\n        if arr[i] > 0 && arr[i] < min && mod(arr[i],\
    \ 2) == 0\n            min = arr[i]\n            idx = i\n        end\n    end\n\
    \    if idx == 0\n        return []\n    end\n    return [min, idx]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbmjgoiz2.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbmjgoiz2.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbmjgoiz2.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpbmjgoiz2.jl:60\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbmjgoiz2.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbmjgoiz2.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpbmjgoiz2.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbmjgoiz2.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbmjgoiz2.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpbmjgoiz2.jl:63\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbmjgoiz2.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbmjgoiz2.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpbmjgoiz2.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbmjgoiz2.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    \"\"\"\n    Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    your task is to pluck one of the nodes and return it.\n \
    \   The plucked node should be the node with the smallest even value.\n    If\
    \ multiple nodes with the same smallest even value are found return the node that\
    \ has smallest index.\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4oz6tque.jl:1\nin expression starting at /tmp/tmp4oz6tque.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    min_idx = -1\n    min_val = maximum(arr)\n    for (i, n) in enumerate(arr)\n\
    \        if n %% 2 == 0 && n < min_val\n            min_idx = i\n            min_val\
    \ = n\n        end\n    end\n    return (min_idx != -1) ? [min_val, min_idx] :\
    \ []\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"%\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk0c6kkf8.jl:38\nin expression starting at\
    \ /tmp/tmpk0c6kkf8.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    res = find_smallest_even(arr)\n    return res == nothing ? Vector{Int64}()\
    \ : [res, findfirst(arr, res)[1]]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpciwwfshn.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  UndefVarError: find_smallest_even\
    \ not defined\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpciwwfshn.jl:35\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpciwwfshn.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpciwwfshn.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpciwwfshn.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  UndefVarError: find_smallest_even not defined\n\
    \  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpciwwfshn.jl:35\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpciwwfshn.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpciwwfshn.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpciwwfshn.jl:45\n  Test threw exception\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarError: find_smallest_even\
    \ not defined\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpciwwfshn.jl:35\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpciwwfshn.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpciwwfshn.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpciwwfshn.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  UndefVarError: find_smallest_even\
    \ not defined\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/t"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpciwwfshn.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if all(!iseven, arr) || length(arr) == 0\n        return []\n    end\n\
    \    return [minimum(filter(iseven, arr)), findfirst(arr, minimum(filter(iseven,\
    \ arr)))]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3ihw1pm5.jl:45\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp3ihw1pm5.jl:38\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3ihw1pm5.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3ihw1pm5.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp3ihw1pm5.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp3ihw1pm5.jl:38\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3ihw1pm5.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3ihw1pm5.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp3ihw1pm5.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3ihw1pm5.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return Vector{Int64}()\n    end\n    result =\
    \ [arr[1], 1]\n    for i in 2:length(arr)\n        if iseven(arr[i])\n       \
    \     if result[1] == 0 || arr[i] < result[1]\n                result = [arr[i],\
    \ i]\n            end\n        end\n    end\n    if result[1] == 0\n        return\
    \ Vector{Int64}()\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmptti4j437.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptti4j437.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptti4j437.jl:55\ntest set: Test\
    \ Failed at /tmp/tmptti4j437.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [1, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmptti4j437.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptti4j437.jl:55\ntest set: Test\
    \ Failed at /tmp/tmptti4j437.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [2, 6] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptti4j437.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptti4j437.jl:55\ntest set: Test\
    \ Failed at /tmp/tmptti4j437.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptti4j437.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptti4j437.jl:55\ntest set: Test\
    \ Failed at /tmp/tmptti4j437.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/c"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptti4j437.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # making a vector of all the evens and getting the minimum value of that\
    \ list.\n    possible_answers = findall(x -> x % 2 == 0, arr) \n    if !isempty(possible_answers)\n\
    \        smallest_even = minimum(possible_answers) \n        # finding the index\
    \ of the first occurance of the smallest_even.\n        index = findfirst(arr\
    \ .== smallest_even)\n        return [smallest_even, index]\n    else\n      \
    \  return []\n    end\nend\n@testset \"Example 1\" begin\n    @test pluck([4,2,3])\
    \ == [2, 1]\nend\n@testset \"Example 2\" begin\n    @test pluck([1,2,3]) == [2,\
    \ 1]\nend\n@testset \"Example 3\" begin\n    @test pluck([]) == []\nend\n@testset\
    \ \"Example 4\" begin\n    @test pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\nend\n@testset\
    \ \"bunch of tests\" begin\n    @test pluck([]) == []\n    @test pluck([1]) ==\
    \ []\n    @test pluck([0]) == [0, 1]\n    @test pluck([2]) == [2, 1]\n    @test\
    \ pluck([0,2]) == [0, 1]\n    @test pluck([0,1,1,1,1,0]) == [0, 1]\n    @test\
    \ pluck([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @testset not defined\nin expression starting\
    \ at /tmp/tmpuzr1penq.jl:46\nin expression starting at /tmp/tmpuzr1penq.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    first_even = nothing\n    first_even_idx = nothing\n    for (idx, item)\
    \ in enumerate(arr)\n        if item % 2 == 0\n            if first_even == nothing\n\
    \                first_even = item\n                first_even_idx = idx\n   \
    \         else\n                if item < first_even\n                    first_even\
    \ = item\n                    first_even_idx = idx\n                end\n    \
    \        end\n        end\n    end\n    if first_even == nothing\n        return\
    \ []\n    else\n        return [first_even, first_even_idx]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpp2yl7xpr.jl:61\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpp2yl7xpr.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpp2yl7xpr.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpp2yl7xpr.jl:62\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpp2yl7xpr.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpp2yl7xpr.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpp2yl7xpr.jl:64\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpp2yl7xpr.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpp2yl7xpr.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpp2yl7xpr.jl:65\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpp2yl7xpr.jl:65 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpp2yl7xpr.jl:60\ntest set: Test\
    \ Failed at /tmp/tmpp2yl7xpr.jl:66\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp2yl7xpr.jl:58\n"
  exit_code: 1
  status: SyntaxError
