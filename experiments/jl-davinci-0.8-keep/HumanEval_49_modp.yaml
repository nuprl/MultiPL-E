name: HumanEval_49_modp
language: jl
prompt: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n \
  \   3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
  \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
  \ p::Int64)::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5)\
  \ == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
  @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
  \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
completions: ["    b = 1\n    for i = 1:n\n        b = (b*2) % p\n    end\n    return\
    \ b\nend", "    n %= p\n    result = 1\n    while n > 0\n        if n % 2 == 1\n\
    \            result = (result * x) % p\n        x = (x * x) % p\n        n >>=\
    \ 1\n    end\n    return result\nend", "    a = 1\n    b = 2\n    for i in 1:n\n\
    \        a = mod(a*b, p)\n    end\n    return a\nend", "    if n == 0\n      \
    \  return 1\n    elseif n == 1\n        return 2\n    elseif n == 2\n        return\
    \ 4\n    elseif n == 3\n        return 8\n    elseif n == 4\n        return 16\n\
    \    elseif n == 5\n        return 32\n    elseif n == 6\n        return 64\n\
    \    elseif n == 7\n        return 128\n    elseif n == 8\n        return 256\n\
    \    elseif n == 9\n        return 512\n    elseif n == 10\n        return 1024\n\
    \    elseif n == 11\n        return 2048\n    elseif n == 12\n        return 4096\n\
    \    elseif n == 13\n        return 8192\n    elseif n == 14\n        return 16384\n\
    \    elseif n == 15\n        return 32768\n    elseif n == 16\n        return\
    \ 65536\n    elseif n == 17\n        return 131072\n    elseif n == 18\n     \
    \   return 262144\n    elseif n == 19\n        return 524288\n    elseif n ==\
    \ 20\n        return 1048576\n    elseif n == 21\n        return 2097152\n   \
    \ elseif n == 22\n        return 4194304\n    elseif n == 23\n        return 8388608\n\
    \    elseif n == 24\n        return 16777216\n    elseif n == 25\n        return\
    \ 33554432\n    elseif n == 26\n        return 67108864\n    elseif n == 27\n\
    \        return 134217728\n    elseif n == 28\n        return 268435456\n    elseif\
    \ n == 29\n        return 536870912\n    elseif n == 30\n        return 1073741824\n\
    \    elseif n == 31\n        return 2147483648\n    elseif n == 32\n        return\
    \ 4294967296\n    elseif n == 33\n        return 8589934592\n    elseif n == 34\n\
    \        return 17179869184\n    elseif n == 35\n        return 34359738368\n\
    \    elseif n == 36\n        return 68719476736\n    elseif n == 37\n        return\
    \ 137438953472\n    elseif n == 38\n        return 274877906944\n    elseif n\
    \ == 39\n        return 549", "    N = 0\n    if n==0\n        return 1\n    end\n\
    \    if p==2\n        return 1\n    end\n    if n<0\n        n *= -1\n       \
    \ n = n % (p-1)\n        N = modp(n, p)\n        return p-N\n    end\n    if n==1\n\
    \        return n\n    end\n    if n%2==0\n        A = modp(n/2, p)\n        return\
    \ (A*A)%p\n    else\n        A = modp(n-1, p)\n        return (A*modp(n, p))%p\n\
    \    end\nend", "    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>>\
    \ modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n  \
    \  1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    \    a, b = 1, 2\n    while n > 0\n        if bit(n, 0) == 1\n            a =\
    \ mod(a * b, p)\n        end\n        b = mod(b * b, p)\n        n = bitshift(n,\
    \ -1)\n    end\n    return a\nend", "    q, r = divrem(n, p)\n    return r\nend",
  "    if n < 0\n        return 0\n    end\n    b, x = n, 1\n    while b > 0\n   \
    \     x = mod(x*b, p)\n        b = div(b, 2)\n    end\n    return x\nend\nmodp(3,\
    \ 5)", "    if p==1\n        return 0\n    end\n    if n==0\n        return 1\n\
    \    end\n    i=1\n    val=2\n    while (2^i)<=n\n        i+=1\n    end\n    if\
    \ i>1\n        val=modp(2^(i-1), p)^2\n    end\n    return val*modp(n-2^(i-1),\
    \ p)\nend", "    res = 1\n    b = 2\n    n = n % (p-1)\n    while n > 0\n    \
    \    if n % 2 == 1\n            res = (res * b) % p\n        end\n        n =\
    \ div(n, 2)\n        b = (b * b) % p\n    end\n    return res\nend", "    modp\
    \ = 1\n    a = 2\n    while n > 0\n        while n % 2 == 0\n            n = div(n,\
    \ 2)\n            a = mod(a^2, p)\n        end\n        n = n - 1\n        modp\
    \ = mod(modp * a, p)\n    end\n    return modp\nend", "    if n == 0\n       \
    \ return 1\n    end\n    # if n == 1, just return the base\n    if n == 1\n  \
    \      return a\n    end\n    b = modp(n >> 1, p)\n    b *= b\n    b = mod(b,\
    \ p)\n    if n & 1 == 1\n        b *= a\n    end\n    return mod(b, p)\nend",
  "    if n == 0\n        return 1\n    end\n    number_times_2 = modp(n - 1, p)\n\
    \    return mod(2 * number_times_2, p)\nend", "    \"\"\"Return 2^n modulo p (be\
    \ aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n  \
    \  2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"\n    if n == 0\n        return 1\n    end\n    a = modp(n>>1,\
    \ p)\n    a = a^2 % p\n    if n % 2 == 1\n        a = a * 2 % p\n    end\n   \
    \ return a\nend", "    n = n % p \n    n = n % p\n    if n < 0\n        n += p\n\
    \    end\n    q = (2^n) % p\n    q = q % p\n    if q < 0\n        q += p\n   \
    \ end\n    return q\nend", "    if n == 0\n        return 1\n    elseif n == 1\n\
    \        return 2\n    elseif n == 2\n        return 4\n    elseif n == 3\n  \
    \      return 8\n    elseif n == 4\n        return 16\n    elseif n == 5\n   \
    \     return 32\n    elseif n == 6\n        return 64\n    elseif n == 7\n   \
    \     return 128\n    elseif n == 8\n        return 256\n    elseif n == 9\n \
    \       return 512\n    elseif n == 10\n        return 1024\n    elseif n == 11\n\
    \        return 2048\n    elseif n == 12\n        return 4096\n    elseif n ==\
    \ 13\n        return 8192\n    elseif n == 14\n        return 16384\n    elseif\
    \ n == 15\n        return 32768\n    elseif n == 16\n        return 65536\n  \
    \  elseif n == 17\n        return 131072\n    elseif n == 18\n        return 262144\n\
    \    elseif n == 19\n        return 524288\n    elseif n == 20\n        return\
    \ 1048576\n    elseif n == 21\n        return 2097152\n    elseif n == 22\n  \
    \      return 4194304\n    elseif n == 23\n        return 8388608\n    elseif\
    \ n == 24\n        return 16777216\n    elseif n == 25\n        return 33554432\n\
    \    elseif n == 26\n        return 67108864\n    elseif n == 27\n        return\
    \ 134217728\n    elseif n == 28\n        return 268435456\n    elseif n == 29\n\
    \        return 536870912\n    elseif n == 30\n        return 1073741824\n   \
    \ elseif n == 31\n        return 2147483648\n    elseif n == 32\n        return\
    \ 4294967296\n    elseif n == 33\n        return 8589934592\n    elseif n == 34\n\
    \        return 17179869184\n    elseif n == 35\n        return 34359738368\n\
    \    elseif n == 36\n        return 68719476736\n    elseif n == 37\n        return\
    \ 137438953472\n    elseif n == 38\n        return 274877906944\n    elseif n\
    \ == 39\n        return 549", "    n = n % p\n    if n == 0\n        return 1\n\
    \    end\n    if n == 1\n        return 2\n    end\n    s = 2\n    for i in 2:n\n\
    \        s = (s * 2) % p\n    end\n    return s\nend", "    while p < 0\n    \
    \    p += n\n    end\n    n % p\nend", "    return mod(round(Int64, 2^n), p)\n\
    end", "    if n == 0\n        return 1\n    elseif n > 0\n        return mod2(n,\
    \ p)\n    else\n        return modp(-n, p)\n    end\nend", "    n %= p \n    return\
    \ n == 0 ? 1 : n\nend", "    if n == 0\n        return 1\n    end\n    if n ==\
    \ 1\n        return 2\n    end\n    if n == 2\n        return 4\n    end\n   \
    \ if n % 2 == 0\n        return (modp(n/2, p)^2) % p\n    else\n        return\
    \ (2 * modp(n-1, p)) % p\n    end\nend", "    if n == 0 \n        return 1\n \
    \   end\n    b = bits(n)\n    b[1] = modp(1, p)\n    for i = 2:length(b)\n   \
    \     b[i] = modp(2 * b[i-1], p)\n    end\n    n = 0\n    for i = 1:length(b)\n\
    \        n += b[i] * (n >= 0 ? 1 : -1)\n    end\n    return n\nend\n ", "    k\
    \ = 0\n    result = 1\n    while k < n\n        result = (result * 2) % p\n  \
    \      k += 1\n    end\n    return result\nend", "    if n == 0\n        return\
    \ 1\n    elseif n == 1\n        return 2\n    elseif n == 2\n        return 4\n\
    \    elseif n == 3\n        return 8\n    elseif n == 4\n        return 16\n \
    \   elseif n == 5\n        return 32\n    elseif n == 6\n        return 64\n \
    \   elseif n == 7\n        return 128\n    elseif n == 8\n        return 29\n\
    \    elseif n == 9\n        return 58\n    elseif n == 10\n        return 116\n\
    \    elseif n == 11\n        return 232\n    elseif n == 12\n        return 205\n\
    \    elseif n == 13\n        return 141\n    elseif n == 14\n        return 202\n\
    \    elseif n == 15\n        return 76\n    elseif n == 16\n        return 152\n\
    \    elseif n == 17\n        return 45\n    elseif n == 18\n        return 90\n\
    \    elseif n == 19\n        return 180\n    elseif n == 20\n        return 117\n\
    \    elseif n == 21\n        return 234\n    elseif n == 22\n        return 201\n\
    \    elseif n == 23\n        return 143\n    elseif n == 24\n        return 186\n\
    \    elseif n == 25\n        return 172\n    elseif n == 26\n        return 68\n\
    \    elseif n == 27\n        return 136\n    elseif n == 28\n        return 57\n\
    \    elseif n == 29\n        return 114\n    elseif n == 30\n        return 228\n\
    \    elseif n == 31\n        return 213\n    elseif n == 32\n        return 183\n\
    \    elseif n == 33\n        return 125\n    elseif n == 34\n        return 250\n\
    \    elseif n == 35\n        return 233\n    elseif n == 36\n        return 197\n\
    \    elseif n == 37\n        return 159\n    elseif n == 38\n        return 98\n\
    \    elseif n == 39\n        return 196\n    elseif n == 40\n        return 154\n\
    \    elseif n == 41\n        return 37\n    elseif n == 42\n        return 74\n\
    \    elseif n == 43\n        return 148\n    elseif n == 44\n        return 53\n\
    \    elseif n == 45\n        return 106\n    elseif n == 46", "    if n == 0\n\
    \        modp = 1\n    else\n        modp = prod([x for x in range(1,n+1)])%p\n\
    \    end\n    return modp\nend", "    if n == 0\n        return 1\n    end\n \
    \   if n == 1\n        return 2\n    end\n    if n%2 == 0\n        a = modp(n/2,\
    \ p)\n        return (a*a)%p\n    else\n        return (2*modp(n-1, p))%p\n  \
    \  end\nend", "    if p == 1\n        return 0\n    end\n    assert(n \u2265 0)\n\
    \    result = 1\n    power = n\n    while power > 0\n        if isodd(power)\n\
    \            result = mod(result * power, p)\n        end\n        power = div(power,\
    \ 2)\n        power = mod(power, p)\n    end\n    return result\nend", "    if\
    \ n == 0\n        return 1\n    end\n    m = modp(n div 2, p)\n    m = rem(m*m,\
    \ p)\n    if mod(n, 2) == 1\n        m = rem(m*2, p)\n    end\n    return m\n\
    end\n ", "    n %= p\n    n == 0 && return 1 # $0^0 = 1$\n    n == 1 && return\
    \ n\n    a = n\n    b = 1\n    while n > 1\n        n % 2 == 0 && (a *= a) %=\
    \ p\n        n >  1 && (b *= a) %= p\n        n >>= 1\n    end\n    return b\n\
    end", "    # initialize result = 1\n    r::Int64 = 1\n    # update r to 2^n mod\
    \ p\n    while n > 0\n        # check if n is odd\n        if n % 2 == 1\n   \
    \         r = (r * 2) % p\n        end\n        # divide n by 2\n        n = div(n,\
    \ 2)\n    end\n    # return result\n    return r\nend", "    if n == 0\n     \
    \   return 1\n    elseif n%2 == 0\n        return modp(n//2, p)^2 % p\n    else\n\
    \        return modp(n//2, p)^2 % p * modp(n-1, p) % p\n    end\nend", "    m\
    \ = 1\n    for i = 1:n\n        m = (m*2) % p\n    end\n    return m\nend", " \
    \   if n < 0 \n        n = n % p\n    end\n    if n < p/2\n        return 2^n\
    \ % p\n    else\n        return 2^(n-p) % p\n    end\nend", "    if n == 0\n \
    \       return 1\n    end\n    a = modp(n \xF7 2, p)\n    a = (a * a) % p\n  \
    \  if n % 2 == 1\n        a = (a * 2) % p\n    end\n    return a\nend", "    if\
    \ n == 0\n        return 1\n    end\n    if mod(n, 2) == 0\n        return mod(modp(n\
    \ \xF7 2, p)^2, p)\n    else\n        return mod(modp(n \xF7 2, p)^2 * 2, p)\n\
    \    end\nend", "    if n == 0\n        return 1\n    elseif n == 1\n        return\
    \ 2 % p\n    elseif n == 2\n        return 4 % p\n    elseif n == 3\n        return\
    \ 8 % p\n    elseif n == 4\n        return 16 % p\n    elseif n == 5\n       \
    \ return 32 % p\n    elseif n == 6\n        return 64 % p\n    elseif n == 7\n\
    \        return 128 % p\n    elseif n == 8\n        return 256 % p\n    elseif\
    \ n == 9\n        return 512 % p\n    elseif n == 10\n        return 1024 % p\n\
    \    elseif n == 11\n        return 2048 % p\n    elseif n == 12\n        return\
    \ 4096 % p\n    elseif n == 13\n        return 8192 % p\n    elseif n == 14\n\
    \        return 16384 % p\n    elseif n == 15\n        return 32768 % p\n    elseif\
    \ n == 16\n        return 65536 % p\n    elseif n == 17\n        return 131072\
    \ % p\n    elseif n == 18\n        return 262144 % p\n    elseif n == 19\n   \
    \     return 524288 % p\n    elseif n == 20\n        return 1048576 % p\n    elseif\
    \ n == 21\n        return 2097152 % p\n    elseif n == 22\n        return 4194304\
    \ % p\n    elseif n == 23\n        return 8388608 % p\n    elseif n == 24\n  \
    \      return 16777216 % p\n    elseif n == 25\n        return 33554432 % p\n\
    \    elseif n == 26\n        return 67108864 % p\n    elseif n == 27\n       \
    \ return 134217728 % p\n    elseif n == 28\n        return 268435456 % p\n   \
    \ elseif n == 29\n        return 536870912 % p\n    elseif n == 30\n        return\
    \ 1073741824 % p\n    elseif n == 31\n        return 2147483648 % p\n    elseif\
    \ n == 32\n        return 4294967296 % p\n    elseif n == 33\n        return 8589934592\
    \ % p\n    elseif n == 34\n        return 17179869184 % p\n    elseif n == 35",
  "  exp = 1\n  base = 2\n  while n > 0\n    if n % 2 == 1\n      exp = mod(exp *\
    \ base, p)\n    end\n    base = mod(base * base, p)\n    n = div(n, 2)\n  end\n\
    \  return exp\nend", "    a = 1\n    b = 2\n    while n > 0\n        if bit(n,\
    \ 0) == 1\n            a = mod2mul(a, b, p)\n        end\n        b = mod2mul(b,\
    \ b, p)\n        n = n >> 1\n    end\n    return a\nend", "    result = 1\n  \
    \  for i = 1:n\n        result = result*2 % p\n    end\n    return result\nend",
  "    r = 1\n    b = 2\n    while n > 0\n        if (n % 2) == 1\n            r =\
    \ (r * b) % p\n        end\n        n = n >> 1\n        b = (b * b) % p\n    end\n\
    \    return r\nend", "    if n < 0 \n        n += floor(n/p) * p \n    end\n \
    \   n % p\nend", "    # return 2^n mod p (be aware of numerics).\n    # from https://github.com/mhaskar/TutorialOfAlgorithms/blob/master/DiscreteLogarithm/PollardRho.jl\n\
    \    n = n % (p-1)\n    if n == 0\n        return 1\n    end\n    w = 2\n    x\
    \ = 1\n    while n > 1\n        while n % 2 == 0\n            n = n / 2\n    \
    \        x = (x * w) % p\n        end\n        n = n - 1\n        t = w\n    \
    \    w = (w * w) % p\n        x = (x * w) % p\n    end\n    return x\nend\n\"\"\
    \"Use one of the Fermat test functions.\n    >>> isprime_f3(3)\n    true\n   \
    \ >>> isprime_f3(4)\n    false\n    >>> isprime_f3(101)\n    true\n    >>> isprime_f3(991)\n\
    \    false\n    >>> isprime_f3(98777)\n    false\n    >>> isprime_f3(98777*991)\n\
    \    true\n    \"\"\"", "    if n < 0\n        b = modp(-n, p)\n        return\
    \ (p-b)%p\n    end\n    #If N is negative, then modp(N, p) is (p-modp(-N, p))\
    \ mod p.\n    b = 1\n    m = n\n    while m > 0\n        if mod(m, 2) == 1\n \
    \           b = (b*n)%p\n        end\n        n = (n*n)%p\n        m = floor(m/2)\n\
    \    end\n    return b\nend", "    r = 1\n    while n > 0\n        if bit_shift(n,\
    \ -1) == 1\n            r = mod(r*2, p)\n        end\n        n = bit_shift(n,\
    \ -1)\n    end\n    return r\nend", "    if n == 0\n        return 1\n    elseif\
    \ n%2 == 0\n        m = modp(n//2, p)\n        return (m*m)%p\n    else\n    \
    \    return (2*modp(n-1, p))%p\n    end\nend", "    if n == 0\n        return\
    \ 1\n    end\n    if n < 0\n        # O(p)\n        return modp(p - (-n % p),\
    \ p)\n    end\n    if n == 1\n        return 2\n    end\n    if n == 2\n     \
    \   return 4\n    end\n    if n % 2 == 0\n        t = modp(n/2, p)\n        return\
    \ (t * t) % p\n    else\n        return (2 * modp(n-1, p)) % p\n    end\nend",
  "    if n == 0 \n        return 1\n    elseif n%2 == 0\n        return modp(n/2,\
    \ p)^2 % p\n    else\n        return modp(n/2, p)^2 * 2 % p\n    end\nend", " \
    \   if n == 0\n        return 1\n    end\n    prod = modp(n >> 1, p)\n    if n\
    \ % 2 == 0\n        return prod * prod % p\n    else\n        return prod * prod\
    \ * n % p\n    end\nend", "    if n == 0\n        return 1\n    end\n    if n\
    \ % 2 == 0\n        return modp(n / 2, p)^2 % p\n    else\n        return modp(n\
    \ / 2, p)^2 * 2 % p\n    end\nend", "    \n    # n may be large\n    #  if n is\
    \ larger than 2^(64-1), it will first be cast to \n    #  a 64-bit signed integer,\
    \ then the bitshift will be done\n    #  if n is larger than 2^63, the bitshift\
    \ will set the sign bit \n    #  to true and not shift anything, then the NOT\
    \ operation will\n    #  clear the sign bit, which will make the result negative\n\
    \    #  Julia will automatically cast the negative value to a UInt64\n    #  which\
    \ can then be cast back to an Int64.\n    #  However, the result will then be\
    \ wrong.\n    #  We therefore convert to a UInt64 before the shift to avoid this.\n\
    \    #  If n is larger than 2^64-1, the bitshift will throw an error\n    if n\
    \ >= 0\n        m = UInt64(n)\n    else\n        m = Int64(UInt64(n))\n    end\n\
    \    \n    # Modular exponentiation by repeated squaring\n    result = 1\n   \
    \ while m > 0\n        if bit(m, 0) == 1\n            result = (result * n) %\
    \ p\n        end\n        m = shift_right(m, 1)\n        n = (n * n) % p\n   \
    \ end\n    return result\nend", "    if n == 0 \n        return 1\n    end\n \
    \   m = modp(n >> 1, p)\n    m = m*m % p\n    if n % 2 == 1\n        m = m*2 %\
    \ p\n    end\n    return m\nend", "  n %= p\n  n = n == 0 ? 1 : n\n  while n <\
    \ 0\n    n += p\n  end\n  if n & 1 == 1 \n    y = 2\n  else\n    y = 1\n  end\n\
    \  a = n\n  while a > 0\n    a >>= 1\n    if a & 1 == 1\n      y = y * 2 % p\n\
    \    end\n  end\n  return y\nend", "    a = 1\n    b = 2\n    while n > 0\n  \
    \      if n % 2 == 1\n            a = (a * b) % p\n        end\n        n = div(n,\
    \ 2)\n        b = (b * b) % p\n    end\n    return a\nend", "    n = n % p\n \
    \   pow = 1\n    while n > 0\n        if bitstring(n)[end] == '1'\n          \
    \  pow = pow * 2 % p\n        end\n        n = div(n, 2)\n    end\n    return\
    \ pow\nend", "    n, k = n, 1\n    while n > 0\n        if n % 2 == 1\n      \
    \      k = k * 2 % p\n        end\n        n = div(n, 2)\n    end\n    return\
    \ k\nend", "    n::Int64\n    n = n % p\n    if n > (p//2)\n        n = p - n\n\
    \    end\n    return n\nend", "    #check if n is an integer\n    #check if p\
    \ is a prime\n    if n == 0\n        return 1\n    end\n    temp = modp(n//2,\
    \ p)\n    temp = (temp*temp) % p\n    if (n%2) == 1\n        temp = (temp*2) %\
    \ p\n    end\n    return temp\nend", "    n = n % p\n    if n < 0\n        n +=\
    \ p\n    end\n    return n\nend", "    \n    if n == 0\n        m = 1\n    elseif\
    \ n == 1\n        m = 2\n    elseif n == 2\n        m = 4\n    elseif n == 3\n\
    \        m = 8\n    elseif n == 4\n        m = 16\n    elseif n == 5\n       \
    \ m = 32\n    elseif n == 6\n        m = 64\n    elseif n == 7\n        m = 128\n\
    \    elseif n == 8\n        m = 256\n    elseif n == 9\n        m = 512\n    elseif\
    \ n == 10\n        m = 1024\n    elseif n == 11\n        m = 2048\n    elseif\
    \ n == 12\n        m = 4096\n    elseif n == 13\n        m = 8192\n    elseif\
    \ n == 14\n        m = 16384\n    elseif n == 15\n        m = 32768\n    elseif\
    \ n == 16\n        m = 65536\n    elseif n == 17\n        m = 131072\n    elseif\
    \ n == 18\n        m = 262144\n    elseif n == 19\n        m = 524288\n    elseif\
    \ n == 20\n        m = 1048576\n    elseif n == 21\n        m = 2097152\n    elseif\
    \ n == 22\n        m = 4194304\n    elseif n == 23\n        m = 8388608\n    elseif\
    \ n == 24\n        m = 16777216\n    elseif n == 25\n        m = 33554432\n  \
    \  elseif n == 26\n        m = 67108864\n    elseif n == 27\n        m = 134217728\n\
    \    elseif n == 28\n        m = 268435456\n    elseif n == 29\n        m = 536870912\n\
    \    elseif n == 30\n        m = 1073741824\n    elseif n == 31\n        m = 2147483648\n\
    \    elseif n == 32\n        m = 4294967296\n    elseif n == 33\n        m = 8589934592\n\
    \    elseif n == 34\n        m = 17179869184\n    elseif n == 35\n        m =\
    \ 34359738368\n    elseif n == 36\n        m = 68719476736\n    elseif n", " \
    \   if n == 0\n        return 1\n    end\n    x = modp(n>>1, p)\n    x = x*x%p\n\
    \    if n&1 == 1\n        x = x*2%p\n    end\n    return x\nend", "    if n ==\
    \ 0\n        return 1\n    else\n        k = n % p\n        q = n//p\n       \
    \ if k%2 == 0\n            return (modp(k, p)^2 - q) % p\n        else\n     \
    \       return ((modp(k, p)^2 - q) * (p-1)) % p\n        end\n    end\nend", " \
    \   return rem(big(2)^n, p)\nend", "    if n == 0\n        return 1\n    elseif\
    \ n % 2 == 0\n        return modp(n \xF7 2, p)^2 mod p\n    else\n        return\
    \ (modp(n - 1, p)^2 mod p) * modp(1, p) mod p\n    end\nend", "    n = mod(n,\
    \ p)\n    r = 1\n    while n > 0\n        if n % 2 == 1\n            r = mod(r\
    \ * r, p)\n        end\n        n = n >> 1\n    end\n    return r\nend", "   \
    \ n == 0 && return 1\n    n % 2 == 0 && return modp(n\xF72, p)^2 % p\n    return\
    \ modp(n\xF72, p)^2 % p * 2 % p\nend", '    iseven(n) && return 2', "    n %=\
    \ p\n    n %= p\n    res = 1\n    #print(\"n=\", n, \" \", res)\n    for i in\
    \ 1:n\n        res *= 2\n        res %= p\n        #print(\"n=\", n, \" \", res)\n\
    \    end\n    res\nend", "    if p == 2\n        # special case\n        return\
    \ 1\n    end\n    if n == 0\n        return 1\n    end\n    if n == 1\n      \
    \  return 2\n    end\n    # we don't want to overflow to get the right answer\n\
    \    r = 1\n    b = 2\n    while n > 0\n        if n % 2 == 1\n            r =\
    \ (r * b) % p\n        end\n        n = div(n, 2)\n        b = (b * b) % p\n \
    \   end\n    return r\nend", "    if n == 0\n        return 1\n    end\n    if\
    \ n%2 == 0\n        return (modp(n/2, p)^2)%p\n    else\n        return (modp(n-1,\
    \ p)*2)%p\n    end\nend", "    if n == 0\n        return 1\n    end\n    a = modp(n\
    \ div 2, p)\n    a *= a\n    if n % 2 == 1\n        a *= 2\n    end\n    return\
    \ mod(a, p)\nend", "    r = 1\n    while n != 0\n        if rem(n, 2) == 1\n \
    \           r = (r * 2) % p\n        end\n        n = div(n, 2)\n    end\n   \
    \ return r\nend", "    return mod(2^n, p)\nend", "    if p == 1\n        return\
    \ 0\n    end\n    a = 1\n    for _ in 1:n\n        a = mod(a*2, p)\n    end\n\
    \    return a\nend\n```", "    if n == 0\n        return 1\n    end\n    if n\
    \ % 2 == 0\n        return modp(div(n, 2), p)^2 % p\n    else\n        return\
    \ 2 * modp(div(n-1, 2), p)^2 % p\n    end\nend", "    if n == 0\n        return\
    \ 1\n    elseif n < 0\n        return modp(n+1, p) * modp(p-1, p)\n    else\n\
    \        if bitlength(n) == 1\n            return n\n        else\n          \
    \  return modp(2*modp(n>>1, p), p)^2\n        end\n    end\nend", "    if n ==\
    \ 0\n        return 1\n    end\n    if mod(n, 2) == 0\n        a = modp(div(n,\
    \ 2), p)\n        return mod(a*a, p)\n    else\n        a = modp(div(n, 2), p)\n\
    \        return mod(2*a*a, p)\n    end\nend", "    if n == 0\n        return 1\n\
    \    end\n    if n == 1\n        return 2\n    end\n    temp = modp(div(n, 2),\
    \ p)\n    res = rem(temp*temp, p)\n    if mod(n, 2) == 1\n        res = rem(res*2,\
    \ p)\n    end\n    return res\nend", "    if n == 0\n        return 1\n    elseif\
    \ p == 1\n        return 0\n    elseif n == 1\n        return 1\n    elseif n\
    \ < 0\n        return modp(-n, p)\n    else\n        u, v = p, n\n        a, b,\
    \ c, d = 1, 0, 0, 1\n        while u != 0\n            q, r = divrem(v, u)\n \
    \           v, u = u, r\n            a, b, c, d = c, d, a - q*c, b - q*d\n   \
    \     end\n        if b < 0\n            b += p\n        end\n        return b\n\
    \    end\nend", "    if n == 0\n        return 1\n    elseif n == 1\n        return\
    \ 2\n    else\n        if n % 2 == 0\n            half = modp(n/2, p)\n      \
    \      return half^2 % p\n        else\n            half = modp((n-1)/2, p)\n\
    \            return (half^2 * 2) % p\n        end\n    end\nend", "    return\
    \ mod(2^n, p)\nend", "    s = 1\n    while n > 0\n        if n % 2 == 1\n    \
    \        s = (s * 2) % p\n        end\n        n = div(n, 2)\n    end\n    return\
    \ s\nend", "    # return mod(Int64(2^n), p)\n    # return mod(n^n, p)\n    return\
    \ 2^(mod(n, p-1)) % p\nend", "    if p == 2 \n        return 1\n    end\n    bin\
    \ = base(2, n)\n    s = 0\n    r = 1\n    for i in 1:length(bin)\n        if bin[i]\
    \ == 1\n            r = r * 2^s\n            r = r mod p\n        end\n      \
    \  s = s + 1\n    end\n    return r\nend", "    return ifelse(n == 0, 1, ifelse(n\
    \ == 1, 2, (2 * modp(n-1, p)) % p))\nend", "  if n == 0\n    return 1\n  else\n\
    \    if n == 1\n      return 2\n    else\n      return (2 * modp(n-1, p)) % p\n\
    \    end\n  end\nend", "    if n == 0\n        return 1\n    end\n    b = 0\n\
    \    q = n\n    while q >= p\n        if q%2 == 1\n            b += 1\n      \
    \  end\n        q = q >> 1\n    end\n    if b % 2 == 0\n        return 2^q % p\n\
    \    else\n        return -2^q % p\n    end\nend", "    @assert p>=3\n    l =\
    \ n\n    @inbounds for i in 1:nbits(l)-1\n        l = l*l\n        if isodd(l)\n\
    \            l = l*n\n        end\n        l %= p\n    end\n    l\nend", "   \
    \ p1 = p - 1\n    n1 = n % p1\n    if n1 == 0 return 1\n    if n1 == 1 return\
    \ n % p\n    # now, n1 >= 2\n    b = Int64(log2(n1))\n    # compute x^(2^b)\n\
    \    x = modp(n, 2^b, p)\n    return x^2 % p\nend", "    n == 0 && return 1\n\
    \    n%2 == 0 && return (modp(n/2, p)^2)%p\n    return (2*modp(n-1, p))%p\nend",
  "    if p == 2\n        return 1\n    end\n    return ((2^n)-1) % p\nend", "   \
    \ n %= p\n    result = 1\n    while n > 0\n        if n & 1 == 1\n           \
    \ result = (result * 2) % p\n        end\n        n >>= 1\n    end\n    return\
    \ result\nend", "    if n == 0\n        return 1\n    end\n    if n % 2 == 0\n\
    \        return ((modp(n \xF7 2, p))^2) % p\n    else\n        return ((modp(n\
    \ \xF7 2, p))^2 * 2) % p\n    end\nend", "    if n == 0\n        return 1\n  \
    \  else\n        z = modp(div(n, 2), p)\n        z = z^2 - p * div(z^2, p) # numerics\
    \ in modpow\n        if n % 2 == 0\n            return z\n        else\n     \
    \       return z * 2 - p * div(z * 2, p)\n        end\n    end\nend", "    result\
    \ = 1 \n    if n == 0 \n        return result \n    end\n    if n == 1 \n    \
    \    return 2\n    end\n    while n > 1 \n        if n % 2 == 0 \n           \
    \ n = n / 2 \n            result = (result * 2) % p \n        else \n        \
    \    n = n - 1 \n            result = (result * 2) % p \n        end\n    end\n\
    \    return result \nend\n```", "    if n == 0\n        return 1\n    else\n \
    \       a = modp(div(n, 2), p)\n        a = a*a % p\n        if n % 2 == 1\n \
    \           a = a*2 % p\n        end\n        return a\n    end\nend", "    if\
    \ n == 0\n        return 1\n    elseif n == 1\n        return 1\n    elseif n\
    \ == 2\n        return 2\n    else\n        if n%2 == 0\n            return (modp(n/2,\
    \ p)^2)%p\n        else\n            return (2*modp(n-1, p))%p\n        end\n\
    \    end\nend", "    n = n % p\n    #if n < 0\n    #    n += p\n    #end\n   \
    \ return n\nend", "  if (n == 0) return 1 else\n  if (n == 1) return 2 else\n\
    \  if (n == 2) return 4 else\n  if (n == 3) return 8 else\n  if (n % 2 == 0) return\
    \ modp(n div 2, p)^2 - (1 mod p) else\n  return 2 * modp(n - 1, p) - (1 mod p)\n\
    end", "    if n == 0\n        return 1\n    else\n        q, r = divrem(n, 2)\n\
    \        if r == 0\n            return modp(q, p)^2 % p\n        else\n      \
    \      return modp(q, p)^2 % p * 2 % p\n        end\n    end\nend", "    a = 1\n\
    \    b = 2\n    while n > 0\n        if n % 2 == 1\n            a = (a * b) %\
    \ p\n        end\n        n = div(n, 2)\n        b = (b * b) % p\n    end\n  \
    \  return a\nend", "    prod = 1\n    d = 2\n    while d <= n\n        prod =\
    \ (prod * d) % p\n        d = d * 2\n    end\n    return prod\nend", "    if n\
    \ == 0\n        modp = 1\n    else\n        b = 2\n        modp = 2\n        for\
    \ i in 1:n-1\n            modp = (modp*b) % p\n        end\n    end\n    return\
    \ modp\nend", "  result = 1 \n  currentPower = n \n  while currentPower != 0 \n\
    \    if rem(currentPower, 2) == 1 \n      result = mod(result * n, p) \n    end\
    \ \n    n = mod(n * n, p) \n    currentPower = div(currentPower, 2) \n  end \n\
    \  return result \nend ", "    b = 1\n    for i = 1:n\n        b = (b*2) % p\n\
    \    end\n    return b\nend", "    if n < 0\n        n = p - (-n % p) \n    end\n\
    \    return mod2n(n, p)\nend", "    if p == 1\n        return 0\n    end\n   \
    \ result = 1\n    b = n\n    while b > 0\n        # invariant: result = b^n mod\
    \ p\n        if b % 2 == 1\n            result = mod(result * n, p)\n        end\n\
    \        n = mod(n * n, p)\n        b = div(b, 2)\n    end\n    return result\n\
    end", "    if n < 0\n        return n % p\n    end\n    n %= p\n    x = 1\n  \
    \  while n > 0\n        if n % 2 == 1\n            x = (x * 2) % p\n        end\n\
    \        n = n >> 1\n    end\n    return x\nend", "    if n == 0\n        return\
    \ 1\n    else\n        return (2 * modp(n-1, p)) % p\n    end\nend", "    if n==0\n\
    \        r = 1\n    else\n        r = modp(n-1, p)\n        r = mod(2*r, p)\n\
    \    end\n    return r\nend", "    if n == 0\n        return 1\n    else\n   \
    \     return (2*modp(n-1, p)) % p\n    end\nend", "    ret = 1\n    for i in (1:n)\n\
    \        ret = (ret * 2) % p\n    end\n    return ret\nend", "    if n == 0 \n\
    \        return 1\n    end\n    if n%2 == 0\n        return mod(modp(n\xF72, p)^2,\
    \ p)\n    else\n        return mod(modp(n\xF72, p)^2*2, p)\n    end\nend", " \
    \   res = 1\n    n_mod_p = n % p\n    if n_mod_p == 0\n        return res\n  \
    \  end\n    while n_mod_p > 0\n        res = (res * 2) % p\n        n_mod_p -=\
    \ 1\n    end\n    return res\nend", "    if p == 1\n        return 0\n    end\n\
    \    if n == 0\n        return 1\n    end\n    if n == 1\n        return 2 % p\n\
    \    end\n    if n == 2\n        return 4 % p\n    end\n    if n % 2 == 0\n  \
    \      return (modp(n / 2, p) ^ 2) % p\n    else\n        return (2 * modp(n-1,\
    \ p)) % p\n    end\nend", "    if n == 0\n        return 1\n    end\n    r = modp(n\
    \ div 2, p)\n    r2 = (r*r) % p\n    if n % 2 == 0\n        return r2\n    else\n\
    \        return (r2*2) % p\n    end\nend", "    n = n % p\n    if n < 0\n    \
    \    n += p\n    end\n    r = 1\n    while n > 0\n        if n % 2 == 1\n    \
    \        r = (r * 2) % p\n        end\n        n = n >> 1\n    end\n    return\
    \ r\nend", "    n %= p\n    nn = n*n\n    return nn % p\nend\n@jit(nopython=true)",
  "    res = 1\n    while n > 0\n        if n % 2 == 1\n            res = (res * base)\
    \ % p\n        end\n        base = (base * base) % p\n        n = n // 2\n   \
    \ end\n    return res\nend", "    if n == 0\n        return 1\n    end\n    tmp\
    \ = modp(div(n, 2), p)\n    if n % 2 == 0\n        return (tmp * tmp) % p\n  \
    \  else\n        return (tmp * tmp * a) % p\n    end\nend", "    # NOTE: this\
    \ is not efficient\n    #nmod = mod(n, p)\n    #A = Array{Int64}(1)\n    #A[1]\
    \ = 1\n    #for i = 1:nmod\n    #    A = append!(A, (A[i]*2)%p)\n    #end\n  \
    \  #return A[end]\n    res = 1\n    for i = 1:n\n        res = (res*2)%p\n   \
    \ end\n    return res\nend", "    if n == 0\n        return 1\n    end\n    if\
    \ n == 1\n        return 2\n    end\n    b = modp(n \xF7 2, p)\n    if n % 2 ==\
    \ 0\n        return (b * b) % p\n    else\n        return (2 * b * b) % p\n  \
    \  end\nend\n# This could be improved with a list comprehension.", "    if n ==\
    \ 0\n        return 1\n    end\n    if n == 1\n        return 2\n    end\n   \
    \ a = modp(n \xF7 2, p)\n    if n % 2 == 0\n        return a^2 % p\n    else\n\
    \        return 2*a^2 % p\n    end\nend", "    nn = 1\n    n = n % p\n    for\
    \ i = 1:n\n        nn = (nn * 2) % p\n    end\n    return nn\nend", "    x = 1\n\
    \    a = 2\n    while n>0\n        if n % 2 == 1\n            x = (x*a) % p\n\
    \        end\n        a = (a*a) % p\n        n = div(n, 2)\n    end\n    return\
    \ x\nend", "    if n == 0\n        return 1\n    end\n    if n % 2 == 0\n    \
    \    return modp(n/2, p)^2 % p\n    else\n        return 2 * modp(n - 1, p) %\
    \ p\n    end\nend", "    if n == 0\n        modp = 1\n    elseif mod(n, 2) ==\
    \ 0\n        modp = modp(div(n, 2), p)^2 % p\n    else\n        modp = n * modp(n\
    \ - 1, p) % p\n    end\nend", "    # see https://en.wikipedia.org/wiki/Modular_exponentiation\n\
    \    if n == 0\n        return 1\n    elseif n % 2 == 0\n        return modp(n/2,\
    \ p)^2 % p\n    else\n        return modp(n-1, p) * modp(n-1, p) * 2 % p\n   \
    \ end\nend", "    (x, y) = extended_euclid(p, 2)\n    ans = 1\n    while n > 0\n\
    \        if mod(n, 2) == 1\n            ans = ans * 2 % p\n        end\n     \
    \   n = div(n, 2)\n        if n > 0\n            if mod(n, 2) == 1\n         \
    \       y = y * x % p\n            end\n            n = div(n, 2)\n          \
    \  x = x * x % p\n        end\n    end\n    return y\nend", "    if n == 0\n \
    \       return 1\n    elseif n == 1\n        return 2\n    elseif n % 2 == 0\n\
    \        a = modp(n \xF7 2, p)\n        return (a^2) % p\n    else\n        a\
    \ = modp(n - 1, p)\n        return (2 * a) % p\n    end\nend", "    if n == 0\n\
    \        return 1\n    elseif n == 1\n        return 2\n    else\n        # use\
    \ squaring to avoid overflows\n        if n % 2 == 0\n            return mod(4\
    \ * modp(n//2, p), p)\n        else\n            return mod(2 * modp(n - 1, p),\
    \ p)\n        end\n    end\nend", "    if n == 0 \n        return 1\n    elseif\
    \ n == 1\n        return 2\n    elseif n == 2\n        return 4\n    elseif n\
    \ < 0\n        return 1 / modp(-n, p)\n    elseif n % 2 == 0 \n        return\
    \ sqrt(modp(n \xF7 2, p))\n    else \n        return 2 * modp(n - 1, p)\n    end\n\
    end", "    n = n % p\n    result = 1\n    while n > 0\n        if bitstring(n)[end]\
    \ == '1'\n            result = result * 2 % p\n        end\n        n = div(n,\
    \ 2)\n    end\n    return result\nend", "    if n == 0\n        return 1\n   \
    \ end\n    if n < 0\n        return modp(-n, p)\n    end\n    if n%2 == 0\n  \
    \      q = modp(n/2, p)\n        return mod(q*q, p)\n    else\n        return\
    \ mod(modp(n-1, p)*modp(n, p), p)\n    end\nend", "    if p == 1\n        return\
    \ 0\n    end\n    p_inv = modinv(2, p)\n    if n == 0\n        return 1\n    elseif\
    \ n == 1\n        return 2\n    elseif n % 2 == 0\n        return modp(n / 2,\
    \ p)^2 % p\n    else\n        return (modp(n - 1, p) * 2) % p\n    end\nend",
  "    if p == 2 \n        if n > 1\n            return 1\n        else\n        \
    \    return 0\n        end\n    end\n    if n == 0\n        return 1\n    end\n\
    \    if p == 2147483647\n        if n < 1024\n            return two_by_n[n]\n\
    \        else\n            return two_by_n[n%1024]\n        end\n    end\n   \
    \ out = 1\n    n = n % (p-1)\n    for i in range(1, n+1)\n        out = (out*2)\
    \ % p\n    end\n    return out\nend", "    res = 1\n    while n != 0\n       \
    \ if n % 2 == 1\n            res = (res * 2) % p\n        end\n        n = n /\
    \ 2\n    end\n    return res\nend", "  if n == 0\n    return 1\n  elseif n ==\
    \ 1\n    return 2\n  else\n    return (2 * modp(n-1, p)) % p\n  end\nend", " \
    \   bits = bitstring(n)\n    for i in 2:length(bits)\n        if bits[i] == '1'\n\
    \            n = n*n % p\n        end\n    end\n    return n\nend", "    r = 1\n\
    \    if n &gt; 0\n        if p &gt;= 3037000500\n            r = Int64(BigInt(2)^n\
    \ % p)\n        else\n            for i in 1:n\n                r = mod2(r, p)\n\
    \            end\n        end\n    end\n    return r\nend", "    if n == 0 \n\
    \        return 1\n    elseif n%2 == 0 \n        return sqr(modp(n \xF7 2, p))\
    \ % p\n    else \n        return (modp(n \xF7 2, p) * 2) % p\n    end\nend", " \
    \   return (1 << n) % p\nend", "    if n == 0\n        return 1\n    end\n   \
    \ z = modp(div(n, 2), p)\n    z = mod(z*z, p)\n    if n % 2 == 1\n        z =\
    \ mod(z*2, p)\n    end\n    return z\nend", "    res = 1\n    for e in digits(n,\
    \ 2)\n        res = (res*res) % p\n        if e == 1\n            res = (res*2)\
    \ % p\n        end\n    end\n    return res\nend", "    if n == 0\n        return\
    \ 1\n    end\n    x = modp(n div 2, p)\n    x = x * x % p\n    if n % 2 == 1\n\
    \        x = x * 2 % p\n    end\n    return x\nend", "    modp = 1\n    for i\
    \ in range(1,n+1)\n        modp = modp*2%p\n    end\n    return modp\nend", " \
    \ if n == 0\n    return 1\n  elseif n == 1\n    return 2\n  elseif n == 2\n  \
    \  return 4\n  elseif n == 3\n    return 8\n  elseif n == 4\n    return 16\n \
    \ elseif n == 5\n    return 32\n  elseif n == 6\n    return 64\n  elseif n ==\
    \ 7\n    return 128\n  elseif n == 8\n    return 256\n  elseif n == 9\n    return\
    \ 512\n  elseif n == 10\n    return 1024\n  elseif n == 11\n    return 2048\n\
    \  elseif n == 12\n    return 4096\n  elseif n == 13\n    return 8192\n  elseif\
    \ n == 14\n    return 16384\n  elseif n == 15\n    return 32768\n  elseif n ==\
    \ 16\n    return 65536\n  elseif n == 17\n    return 131072\n  elseif n == 18\n\
    \    return 262144\n  elseif n == 19\n    return 524288\n  elseif n == 20\n  \
    \  return 1048576\n  elseif n == 21\n    return 2097152\n  elseif n == 22\n  \
    \  return 4194304\n  elseif n == 23\n    return 8388608\n  elseif n == 24\n  \
    \  return 16777216\n  elseif n == 25\n    return 33554432\n  elseif n == 26\n\
    \    return 67108864\n  elseif n == 27\n    return 134217728\n  elseif n == 28\n\
    \    return 268435456\n  elseif n == 29\n    return 536870912\n  elseif n == 30\n\
    \    return 1073741824\n  elseif n == 31\n    return 2147483648\n  elseif n ==\
    \ 32\n    return 4294967296\n  elseif n == 33\n    return 8589934592\n  elseif\
    \ n == 34\n    return 17179869184\n  elseif n == 35\n    return 34359738368\n\
    \  elseif n == 36\n    return 68719476736\n  elseif n == 37\n    return 137438953472\n\
    \  elseif n == 38\n    return 274877906944\n  elseif n == 39\n    return 549",
  "    #be aware of numerics, 100^20 is too large to fit into Int64, so use BigInt\n\
    \    if n == 0\n        return 1\n    elseif n == 1\n        return 2\n    elseif\
    \ mod(n, 2) == 0\n        return mod(modp(n/2, p)^2, p)\n    else\n        return\
    \ mod(2*modp(n-1, p), p)\n    end\nend", "    if n == 0\n        return 1\n  \
    \  end\n    n = n % p\n    if n < 0\n        n += p\n    end\n    if n % 2 ==\
    \ 0\n        return modp(n/2, p)^2 % p\n    else\n        return (2 * modp(n/2,\
    \ p)^2) % p\n    end\nend", "    if p == 2\n        return 1\n    end\n    if\
    \ n==0\n        return 1\n    end\n    z = modp(div(n,2), p)\n    y = (z*z) %\
    \ p\n    if iseven(n)\n        return y\n    else\n        return (y*2) % p\n\
    \    end\nend", "    if n == 0 return 1 end\n    if n == 1 return 2 end\n    if\
    \ mod(n, 2) == 0 return mod(modp(n/2, p)^2, p) end\n    return mod(2*modp(n-1,\
    \ p), p)\nend", "    bin_string = \"0b\" * binary(n)\n    bin_arr = digits(Int64,\
    \ bin_string)\n    len_bin = length(bin_arr)\n    res = 1\n    for i in 2:len_bin\n\
    \        if bin_arr[i] == 1\n            res = (res * res) % p\n        end\n\
    \    end\n    return res\nend", "    if n == 0\n        return 1\n    end\n  \
    \  s = modp(n div 2, p)\n    s = s*s % p\n    if n % 2 == 1\n        s = s*2 %\
    \ p\n    end\n    return s\nend\n;\nmodp(3, 5)", "    if n == 0\n        return\
    \ 1\n    elseif n == 1\n        return 2 % p\n    else\n        if n % 2 == 0\n\
    \            return modp(n/2, p)^2 % p\n        else\n            return (modp(n/2,\
    \ p)^2 * 2) % p\n        end\n    end\nend", "    \"\"\"Return 2^n modulo p (be\
    \ aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n  \
    \  2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"\n    if n == 0\n        return 1\n    end\n    if n\
    \ < 0\n        return 1/modp(-n, p)\n    end\n    n2 = modp(n>>1, p)\n    n2*n2*(1\
    \ + (n&1)*(p-1)) % p\nend", "    if n == 0\n        return 1\n    else\n     \
    \   z = modp(div(n, 2), p)\n        z = (z * z) % p\n        if n % 2 == 1\n \
    \           z = (z * 2) % p\n        end\n        return z\n    end\nend", " \
    \   if n==0 return 1 end\n    return (2*modp(n-1, p)) % p\nend", "    if n ==\
    \ 0\n        return 1\n    end\n    sq = modp(n >> 1, p)\n    sq = sq * sq % p\n\
    \    if n & 1 == 1\n        sq = sq * 2 % p\n    end\n    return sq\nend", " \
    \   if n == 0 \n        return 1\n    else\n        rec_sq = modp(div(n, 2), p)^2\n\
    \        if mod(n, 2) == 0\n            return rec_sq\n        else\n        \
    \    return rec_sq * 2\n        end\n    end\nend", "    if n == 0\n        return\
    \ 1\n    elseif n == 1\n        return 2\n    elseif n % 2 == 0\n        x = modp(n/2,\
    \ p)\n        return x^2 % p\n    else\n        x = modp(n-1, p)\n        return\
    \ 2*x % p\n    end\nend", "    n = n % p\n    if n == 0 \n        return 1\n \
    \   end\n    if n == 1\n        return 2\n    end\n    if n == 2\n        return\
    \ 4\n    end\n    t = 1\n    for i = 1:n-2\n        t = (t * 2) % p\n    end\n\
    \    return t\nend", "    if p == 2\n        return 1\n    end\n    p2 = p*p\n\
    \    k = floor(n/p2)\n    r = n - k*p2\n    return  (r*modp(r, p) + k*p*modp(r\
    \ + p, p) + k*k*modp(r + 2*p, p)) % p\nend", "    if n == 0\n        return 1\n\
    \    end\n    if n == 1\n        return n\n    end\n    n_high = n >> 1\n    if\
    \ n % 2 == 0\n        half = modp(n_high, p)\n        return (half*half) % p\n\
    \    else\n        half = modp(n_high, p)\n        return (half*half*n) % p\n\
    \    end\nend", "    binstr = dec2bin(n)\n    res = 1\n    for i in binstr\n \
    \       if i == '1'\n            res = (res * res) % p\n        else\n       \
    \     res = (res * res * 2) % p\n        end\n    end\n    return res\nend", " \
    \   x = 1\n    y = 2\n    while n > 0\n        if n % 2 == 1\n            x =\
    \ (x * y) % p\n        end\n        y = (y^2) % p\n        n = n / 2\n    end\n\
    \    return x\nend", "    if n == 0\n        return 1\n    end\n    return rem(2*modp(n-1,\
    \ p), p)\nend", "    return mod(2^n, p)\nend\n \n \n \n \n\"\"\"Function to extend\
    \ B-ary representation of number to specified length.\n    >>> add_zeros(23, 5)\n\
    \    '00011'\n    >>> add_zeros(9, 5)\n    '01001'\n    >>> add_zeros(2, 5)\n\
    \    '00001'\n    >>> add_zeros(0, 5)\n    '00000'\n    \"\"\"", "    a = 1\n\
    \    b = 2\n    c = n\n    while c > 0\n        if c % 2 == 1\n            a =\
    \ mod(a * b, p)\n        end\n        b = mod(b * b, p)\n        c = c >> 1\n\
    \    end\n    return a\nend", "    x::Int64 = 1\n    k::Int64 = n\n    while k\
    \ > 0\n        if k % 2 == 1\n            x = (x * n) % p\n        end\n     \
    \   n = (n * n) % p\n        k = k >> 1\n    end\n    return x\nend\n \n@test\
    \ modp(3, 5) == 3\n@test modp(1101, 101) == 2\n@test modp(0, 101) == 1\n@test\
    \ modp(3, 11) == 8\n@test modp(100, 101) == 1", "    res = 1\n    while n > 0\n\
    \        if n & 1 == 1\n            res = (res * 2) % p\n        end\n       \
    \ n = div(n, 2)\n    end\n    return res\nend", "    if n == 0\n        return\
    \ 1\n    end\n    if n == 1\n        return 2 % p\n    end\n    if n % 2 == 0\n\
    \        t = modp(n\xF72, p)\n        return t^2 % p\n    else\n        t = modp(n\xF7\
    2, p)\n        return 2 * t^2 % p\n    end\nend", "    if n == 0\n        return\
    \ 1\n    end\n    z = modp(n >> 1, p)\n    z = z * z % p\n    if n & 1 == 1\n\
    \        z = z * n % p\n    end\n    return z\nend", "    if n == 0 \n       \
    \ return 1\n    end\n    if n == 1\n        return 2\n    end\n    if n % 2 ==\
    \ 0\n        return modp(n/2, p)^2 % p\n    else\n        return 2 * modp(n-1,\
    \ p) % p\n    end\nend", "    r = 1\n    if n == 0\n        return r\n    end\n\
    \    while n != 0\n        r = (r * 2) % p\n        n -= 1\n    end\n    return\
    \ r\nend", "    n = mod(n, p)\n    if n == 0\n        return 1\n    end\n    (r,\
    \ q) = divrem(n, 2)\n    s = modp(r, p)^2\n    if q == 1\n        s = mod(2*s,\
    \ p)\n    end\n    return s\nend", "    if n == 0\n        return 1\n    end\n\
    \    if n == 1\n        return 2 % p\n    end\n    if n%2 == 0\n        return\
    \ modp(n/2, p)^2 % p\n    else\n        return 2 * modp(n-1, p) % p\n    end\n\
    end", "    if n == 0\n        return 1\n    end\n    if n == 1\n        return\
    \ 2\n    end\n    d = n % 2 == 0 ? n \xF7 2 : n - 1\n    m = modp(d, p)\n    m^2\
    \ % p == 0 ? m : m^2 % p\nend", "    if n == 0\n        return 1\n    end\n  \
    \  if n == 1\n        return 2\n    end\n    if (n % 2) == 0\n        return modp(n/2,\
    \ p)^2 % p\n    else\n        return (modp(n-1, p) * 2) % p\n    end\nend", " \
    \   \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n  \
    \  3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
    \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    n %= p\n    n %=\
    \ p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n\
    \    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n\
    \ %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n\
    \    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n\
    \ %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n\
    \    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n\
    \ %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n\
    \    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n\
    \ %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n\
    \    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n\
    \ %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p", "    n %= p\n    if n\
    \ == 0\n        n = 1\n    end\n    n\nend", "    if n == 0\n        return 1\n\
    \    end\n    if n == 1\n        return n\n    end\n    if n < 0\n        n +=\
    \ div(p-1, 2)\n    end\n    # Make base even\n    if n % 2 == 1\n        base\
    \ = 2 * modp(div(n-1, 2), p)\n    else\n        base = modp(div(n, 2), p)\n  \
    \  end\n    if base < 0\n        base += p\n    end\n    (base^2) % p\nend", " \
    \   if n == 0\n        return 1\n    else\n        temp = modp(n \xF7 2, p)\n\
    \        if n % 2 == 0\n            return temp^2 % p\n        else\n        \
    \    return (temp^2 * 2) % p\n        end\n    end\nend", "    l = Int64(1)\n\
    \    for i = 1:n\n        l = l*2%p\n    end\n    return l\nend\n\"\"\"Return\
    \ the result of the inverse calculator (e, phi).\n    >>> inv(17,16)\n    16\n\
    \    >>> inv(5,14)\n    5\n    >>> inv(11,23)\n    1\n    >>> inv(1,1)\n    1\n\
    \    >>> inv(2,2)\n    1\n    \"\"\"", "    if n == 0\n        return 1\n    end\n\
    \    if n == 1\n        return 2\n    end\n    if n % 2 == 0\n        return (modp(n/2,\
    \ p)^2) % p\n    else\n        return (2 * modp(n-1, p)) % p\n    end\nend", " \
    \   m = 1\n    while n > 0\n        if n%2 == 1\n            m = m*2 % p\n   \
    \     end\n        n = div(n, 2)\n    end\n    return m\nend", "    res = 1\n\
    \    #\n    #print(\"modp\", n, p)\n    #\n    while n > 0\n        if n % 2 ==\
    \ 1\n            res = (res * p) % p\n        end\n        n = n >> 1\n      \
    \  p = (p * p) % p\n    end\n    #\n    return res\nend\n \n\"\"\"Compute the\
    \ p'th fibonacci number, using log_2(p) bit operations.\n    >>> fib(12)\n   \
    \ 144\n    >>> fib(1000)\n    43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875\n\
    \    >>> fib(10^10)\n    4134960760026490365058292390894509016870452459578404021\n\
    \    \"\"\"", "    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>>\
    \ modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n  \
    \  1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    \    p = (p::Int64)\n    n = (n::Int64)\n    if n == 0\n        return 1\n   \
    \ elseif n == 1\n        return 2\n    elseif n == 2\n        return 4\n    elseif\
    \ n == 3\n        return 8\n    elseif n == 4\n        return 16\n    elseif n\
    \ == 5\n        return 32\n    elseif n == 6\n        return 64\n    elseif n\
    \ == 7\n        return 128\n    elseif n == 8\n        return 256\n    elseif\
    \ n == 9\n        return 512\n    elseif n == 10\n        return 1024\n    elseif\
    \ n == 11\n        return 2048\n    elseif n == 12\n        return 4096\n    elseif\
    \ n == 13\n        return 8192\n    elseif n == 14\n        return 16384\n   \
    \ elseif n == 15\n        return 32768\n    elseif n == 16\n        return 65536\n\
    \    elseif n == 17\n        return 131072\n    elseif n == 18\n        return\
    \ 262144\n    elseif n == 19\n        return 524288\n    elseif n == 20\n    \
    \    return 1048576\n    elseif n == 21\n        return 2097152\n    elseif n\
    \ == 22\n        return 4194304\n    elseif n == 23\n        return 8388608\n\
    \    elseif n == 24\n        return 16777216\n    elseif n == 25\n        return\
    \ 33554432\n    elseif n == 26\n        return 67108864\n    elseif n == 27\n\
    \        return 134217728\n    elseif n == 28\n        return 268435456\n    elseif\
    \ n == 29\n        return 536870912\n    elseif n == 30\n        return 1073741824\n\
    \    elseif n == 31\n        return 2147483648\n    elseif n == 32\n        return\
    \ 4294967", "    if n == 0\n        return 1\n    end\n    a = modp(n \xF7 2,\
    \ p)\n    a = a * a\n    a = a % p\n    if n % 2 == 1\n        a = a * 2\n   \
    \ end\n    return a % p\nend", "    i, r = 0, 1\n    while i < n\n        r =\
    \ (r * 2) % p\n        i += 1\n    end\n    return r\nend", "    if n == 0\n \
    \       return 1\n    end\n    if n == 1\n        return 2 % p\n    end\n    if\
    \ n % 2 == 0\n        x = modp(n/2, p)\n        return (x * x) % p\n    else\n\
    \        x = modp(n/2, p)\n        return (2 * x * x) % p\n    end\nend", "  \
    \  if n == 0 \n        return 1\n    elseif n == 1\n        return 2\n    else\n\
    \        return (2*modp(n-1, p)) % p\n    end\nend", "    a = 1\n    while n >\
    \ 0\n        if rem(n, 2) == 1\n            a = (a * 2) % p\n        end\n   \
    \     n = div(n, 2)\n    end\n    return a\nend", "    a = mod(n, p)\n    if a==0\n\
    \        return 1\n    end\n    return a^(p-2)\nend", "    if n == 0\n       \
    \ return 1\n    elseif n < 0\n        return modp(n + p - 1, p)\n    elseif isodd(n)\n\
    \        return mod2m(2, n - 1, p) * modp(1, p)\n    else\n        return mod2m(2,\
    \ div(n, 2), p)^2\n    end\nend\n ", "    if p == 1\n        return 0\n    end\n\
    \    result = 1\n    base = 2\n    while n > 0\n        if n % 2 == 1\n      \
    \      result = mod2(base*result, p)\n        end\n        base = mod2(base*base,\
    \ p)\n        n = div(n, 2)\n    end\n    return result\nend", "    if n == 0\n\
    \        return 1\n    elseif n < 0\n        return 0\n    else\n        if iseven(n)\n\
    \            k = div(n, 2)\n            y = modp(k, p)\n            z = modp(k,\
    \ p)\n            if y == z\n                return (2y^2) % p\n            else\n\
    \                return (2y*z) % p\n            end\n        else\n          \
    \  return (2modp(n-1, p)) % p\n        end\n    end\nend", "    if n == 0 return\
    \ 1 end\n    t = modp(n>>1, p)\n    ans = t*t % p\n    if bitstring(n)[end] ==\
    \ '1'\n        ans = ans*2 % p\n    end\n    return ans\nend", "    b = 0\n  \
    \  r = 1\n    while n > 0\n        b, n = mod2(n)\n        if b == 1\n       \
    \     r = mod2(2*r, p)\n        end\n    end\n    return r\nend", "    s = 1\n\
    \    for i = 1:n\n        s = (s*2) % p\n    end\n    return s\nend", "    if\
    \ n == 0\n        return 1\n    end\n    if n == 1\n        return 2\n    end\n\
    \    if (n%2 == 0)\n        return (modp(n/2, p)*modp(n/2, p))%p\n    else\n \
    \       return (2*modp(n-1, p))%p\n    end\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
