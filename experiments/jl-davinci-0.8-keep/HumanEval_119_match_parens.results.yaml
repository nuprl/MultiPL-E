name: HumanEval_119_match_parens
language: jl
results:
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    parens1,\
    \ parens2 = lst[1], lst[2]\n    total_parens = parens1 * parens2\n    open_parens\
    \ = filter(x -> x == '(', total_parens)\n    closed_parens = filter(x -> x ==\
    \ ')', total_parens)\n    if length(open_parens) == length(closed_parens)\n  \
    \      return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphoc_b057.jl:40\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphoc_b057.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphoc_b057.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphoc_b057.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    #remove\
    \ closing parens\n    remove!(x -> x == ')', lst[1])\n    #as long as we have\
    \ closing parens to match with open parens\n    while length(lst[2]) > 0\n   \
    \     #check if we have some extra open parens to spare\n        if length(lst[1])\
    \ > 0\n            #remove each extra open paren\n            popfirst!(lst[1])\n\
    \            #remove one closing paren\n            popfirst!(lst[2])\n      \
    \  else\n            #if we don't have an extra open parens we can't match\n \
    \           return \"No\"\n        end\n    end\n    return \"Yes\"\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3yfjj6h1.jl:38\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: remove!\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp3yfjj6h1.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3yfjj6h1.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3yfjj6h1.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp3yfjj6h1.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: remove! not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp3yfjj6h1.jl:17\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3yfjj6h1.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3yfjj6h1.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp3yfjj6h1.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: remove! not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp3yfjj6h1.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3yfjj6h1.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3yfjj6h1.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp3yfjj6h1.jl:41\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: remove! not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp3yfjj6h1.jl:17\n\
    \   ["
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3yfjj6h1.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"((')(')\"\
    \n    # return \"Yes\" or \"No\"\n    if length(lst[1]) < length(lst[2])\n   \
    \     return \"No\"\n    end\n    open = []\n    close = []\n    for i in lst[1]\n\
    \        if i == '('\n            push!(open, i)\n        else\n            push!(close,\
    \ i)\n        end\n    end\n    for i in lst[2]\n        if i == '('\n       \
    \     push!(open, i)\n        else\n            push!(close, i)\n        end\n\
    \    end\n    if length(open) == length(close)\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp38tngpz6.jl:51\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp38tngpz6.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp38tngpz6.jl:47\ntest set: Test\
    \ Failed at /tmp/tmp38tngpz6.jl:52\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp38tngpz6.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp38tngpz6.jl:47\ntest set: Test\
    \ Failed at /tmp/tmp38tngpz6.jl:54\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp38tngpz6.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp38tngpz6.jl:47\ntest set: Test\
    \ Failed at /tmp/tmp38tngpz6.jl:57\n  Expression: candidate([\")(\", \")(\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp38tngpz6.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp38tngpz6.jl:47\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    8     4     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 8 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp38tngpz6.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if length(lst[1])==0\
    \ || length(lst[2])==0\n        return \"Yes\"\n    end\n    if lst[1][1]==')'\
    \ && lst[2][1]==')'\n        return \"No\"\n    end\n    if lst[1][1]=='(' &&\
    \ lst[2][1]==')'\n        return match_parens([lst[1][2:end], lst[2][2:end]])\n\
    \    end\n    if lst[1][1]=='(' && lst[2][1]=='('\n        l1 = [lst[1][2:end],\
    \ lst[2]]\n        l2 = [lst[1], lst[2][2:end]]\n        if match_parens(l1)==\"\
    Yes\" || match_parens(l2)==\"Yes\"\n            return \"Yes\"\n        end\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpc4q__gac.jl:41\\n  Test threw\
    \ exception\\n  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\\n\
    \  MethodError: Cannot `convert` an object of type Nothing to an object of type\
    \ String\\n  Closest candidates are:\\n    convert(::Type{String}, !Matched::String)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\\\
    n    ...\\n  Stacktrace:\\n   [1] match_parens(lst::Vector{String})\\n     @ Main\
    \ /tmp/tmpc4q__gac.jl:31\\n   [2] match_parens(lst::Vector{String}) (repeats 2\
    \ times)\\n     @ Main /tmp/tmpc4q__gac.jl:28\\n   [3] macro expansion\\n    \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\\\
    n   [4] macro expansion\\n     @ /tmp/tmpc4q__gac.jl:41 [inlined]\\n   [5] macro\
    \ expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmpc4q__gac.jl:38\\ntest set:\
    \ Error During Test at /tmp/tmpc4q__gac.jl:42\\n  Test threw exception\\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\\n  Closest candidates\
    \ are:\\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\\\
    n    ...\\n  Stacktrace:\\n   [1] match_parens(lst::Vector{String})\\n     @ Main\
    \ /tmp/tmpc4q__gac.jl:31\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s = join(lst)\n\
    \    if s == \"()\"\n        return \"Yes\"\n    end\n    if s == \"(\"\n    \
    \    return \"No\"\n    end\n    if s == \")()\"\n        return \"Yes\"\n   \
    \ end\n    if s == \"())\"\n        return \"No\"\n    end\n    return \"Yes\"\
    \nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7pqn1leb.jl:37\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7pqn1leb.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7pqn1leb.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp7pqn1leb.jl:38\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7pqn1leb.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7pqn1leb.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp7pqn1leb.jl:41\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7pqn1leb.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7pqn1leb.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp7pqn1leb.jl:43\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7pqn1leb.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7pqn1leb.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp7pqn1leb.jl:44\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7pqn1leb.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    You are given a list of two strings, both strings consist of open\n    parentheses\
    \ '(' or close parentheses ')' only.\n    Your job is to check if it is possible\
    \ to concatenate the two strings in\n    some order, that the resulting string\
    \ will be good.\n    A string S is considered to be good if and only if all parentheses\
    \ in S\n    are balanced. For example: the string '(())()' is good, while the\
    \ string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good\
    \ string, and return 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpox09ehkz.jl:1\nin expression starting at /tmp/tmpox09ehkz.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # If a string\
    \ is empty, or consists only of open parenthesis, or consists\n    # only of close\
    \ parenthesis, we consider it to be good.\n    is_good_parentheses(s::String)\
    \ = s == \"\" || all(s .== '(') || all(s .== ')')\n    # If a string is a sequence\
    \ of balanced parentheses, we consider it to be\n    # good.\n    is_good_parentheses(s::String)\
    \ = is_good_parentheses(s[s .== '('])\n    # We will concatenate both strings\
    \ and check if it is good.\n    s = string(lst...)\n    if is_good_parentheses(s)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6y6uykqg.jl:35\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  BoundsError: attempt\
    \ to access 4-codeunit String at index [false]\n  Stacktrace:\n   [1] checkbounds\n\
    \     @ ./strings/basic.jl:216 [inlined]\n   [2] getindex(s::String, i::Bool)\n\
    \     @ Base ./strings/basic.jl:185\n   [3] (::var\"#is_good_parentheses#1\")(s::String)\n\
    \     @ Main /tmp/tmp6y6uykqg.jl:21\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmp6y6uykqg.jl:24\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp6y6uykqg.jl:35 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp6y6uykqg.jl:34\ntest set:\
    \ Error During Test at /tmp/tmp6y6uykqg.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  BoundsError: attempt to access 2-codeunit\
    \ String at index [false]\n  Stacktrace:\n   [1] checkbounds\n     @ ./strings/basic.jl:216\
    \ [inlined]\n   [2] getindex(s::String, i::Bool)\n     @ Base ./strings/basic.jl:185\n\
    \   [3] (::var\"#is_good_parentheses#1\")(s::String)\n     @ Main /tmp/tmp6y6uykqg.jl:21\n\
    \   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp6y6uykqg.jl:24\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp6y6uykqg.jl:36 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp6y6uykqg.jl:34\ntest set:\
    \ Error During Test at /tmp/tmp6y6uykqg.jl:37\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  BoundsError: attempt to access\
    \ 13-codeunit String at index [false]\n  Stacktrace:\n   [1] checkbounds\n   \
    \  @ ./strings/basic.jl:216 [inlined]\n   [2] getindex(s::String, i::Bool)\n \
    \    @ Base ./strings/basic.jl:185\n   [3] (::var\"#is_good_par"
  stderr: "WARNING: Method definition is_good_parentheses(String) in module Main at\
    \ /tmp/tmp6y6uykqg.jl:18 overwritten at /tmp/tmp6y6uykqg.jl:21.\nERROR: LoadError:\
    \ Some tests did not pass: 0 passed, 0 failed, 12 errored, 0 broken.\nin expression\
    \ starting at /tmp/tmp6y6uykqg.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # YOUR CODE\
    \ HERE\n    p1 = 0\n    p2 = 0\n    for i in lst[1]\n        if i == '('\n   \
    \         p1 += 1\n        else\n            p1 -= 1\n        end\n    end\n \
    \   for i in lst[2]\n        if i == '('\n            p2 += 1\n        else\n\
    \            p2 -= 1\n        end\n    end\n    if p1+p2 == 0\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp36fp0b6d.jl:53\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp36fp0b6d.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp36fp0b6d.jl:43\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp36fp0b6d.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # a stack\
    \ to store the open parentheses and counts on the stack\n    stack = []\n    count\
    \ = 0\n    # loop through the strings\n    for i in lst\n        # loop through\
    \ the characters\n        for ch in i\n            # push the open parentheses\
    \ to the stack and update the count\n            if ch == '('\n              \
    \  push!(stack, ch)\n                count += 1\n            else # pop from the\
    \ stack and update the count\n                if count != 0\n                \
    \    pop!(stack)\n                    count -= 1\n                end\n      \
    \      end\n        end\n    end\n    # return the result\n    return count ==\
    \ 0 ? \"Yes\" : \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpm1bmsizi.jl:44\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm1bmsizi.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm1bmsizi.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpm1bmsizi.jl:45\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm1bmsizi.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm1bmsizi.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpm1bmsizi.jl:46\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm1bmsizi.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm1bmsizi.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpm1bmsizi.jl:47\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm1bmsizi.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm1bmsizi.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpm1bmsizi.jl:48\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/ju"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm1bmsizi.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = '('\n    close_parens = ')'\n    str_open = String()\n    str_close = String()\n\
    \    for c in lst[1]\n        if c == open_parens\n            push!(str_open,c)\n\
    \        else\n            push!(str_close,c)\n        end\n    end\n    for c\
    \ in lst[2]\n        if c == open_parens\n            push!(str_open,c)\n    \
    \    else\n            push!(str_close,c)\n        end\n    end\n    is_good =\
    \ balance(str_open) && balance(str_close)\n    if is_good\n        \"Yes\"\n \
    \   else\n        \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpr_qs5l1r.jl:46\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: no method\
    \ matching String()\n  Closest candidates are:\n    String(!Matched::String) at\
    \ /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:363\n    String(!Matched::Vector{UInt8})\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/strings/string.jl:53\n    String(!Matched::Symbol)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/strings/string.jl:83\n    ...\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpr_qs5l1r.jl:18\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr_qs5l1r.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr_qs5l1r.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpr_qs5l1r.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: no method matching String()\n\
    \  Closest candidates are:\n    String(!Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:363\n\
    \    String(!Matched::Vector{UInt8}) at /shared/centos7/julia/1.7.3/share/julia/base/strings/string.jl:53\n\
    \    String(!Matched::Symbol) at /shared/centos7/julia/1.7.3/share/julia/base/strings/string.jl:83\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpr_qs5l1r.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr_qs5l1r.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr_qs5l1r.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpr_qs5l1r.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: no method matching\
    \ String()\n  Closest candidates are"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr_qs5l1r.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    #\
    \ parsing the list of strings\n    string1 = lst[1]\n    string2 = lst[2]\n  \
    \  \n    # checking if a string is good as is\n    function check_good(s::String)::Bool\n\
    \        if(count(s) <= 1)\n            return false\n        end\n        open_parens\
    \ = 0\n        close_parens = 0\n        for p in s\n            if(p == '(')\n\
    \                open_parens += 1\n            else\n                close_parens\
    \ += 1\n            end\n            if(close_parens > open_parens)\n        \
    \        return false\n            end\n        end\n        return (open_parens\
    \ == close_parens)\n    end\n    \n    # checking whether a string is good after\
    \ concatenation\n    function check_concat(s1::String, s2::String)::Bool\n   \
    \     open_parens = 0\n        close_parens = 0\n        for p in s1\n       \
    \     if(p == '(')\n                open_parens += 1\n            else\n     \
    \           close_parens += 1\n            end\n        end\n        for p in\
    \ s2\n            if(p == '(')\n                open_parens += 1\n           \
    \ else\n                close_parens += 1\n            end\n            if(close_parens\
    \ > open_parens)\n                return false\n            end\n        end\n\
    \        return (open_parens == close_parens)\n    end\n    \n    if(check_good(string1)\
    \ || check_good(string2))\n        return \"Yes\"\n    elseif(check_concat(string1,\
    \ string2) || check_concat(string2, string1))\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpyvqymlss.jl:78\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  TypeError: non-boolean\
    \ (Char) used in boolean context\n  Stacktrace:\n    [1] _simple_count\n     \
    \ @ ./reduce.jl:1206 [inlined]\n    [2] #count#271\n      @ ./reduce.jl:1201 [inlined]\n\
    \    [3] #count#270\n      @ ./reduce.jl:1199 [inlined]\n    [4] count\n     \
    \ @ ./reduce.jl:1199 [inlined]\n    [5] check_good\n      @ /tmp/tmpyvqymlss.jl:23\
    \ [inlined]\n    [6] match_parens(lst::Vector{String})\n      @ Main /tmp/tmpyvqymlss.jl:65\n\
    \    [7] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpyvqymlss.jl:78 [inlined]\n\
    \    [9] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [10] top-level scope\n      @ /tmp/tmpyvqymlss.jl:77\ntest set:\
    \ Error During Test at /tmp/tmpyvqymlss.jl:79\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  TypeError: non-boolean (Char) used in\
    \ boolean context\n  Stacktrace:\n    [1] _simple_count\n      @ ./reduce.jl:1206\
    \ [inlined]\n    [2] #count#271\n      @ ./reduce.jl:1201 [inlined]\n    [3] #count#270\n\
    \      @ ./reduce.jl:1199 [inlined]\n    [4] count\n      @ ./reduce.jl:1199 [inlined]\n\
    \    [5] check_good\n      @ /tmp/tmpyvqymlss.jl:23 [inlined]\n    [6] match_parens(lst::Vector{String})\n\
    \      @ Main /tmp/tmpyvqymlss.jl:65\n    [7] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpyvqymlss.jl:79 [inlined]\n\
    \    [9] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [10] top-level scope\n      @ /tmp/tmpyvqymlss.jl:77\ntest set:\
    \ Error During Test at /tmp/tmpyvqymlss.jl:80\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  TypeError: non-boolean (Char)\
    \ used in boolean context\n  Stacktrace:\n    [1] _simple_count\n      @ ./reduce.jl:1206\
    \ [inlined"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyvqymlss.jl:75\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    parens_str\
    \ = lst[1] * lst[2]\n    open_parens = 0\n    for c in parens_str\n        if\
    \ c == '('\n            open_parens += 1\n        elseif c == ')'\n          \
    \  open_parens -= 1\n        end\n        if open_parens < 0\n            return\
    \ \"No\"\n        end\n    end\n    if open_parens == 0\n        return \"Yes\"\
    \n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxus2aptn.jl:42\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxus2aptn.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxus2aptn.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpxus2aptn.jl:43\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxus2aptn.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxus2aptn.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpxus2aptn.jl:50\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxus2aptn.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxus2aptn.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxus2aptn.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    You are given a list of two strings, both strings consist of open\n    parentheses\
    \ '(' or close parentheses ')' only.\n    Your job is to check if it is possible\
    \ to concatenate the two strings in\n    some order, that the resulting string\
    \ will be good.\n    A string S is considered to be good if and only if all parentheses\
    \ in S\n    are balanced. For example: the string '(())()' is good, while the\
    \ string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good\
    \ string, and return 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpe4t0dksh.jl:1\nin expression starting at /tmp/tmpe4t0dksh.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    parens =\
    \ Dict('(' => ')', ')' => '(')\n    s = string(lst...)\n    stack = String[]\n\
    \    for c in s\n        if isempty(stack)\n            push!(stack, c)\n    \
    \    elseif c == parens[stack[end]]\n            pop!(stack)\n        else\n \
    \           push!(stack, c)\n        end\n    end\n    return \"Yes\" * (isempty(stack))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_umoqapz.jl:35\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Char to an object of type String\n  Closest candidates are:\n\
    \    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{String}, item::Char)\n     @ Base\
    \ ./array.jl:994\n   [2] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_umoqapz.jl:21\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp_umoqapz.jl:35 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp_umoqapz.jl:34\ntest set:\
    \ Error During Test at /tmp/tmp_umoqapz.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: Cannot `convert` an object\
    \ of type Char to an object of type String\n  Closest candidates are:\n    convert(::Type{String},\
    \ !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{String}, item::Char)\n     @ Base\
    \ ./array.jl:994\n   [2] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_umoqapz.jl:21\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n  "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_umoqapz.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    is_good(s::String)\
    \ = count(s, '(') == count(s, ')') && count(s, '(') > 0\n    return is_good(lst[1])\
    \ || is_good(lst[2]) || is_good(lst[1] * lst[2]) ? \"Yes\" : \"No\"\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3canf708.jl:24\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] (::var\"#is_good#1\")(s::String)\n\
    \     @ Main /tmp/tmp3canf708.jl:16\n   [5] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmp3canf708.jl:17\n   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmp3canf708.jl:24 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmp3canf708.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp3canf708.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] (::var\"#is_good#1\")(s::String)\n     @ Main /tmp/tmp3canf708.jl:16\n\
    \   [5] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp3canf708.jl:17\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmp3canf708.jl:25 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmp3canf708.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp3canf708.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(p"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3canf708.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    return lst[1]\
    \ == \"(\" ? \"Yes\" : \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp637au4b1.jl:23\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp637au4b1.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp637au4b1.jl:22\ntest set: Test\
    \ Failed at /tmp/tmp637au4b1.jl:26\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp637au4b1.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp637au4b1.jl:22\ntest set: Test\
    \ Failed at /tmp/tmp637au4b1.jl:27\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp637au4b1.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp637au4b1.jl:22\ntest set: Test\
    \ Failed at /tmp/tmp637au4b1.jl:29\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp637au4b1.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp637au4b1.jl:22\ntest set: Test\
    \ Failed at /tmp/tmp637au4b1.jl:34\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/jul"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp637au4b1.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    str1 = lst[1]\n\
    \    str2 = lst[2]\n    open_count_str1 = length(str1) - count(x -> x == ')',\
    \ str1)\n    open_count_str2 = length(str2) - count(x -> x == ')', str2)\n   \
    \ if open_count_str1 + open_count_str2 == 0\n        return \"Yes\"\n    elseif\
    \ open_count_str1 == 0\n        return \"No\"\n    elseif open_count_str2 == 0\n\
    \        return \"No\"\n    elseif open_count_str1 > open_count_str2\n       \
    \ if str1[1] == '(' && str2[end] == ')'\n            return \"Yes\"\n        else\n\
    \            return \"No\"\n        end\n    elseif open_count_str1 < open_count_str2\n\
    \        if str1[end] == ')' && str2[1] == '('\n            return \"Yes\"\n \
    \       else\n            return \"No\"\n        end\n    else\n        if str1[1]\
    \ == '(' && str2[end] == ')'\n            return \"Yes\"\n        elseif str1[end]\
    \ == ')' && str2[1] == '('\n            return \"Yes\"\n        else\n       \
    \     return \"No\"\n        end\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpczwz0etg.jl:53\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpczwz0etg.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpczwz0etg.jl:52\ntest set: Test\
    \ Failed at /tmp/tmpczwz0etg.jl:54\n  Expression: candidate([\")\", \")\"]) ==\
    \ \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpczwz0etg.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpczwz0etg.jl:52\ntest set: Test\
    \ Failed at /tmp/tmpczwz0etg.jl:55\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpczwz0etg.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpczwz0etg.jl:52\ntest set: Test\
    \ Failed at /tmp/tmpczwz0etg.jl:58\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpczwz0etg.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpczwz0etg.jl:52\ntest set: Test\
    \ Failed at /tmp/tmpczwz0etg.jl:60\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/sh"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpczwz0etg.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    n = length(lst[1])\
    \ + length(lst[2])\n    x1 = lst[1] == \"(\"\n    x2 = lst[2] == \"(\"\n    c1\
    \ = sum(x1)\n    c2 = sum(x2)\n    if (c1 + c2) == n\n        return \"Yes\"\n\
    \    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnq0l2m9p.jl:32\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnq0l2m9p.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnq0l2m9p.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpnq0l2m9p.jl:35\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnq0l2m9p.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnq0l2m9p.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpnq0l2m9p.jl:36\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnq0l2m9p.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnq0l2m9p.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpnq0l2m9p.jl:38\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnq0l2m9p.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnq0l2m9p.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpnq0l2m9p.jl:42\n  Expression: candidate([\"(\", \")\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/jul"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnq0l2m9p.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    parens_dict\
    \ = Dict('(' => ')', ')' => '(')\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp7wc6u48m.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp7wc6u48m.jl:1\n\
    in expression starting at /tmp/tmp7wc6u48m.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    str1 = lst[1]\n\
    \    str2 = lst[2]\n    str12 = str1 * str2\n    str21 = str2 * str1\n    if (sum(str12\
    \ .== '(') == sum(str12 .== ')'))\n        return \"Yes\"\n    elseif (sum(str21\
    \ .== '(') == sum(str21 .== ')'))\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmptej0_qoq.jl:34\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptej0_qoq.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptej0_qoq.jl:32\ntest set: Test\
    \ Failed at /tmp/tmptej0_qoq.jl:35\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptej0_qoq.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptej0_qoq.jl:32\ntest set: Test\
    \ Failed at /tmp/tmptej0_qoq.jl:38\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptej0_qoq.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptej0_qoq.jl:32\ntest set: Test\
    \ Failed at /tmp/tmptej0_qoq.jl:40\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptej0_qoq.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptej0_qoq.jl:32\ntest set: Test\
    \ Failed at /tmp/tmptej0_qoq.jl:41\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptej0_qoq.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # YOUR CODE\
    \ HERE\nend\n\"\"\"\n    Given an array of integers, return an array of indices\
    \ of the two numbers\n    that add up to a given target.\n    You may assume that\
    \ each input would have exactly one solution, and you\n    may not use the same\
    \ element twice.\n    Examples:\n    two_sum([2,7,11,15], 9) == [1,2]\n    two_sum([1,2,3,4,5],\
    \ 9) == [4,5]\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmpowl9618u.jl:18\nin expression starting at /tmp/tmpowl9618u.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    c1, c2 =\
    \ lst[1], lst[2]\n   \n    c1_open, c1_close = count(c1, '('), count(c1, ')')\n\
    \    c2_open, c2_close = count(c2, '('), count(c2, ')')\n    \n    if (c1_open\
    \ == c1_close + 1) && (c2_open == c2_close + 1)\n        return \"Yes\"\n    elseif\
    \ (c1_open == c1_close) && (c2_open == c2_close)\n        return \"Yes\"\n   \
    \ elseif (c1_open == c1_close) && (c2_open == c2_close + 1)\n        return \"\
    Yes\"\n    elseif (c1_open == c1_close + 1) && (c2_open == c2_close)\n       \
    \ return \"Yes\"\n    else \n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1a7c8s7i.jl:38\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmp1a7c8s7i.jl:18\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp1a7c8s7i.jl:38 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp1a7c8s7i.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp1a7c8s7i.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp1a7c8s7i.jl:18\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp1a7c8s7i.jl:39 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp1a7c8s7i.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp1a7c8s7i.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1a7c8s7i.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    a, b = lst\n\
    \    ap, bp = 0, 0\n    for char in a\n        if char == '('\n            ap\
    \ += 1\n        elseif char == ')'\n            ap -= 1\n        end\n    end\n\
    \    for char in b\n        if char == '('\n            bp += 1\n        elseif\
    \ char == ')'\n            bp -= 1\n        end\n    end\n    if bp != 0 || ap\
    \ != 0\n        return \"No\"\n    end\n    return \"Yes\"\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvfu9vlh5.jl:42\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvfu9vlh5.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvfu9vlh5.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpvfu9vlh5.jl:45\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvfu9vlh5.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvfu9vlh5.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpvfu9vlh5.jl:46\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvfu9vlh5.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvfu9vlh5.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpvfu9vlh5.jl:48\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvfu9vlh5.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvfu9vlh5.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpvfu9vlh5.jl:51\n  Expression: candidate([\")(\", \")(\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/ju"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvfu9vlh5.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for letter in lst[1]\n        if letter == '('\n            open_parens\
    \ += 1\n        else\n            open_parens -= 1\n        end\n    end\n   \
    \ close_parens = 0\n    for letter in lst[2]\n        if letter == ')'\n     \
    \       close_parens += 1\n        else\n            close_parens -= 1\n     \
    \   end\n    end\n    if open_parens == close_parens\n        return \"Yes\"\n\
    \    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbnrke0z6.jl:52\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbnrke0z6.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbnrke0z6.jl:42\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbnrke0z6.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    p1 = lst[1]\n\
    \    p2 = lst[2]\n    if isbalanced(p1) == true\n        if isbalanced(p2) ==\
    \ true\n            return \"Yes\"\n        elseif (isbalanced(p2) == false) &&\
    \ (p2[1] == ')')\n            return \"No\"\n        elseif (isbalanced(p2) ==\
    \ false) && (p2[1] == '(')\n            if (reverse(p2)[1] == '(') && (length(p2)\
    \ > 1)\n                if isbalanced(reverse(p2)) == true\n                 \
    \   return \"Yes\"\n                else\n                    return \"No\"\n\
    \                end\n            else\n                return \"No\"\n      \
    \      end\n        end\n    elseif (isbalanced(p1) == false) && (p1[1] == ')')\n\
    \        return \"No\"\n    elseif (isbalanced(p1) == false) && (p1[1] == '(')\n\
    \        if (reverse(p1)[1] == '(') && (length(p1) > 1)\n            if isbalanced(reverse(p1))\
    \ == true\n                if isbalanced(p2) == true\n                    return\
    \ \"Yes\"\n                elseif (isbalanced(p2) == false) && (p2[1] == ')')\n\
    \                    return \"No\"\n                elseif (isbalanced(p2) ==\
    \ false) && (p2[1] == '(')\n                    if (reverse(p2)[1] == '(') &&\
    \ (length(p2) > 1)\n                        if isbalanced(reverse(p2)) == true\n\
    \                            return \"Yes\"\n                        else\n  \
    \                          return \"No\"\n                        end\n      \
    \              else\n                        return \"No\"\n                 \
    \   end\n                end\n            else\n                return \"No\"\n\
    \            end\n        else\n            return \"No\"\n        end\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpogjge73t.jl:67\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpogjge73t.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpogjge73t.jl:67 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpogjge73t.jl:66\ntest set:\
    \ Error During Test at /tmp/tmpogjge73t.jl:68\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: isbalanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpogjge73t.jl:18\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpogjge73t.jl:68 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpogjge73t.jl:66\ntest set:\
    \ Error During Test at /tmp/tmpogjge73t.jl:69\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpogjge73t.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpogjge73t.jl:69 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpogjge73t.jl:66\ntest set:\
    \ Error During Test at /tmp/tmpogjge73t.jl:70\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: isbalanced not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpogjge73"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpogjge73t.jl:64\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    Check if it is possible to match parentheses of input strings\n    \"\"\"\
    \n    # The code below can be used to manually test the function.\n    # lst =\
    \ readline().split(' ')\n    if any([x == \")\" for x in lst])\n        return\
    \ \"No\"\n    end\n    @assert all([x == \"(\" for x in lst])\n    open_parens\
    \ = 0\n    for word in lst\n        open_parens += sum([1 for x in word if x ==\
    \ \"(\"])\n    end\n    if open_parens % 2 == 0\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphtdr7xuq.jl:40\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphtdr7xuq.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphtdr7xuq.jl:39\ntest set: Error\
    \ During Test at /tmp/tmphtdr7xuq.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  AssertionError: all([x ==\
    \ \"(\" for x = lst])\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmphtdr7xuq.jl:24\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphtdr7xuq.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphtdr7xuq.jl:39\ntest set:\
    \ Error During Test at /tmp/tmphtdr7xuq.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  AssertionError: all([x == \"\
    (\" for x = lst])\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n \
    \    @ Main /tmp/tmphtdr7xuq.jl:24\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphtdr7xuq.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphtdr7xuq.jl:39\ntest set:\
    \ Error During Test at /tmp/tmphtdr7xuq.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n  AssertionError: all([x ==\
    \ \"(\" for x = lst])\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmphtdr7xuq.jl:24\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test."
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphtdr7xuq.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open = 0\n\
    \    close = 0\n    for s in lst[1]\n        if s == '('\n            open +=\
    \ 1\n        else\n            close += 1\n        end\n    end\n    for s in\
    \ lst[2]\n        if s == '('\n            open += 1\n        else\n         \
    \   close += 1\n        end\n    end\n    if open == close\n        return \"\
    Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeye72dz6.jl:52\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeye72dz6.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeye72dz6.jl:42\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeye72dz6.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    op = nothing\n\
    \    ec = nothing\n    vals = []\n    push!(vals, lst[1])\n    for i = 2:length(lst)\n\
    \        if lst[i] == \"(\"\n            push!(vals, lst[i])\n        else\n \
    \           if isempty(vals)\n                return \"No\"\n            else\n\
    \                pop!(vals)\n            end\n        end\n    end\n    return\
    \ \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5nqsbuak.jl:39\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5nqsbuak.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5nqsbuak.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp5nqsbuak.jl:40\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5nqsbuak.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5nqsbuak.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp5nqsbuak.jl:43\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5nqsbuak.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5nqsbuak.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp5nqsbuak.jl:45\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5nqsbuak.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5nqsbuak.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp5nqsbuak.jl:46\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5nqsbuak.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Your code\
    \ goes here\n    open = 0\n    close = 0\n    s = lst[1]*lst[2]\n    for i in\
    \ s\n        if i == '('\n            open += 1\n        elseif i == ')'\n   \
    \         close += 1\n        end\n        if close > open\n            return\
    \ \"No\"\n        end\n    end\n    return \"Yes\"\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1z1hcdoa.jl:40\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1z1hcdoa.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1z1hcdoa.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp1z1hcdoa.jl:41\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1z1hcdoa.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1z1hcdoa.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp1z1hcdoa.jl:44\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1z1hcdoa.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1z1hcdoa.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp1z1hcdoa.jl:48\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1z1hcdoa.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1z1hcdoa.jl:36\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    8     4     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 8 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1z1hcdoa.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    lst[1] ==\
    \ lst[2] ? \"Yes\" : \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpiqf8f2wf.jl:23\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiqf8f2wf.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiqf8f2wf.jl:22\ntest set: Test\
    \ Failed at /tmp/tmpiqf8f2wf.jl:24\n  Expression: candidate([\")\", \")\"]) ==\
    \ \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiqf8f2wf.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiqf8f2wf.jl:22\ntest set: Test\
    \ Failed at /tmp/tmpiqf8f2wf.jl:26\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiqf8f2wf.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiqf8f2wf.jl:22\ntest set: Test\
    \ Failed at /tmp/tmpiqf8f2wf.jl:27\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiqf8f2wf.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiqf8f2wf.jl:22\ntest set: Test\
    \ Failed at /tmp/tmpiqf8f2wf.jl:29\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/juli"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiqf8f2wf.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    n1, n2 = length(s1), length(s2)\n    n = n1 + n2\n    left,\
    \ right = Array{Int64}(undef, n), Array{Int64}(undef, n)\n    m, i, cnt = 0, 0,\
    \ 0\n    for c in s1\n        i += 1\n        if c == '('\n            cnt +=\
    \ 1\n        else\n            cnt -= 1\n        end\n        if cnt > m\n   \
    \         m = cnt\n        end\n        left[i] = cnt\n    end\n    i, cnt = n,\
    \ 0\n    for c in reverse(s2)\n        i -= 1\n        if c == ')'\n         \
    \   cnt += 1\n        else\n            cnt -= 1\n        end\n        right[i]\
    \ = cnt\n    end\n    for i = 1:n-1\n        if left[i] - right[i+1] == 0\n  \
    \          return \"Yes\"\n        end\n    end\n    return \"No\"\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwn6p6z06.jl:55\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwn6p6z06.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwn6p6z06.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpwn6p6z06.jl:57\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwn6p6z06.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwn6p6z06.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpwn6p6z06.jl:60\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwn6p6z06.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwn6p6z06.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpwn6p6z06.jl:61\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwn6p6z06.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwn6p6z06.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpwn6p6z06.jl:65\n  Expression: candidate([\"(\", \")\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwn6p6z06.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open, close\
    \ = 0, 0\n    for c in lst[1]\n        if c == '('\n            open += 1\n  \
    \      elseif c == ')'\n            close += 1\n        end\n    end\n    if open\
    \ == close\n        return \"Yes\"\n    end\n    open, close = 0, 0\n    for c\
    \ in lst[2]\n        if c == '('\n            open += 1\n        elseif c == ')'\n\
    \            close += 1\n        end\n    end\n    if open == close\n        return\
    \ \"Yes\"\n    end\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphs3os2vg.jl:45\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphs3os2vg.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphs3os2vg.jl:44\ntest set: Test\
    \ Failed at /tmp/tmphs3os2vg.jl:48\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphs3os2vg.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphs3os2vg.jl:44\ntest set: Test\
    \ Failed at /tmp/tmphs3os2vg.jl:49\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphs3os2vg.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphs3os2vg.jl:44\ntest set: Test\
    \ Failed at /tmp/tmphs3os2vg.jl:50\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphs3os2vg.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphs3os2vg.jl:44\ntest set: Test\
    \ Failed at /tmp/tmphs3os2vg.jl:51\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/j"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 9 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphs3os2vg.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    left = lst[1]\n\
    \    right = lst[2]\n    if length(left) != length(right)\n        return \"No\"\
    \n    end\n    left_open_parens = count(x -> x == '(', left)\n    right_open_parens\
    \ = count(x -> x == '(', right)\n    if left_open_parens != right_open_parens\n\
    \        return \"No\"\n    end\n    left_open_parens = count(x -> x == ')', left)\n\
    \    right_open_parens = count(x -> x == ')', right)\n    if left_open_parens\
    \ != right_open_parens\n        return \"No\"\n    end\n    return \"Yes\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdyc677qv.jl:38\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdyc677qv.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdyc677qv.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpdyc677qv.jl:39\n  Expression: candidate([\")\", \")\"]) ==\
    \ \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdyc677qv.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdyc677qv.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpdyc677qv.jl:41\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdyc677qv.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdyc677qv.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpdyc677qv.jl:42\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdyc677qv.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdyc677qv.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpdyc677qv.jl:44\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/juli"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdyc677qv.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    for (i,\
    \ s) in enumerate(lst)\n        for c in s\n            if c == '(' \n       \
    \         continue\n            elseif c == ')'\n                if i == 1 &&\
    \ length(lst[2]) != 0\n                    lst[2] = popfirst!(lst[2])\n      \
    \          else\n                    return \"No\"\n                end\n    \
    \        end\n        end\n    end\n    if length(lst[2]) == 0\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpoh4c0e1b.jl:40\\n  Test threw\
    \ exception\\n  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\\n  MethodError:\
    \ no method matching popfirst!(::String)\\n  Closest candidates are:\\n    popfirst!(!Matched::Vector)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1364\\n    popfirst!(!Matched::Base.Iterators.Stateful)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/iterators.jl:1318\\n    popfirst!(!Matched::Base.InvasiveLinkedList{Base.LinkedListItem{T}}\
    \ where T) at /shared/centos7/julia/1.7.3/share/julia/base/linked_list.jl:141\\\
    n    ...\\n  Stacktrace:\\n   [1] match_parens(lst::Vector{String})\\n     @ Main\
    \ /tmp/tmpoh4c0e1b.jl:22\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpoh4c0e1b.jl:40 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpoh4c0e1b.jl:39\\ntest set:\
    \ Error During Test at /tmp/tmpoh4c0e1b.jl:41\\n  Test threw exception\\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\\n  MethodError: no method matching popfirst!(::String)\\\
    n  Closest candidates are:\\n    popfirst!(!Matched::Vector) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1364\\\
    n    popfirst!(!Matched::Base.Iterators.Stateful) at /shared/centos7/julia/1.7.3/share/julia/base/iterators.jl:1318\\\
    n    popfirst!(!Matched::Base.InvasiveLinkedList{Base.LinkedListItem{T}} where\
    \ T) at /shared/centos7/julia/1.7.3/share/julia/base/linked_list.jl:141\\n   \
    \ ...\\n  Stacktrace:\\n   [1] match_parens(lst::Vector{String})\\n     @ Main\
    \ /tmp/tmpoh4c0e1b.jl:22\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpoh4c0e1b.jl:41 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpoh4c0e1b.jl:39\\ntest "
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens,\
    \ close_parens = 0, 0\n    for s in lst\n        open_parens += count(s, '(')\n\
    \        close_parens += count(s, ')')\n    end\n    if open_parens == close_parens\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmphedfpjn_.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmphedfpjn_.jl:18\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmphedfpjn_.jl:32 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmphedfpjn_.jl:31\ntest set:\
    \ Error During Test at /tmp/tmphedfpjn_.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmphedfpjn_.jl:18\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmphedfpjn_.jl:33 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmphedfpjn_.jl:31\ntest set:\
    \ Error During Test at /tmp/tmphedfpjn_.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphedfpjn_.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    Check whether it is possible to concatenate two strings given as\n    a list\
    \ of strings and form a valid string.\n    \"\"\"\n    open_par = 0 # count open\
    \ parentheses\n    closed_par = 0 # count closed parentheses\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            # keep track of the number of\
    \ open and closed parentheses\n            if lst[i][j] == '('\n             \
    \   open_par += 1\n            elseif lst[i][j] == ')'\n                closed_par\
    \ += 1\n            end\n        end\n    end\n    # if the number of open parentheses\
    \ is not equal to the number of\n    # closed parentheses, it is not possible\
    \ to concatenate the two\n    # strings and form a valid string\n    if open_par\
    \ != closed_par\n        return \"No\"\n    else\n        return \"Yes\"\n   \
    \ end\nend\nmatch_parens(['()(', ')']) == \"Yes\"\nmatch_parens([')', ')']) ==\
    \ \"No\"\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpf9pp4fh8.jl:41\nin expression\
    \ starting at /tmp/tmpf9pp4fh8.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    op = popfirst!(lst)\n\
    \    cl = popfirst!(lst)\n    if length(op) == 0\n        if length(cl) == 0\n\
    \            return \"Yes\"\n        else\n            return \"No\"\n       \
    \ end\n    elseif (op[1] == '(') & (cl[1] == ')')\n        return match_parens([op[2:end],\
    \ cl[2:end]])\n    elseif (op[1] == '(') & (cl[1] == '(')\n        return match_parens([op[2:end],\
    \ cl])\n    elseif (op[1] == ')') & (cl[1] == ')')\n        return match_parens([op,\
    \ cl[2:end]])\n    elseif (op[1] == ')') & (cl[1] == '(')\n        return match_parens([op,\
    \ cl[2:end]])\n    end\nend\nprintln(match_parens(['()(', ')']) == 'Yes')\nprintln(match_parens([')',\
    \ ')']) == 'No')\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpc5gsttyw.jl:34\nin expression\
    \ starting at /tmp/tmpc5gsttyw.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    for (s1,\
    \ s2) in zip(lst[1], lst[2])\n        if s1 == '('\n            if s2 == ')'\n\
    \                return \"Yes\"\n            else\n                return \"No\"\
    \n            end\n        elseif s1 == ')'\n            if s2 == '('\n      \
    \          return \"Yes\"\n            else\n                return \"No\"\n \
    \           end\n        end\n    end\nend\n@test match_parens([\"()(\", \")\"\
    ]) == \"Yes\"\n@test match_parens([\")\", \")\"]) == \"No\"\n@test match_parens([\"\
    (()\", \")\"]) == \"No\"\n@test match_parens([\"((\", \"))\"]) == \"Yes\"\n@test\
    \ match_parens([\"()\", \")\"]) == \"No\"\n@test match_parens([\"()\", \"())\"\
    ]) == \"Yes\"\n@test match_parens([\"()\", \"())\"]) == \"Yes\"\n@test match_parens([\"\
    (\", \"(\"]) == \"No\"\n@test match_parens([\"(\", \"))\"]) == \"Yes\"\n@test\
    \ match_parens([\"(()))\", \")\"]) == \"Yes\"\n@test match_parens([\"()))\", \"\
    )\"]) == \"No\"\n@test match_parens([\"()))\", \"(((\"]) == \"No\"\n@test match_parens([\"\
    ()\", \"(\"]) == \"No\"\n@test match_parens([\"(()\", \"(\"]) == \"No\"\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @test not defined\nin expression starting\
    \ at /tmp/tmpd5o8fqhs.jl:32\nin expression starting at /tmp/tmpd5o8fqhs.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    left = 0\n\
    \    right = 0\n    str = join(lst, \"\")\n    for c in str\n        if c == '('\n\
    \            left += 1\n        elseif c == ')'\n            right += 1\n    \
    \    end\n        if right > left\n            return \"No\"\n        end\n  \
    \  end\n    if left == right\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqvufsikk.jl:43\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqvufsikk.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqvufsikk.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpqvufsikk.jl:44\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqvufsikk.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqvufsikk.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpqvufsikk.jl:51\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqvufsikk.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqvufsikk.jl:39\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqvufsikk.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    Check if we can concatenate strings to form a balanced string.\n    \"\"\"\
    \n    # we can assume at most one string starts with a closing parenthesis\n \
    \   # because the other would be malformed.\n    one, two = lst[1], lst[2]\n \
    \   if one[1] == ')'; two, one = one, two end\n    if one[end] == ')' && two[1]\
    \ == ')'; return \"No\" end\n    if two[1] == ')'\n        one = one[2:end] #\
    \ remove the opening parenthesis\n        two = two[2:end] # remove the closing\
    \ parenthesis\n    end\n    # now we want to find the number of extra opening/closing\
    \ parentheses\n    # in the strings.\n    extra_open, extra_close = 0, 0\n   \
    \ for ch in one\n        if ch == '('; extra_open += 1 else extra_close += 1 end\n\
    \    end\n    for ch in two\n        if ch == '('; extra_open += 1 else extra_close\
    \ += 1 end\n    end\n    if extra_open == extra_close; return \"Yes\" else return\
    \ \"No\" end\nend\n    \nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |   12     12\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    close_parens = 0\n    for s in lst\n        for c in s\n          \
    \  if c == '('\n                open_parens += 1\n            elseif c == ')'\n\
    \                close_parens += 1\n            end\n        end\n    end\n  \
    \  if open_parens == close_parens\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9pd7d4gd.jl:47\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9pd7d4gd.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9pd7d4gd.jl:37\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9pd7d4gd.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    is_balanced(x) = sum(x .== '(') == sum(x .== ')')\n    if length(s1)\
    \ == 0 || length(s2) == 0\n        return \"Yes\"\n    elseif is_balanced(s1)\
    \ && is_balanced(s2)\n        return \"Yes\"\n    elseif is_balanced(s1)\n   \
    \     return match_parens([s1, s2[2:end]])\n    elseif is_balanced(s2)\n     \
    \   return match_parens([s1[2:end], s2])\n    else\n        return \"No\"\n  \
    \  end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpn97tpwfu.jl:36\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn97tpwfu.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn97tpwfu.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpn97tpwfu.jl:37\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn97tpwfu.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn97tpwfu.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpn97tpwfu.jl:40\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn97tpwfu.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn97tpwfu.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpn97tpwfu.jl:42\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn97tpwfu.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn97tpwfu.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpn97tpwfu.jl:43\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn97tpwfu.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    paren1 =\
    \ count(x -> x == '(', lst[1])\n    paren2 = count(x -> x == '(', lst[2])\n  \
    \  paren3 = count(x -> x == ')', lst[1])\n    paren4 = count(x -> x == ')', lst[2])\n\
    \    if paren1 == paren3 && paren2 == paren4\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpko8lszgx.jl:31\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpko8lszgx.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpko8lszgx.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpko8lszgx.jl:34\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpko8lszgx.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpko8lszgx.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpko8lszgx.jl:35\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpko8lszgx.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpko8lszgx.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpko8lszgx.jl:37\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpko8lszgx.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpko8lszgx.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpko8lszgx.jl:40\n  Expression: candidate([\")(\", \")(\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/ju"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpko8lszgx.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if count(x\
    \ -> x == '(', lst[1]) == count(x -> x == ')', lst[2])\n        return \"Yes\"\
    \n    else\n        return \"No\"\n    end\nend\nprintln(match_parens([\"()(\"\
    , \")\"]))\nprintln(match_parens([\")\", \")\"]))\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "No\nNo\ntest set: Test Failed at /tmp/tmptoue0_6b.jl:29\n  Expression:\
    \ candidate([\"()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptoue0_6b.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptoue0_6b.jl:28\ntest set: Test\
    \ Failed at /tmp/tmptoue0_6b.jl:31\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptoue0_6b.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptoue0_6b.jl:28\ntest set: Test\
    \ Failed at /tmp/tmptoue0_6b.jl:32\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptoue0_6b.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptoue0_6b.jl:28\ntest set: Test\
    \ Failed at /tmp/tmptoue0_6b.jl:33\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptoue0_6b.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptoue0_6b.jl:28\ntest set: Test\
    \ Failed at /tmp/tmptoue0_6b.jl:35\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /sh"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptoue0_6b.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # check\
    \ if there are more \"(\" than \")\" in the first string\n    s1 = lst[1]\n  \
    \  s2 = lst[2]\n    more_left_than_right = (count(x -> x == '(', s1) > count(x\
    \ -> x == ')', s1))\n    more_right_than_left = (count(x -> x == ')', s1) > count(x\
    \ -> x == '(', s1))\n    # if there are more right than left, we are fucked\n\
    \    if more_right_than_left\n        return \"No\"\n    end\n    # if there are\
    \ more left than right, we need to check the second string\n    if more_left_than_right\n\
    \        more_left_than_right = (count(x -> x == '(', s2) > count(x -> x == ')',\
    \ s2))\n        if more_left_than_right\n            return \"No\"\n        end\n\
    \    end\n    # now we only need to check that the number of lefts is equal to\
    \ the number of rights\n    if (count(x -> x == '(', s1) == count(x -> x == ')',\
    \ s1)) && (count(x -> x == '(', s2) == count(x -> x == ')', s2))\n        return\
    \ \"Yes\"\n    end\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcaca2763.jl:43\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcaca2763.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcaca2763.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpcaca2763.jl:46\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcaca2763.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcaca2763.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpcaca2763.jl:47\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcaca2763.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcaca2763.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpcaca2763.jl:49\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcaca2763.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcaca2763.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpcaca2763.jl:52\n  Expression: candidate([\")(\", \")(\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/ju"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcaca2763.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    str = string(lst[1],\
    \ lst[2])\n    cnt = 0\n    for ch in str\n        cnt += (ch == '(') - (ch ==\
    \ ')')\n        if cnt < 0\n            return \"No\"\n        end\n    end\n\
    \    return (cnt == 0) ? \"Yes\" : \"No\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpz3uw1vfy.jl:34\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz3uw1vfy.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz3uw1vfy.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpz3uw1vfy.jl:35\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz3uw1vfy.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz3uw1vfy.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpz3uw1vfy.jl:42\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz3uw1vfy.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz3uw1vfy.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz3uw1vfy.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s = reverse(lst[1])\n\
    \    r = lst[2]\n    s_cnt = 0\n    r_cnt = 0\n    while length(s) != 0 || length(r)\
    \ != 0\n        if length(s) != 0\n            substr = popfirst!(s)\n       \
    \     if substr == '('\n                s_cnt += 1\n            else\n       \
    \         s_cnt -= 1\n            end\n        end\n        if length(r) != 0\n\
    \            substr = popfirst!(r)\n            if substr == '('\n           \
    \     r_cnt += 1\n            else\n                r_cnt -= 1\n            end\n\
    \        end\n        if s_cnt < 0 || r_cnt < 0\n            return \"No\"\n \
    \       end\n    end\n    if s_cnt == 0 && r_cnt == 0\n        return \"Yes\"\n\
    \    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpkm0nucvr.jl:52\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: no method\
    \ matching popfirst!(::String)\n  Closest candidates are:\n    popfirst!(!Matched::Vector)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1364\n    popfirst!(!Matched::Base.Iterators.Stateful)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/iterators.jl:1318\n    popfirst!(!Matched::Base.InvasiveLinkedList{Base.LinkedListItem{T}}\
    \ where T) at /shared/centos7/julia/1.7.3/share/julia/base/linked_list.jl:141\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpkm0nucvr.jl:22\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkm0nucvr.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkm0nucvr.jl:51\ntest set:\
    \ Error During Test at /tmp/tmpkm0nucvr.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: no method matching popfirst!(::String)\n\
    \  Closest candidates are:\n    popfirst!(!Matched::Vector) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1364\n\
    \    popfirst!(!Matched::Base.Iterators.Stateful) at /shared/centos7/julia/1.7.3/share/julia/base/iterators.jl:1318\n\
    \    popfirst!(!Matched::Base.InvasiveLinkedList{Base.LinkedListItem{T}} where\
    \ T) at /shared/centos7/julia/1.7.3/share/julia/base/linked_list.jl:141\n    ...\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpkm0nucvr.jl:22\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkm0nucvr.jl:53 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkm0nucvr.jl:51\ntest set:\
    \ Error During Test at /tmp/tmpkm0nucvr"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkm0nucvr.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    n1, n2 = length(s1), length(s2)\n    min_diff = n1 - n2\n    max_diff\
    \ = n1 + n2\n    diff = 0\n    open = 0\n    for c in s1\n        diff += c ==\
    \ '(' ? 1 : -1\n        open += c == '(' ? 1 : 0\n        if diff < min_diff ||\
    \ (diff == min_diff && open == 0)\n            return \"No\"\n        end\n  \
    \  end\n    for c in s2\n        diff += c == '(' ? 1 : -1\n        open += c\
    \ == '(' ? 1 : 0\n        if diff > max_diff || (diff == max_diff && open > 0)\n\
    \            return \"No\"\n        end\n    end\n    return \"Yes\"\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpo6m18hfq.jl:43\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo6m18hfq.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo6m18hfq.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpo6m18hfq.jl:45\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo6m18hfq.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo6m18hfq.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpo6m18hfq.jl:48\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo6m18hfq.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo6m18hfq.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpo6m18hfq.jl:50\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo6m18hfq.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo6m18hfq.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpo6m18hfq.jl:54\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/s"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo6m18hfq.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    idx1, idx2 = 0, 0\n    while idx1 <= length(s1) && idx2 <= length(s2)\n\
    \        if s1[idx1] == '('\n            idx1 += 1\n        elseif s2[idx2] ==\
    \ ')'\n            idx2 += 1\n        else\n            return \"No\"\n      \
    \  end\n    end\n    if idx1 <= length(s1)\n        for ch in s1[idx1:end]\n \
    \           if ch == ')'\n                return \"No\"\n            end\n   \
    \     end\n    elseif idx2 <= length(s2)\n        for ch in s2[idx2:end]\n   \
    \         if ch == '('\n                return \"No\"\n            end\n     \
    \   end\n    end\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpd9obgbbq.jl:47\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  BoundsError: attempt\
    \ to access 3-codeunit String at index [0]\n  Stacktrace:\n   [1] checkbounds\n\
    \     @ ./strings/basic.jl:216 [inlined]\n   [2] codeunit\n     @ ./strings/string.jl:102\
    \ [inlined]\n   [3] getindex\n     @ ./strings/string.jl:223 [inlined]\n   [4]\
    \ match_parens(lst::Vector{String})\n     @ Main /tmp/tmpd9obgbbq.jl:19\n   [5]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpd9obgbbq.jl:47 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpd9obgbbq.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpd9obgbbq.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  BoundsError: attempt to access 1-codeunit\
    \ String at index [0]\n  Stacktrace:\n   [1] checkbounds\n     @ ./strings/basic.jl:216\
    \ [inlined]\n   [2] codeunit\n     @ ./strings/string.jl:102 [inlined]\n   [3]\
    \ getindex\n     @ ./strings/string.jl:223 [inlined]\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpd9obgbbq.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpd9obgbbq.jl:48 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpd9obgbbq.jl:46\ntest set:\
    \ Error During Test at /tmp/tmpd9obgbbq.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  BoundsError: attempt to access\
    \ 7-codeunit String at index [0]\n  Stacktrace:\n   [1] checkbounds\n     @ ./strings/basic.jl:216\
    \ [inlined]\n   [2] codeunit\n     @ ./strings/string.jl:102 [inlined]\n   [3]\
    \ getindex\n     @ ./strings/string.jl:223 [inlined]\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpd9obgbbq.jl:19\n   ["
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd9obgbbq.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # pick first\
    \ string and put it on the stack\n    # pick second string, if a closing parenthesis\
    \ is found\n    # check the last (top-most) element in the stack, if not matching\n\
    \    # return 'No'\n    # if all the pairs matches return 'Yes'\n    # if second\
    \ string is empty, then return 'No'\n    stack = []\n    for c in lst[1]\n   \
    \     push!(stack, c)\n    end\n    for c in lst[2]\n        if c == ')'\n   \
    \         if isempty(stack) || stack[end] != '('\n                return \"No\"\
    \n            else\n                pop!(stack)\n            end\n        end\n\
    \    end\n    if !isempty(stack)\n        return \"No\"\n    else\n        return\
    \ \"Yes\"\n    end\nend\nprintln(match_parens(['()(', ')']))\nprintln(match_parens([')',\
    \ ')']))\nprintln(match_parens(['()(', '(']))\nprintln(match_parens(['((())(',\
    \ ')(']))\nprintln(match_parens(['()(()', '()']))\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmphhgc3oo4.jl:41\nin expression\
    \ starting at /tmp/tmphhgc3oo4.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if isbalanced(lst[1])\
    \ && isbalanced(lst[2])\n        return \"Yes\"\n    elseif !isbalanced(lst[1])\
    \ && !isbalanced(lst[2])\n        return \"No\"\n    else\n        if !isbalanced(lst[1])\n\
    \            temp = findall(x -> x == '(', lst[1])\n            if length(temp)\
    \ > length(findall(x -> x == ')', lst[2]))\n                return \"No\"\n  \
    \          else\n                return \"Yes\"\n            end\n        else\n\
    \            temp = findall(x -> x == ')', lst[1])\n            if length(temp)\
    \ > length(findall(x -> x == '(', lst[2]))\n                return \"No\"\n  \
    \          else\n                return \"Yes\"\n            end\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpd3ceo959.jl:43\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpd3ceo959.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd3ceo959.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd3ceo959.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpd3ceo959.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: isbalanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpd3ceo959.jl:16\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd3ceo959.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd3ceo959.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpd3ceo959.jl:45\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpd3ceo959.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd3ceo959.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd3ceo959.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpd3ceo959.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: isbalanced not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd3ceo95"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd3ceo959.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    is_good\
    \ = true\n    for s in lst\n        if !is_good_string(s)\n            is_good\
    \ = false\n            break\n        end\n    end\n    return (is_good ? \"Yes\"\
    \ : \"No\")\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpliwj0_wg.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good_string\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpliwj0_wg.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpliwj0_wg.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpliwj0_wg.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpliwj0_wg.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good_string not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpliwj0_wg.jl:18\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpliwj0_wg.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpliwj0_wg.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpliwj0_wg.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good_string\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpliwj0_wg.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpliwj0_wg.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpliwj0_wg.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpliwj0_wg.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good_string\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpliwj0_wg.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    function lefty(s)\n        cnt = 0\n        for c in s\n          \
    \  if c == '('\n                cnt += 1\n            elseif c == ')'\n      \
    \          cnt -= 1\n            end\n            if cnt < 0\n               \
    \ return false\n            end\n        end\n        return cnt == 0\n    end\n\
    \    return \"Yes\" * (lefty(s1) && lefty(s2)) + \"No\" * (lefty(s1) && !lefty(s2))\
    \ + \"No\" * (!lefty(s1) && lefty(s2)) + \"No\" * (!lefty(s1) && !lefty(s2))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpgr__976t.jl:38\\n  Test threw\
    \ exception\\n  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\\n  MethodError:\
    \ no method matching *(::String, ::Bool)\\n  Closest candidates are:\\n    *(::Any,\
    \ ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\\\
    n    *(::Union{AbstractChar, AbstractString}, !Matched::Union{AbstractChar, AbstractString}...)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:260\\n    *(::Union{AbstractChar,\
    \ AbstractString}, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:183\\\
    n    ...\\n  Stacktrace:\\n   [1] match_parens(lst::Vector{String})\\n     @ Main\
    \ /tmp/tmpgr__976t.jl:31\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpgr__976t.jl:38 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpgr__976t.jl:37\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open1 =\
    \ 0\n    close1 = 0\n    open2 = 0\n    close2 = 0\n    for i in 1:length(lst[1])\n\
    \        if lst[1][i] == '('\n            open1 += 1\n        elseif lst[1][i]\
    \ == ')'\n            close1 += 1\n        end\n    end\n    for i in 1:length(lst[2])\n\
    \        if lst[2][i] == '('\n            open2 += 1\n        elseif lst[2][i]\
    \ == ')'\n            close2 += 1\n        end\n    end\n    if open1 == close2\
    \ && open2 == close1\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nmatch_parens(['()(', ')'])\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp2o5_eqhc.jl:40\nin expression\
    \ starting at /tmp/tmp2o5_eqhc.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if lst[1]\
    \ == \"\"\n        s = lst[2]\n    elseif lst[2] == \"\"\n        s = lst[1]\n\
    \    else\n        s = lst[1] * lst[2]\n    end\n    if s == \"\"\n        return\
    \ \"Yes\"\n    end\n    op = [x == '(' for x in s]\n    cl = [x == ')' for x in\
    \ s]\n    while any(op) && any(cl)\n        if op[1]\n            op[1] = false\n\
    \        else\n            op[2:end] = op[1:end-1]\n            op[1] = false\n\
    \        end\n        if cl[end]\n            cl[end] = false\n        else\n\
    \            cl[1:end-1] = cl[2:end]\n            cl[end] = false\n        end\n\
    \    end\n    if all(op) || all(cl)\n        return \"No\"\n    else\n       \
    \ return \"Yes\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppcco6n__.jl:55\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppcco6n__.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppcco6n__.jl:52\ntest set: Test\
    \ Failed at /tmp/tmppcco6n__.jl:58\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppcco6n__.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppcco6n__.jl:52\ntest set: Test\
    \ Failed at /tmp/tmppcco6n__.jl:60\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppcco6n__.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppcco6n__.jl:52\ntest set: Test\
    \ Failed at /tmp/tmppcco6n__.jl:61\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppcco6n__.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppcco6n__.jl:52\ntest set: Test\
    \ Failed at /tmp/tmppcco6n__.jl:62\n  Expression: candidate([\")(\", \")(\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppcco6n__.jl:50\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open = count(lst[1],\
    \ '(')\n    close = count(lst[1], ')')\n    for i in lst[2]\n        i == '('\
    \ ? open += 1 : close += 1\n    end\n    if open == close\n        return \"Yes\"\
    \n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpd4gpkmak.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpd4gpkmak.jl:16\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpd4gpkmak.jl:32 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpd4gpkmak.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpd4gpkmak.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpd4gpkmak.jl:16\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpd4gpkmak.jl:33 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpd4gpkmak.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpd4gpkmak.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd4gpkmak.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # the number\
    \ of ( - )\n    pdiff = 0\n    for i in 1:2\n        pdiff += count(x -> x ==\
    \ '(', lst[i]) - count(x -> x == ')', lst[i])\n    end\n    # If an odd number\
    \ of ( - ), cannot be balanced\n    if pdiff % 2 != 0\n        return \"No\"\n\
    \    end\n    # The number of ( - ) of the longer string must be greater than\
    \ or equal to the number of ( - ) of the shorter string\n    if pdiff > 0\n  \
    \      return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpa0uep5y0.jl:37\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa0uep5y0.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa0uep5y0.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpa0uep5y0.jl:40\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa0uep5y0.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa0uep5y0.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpa0uep5y0.jl:41\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa0uep5y0.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa0uep5y0.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpa0uep5y0.jl:43\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa0uep5y0.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa0uep5y0.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpa0uep5y0.jl:45\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa0uep5y0.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # return\
    \ string \"Yes\" or \"No\"\n    # print(lst)\n    # print(lst[1])\n    # print(lst[2])\n\
    \    if sum(count(x-> x == '(', lst[1])) == sum(count(x-> x == ')', lst[1]))\n\
    \        # print(\"first str equal\")\n        if sum(count(x-> x == '(', lst[2]))\
    \ == sum(count(x-> x == ')', lst[2]))\n            # print(\"both str equal\"\
    )\n            return \"Yes\"\n        else\n            # print(\"second str\
    \ not equal\")\n            return \"No\"\n        end\n    else\n        # print(\"\
    first str not equal\")\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmxfmfip1.jl:39\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmxfmfip1.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmxfmfip1.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpmxfmfip1.jl:42\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmxfmfip1.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmxfmfip1.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpmxfmfip1.jl:43\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmxfmfip1.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmxfmfip1.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpmxfmfip1.jl:45\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmxfmfip1.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmxfmfip1.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpmxfmfip1.jl:48\n  Expression: candidate([\")(\", \")(\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/ju"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmxfmfip1.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    op::Int\
    \ = count(x -> x == '(', lst[1])\n    cp::Int = count(x -> x == ')', lst[1])\n\
    \    s2::String = lst[2]\n    s2op::Int = count(x -> x == '(', s2)\n    s2cp::Int\
    \ = count(x -> x == ')', s2)\n    if op+s2op == cp+s2cp\n        return \"Yes\"\
    \n    else\n        return \"No\"\n    end\nend\nmatch_parens(['()(', ')'])\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmprlb7epqq.jl:27\nin expression\
    \ starting at /tmp/tmprlb7epqq.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    for i in\
    \ 1:length(lst[1])\n        for j in i:length(lst[2])\n            if check_parens(lst[1][1:i]\
    \ * lst[2][1:j])\n                return \"Yes\"\n            end\n        end\n\
    \    end\n    return \"No\"\nend\nmatch_parens([\"()(\", \")\"])\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: check_parens not defined\nStacktrace:\n\
    \ [1] match_parens(lst::Vector{String})\n   @ Main /tmp/tmp7hckv0am.jl:18\n [2]\
    \ top-level scope\n   @ /tmp/tmp7hckv0am.jl:25\nin expression starting at /tmp/tmp7hckv0am.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if lst[1]\
    \ == \"(\" && lst[2] == \")\"\n        return \"Yes\"\n    elseif lst[1] == \"\
    )\" && lst[2] == \"(\"\n        return \"Yes\"\n    elseif lst[1] == \")\" &&\
    \ lst[2] == \")\"\n        return \"No\"\n    elseif lst[1] == \"(\" && lst[2]\
    \ == \"(\"\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6zehfq51.jl:31\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp6zehfq51.jl:23\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6zehfq51.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6zehfq51.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp6zehfq51.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp6zehfq51.jl:23\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6zehfq51.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6zehfq51.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if length(lst[1])\
    \ + length(lst[2]) < 0\n        return \"No\"\n    end\n    for i in 1:length(lst[1])\n\
    \        if lst[1][i] == '('\n            lst[1][i] = ')'\n        else\n    \
    \        lst[1][i] = '('\n        end\n    end\n    for i in 1:length(lst[2])\n\
    \        if lst[2][i] == '('\n            lst[2][i] = ')'\n        else\n    \
    \        lst[2][i] = '('\n        end\n    end\n    return \"Yes\"\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmprlwdo9ad.jl:40\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: no method\
    \ matching setindex!(::String, ::Char, ::Int64)\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmprlwdo9ad.jl:21\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprlwdo9ad.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprlwdo9ad.jl:39\ntest set:\
    \ Error During Test at /tmp/tmprlwdo9ad.jl:41\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: no method matching setindex!(::String,\
    \ ::Char, ::Int64)\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmprlwdo9ad.jl:23\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprlwdo9ad.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprlwdo9ad.jl:39\ntest set:\
    \ Error During Test at /tmp/tmprlwdo9ad.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: no method matching\
    \ setindex!(::String, ::Char, ::Int64)\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmprlwdo9ad.jl:21\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprlwdo9ad.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprlwdo9ad.jl:39\ntest set:\
    \ Error During Test at /tmp/tmprlwdo9ad.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  MethodError: no method matc"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprlwdo9ad.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    str1 = lst[1]\n\
    \    str2 = lst[2]\n    itr1 = 1\n    itr2 = 1\n    # check until the end of shorter\
    \ string or until the end of longer string\n    # with balanced parens\n    while\
    \ itr1 <= length(str1) && itr2 <= length(str2)\n        # skip over parens that\
    \ cancel each other\n        while itr1 <= length(str1) && itr2 <= length(str2)\
    \ &&\n            str1[itr1] == '(' && str2[itr2] == ')'\n            itr1 +=\
    \ 1\n            itr2 += 1\n        end\n        if itr1 <= length(str1) && str1[itr1]\
    \ == ')'\n            return \"No\"\n        elseif itr2 <= length(str2) && str2[itr2]\
    \ == '('\n            return \"No\"\n        end\n        itr1 += 1\n        itr2\
    \ += 1\n    end\n    if itr1 <= length(str1) && count(str1[itr1:end], '(') !=\
    \ count(str1[itr1:end], ')')\n        return \"No\"\n    elseif itr2 <= length(str2)\
    \ && count(str2[itr2:end], '(') != count(str2[itr2:end], ')')\n        return\
    \ \"No\"\n    end\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpg0ejv8n4.jl:49\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg0ejv8n4.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg0ejv8n4.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpg0ejv8n4.jl:52\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg0ejv8n4.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg0ejv8n4.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpg0ejv8n4.jl:53\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg0ejv8n4.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg0ejv8n4.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpg0ejv8n4.jl:55\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg0ejv8n4.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg0ejv8n4.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpg0ejv8n4.jl:60\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/jul"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg0ejv8n4.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    op1 = lst[1]\n\
    \    op2 = lst[2]\n    if op1[1] == ')' || op2[1] == ')' \n        return \"No\"\
    \n    end \n    if op1[end] == '(' || op2[end] == '(' \n        return \"No\"\n\
    \    end\n    n1 = length(op1)\n    n2 = length(op2)\n    return get_count(op1,\
    \ n1) == get_count(op2, n2) ? \"Yes\" : \"No\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpg7qzqj2c.jl:33\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg7qzqj2c.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg7qzqj2c.jl:32\ntest set: Error\
    \ During Test at /tmp/tmpg7qzqj2c.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: get_count not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpg7qzqj2c.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg7qzqj2c.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg7qzqj2c.jl:32\ntest set:\
    \ Test Failed at /tmp/tmpg7qzqj2c.jl:36\n  Expression: candidate([\")())\", \"\
    (()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg7qzqj2c.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg7qzqj2c.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpg7qzqj2c.jl:37\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg7qzqj2c.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg7qzqj2c.jl:32\ntest set: Error\
    \ During Test at /tmp/tmpg7q"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 6 failed, 2 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg7qzqj2c.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    Returns 'Yes' if it is possible to concatenate two strings\n    into a good\
    \ string, 'No' otherwise.\n    \"\"\"\n    s = \"\"\n    for i in 1:length(lst)\n\
    \        s = s * lst[i]\n    end\n    counter = 0\n    for letter in s\n     \
    \   if letter == '('\n            counter += 1\n        elseif letter == ')'\n\
    \            counter -= 1\n        end\n        if counter < 0\n            return\
    \ \"No\"\n        end\n    end\n    return counter == 0 ? \"Yes\" : \"No\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpv87awcmz.jl:45\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv87awcmz.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv87awcmz.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpv87awcmz.jl:46\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv87awcmz.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv87awcmz.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpv87awcmz.jl:53\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv87awcmz.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv87awcmz.jl:41\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv87awcmz.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    Determine if it is possible to concatenate strings in lst\n    and have a\
    \ string with balanced parentheses.\n    \"\"\"\n    (left, right) = lst\n   \
    \ prefixes = [prefix for prefix in string_prefixes(left)]\n    count_left = sum(x\
    \ == '(' for x in prefixes)\n    return \"Yes\" if count_left == count(right,\
    \ ')') else \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"function\" at /tmp/tmp_zh7f542.jl:15 expected\
    \ \"end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp_zh7f542.jl:23\n\
    in expression starting at /tmp/tmp_zh7f542.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    size1 =\
    \ length(lst[1])\n    size2 = length(lst[2])\n    for i in 1:size1\n        for\
    \ j in 1:size2\n            if count_open(lst[1][1:i]) == count_close(lst[2][1:j])\n\
    \                return \"Yes\"\n            end\n        end\n    end\n    return\
    \ \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp23jy4d3l.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: count_open\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp23jy4d3l.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp23jy4d3l.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp23jy4d3l.jl:31\ntest set:\
    \ Error During Test at /tmp/tmp23jy4d3l.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: count_open not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp23jy4d3l.jl:20\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp23jy4d3l.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp23jy4d3l.jl:31\ntest set:\
    \ Error During Test at /tmp/tmp23jy4d3l.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: count_open\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp23jy4d3l.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp23jy4d3l.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp23jy4d3l.jl:31\ntest set:\
    \ Error During Test at /tmp/tmp23jy4d3l.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: count_open not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp23jy4d3"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp23jy4d3l.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    s\
    \ = join(lst)\n    # remove all ( parentheses\n    while contains(s, \"(\"); s\
    \ = replace(s, \"(\" => \"\"); end\n    # count the remaining ) parentheses\n\
    \    c = count(s, \")\")\n    return c%2 == 0 ? \"Yes\" : \"No\"\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4iz1c1s4.jl:30\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4iz1c1s4.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4iz1c1s4.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp4iz1c1s4.jl:31\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4iz1c1s4.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4iz1c1s4.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp4iz1c1s4.jl:34\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4iz1c1s4.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4iz1c1s4.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp4iz1c1s4.jl:36\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4iz1c1s4.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4iz1c1s4.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp4iz1c1s4.jl:37\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4iz1c1s4.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    if length(s1) + length(s2) == 0\n        return \"Yes\"\n\
    \    end\n    a, b = count(p -> p == '(', s1), count(p -> p == '(', s2)\n    if\
    \ a == 0 && b == 0\n        return \"Yes\"\n    elseif a == 0\n        return\
    \ \"No\"\n    elseif b == 0\n        return \"No\"\n    elseif a == 1\n      \
    \  return \"Yes\"\n    elseif b == 1\n        return \"Yes\"\n    elseif b ==\
    \ 2\n        return \"Yes\"\n    elseif a == 2\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2hvb9gwb.jl:44\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2hvb9gwb.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2hvb9gwb.jl:43\ntest set: Test\
    \ Failed at /tmp/tmp2hvb9gwb.jl:45\n  Expression: candidate([\")\", \")\"]) ==\
    \ \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2hvb9gwb.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2hvb9gwb.jl:43\ntest set: Test\
    \ Failed at /tmp/tmp2hvb9gwb.jl:46\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2hvb9gwb.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2hvb9gwb.jl:43\ntest set: Test\
    \ Failed at /tmp/tmp2hvb9gwb.jl:49\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2hvb9gwb.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2hvb9gwb.jl:43\ntest set: Test\
    \ Failed at /tmp/tmp2hvb9gwb.jl:52\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/sha"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2hvb9gwb.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open = '('\n\
    \    close = ')'\n    for (i, item) in enumerate(lst)\n        for char in item\n\
    \            if char == open\n                lst[i] = replace(lst[i], open =>\
    \ \"\")\n            elseif char == close\n                lst[i] = replace(lst[i],\
    \ close => \"\")\n            end\n        end\n    end\n    if lst[1] == lst[2]\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8iiseq9z.jl:39\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8iiseq9z.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8iiseq9z.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp8iiseq9z.jl:40\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8iiseq9z.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8iiseq9z.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp8iiseq9z.jl:43\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8iiseq9z.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8iiseq9z.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp8iiseq9z.jl:45\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8iiseq9z.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8iiseq9z.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp8iiseq9z.jl:46\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8iiseq9z.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_lst\
    \ = []\n    close_lst = []\n    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n\
    \            if lst[i][j] == '('\n                push!(open_lst, 1)\n       \
    \     elseif lst[i][j] == ')'\n                push!(close_lst, 1)\n         \
    \   end\n        end\n    end\n    if sum(open_lst) == sum(close_lst)\n      \
    \  return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpui6tnzhx.jl:39\n  Test threw exception\n\
    \  Expression: candidate([\")\", \")\"]) == \"No\"\n  MethodError: no method matching\
    \ zero(::Type{Any})\n  Closest candidates are:\n    zero(::Type{Union{Missing,\
    \ T}}) where T at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:105\n\
    \    zero(!Matched::Union{Type{P}, P}) where P<:Dates.Period at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Dates/src/periods.jl:53\n\
    \    zero(!Matched::T) where T<:Dates.TimeType at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Dates/src/types.jl:450\n\
    \    ...\n  Stacktrace:\n    [1] zero(#unused#::Type{Any})\n      @ Base ./missing.jl:106\n\
    \    [2] reduce_empty(#unused#::typeof(+), #unused#::Type{Any})\n      @ Base\
    \ ./reduce.jl:313\n    [3] reduce_empty(#unused#::typeof(Base.add_sum), #unused#::Type{Any})\n\
    \      @ Base ./reduce.jl:322\n    [4] mapreduce_empty(#unused#::typeof(identity),\
    \ op::Function, T::Type)\n      @ Base ./reduce.jl:345\n    [5] reduce_empty(op::Base.MappingRF{typeof(identity),\
    \ typeof(Base.add_sum)}, #unused#::Type{Any})\n      @ Base ./reduce.jl:331\n\
    \    [6] reduce_empty_iter\n      @ ./reduce.jl:357 [inlined]\n    [7] mapreduce_empty_iter(f::Function,\
    \ op::Function, itr::Vector{Any}, ItrEltype::Base.HasEltype)\n      @ Base ./reduce.jl:353\n\
    \    [8] _mapreduce(f::typeof(identity), op::typeof(Base.add_sum), #unused#::IndexLinear,\
    \ A::Vector{Any})\n      @ Base ./reduce.jl:402\n    [9] _mapreduce_dim\n    \
    \  @ ./reducedim.jl:330 [inlined]\n   [10] #mapreduce#731\n      @ ./reducedim.jl:322\
    \ [inlined]\n   [11] mapreduce\n      @ ./reducedim.jl:322 [inlined]\n   [12]\
    \ #_sum#741\n      @ ./reducedim.jl:894 [inlined]\n   [13] _sum\n      @ ./reducedim.jl:894\
    \ [inlined]\n   [14] #_sum#740\n      @ ./reducedim.jl:893 [inlined]\n   [15]\
    \ _sum\n      @ ./reducedim.jl:893 [inlined]\n   [16] #sum#738\n      @ ./reducedim.jl:889\
    \ [inlined]\n   [17] sum\n      @ ./reducedim.jl:889 [inlined]\n   [18] match_parens(lst::Vector{String})\n\
    \      @ Main /tmp/tmpui6tnzhx.jl:27\n   [19] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/s"
  stderr: "ERROR: LoadError: Some tests did not pass: 10 passed, 1 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpui6tnzhx.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    Determines if it is possible to concatenate the two strings in\n    some\
    \ order, that the resulting string will be good.\n    \"\"\"\n    if findfirst(r\"\
    ([^\\(\\)]+)\", lst[1]) != nothing || findfirst(r\"([^\\(\\)]+)\", lst[2]) !=\
    \ nothing\n        return \"No\"\n    end\n    # ensures parentheses are balanced\n\
    \    if isbalanced(join(lst)) == true\n        return \"Yes\"\n    else\n    \
    \    return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmppndh2nd7.jl:35\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmppndh2nd7.jl:24\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmppndh2nd7.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmppndh2nd7.jl:34\ntest set:\
    \ Error During Test at /tmp/tmppndh2nd7.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: isbalanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmppndh2nd7.jl:24\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmppndh2nd7.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmppndh2nd7.jl:34\ntest set:\
    \ Error During Test at /tmp/tmppndh2nd7.jl:37\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmppndh2nd7.jl:24\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmppndh2nd7.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmppndh2nd7.jl:34\ntest set:\
    \ Error During Test at /tmp/tmppndh2nd7.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: isbalanced not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmppndh2nd"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppndh2nd7.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Check\
    \ if first string is balanced\n    for str in lst\n        if !is_balanced(str)\n\
    \            return \"No\"\n        end\n    end\n    return \"Yes\"\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp4h34sl2o.jl:29\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_balanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp4h34sl2o.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4h34sl2o.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4h34sl2o.jl:28\ntest set:\
    \ Error During Test at /tmp/tmp4h34sl2o.jl:30\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_balanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp4h34sl2o.jl:18\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4h34sl2o.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4h34sl2o.jl:28\ntest set:\
    \ Error During Test at /tmp/tmp4h34sl2o.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_balanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp4h34sl2o.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4h34sl2o.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4h34sl2o.jl:28\ntest set:\
    \ Error During Test at /tmp/tmp4h34sl2o.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_balanced not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp4h3"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4h34sl2o.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    You are given a list of two strings, both strings consist of open\n    parentheses\
    \ '(' or close parentheses ')' only.\n    Your job is to check if it is possible\
    \ to concatenate the two strings in\n    some order, that the resulting string\
    \ will be good.\n    A string S is considered to be good if and only if all parentheses\
    \ in S\n    are balanced. For example: the string '(())()' is good, while the\
    \ string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good\
    \ string, and return 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpls5cqnjl.jl:1\nin expression starting at /tmp/tmpls5cqnjl.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    string_one\
    \ = lst[1]\n    string_two = lst[2]\n    open_count = 0\n    closed_count = 0\n\
    \    open_count_two = 0\n    closed_count_two = 0\n    for i in string_one\n \
    \       if i == '('\n            open_count += 1\n        elseif i == ')'\n  \
    \          closed_count += 1\n        end\n    end\n    for i in string_two\n\
    \        if i == '('\n            open_count_two += 1\n        elseif i == ')'\n\
    \            closed_count_two += 1\n        end\n    end\n    if open_count ==\
    \ closed_count && open_count_two == closed_count_two\n        return \"Yes\"\n\
    \    else\n        return \"No\"\n    end\nend\n\"\"\"\n    You are given a set\
    \ of words. \n    You are asked to remove any nouns and adjectives from the set,\
    \ \n    and return the remaining words as a vector of strings.\n    For this task,\
    \ a word is considered to be a noun or an adjective if it ends \n    with 'ment'\
    \ or 'ness'.\n    For example:\n    [\"direction\", \"management\", \"happiness\"\
    , \"happi\", \"happinessment\"]\n    will become\n    [\"direction\", \"happi\"\
    ]\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmpabqlbi3r.jl:42\nin expression starting at /tmp/tmpabqlbi3r.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpbnr0s0es.jl:23\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpbnr0s0es.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbnr0s0es.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbnr0s0es.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpbnr0s0es.jl:24\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpbnr0s0es.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbnr0s0es.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbnr0s0es.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s = lst[1]\
    \ * lst[2]\n    cnt = 0\n    for (i, ch) in enumerate(s)\n        cnt += (ch ==\
    \ '(') ? 1 : -1\n        if cnt < 0\n            return \"No\"\n        end\n\
    \    end\n    return (cnt == 0) ? \"Yes\" : \"No\"\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjoemj5kz.jl:34\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjoemj5kz.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjoemj5kz.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpjoemj5kz.jl:35\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjoemj5kz.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjoemj5kz.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpjoemj5kz.jl:42\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjoemj5kz.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjoemj5kz.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjoemj5kz.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    str1 = lst[1]\n\
    \    str2 = lst[2]\n    open_count = 0\n    close_count = 0\n    for i in str1\n\
    \        if i == '('\n            open_count += 1\n        else\n            close_count\
    \ += 1\n        end\n    end\n    if open_count == close_count\n        return\
    \ \"Yes\"\n    end\n    open_count = 0\n    close_count = 0\n    for i in str2\n\
    \        if i == '('\n            open_count += 1\n        else\n            close_count\
    \ += 1\n        end\n    end\n    if open_count == close_count\n        return\
    \ \"Yes\"\n    end\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpahu_qgf7.jl:49\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpahu_qgf7.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpahu_qgf7.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpahu_qgf7.jl:52\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpahu_qgf7.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpahu_qgf7.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpahu_qgf7.jl:53\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpahu_qgf7.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpahu_qgf7.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpahu_qgf7.jl:54\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpahu_qgf7.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpahu_qgf7.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpahu_qgf7.jl:55\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/j"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 9 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpahu_qgf7.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    Check if it is possible to concatenate the two strings in some order,\n \
    \   that the resulting string will be good.\nusing Test\n\n@testset begin\n\n\
    candidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t\
    @test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"\
    ())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\
    \t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7_joyovg.jl:1\nin expression starting at /tmp/tmp7_joyovg.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    Given a vector of two strings containing only parentheses, return 'Yes'\n\
    \    if the two strings can be concatenated to form a good string and 'No'\n \
    \   otherwise.\n    \"\"\"\n    if lst[1][end] == '(' && lst[2][1] == ')'\n  \
    \      return \"Yes\"\n    elseif lst[1][end] == ')' && lst[2][1] == '('\n   \
    \     return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzastx548.jl:36\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzastx548.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzastx548.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpzastx548.jl:39\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzastx548.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzastx548.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpzastx548.jl:40\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzastx548.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzastx548.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpzastx548.jl:42\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzastx548.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzastx548.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpzastx548.jl:43\n  Expression: candidate([\")(\", \")(\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzastx548.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s = string(lst[1])\
    \ * string(lst[2])\n    left_parens = 0\n    right_parens = 0\n    for i = 1:length(s)\n\
    \        if s[i] == '('\n            left_parens += 1\n        else\n        \
    \    right_parens += 1\n        end\n        if right_parens > left_parens\n \
    \           return \"No\"\n        end\n    end\n    if left_parens == right_parens\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpq31mryr3.jl:43\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpq31mryr3.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq31mryr3.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpq31mryr3.jl:44\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpq31mryr3.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq31mryr3.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpq31mryr3.jl:51\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpq31mryr3.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq31mryr3.jl:39\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq31mryr3.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open = count(l\
    \ => l == '(', lst[1])\n    close = count(l => l == ')', lst[2])\n    if open\
    \ < close \n        return \"No\"\n    end \n    if open > close \n        return\
    \ \"No\"\n    end \n    return \"Yes\"\nend \nusing Test\n\n@testset begin\n\n\
    candidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t\
    @test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"\
    ())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\
    \t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpc26r2n6h.jl:31\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: l not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpc26r2n6h.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpc26r2n6h.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpc26r2n6h.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpc26r2n6h.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: l not defined\n  Stacktrace:\n\
    \   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpc26r2n6h.jl:16\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpc26r2n6h.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpc26r2n6h.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpc26r2n6h.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: l not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpc26r2n6h.jl:16\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpc26r2n6h.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpc26r2n6h.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpc26r2n6h.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: l not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpc26r2n6h.jl:16\n\
    \   [2] macro expansion\n     "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpc26r2n6h.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    total_open\
    \ = 0\n    total_close = 0\n    for i = 1:length(lst[1])\n        if lst[1][i]\
    \ == '('\n            total_open += 1\n        else\n            total_close +=\
    \ 1\n        end\n    end\n    for i = 1:length(lst[2])\n        if lst[2][i]\
    \ == '('\n            total_open += 1\n        else\n            total_close +=\
    \ 1\n        end\n    end\n    if (total_open == total_close)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpc0ewrqu9.jl:52\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc0ewrqu9.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc0ewrqu9.jl:42\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpc0ewrqu9.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Determine\
    \ whether it is possible to concatenate two given strings\n    # into a good string.\n\
    \    #\n    # INPUT:\n    #\n    # two strings s1 and s2, both consisting of (\
    \ and ) parentheses only.\n    #\n    # OUTPUT:\n    #\n    # either 'Yes' or\
    \ 'No' depending on whether it is possible to form a good\n    # string by concatenating\
    \ s1 and s2 in some order.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpk5eue941.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpk5eue941.jl:1\n\
    in expression starting at /tmp/tmpk5eue941.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    is_open(c::Char)\
    \ = c == '('\n    is_close(c::Char) = c == ')'\n    dict_parens = Dict(is_open\
    \ => is_close, is_close => is_open)\n    is_balanced(s::String) = length(s) ==\
    \ 0 ? true : (length(s) % 2 == 0 ? false : false)\n    for s in lst \n       \
    \ for i in 2:length(s)\n            open = s[i-1]\n            close = s[i]\n\
    \            if open in keys(dict_parens) && close in values(dict_parens)\n  \
    \              continue\n            elseif open in values(dict_parens) && close\
    \ in keys(dict_parens)\n                continue\n            else\n         \
    \       return \"No\"\n            end\n        end\n    end\n    return \"Yes\"\
    \nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgmj37wue.jl:40\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgmj37wue.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgmj37wue.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpgmj37wue.jl:41\n  Expression: candidate([\")\", \")\"]) ==\
    \ \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgmj37wue.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgmj37wue.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpgmj37wue.jl:43\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgmj37wue.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgmj37wue.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpgmj37wue.jl:44\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgmj37wue.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgmj37wue.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpgmj37wue.jl:46\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/juli"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgmj37wue.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    let n =\
    \ n_open = n_close = 0\n        for p in lst[1]\n            if p == '('\n   \
    \             n_open += 1\n            elseif p == ')'\n                n_close\
    \ += 1\n            end\n        end\n        for p in lst[2]\n            if\
    \ p == '('\n                n_open += 1\n            elseif p == ')'\n       \
    \         n_close += 1\n            end\n        end\n        n = n_open - n_close\n\
    \        n < 0 ? return \"No\" : return \"Yes\"\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: colon expected in \"?\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphszn4umy.jl:33\nin expression starting at\
    \ /tmp/tmphszn4umy.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    A, B = lst[1],\
    \ lst[2]\n    # is_good = (open, close) -> open == 0 && close == 0 \n    is_good(open,\
    \ close) = open == 0 && close == 0\n    Aopen, Aclose = 0, 0\n    Bopen, Bclose\
    \ = 0, 0\n    for c in A\n        if c == '('\n            Aopen += 1\n      \
    \  else\n            Aclose += 1\n        end\n    end\n    for c in B\n     \
    \   if c == '('\n            Bopen += 1\n        else\n            Bclose += 1\n\
    \        end\n    end\n    if is_good(Aopen, Aclose) || is_good(Bopen, Bclose)\
    \ || \n        is_good(Aopen + Bopen, Aclose + Bclose) || \n        is_good(Aopen\
    \ + Bclose, Aclose + Bopen)\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\n        \nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeltcnsxu.jl:49\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeltcnsxu.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeltcnsxu.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpeltcnsxu.jl:52\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeltcnsxu.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeltcnsxu.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpeltcnsxu.jl:53\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeltcnsxu.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeltcnsxu.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpeltcnsxu.jl:55\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeltcnsxu.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeltcnsxu.jl:48\ntest set: Test\
    \ Failed at /tmp/tmpeltcnsxu.jl:59\n  Expression: candidate([\"(\", \")\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/jul"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeltcnsxu.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if isempty(lst[1])\
    \ && isempty(lst[2])\n        return \"Yes\"\n    elseif lst[1][1] == ')' || lst[2][1]\
    \ == ')'\n        return \"No\"\n    elseif lst[1][1] == '(' && lst[2][1] == '('\n\
    \        return match_parens([lst[1][2:end],lst[2][2:end]])\n    elseif lst[1][1]\
    \ == '(' && lst[2][1] == ')'\n        return match_parens([lst[1][2:end],lst[2][2:end]])\n\
    \    elseif lst[1][1] == ')' && lst[2][1] == '('\n        return match_parens([lst[1][2:end],lst[2][2:end]])\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8bp4mqxf.jl:33\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8bp4mqxf.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8bp4mqxf.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp8bp4mqxf.jl:36\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8bp4mqxf.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8bp4mqxf.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp8bp4mqxf.jl:37\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8bp4mqxf.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8bp4mqxf.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp8bp4mqxf.jl:39\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8bp4mqxf.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8bp4mqxf.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp8bp4mqxf.jl:43\n  Expression: candidate([\"(\", \")\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/jul"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8bp4mqxf.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    #Create\
    \ a new string from the two input strings\n    new_string = string(lst[1], lst[2])\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpxm0igfwx.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpxm0igfwx.jl:1\n\
    in expression starting at /tmp/tmpxm0igfwx.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    good = false\n\
    \    for i in lst[1]\n        for j in lst[2]\n            if i == '(' && j ==\
    \ ')'\n                good = true\n            end\n        end\n    end\n  \
    \  if good == true\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw9u846sc.jl:37\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw9u846sc.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw9u846sc.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpw9u846sc.jl:40\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw9u846sc.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw9u846sc.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpw9u846sc.jl:42\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw9u846sc.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw9u846sc.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpw9u846sc.jl:43\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw9u846sc.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw9u846sc.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpw9u846sc.jl:44\n  Expression: candidate([\")(\", \")(\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw9u846sc.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    Takes a list of two strings, each consisting of parenthesis only, and\n \
    \   tests whether the strings can be concatenated in a way that results in a\n\
    \    balanced parenthesis. Returns 'Yes' if this is possible, and 'No' otherwise.\n\
    \    \"\"\"\n    l1, l2 = lst\n    if l1 == \"\"\n        return test_parens(l2)\
    \ ? \"Yes\" : \"No\"\n    elseif l2 == \"\"\n        return test_parens(l1) ?\
    \ \"Yes\" : \"No\"\n    elseif l1[end] == '(' && l2[1] == ')'\n        return\
    \ test_parens(l1[1:end-1] * l2[2:end]) ? \"Yes\" : \"No\"\n    elseif l1[end]\
    \ == ')' && l2[1] == '('\n        return test_parens(l1[1:end-1] * l2[2:end])\
    \ ? \"Yes\" : \"No\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpubcnrdas.jl:39\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: test_parens\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpubcnrdas.jl:27\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpubcnrdas.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpubcnrdas.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpubcnrdas.jl:41\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: test_parens\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpubcnrdas.jl:29\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpubcnrdas.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpubcnrdas.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpubcnrdas.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: test_parens not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpubcnrdas.jl:29\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpubcnrdas.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpubcnrdas.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpubcnrdas.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n  UndefVarError: test_parens\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Mai"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 1 failed, 9 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpubcnrdas.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    string1\
    \ = lst[1]\n    string2 = lst[2]\n    #concatenate strings in all possible orders\
    \ and check to see if balanced\n    if balance_parens(string1 * string2) || balance_parens(string2\
    \ * string1)\n        return \"Yes\"\n    else\n        return \"No\"\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpbo7zs46h.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: balance_parens\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpbo7zs46h.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbo7zs46h.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbo7zs46h.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpbo7zs46h.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: balance_parens not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpbo7zs46h.jl:19\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbo7zs46h.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbo7zs46h.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpbo7zs46h.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: balance_parens\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpbo7zs46h.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbo7zs46h.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbo7zs46h.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpbo7zs46h.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: balance_parens\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbo7zs46h.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    lst1 = lst[1]\n\
    \    lst2 = lst[2]\n    left_cnt = 0\n    right_cnt = 0\n    for c in lst1\n \
    \       if c == '('\n            left_cnt += 1\n        else\n            right_cnt\
    \ += 1\n        end\n    end\n    for c in lst2\n        if c == '('\n       \
    \     left_cnt += 1\n        else\n            right_cnt += 1\n        end\n \
    \   end\n    if left_cnt == right_cnt\n        return \"Yes\"\n    else\n    \
    \    return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6t2wtn32.jl:54\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6t2wtn32.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6t2wtn32.jl:44\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6t2wtn32.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if length(lst[1])\
    \ == 0 && length(lst[2]) == 0\n        return \"Yes\"\n    elseif length(lst[1])\
    \ == 0 || length(lst[2]) == 0\n        return \"No\"\n    elseif lst[1][1] ==\
    \ '('\n        return match_parens([lst[1][2:end], lst[2]])\n    elseif lst[2][end]\
    \ == ')'\n        return match_parens([lst[1], lst[2][1:end-1]])\n    else\n \
    \       return \"No\"\n    end\nend\n@testset \"match_parens test set\" begin\n\
    \    @test match_parens([\"()(\", \")\"]) == \"Yes\"\n    @test match_parens([\"\
    )\", \")\"]) == \"No\"\n    @test match_parens([\"(()(()\", \")\"]) == \"Yes\"\
    \n    @test match_parens([\"())(()\", \")\"]) == \"No\"\n    @test match_parens([\"\
    ()\", \"())\"]) == \"Yes\"\n    @test match_parens([\"()(()\", \")\"]) == \"No\"\
    \n    @test match_parens([\"()((\", \")\"]) == \"No\"\n    @test match_parens([\"\
    ))\", \")\"]) == \"No\"\n    @test match_parens([\"(()\", \")\"]) == \"No\"\n\
    \    @test match_parens([\"((\", \")\"]) == \"No\"\n    @test match_parens([\"\
    ((()(\", \")\"]) == \"No\"\n    @test match_parens([\"((()(()\", \")\"]) == \"\
    No\"\n    @test match_parens([\"(((()(\", \")\"]) == \"No\"\n    @test match_parens([\"\
    (()(\", \"))\"]) == \"Yes\"\n    @test match_parens([\"(\", \")\"]) == \"No\"\n\
    \    @test match_parens([\"()()\", \")\"]) == \"No\"\n    @test match_parens([\"\
    ()\",\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: missing separator in array expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpfzxtv4jg.jl:48\nin expression starting at\
    \ /tmp/tmpfzxtv4jg.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open, closed\
    \ = lst[1], lst[2]\n    balance = [0, 0]\n    for c in open\n        if c == '('\n\
    \            balance[1] += 1\n        elseif c == ')'\n            balance[2]\
    \ += 1\n        end\n    end\n    for c in closed\n        if c == '('\n     \
    \       balance[1] -= 1\n        elseif c == ')'\n            balance[2] -= 1\n\
    \        end\n    end\n    if balance[1] < 0 || balance[2] < 0 || any(x -> x <\
    \ 0, balance)\n        return \"No\"\n    else\n        return \"Yes\"\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpptto7f8_.jl:44\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpptto7f8_.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpptto7f8_.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpptto7f8_.jl:46\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpptto7f8_.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpptto7f8_.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpptto7f8_.jl:47\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpptto7f8_.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpptto7f8_.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpptto7f8_.jl:49\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpptto7f8_.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpptto7f8_.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpptto7f8_.jl:52\n  Expression: candidate([\")(\", \")(\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpptto7f8_.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if !(isbalanced(s1) && isbalanced(s2))\n        return \"No\"\n   \
    \ end\n    @inbounds for i in 1:length(s1)\n        for j in 1:length(s2)\n  \
    \          if isbalanced(s1[1:i-1] * s2[1:j-1])\n                return \"Yes\"\
    \n            end\n        end\n    end\n    return \"No\"\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9tl9i44s.jl:34\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp9tl9i44s.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9tl9i44s.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9tl9i44s.jl:33\ntest set:\
    \ Error During Test at /tmp/tmp9tl9i44s.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: isbalanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp9tl9i44s.jl:17\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9tl9i44s.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9tl9i44s.jl:33\ntest set:\
    \ Error During Test at /tmp/tmp9tl9i44s.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp9tl9i44s.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9tl9i44s.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9tl9i44s.jl:33\ntest set:\
    \ Error During Test at /tmp/tmp9tl9i44s.jl:37\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: isbalanced not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp9tl9i44"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9tl9i44s.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    string =\
    \ \"\"\n    for (i, s) in enumerate(lst)\n        if i == 1\n            string\
    \ = string*s\n        elseif i == 2\n            string = s*string\n        end\n\
    \    end\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpic1okyrn.jl:32\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpic1okyrn.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpic1okyrn.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpic1okyrn.jl:33\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpic1okyrn.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpic1okyrn.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpic1okyrn.jl:36\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpic1okyrn.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpic1okyrn.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpic1okyrn.jl:38\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpic1okyrn.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpic1okyrn.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpic1okyrn.jl:39\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpic1okyrn.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    lst[1]=='()(()())'\
    \ && lst[2]=='(()())()' ? \"Yes\" : \"No\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmp2gly0ep7.jl:16\nin expression\
    \ starting at /tmp/tmp2gly0ep7.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s = \"\"\
    \n    for i in lst\n        if i[1] == ')'\n            return \"No\"\n      \
    \  end\n        s *= i\n    end\n    balance = 0\n    for i in s\n        if i\
    \ == '('\n            balance += 1\n        elseif i == ')'\n            balance\
    \ -= 1\n        end\n        if balance < 0\n            return \"No\"\n     \
    \   end\n    end\n    if balance == 0\n        return \"Yes\"\n    else\n    \
    \    return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp99_q52fy.jl:45\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp99_q52fy.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp99_q52fy.jl:44\ntest set: Test\
    \ Failed at /tmp/tmp99_q52fy.jl:48\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp99_q52fy.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp99_q52fy.jl:44\ntest set: Test\
    \ Failed at /tmp/tmp99_q52fy.jl:49\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp99_q52fy.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp99_q52fy.jl:44\ntest set: Test\
    \ Failed at /tmp/tmp99_q52fy.jl:55\n  Expression: candidate([\"(\", \")\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp99_q52fy.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp99_q52fy.jl:44\ntest set: Test\
    \ Failed at /tmp/tmp99_q52fy.jl:56\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp99_q52fy.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    str_concat\
    \ = string(lst[1], lst[2])\n    while true\n        idx_open = search(str_concat,\
    \ \"(\").stop\n        idx_close = search(str_concat, \")\").stop\n        if\
    \ idx_open == idx_close == -1\n            return \"Yes\"\n        elseif idx_open\
    \ > idx_close\n            return \"No\"\n        else\n            str_concat\
    \ = string(str_concat[1:idx_open-1], str_concat[idx_close+1:end])\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpq11qll8c.jl:34\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: search\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpq11qll8c.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq11qll8c.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq11qll8c.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpq11qll8c.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: search not defined\n \
    \ Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpq11qll8c.jl:18\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq11qll8c.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq11qll8c.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpq11qll8c.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: search not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpq11qll8c.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq11qll8c.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq11qll8c.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpq11qll8c.jl:37\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: search not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpq11qll8c.jl:18\n\
    \   [2] m"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq11qll8c.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Write\
    \ your code here, using the functions you've written in the previous cells.\n\
    \    # If you're new to Julia, you can use 'println()' to print your answers.\n\
    \    # Don't forget to 'return' your answers.\n    # You can use a variable to\
    \ store your answer, and then 'return' it here.\n    # Example: \n    #     ans\
    \ = 5\n    #     return ans\n    return \"Hello World!\"\nend\n \n# Do not edit\
    \ this cell\n@testset \"Basic tests\" begin\n    @test match_parens([\"()(\",\
    \ \")\"]) == \"Yes\"\n    @test match_parens([\")\", \")\"]) == \"No\"\n    @test\
    \ match_parens([\"(()\", \")\"]) == \"Yes\"\n    @test match_parens([\"(\", \"\
    )\"]) == \"Yes\"\n    @test match_parens([\"(()\", \")(\"]) == \"Yes\"\n    @test\
    \ match_parens([\"()(\", \"))\"]) == \"Yes\"\n    @test match_parens([\"()))(\"\
    , \"))\"]) == \"Yes\"\n    @test match_parens([\"()))(\", \")))\"]) == \"No\"\n\
    \    @test match_parens([\"()(()\", \"))((()\"]) == \"Yes\"\n    @test match_parens([\"\
    ()(()(\", \"))((()\"]) == \"No\"\n    @test match_parens([\"()(()(\", \"))((()\"\
    ]) == \"No\"\n    @test match_parens([\"()(()(\", \")))((()\"]) == \"No\"\n  \
    \  @test match_parens([\"()(()(\", \"))((()\"]) == \"No\"\n    @test match_parens([\"\
    (()(()(\", \"))((()\"]) == \"No\"\n    @test match_parens([\"(()(()(\", \"))((()\"\
    ]) == \"No\"\n    @test match_parens([\"()(()\", \"))(((()\"]) == \"No\"\n   \
    \ @test match_parens([\"()(()\", \"))(((()\"]) ==\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"begin\" at /tmp/tmpznghs7jm.jl:27\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpznghs7jm.jl:27\n\
    in expression starting at /tmp/tmpznghs7jm.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Using\
    \ regex to get the count of open and close parens\n    regex_close = r\"\\)\"\n\
    \    regex_open = r\"\\(\"\n    if count(regex_close, lst[1]) - count(regex_open,\
    \ lst[1]) == \n        count(regex_close, lst[2]) - count(regex_open, lst[2])\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2kt8upfx.jl:31\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2kt8upfx.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2kt8upfx.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp2kt8upfx.jl:32\n  Expression: candidate([\")\", \")\"]) ==\
    \ \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2kt8upfx.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2kt8upfx.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp2kt8upfx.jl:34\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2kt8upfx.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2kt8upfx.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp2kt8upfx.jl:35\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2kt8upfx.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2kt8upfx.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp2kt8upfx.jl:37\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/juli"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2kt8upfx.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\"\
    \n    Returns 'Yes' if there's a way to make a good string.\n    Returns 'No'\
    \ otherwise.\n    \"\"\"\n    parens_list = join(lst)\n    count = 0\n    for\
    \ i in 1:length(parens_list)\n        if parens_list[i] == '('\n            count\
    \ += 1\n        elseif parens_list[i] == ')'\n            count -= 1\n       \
    \ end\n        if count < 0\n            return \"No\"\n        end\n    end\n\
    \    if count == 0\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7n9rnwdd.jl:46\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7n9rnwdd.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7n9rnwdd.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp7n9rnwdd.jl:47\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7n9rnwdd.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7n9rnwdd.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp7n9rnwdd.jl:54\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7n9rnwdd.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7n9rnwdd.jl:42\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7n9rnwdd.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    #First concatenate\
    \ the two strings\n    concat = join(lst)\n    #Since we are only dealing with\
    \ parentheses, one can count the number of\n    #each type of parenthesis. If\
    \ there are an odd number of one kind, or if\n    #the number of close parentheses\
    \ is ever greater than the number of open\n    #parentheses at any step, the string\
    \ is not good.\n    numopen = 0\n    numclose = 0\n    for i in 1:length(concat)\n\
    \        if concat[i] == '('\n            numopen += 1\n        else\n       \
    \     numclose += 1\n        end\n        if numclose > numopen\n            return\
    \ \"No\"\n        end\n    end\n    #If there are an odd number of either, the\
    \ string is not good.\n    if (numopen % 2 == 1) || (numclose % 2 == 1)\n    \
    \    return \"No\"\n    end\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppka_s96e.jl:48\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppka_s96e.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppka_s96e.jl:44\ntest set: Test\
    \ Failed at /tmp/tmppka_s96e.jl:49\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppka_s96e.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppka_s96e.jl:44\ntest set: Test\
    \ Failed at /tmp/tmppka_s96e.jl:51\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppka_s96e.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppka_s96e.jl:44\ntest set: Test\
    \ Failed at /tmp/tmppka_s96e.jl:55\n  Expression: candidate([\"(\", \")\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppka_s96e.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppka_s96e.jl:44\ntest set: Test\
    \ Failed at /tmp/tmppka_s96e.jl:56\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppka_s96e.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    # count the number of open parens in s1, and close parens\
    \ in s2\n    # if they're equal, you can make a good string\n    return (sum(s1\
    \ .== '(') == sum(s2 .== ')')) ? \"Yes\" : \"No\"\nend\n \nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvcdgzg4y.jl:28\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvcdgzg4y.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvcdgzg4y.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpvcdgzg4y.jl:29\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvcdgzg4y.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvcdgzg4y.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpvcdgzg4y.jl:32\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvcdgzg4y.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvcdgzg4y.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpvcdgzg4y.jl:34\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvcdgzg4y.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvcdgzg4y.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpvcdgzg4y.jl:35\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvcdgzg4y.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    @assert\
    \ length(lst) == 2 \"\"\n    (s1, s2) = lst\n    if length(s1) > length(s2)\n\
    \        (s1, s2) = (s2, s1)\n    end\n    idx = 0\n    for i in 1:length(s1)\n\
    \        if s1[i] == '('\n            idx += 1\n        else\n            idx\
    \ -= 1\n        end\n    end\n    if idx < 0\n        return \"No\"\n    end\n\
    \    idx = 0\n    for i in 1:length(s2)\n        if s2[i] == '('\n           \
    \ idx += 1\n        else\n            idx -= 1\n        end\n    end\n    if idx\
    \ < 0\n        return \"No\"\n    end\n    idx1 = 0\n    idx2 = 0\n    for i in\
    \ 1:length(s1)\n        if s1[i] == '('\n            idx1 += 1\n        else\n\
    \            idx1 -= 1\n        end\n        for j in 1:length(s2)\n         \
    \   if s2[j] == '('\n                idx2 += 1\n            else\n           \
    \     idx2 -= 1\n            end\n            if i == length(s1) && j == length(s2)\n\
    \                if idx1 == 0 && idx2 == 0\n                    return \"Yes\"\
    \n                end\n            end\n        end\n    end\n    return \"No\"\
    \nend\n```\n## Tests\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid \"`\" syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpjcl30ytz.jl:66\nin expression starting at\
    \ /tmp/tmpjcl30ytz.jl:66\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    openers\
    \ = 0\n    closers = 0\n    for item in lst\n        for c in item\n         \
    \   if c == '('\n                openers += 1\n            else\n            \
    \    closers += 1\n            end\n        end\n    end\n    openers == closers\
    \ ? \"Yes\" : \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvltnvin_.jl:43\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvltnvin_.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvltnvin_.jl:33\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvltnvin_.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if (sum(count(x\
    \ -> x == '(', lst[1])) - sum(count(x -> x == ')', lst[1]))) ==\n        (sum(count(x\
    \ -> x == '(', lst[2])) - sum(count(x -> x == ')', lst[2])))\n        return \"\
    Yes\"\n    else \n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpg_wlf7zw.jl:28\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg_wlf7zw.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg_wlf7zw.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpg_wlf7zw.jl:29\n  Expression: candidate([\")\", \")\"]) ==\
    \ \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg_wlf7zw.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg_wlf7zw.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpg_wlf7zw.jl:31\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg_wlf7zw.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg_wlf7zw.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpg_wlf7zw.jl:32\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg_wlf7zw.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg_wlf7zw.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpg_wlf7zw.jl:34\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/juli"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg_wlf7zw.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    close_parens = 0\n    for l in lst\n        for c in l\n          \
    \  if c == '('\n                open_parens += 1\n            elseif c == ')'\n\
    \                close_parens += 1\n            end\n        end\n    end\n  \
    \  if open_parens == close_parens\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpksuz43y7.jl:47\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpksuz43y7.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpksuz43y7.jl:37\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpksuz43y7.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # The first\
    \ string is left parenthesis and the second is right\n    # parenthesis\n    result\
    \ = \"Yes\"\n    left_parens = count(lst[1], '(')\n    right_parens = count(lst[2],\
    \ ')')\n    if left_parens == right_parens\n        return result\n    elseif\
    \ left_parens > right_parens\n        for i in 1:left_parens-right_parens\n  \
    \          lst[1] = replace(lst[1], '()', '', count=1)\n        end\n        if\
    \ (count(lst[1], '(') == count(lst[1], ')')) && (count(lst[2], '(') == count(lst[2],\
    \ ')'))\n            return result\n        else\n            return \"No\"\n\
    \        end\n    else\n        for i in 1:right_parens-left_parens\n        \
    \    lst[2] = replace(lst[2], '()', '', count=1)\n        end\n        if (count(lst[1],\
    \ '(') == count(lst[1], ')')) && (count(lst[2], '(') == count(lst[2], ')'))\n\
    \            return result\n        else\n            return \"No\"\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpqwn6ttzy.jl:25\nin expression\
    \ starting at /tmp/tmpqwn6ttzy.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s = lst[1]\
    \ + lst[2]\n    open_parens = 0\n    for char in s\n        if char == '('\n \
    \           open_parens += 1\n        elseif char == ')'\n            open_parens\
    \ -= 1\n        end\n        if open_parens < 0\n            return \"No\"\n \
    \       end\n    end\n    if open_parens == 0\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpzft019qq.jl:39\\n  Test threw\
    \ exception\\n  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\\n  MethodError:\
    \ no method matching +(::String, ::String)\\n  Closest candidates are:\\n    +(::Any,\
    \ ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\\\
    n  Stacktrace:\\n   [1] match_parens(lst::Vector{String})\\n     @ Main /tmp/tmpzft019qq.jl:16\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpzft019qq.jl:39 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpzft019qq.jl:38\\ntest set:\
    \ Error During Test at /tmp/tmpzft019qq.jl:40\\n  Test threw exception\\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\\n  MethodError: no method matching +(::String,\
    \ ::String)\\n  Closest candidates are:\\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\\n  Stacktrace:\\\
    n   [1] match_parens(lst::Vector{String})\\n     @ Main /tmp/tmpzft019qq.jl:16\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpzft019qq.jl:40 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpzft019qq.jl:38\\ntest set:\
    \ Error During Test at /tmp/tmpzft019qq.jl:41\\n  Test threw exception\\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\\n  MethodError: no method matching\
    \ +(::String, ::String)\\n  Closest candidates are:\\n    +(::Any, ::Any, !Matched::Any,\
    \ !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\\\
    n  Stacktrace:\\n   [1] match_parens(lst::Vector{String})\\n     @ Main /tmp/tmpzft019qq.jl:16\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if lst[1]\
    \ == \"\" && lst[2] == \"\"\n        return \"Yes\"\n    elseif lst[1] == \"\"\
    \ && lst[2] != \"\"\n        return \"No\"\n    elseif lst[1] != \"\" && lst[2]\
    \ == \"\"\n        return \"No\"\n    else\n        return \"Yes\"\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpf3dfsogl.jl:32\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf3dfsogl.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf3dfsogl.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpf3dfsogl.jl:33\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf3dfsogl.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf3dfsogl.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpf3dfsogl.jl:36\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf3dfsogl.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf3dfsogl.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpf3dfsogl.jl:38\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf3dfsogl.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf3dfsogl.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpf3dfsogl.jl:39\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf3dfsogl.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    is_good\
    \ = false\n    if lst[1] == \"(\"\n        is_good = true\n    end\n    check\
    \ = () -> 1\n    for i = 1:length(lst[2])\n        if lst[2][i] == \"(\"\n   \
    \         check = (x) -> x+1\n        else\n            check = (x) -> x-1\n \
    \       end\n        is_good = is_good && check(1) > 0\n    end\n    if is_good\
    \ == true\n        return \"Yes\"\n    else\n        return \"No\"\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpr56pl_pz.jl:40\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr56pl_pz.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr56pl_pz.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpr56pl_pz.jl:43\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr56pl_pz.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr56pl_pz.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpr56pl_pz.jl:44\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr56pl_pz.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr56pl_pz.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpr56pl_pz.jl:46\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr56pl_pz.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr56pl_pz.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpr56pl_pz.jl:50\n  Expression: candidate([\"(\", \")\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/jul"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr56pl_pz.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s = cat(lst[1],\
    \ lst[2])\n    if (count(s, '(') == count(s, ')'))\n        return \"Yes\"\n \
    \   else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t\
    @test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"\
    ())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\
    \t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpysdcqywa.jl:28\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefKeywordError: keyword\
    \ argument dims not assigned\n  Stacktrace:\n   [1] cat\n     @ ./abstractarray.jl:1861\
    \ [inlined]\n   [2] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpysdcqywa.jl:16\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpysdcqywa.jl:28 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpysdcqywa.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpysdcqywa.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefKeywordError: keyword argument dims\
    \ not assigned\n  Stacktrace:\n   [1] cat\n     @ ./abstractarray.jl:1861 [inlined]\n\
    \   [2] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpysdcqywa.jl:16\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpysdcqywa.jl:29 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpysdcqywa.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpysdcqywa.jl:30\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefKeywordError: keyword\
    \ argument dims not assigned\n  Stacktrace:\n   [1] cat\n     @ ./abstractarray.jl:1861\
    \ [inlined]\n   [2] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpysdcqywa.jl:16\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpysdcqywa.jl:30 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpysdcqywa.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpysdcqywa."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpysdcqywa.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if count(x\
    \ -> x == ')', lst[1]) > count(x -> x == '(', lst[2])\n        return \"No\"\n\
    \    end\n    if isbalanced(lst[1] * lst[2])\n        return \"Yes\"\n    end\n\
    \    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdv7isf2j.jl:29\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdv7isf2j.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdv7isf2j.jl:28\ntest set: Error\
    \ During Test at /tmp/tmpdv7isf2j.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: isbalanced not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpdv7isf2j.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdv7isf2j.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdv7isf2j.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpdv7isf2j.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpdv7isf2j.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdv7isf2j.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdv7isf2j.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpdv7isf2j.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\"()\", \"())\"]) == \"No\"\n  UndefVarError: isbalanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpdv7isf2j.jl:19\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] ma"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 1 failed, 9 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdv7isf2j.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    S = lst[1]\
    \ * lst[2]\n    @assert length(S) > 0\n    balance = 0\n    for p in S\n     \
    \   if p == '('\n            balance += 1\n        elseif p == ')'\n         \
    \   balance -= 1\n        end\n        if balance < 0\n            return \"No\"\
    \n        end\n    end\n    if balance == 0\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpiqh7w3zi.jl:43\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiqh7w3zi.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiqh7w3zi.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpiqh7w3zi.jl:44\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiqh7w3zi.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiqh7w3zi.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpiqh7w3zi.jl:51\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiqh7w3zi.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiqh7w3zi.jl:39\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiqh7w3zi.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # check\
    \ that both strings are balanced\n    balanced(s) = s == \"()\" || (s[1] == '('\
    \ && s[end] == ')')\n    # check that the result string is balanced\n    balanced(l,\
    \ r) = balanced(l) && balanced(r) || balanced(l * r)\n    # list of strings, we\
    \ need to check all combinations\n    lst[1], lst[2] == \"()\" && return \"Yes\"\
    \n    balanced(lst[1], lst[2]) && return \"Yes\"\n    balanced(lst[2], lst[1])\
    \ && return \"Yes\"\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\n\
    candidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t\
    @test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"\
    ())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\
    \t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmqovlqej.jl:33\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmqovlqej.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmqovlqej.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpmqovlqej.jl:36\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmqovlqej.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmqovlqej.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpmqovlqej.jl:38\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmqovlqej.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmqovlqej.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpmqovlqej.jl:39\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmqovlqej.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmqovlqej.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    8     4     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 8 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmqovlqej.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Find a\
    \ way to make a good string\n    num_open_parentheses = 0\n    num_closed_parentheses\
    \ = 0\n    for i = 1:length(lst[1])\n        if lst[1][i] == '('\n           \
    \ num_open_parentheses += 1\n        else\n            num_closed_parentheses\
    \ += 1\n        end\n    end\n    for i = 1:length(lst[2])\n        if lst[2][i]\
    \ == '('\n            num_open_parentheses += 1\n        else\n            num_closed_parentheses\
    \ += 1\n        end\n    end\n    if (num_open_parentheses == num_closed_parentheses)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n\"\"\"\
    \n    You're in charge of managing the team that is responsible for design and\n\
    \    construction of the trail system in your local national park. Currently,\n\
    \    there are several trails in the park, and they are not connected together.\n\
    \    You want to connect all of the trails together, so that hikers, bikers,\n\
    \    and skiers can travel between all of the trails.\n    The park service has\
    \ made a map of the trails and the locations they are\n    connected at.\n   \
    \ You are given a list of strings, each string is a trail path, and each\n   \
    \ trail has a name. Each string contains one or more '=' signs, and each\n   \
    \ string begins with the name of the trail.\n    The '=' signs represent connections\
    \ between the trail and the trail or\n    trails that the connection branches\
    \ off of. \n    For example, 'Big Mountain Ski Resort=Sugar Bowl Ski Resort=Royal\
    \ Gorge\n    Cross Country Ski Resort' means that the trail 'Big Mountain Ski\
    \ Resort'\n    is connected to the trails 'Sugar Bowl Ski Resort' and 'Royal Gorge\
    \ Cross\n    Country Ski Resort'.\n    Return a list of strings with the names\
    \ of the trails, in the order that\n    the trails should be visited to connect\
    \ all of the trails together.\n    The first element in the list should be the\
    \ starting trail, and the last\n    element in the list should be the ending trail.\n\
    \    The output list should not contain any duplicates.\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgnz9x5uh.jl:39\nin expression starting at\
    \ /tmp/tmpgnz9x5uh.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    match_parens_1(lst)\
    \ ? \"Yes\" : \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzmyy20rq.jl:23\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: match_parens_1\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpzmyy20rq.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzmyy20rq.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzmyy20rq.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpzmyy20rq.jl:24\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: match_parens_1 not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpzmyy20rq.jl:16\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzmyy20rq.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzmyy20rq.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpzmyy20rq.jl:25\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: match_parens_1\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpzmyy20rq.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzmyy20rq.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzmyy20rq.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpzmyy20rq.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: match_parens_1\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzmyy20rq.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    #\
    \ put everything in one string to count parens easier\n    str1 = lst[1]\n   \
    \ str2 = lst[2]\n    str = str1 * str2\n    \n    # test if good\n    n = length(str)\n\
    \    open = 0\n    for i in 1:n\n        if str[i] == '('\n            open +=\
    \ 1\n        elseif str[i] == ')'\n            open -= 1\n        end\n      \
    \  if open < 0\n            return \"No\"\n        end\n    end\n    \n    if\
    \ open != 0\n        return \"No\"\n    else\n        return \"Yes\"\n    end\n\
    \    \nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpz3aw23b2.jl:51\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz3aw23b2.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz3aw23b2.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpz3aw23b2.jl:52\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz3aw23b2.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz3aw23b2.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpz3aw23b2.jl:59\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz3aw23b2.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz3aw23b2.jl:47\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz3aw23b2.jl:45\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    You are given a list of two strings, both strings consist of open\n    parentheses\
    \ '(' or close parentheses ')' only.\n    Your job is to check if it is possible\
    \ to concatenate the two strings in\n    some order, that the resulting string\
    \ will be good.\n    A string S is considered to be good if and only if all parentheses\
    \ in S\n    are balanced. For example: the string '(())()' is good, while the\
    \ string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good\
    \ string, and return 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4814x9k4.jl:1\nin expression starting at /tmp/tmp4814x9k4.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    lst is a vector of two strings both consisting of open parentheses '('\n\
    \    or close parentheses ')' only.\n    Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n    \"\"\"\n    # Extract the two\
    \ strings from the vector.\n    str1, str2 = lst\n    # The strings are good if\
    \ the number of open parentheses equals the number\n    # of close parentheses\
    \ and vice versa.\n    bool1 = count(str1, '(') == count(str1, ')')\n    bool2\
    \ = count(str2, '(') == count(str2, ')')\n    # Return 'Yes' if both strings are\
    \ good and 'No' otherwise.\n    return bool1 && bool2 ? \"Yes\" : \"No\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmprytr6d4y.jl:35\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmprytr6d4y.jl:25\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmprytr6d4y.jl:35 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmprytr6d4y.jl:34\ntest set:\
    \ Error During Test at /tmp/tmprytr6d4y.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmprytr6d4y.jl:25\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmprytr6d4y.jl:36 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmprytr6d4y.jl:34\ntest set:\
    \ Error During Test at /tmp/tmprytr6d4y.jl:37\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprytr6d4y.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    total = length(s1) + length(s2)\n    good_count = sum([1 for s in [s1,\
    \ s2] if sum([1 for c in s if c == '(']) == sum([1 for c in s if c == ')'])])\n\
    \    bad_count = 2 - good_count\n    n_missing = total - 2*sum([1 for s in [s1,\
    \ s2] for c in s if c == '('])\n    return if bad_count < 1 && (n_missing % 2\
    \ == 0) \"Yes\" else \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp9g3d_anu.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp9g3d_anu.jl:1\n\
    in expression starting at /tmp/tmp9g3d_anu.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_count\
    \ = 0\n    close_count = 0\n    for ch in lst[1]\n        if ch == '('\n     \
    \       open_count += 1\n        else\n            close_count += 1\n        end\n\
    \    end\n    for ch in lst[2]\n        if ch == '('\n            open_count +=\
    \ 1\n        else\n            close_count += 1\n        end\n    end\n    if\
    \ open_count == close_count\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nprintln(match_parens(['()(', ')']))\nprintln(match_parens([')',\
    \ ')']))\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpzdylb_r9.jl:38\nin expression\
    \ starting at /tmp/tmpzdylb_r9.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    lst = cat(lst,\
    \ dims=1)\n    if lst == \"()\"\n        return \"Yes\"\n    elseif lst == \"\"\
    \n        return \"Yes\"\n    elseif lst == \")(\"\n        return \"No\"\n  \
    \  elseif lst == \"(\"\n        return \"No\"\n    elseif lst == \")\"\n     \
    \   return \"No\"\n    else\n        return match_parens(split(lst, r\"(?<=[()])\"\
    ))\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpw7m5p7fw.jl:36\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: no method\
    \ matching split(::Vector{String}, ::Regex)\n  Closest candidates are:\n    split(!Matched::T,\
    \ ::Any; limit, keepempty) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:417\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpw7m5p7fw.jl:28\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpw7m5p7fw.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpw7m5p7fw.jl:35\ntest set:\
    \ Error During Test at /tmp/tmpw7m5p7fw.jl:37\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: no method matching split(::Vector{String},\
    \ ::Regex)\n  Closest candidates are:\n    split(!Matched::T, ::Any; limit, keepempty)\
    \ where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:417\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpw7m5p7fw.jl:28\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpw7m5p7fw.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpw7m5p7fw.jl:35\ntest set:\
    \ Error During Test at /tmp/tmpw7m5p7fw.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: no method matching\
    \ split(::Vector{String}, ::Regex)\n  Closest candidates are:\n    split(!Matched::T,\
    \ ::Any; limit, keepempty) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:417\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpw7m5p7fw.jl:28\n\
    \   [2] macro exp"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw7m5p7fw.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    s1_open, s1_close = count(s1, '('), count(s1, ')')\n    s2_open, s2_close\
    \ = count(s2, '('), count(s2, ')')\n    if s1_open - s1_close != s2_open - s2_close\n\
    \        return \"No\"\n    end\n    if s1_open == s1_close && s2_open == s2_close\n\
    \        return \"Yes\"\n    end\n    if s1_open > s1_close && s2_open == s2_close\n\
    \        return \"Yes\"\n    end\n    if s1_open == s1_close && s2_open > s2_close\n\
    \        return \"Yes\"\n    end\n    return \"No\"\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2j626dx1.jl:38\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmp2j626dx1.jl:17\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp2j626dx1.jl:38 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp2j626dx1.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp2j626dx1.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp2j626dx1.jl:17\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp2j626dx1.jl:39 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp2j626dx1.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp2j626dx1.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2j626dx1.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open::Int\
    \ = count(x -> x == '(', lst[1])\n    close::Int = count(x -> x == ')', lst[1])\n\
    \    newopen::Int = count(x -> x == '(', lst[2])\n    newclose::Int = count(x\
    \ -> x == ')', lst[2])\n    if newopen > newclose\n        open += newopen - newclose\n\
    \    else\n        close += newclose - newopen\n    end\n    if close == open\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbn2y1rcj.jl:45\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbn2y1rcj.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbn2y1rcj.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbn2y1rcj.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    left = count(x\
    \ -> x == '(', lst[1])\n    right = count(x -> x == ')', lst[2])\n    if (left\
    \ == right)\n        return \"Yes\"\n    else\n        return \"No\"\n    end\n\
    end\n\"\"\"\n    You are given a two-dimensional map of numbers.\n    Each map\
    \ contains the same number of rows and columns.\n    Every cell of the map contains\
    \ one of the numbers: 0, 1, or 2.\n    Your job is to create a function that will\
    \ return the result map.\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvudtal56.jl:24\nin expression starting at\
    \ /tmp/tmpvudtal56.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if is_good(s1 + s2)\n        return \"Yes\"\n    elseif is_good(s2\
    \ + s1)\n        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpr_9tavp5.jl:30\\n  Test threw\
    \ exception\\n  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\\n  MethodError:\
    \ no method matching +(::String, ::String)\\n  Closest candidates are:\\n    +(::Any,\
    \ ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\\\
    n  Stacktrace:\\n   [1] match_parens(lst::Vector{String})\\n     @ Main /tmp/tmpr_9tavp5.jl:17\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpr_9tavp5.jl:30 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpr_9tavp5.jl:29\\ntest set:\
    \ Error During Test at /tmp/tmpr_9tavp5.jl:31\\n  Test threw exception\\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\\n  MethodError: no method matching +(::String,\
    \ ::String)\\n  Closest candidates are:\\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\\n  Stacktrace:\\\
    n   [1] match_parens(lst::Vector{String})\\n     @ Main /tmp/tmpr_9tavp5.jl:17\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpr_9tavp5.jl:31 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpr_9tavp5.jl:29\\ntest set:\
    \ Error During Test at /tmp/tmpr_9tavp5.jl:32\\n  Test threw exception\\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\\n  MethodError: no method matching\
    \ +(::String, ::String)\\n  Closest candidates are:\\n    +(::Any, ::Any, !Matched::Any,\
    \ !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\\\
    n  Stacktrace:\\n   [1] match_parens(lst::Vector{String})\\n     @ Main /tmp/tmpr_9tavp5.jl:17\\\
    n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"Concatenate\
    \ the strings in lst and check if they can make a good string.\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpujiavu7x.jl:1\nin expression starting at /tmp/tmpujiavu7x.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    counter\
    \ = 0\n    if length(lst[1]) == 1 && length(lst[2]) == 1\n        if lst[1] ==\
    \ \"(\" && lst[2] == \")\"\n            return \"Yes\"\n        else\n       \
    \     return \"No\"\n        end\n    end\n    for i in lst[1]\n        if i ==\
    \ \"(\"\n            counter += 1\n        else\n            counter -= 1\n  \
    \      end\n    end\n    for i in lst[2]\n        if i == \"(\"\n            counter\
    \ += 1\n        else\n            counter -= 1\n        end\n    end\n    if counter\
    \ == 0\n        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8i1w7acl.jl:49\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8i1w7acl.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8i1w7acl.jl:48\ntest set: Test\
    \ Failed at /tmp/tmp8i1w7acl.jl:52\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8i1w7acl.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8i1w7acl.jl:48\ntest set: Test\
    \ Failed at /tmp/tmp8i1w7acl.jl:53\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8i1w7acl.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8i1w7acl.jl:48\ntest set: Test\
    \ Failed at /tmp/tmp8i1w7acl.jl:55\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8i1w7acl.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8i1w7acl.jl:48\ntest set: Test\
    \ Failed at /tmp/tmp8i1w7acl.jl:60\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/jul"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8i1w7acl.jl:46\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    parens =\
    \ Set(\"()\")\n    openparens = Set(\"(\")\n    closedparens = Set(\")\")\n  \
    \  num_opens = 0\n    num_closed = 0\n    for c in lst[1]\n        if c in openparens\n\
    \            num_opens += 1\n        elseif c in closedparens\n            num_closed\
    \ += 1\n        end\n    end\n    for c in lst[2]\n        if c in openparens\n\
    \            num_opens += 1\n        elseif c in closedparens\n            num_closed\
    \ += 1\n        end\n    end\n    if num_opens == num_closed\n        return \"\
    Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8owi9jxe.jl:55\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8owi9jxe.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8owi9jxe.jl:45\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8owi9jxe.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if length(lst[1])\
    \ == length(lst[2])\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbct46wga.jl:27\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbct46wga.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbct46wga.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpbct46wga.jl:28\n  Expression: candidate([\")\", \")\"]) ==\
    \ \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbct46wga.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbct46wga.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpbct46wga.jl:30\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbct46wga.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbct46wga.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpbct46wga.jl:31\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbct46wga.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbct46wga.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpbct46wga.jl:33\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/juli"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbct46wga.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    Checks whether the parentheses in a string are balanced\n    \"\"\"\n   \
    \ if (lst[1] == lst[2]) && (lst[1] == \")\")\n        return \"No\"\n    elseif\
    \ (lst[1] == lst[2]) && (lst[1] == \"(\")\n        return \"Yes\"\n    elseif\
    \ (lst[1] == \"(\") && (lst[2] == \")\")\n        return \"Yes\"\n    else\n \
    \       return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp19_12a46.jl:34\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp19_12a46.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp19_12a46.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp19_12a46.jl:37\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp19_12a46.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp19_12a46.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp19_12a46.jl:38\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp19_12a46.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp19_12a46.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp19_12a46.jl:40\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp19_12a46.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp19_12a46.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp19_12a46.jl:45\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/jul"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp19_12a46.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    opencount = 0\n    closecount = 0\n    for (i,par) in enumerate(lst[1])\n\
    \        if par == '('\n            opencount += 1\n        elseif par == ')'\n\
    \            opencount -= 1\n        end\n    end\n    for (i,par) in enumerate(lst[2])\n\
    \        if par == '('\n            closecount += 1\n        elseif par == ')'\n\
    \            closecount -= 1\n        end\n    end\n    if opencount == closecount\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcz4jqk5c.jl:44\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcz4jqk5c.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcz4jqk5c.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpcz4jqk5c.jl:45\n  Expression: candidate([\")\", \")\"]) ==\
    \ \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcz4jqk5c.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcz4jqk5c.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpcz4jqk5c.jl:47\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcz4jqk5c.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcz4jqk5c.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpcz4jqk5c.jl:48\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcz4jqk5c.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcz4jqk5c.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpcz4jqk5c.jl:50\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/juli"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcz4jqk5c.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    S = [s for\
    \ s in lst]\n    reverse!(S)\n    while isempty(S) == false\n        if S[end]\
    \ == \")\"\n            push!(S, \"(\")\n        else\n            S = S[1:end-1]\n\
    \        end\n    end\n    if S == []\n        return \"Yes\"\n    else\n    \
    \    return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    o = count(x\
    \ -> x == '(', lst[1])\n    c = count(x -> x == ')', lst[1])\n    match_counter\
    \ = o - c\n    o = count(x -> x == '(', lst[2])\n    c = count(x -> x == ')',\
    \ lst[2])\n    match_counter += o - c\n    if match_counter > 0\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_jrt5tje.jl:33\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_jrt5tje.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_jrt5tje.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp_jrt5tje.jl:36\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_jrt5tje.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_jrt5tje.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp_jrt5tje.jl:37\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_jrt5tje.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_jrt5tje.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp_jrt5tje.jl:39\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_jrt5tje.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_jrt5tje.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp_jrt5tje.jl:40\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/cento"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_jrt5tje.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if count(x\
    \ -> x == '(' , lst[1]) == count(x -> x == ')' , lst[2])\n        return \"Yes\"\
    \n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3zs6ostn.jl:27\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3zs6ostn.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3zs6ostn.jl:26\ntest set: Test\
    \ Failed at /tmp/tmp3zs6ostn.jl:29\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3zs6ostn.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3zs6ostn.jl:26\ntest set: Test\
    \ Failed at /tmp/tmp3zs6ostn.jl:30\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3zs6ostn.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3zs6ostn.jl:26\ntest set: Test\
    \ Failed at /tmp/tmp3zs6ostn.jl:31\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3zs6ostn.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3zs6ostn.jl:26\ntest set: Test\
    \ Failed at /tmp/tmp3zs6ostn.jl:33\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/c"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3zs6ostn.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # get string\
    \ 1, strip parenthesis and check if it's balanced\n    string1 = lst[1]\n    if\
    \ string1[1] == '(' && string1[end] == ')'\n        string1 = string1[2:end-1]\n\
    \    end\n    # get string 2, strip parenthesis and check if it's balanced\n \
    \   string2 = lst[2]\n    if string2[1] == '(' && string2[end] == ')'\n      \
    \  string2 = string2[2:end-1]\n    end\n    parens1 = count(string1, '(')\n  \
    \  parens2 = count(string2, '(')\n    if parens1 == count(string1, ')') && parens2\
    \ == count(string2, ')')\n        return \"Yes\"\n    else\n        return \"\
    No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmop9wijz.jl:39\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpmop9wijz.jl:26\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpmop9wijz.jl:39 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpmop9wijz.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpmop9wijz.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpmop9wijz.jl:26\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpmop9wijz.jl:40 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpmop9wijz.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpmop9wijz.jl:41\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmop9wijz.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    @assert\
    \ length(lst) == 2\n    lst[1] == ')' && lst[2] == ')' && return \"No\"\n    lst[1]\
    \ == '(' && lst[2] == '(' && return \"Yes\"\n    lst[1] == ')' && lst[2] == '('\
    \ && return \"Yes\"\n    lst[1] == '(' && lst[2] == ')' && return \"Yes\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp9etl6sqp.jl:27\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Bool to an object of type String\n  Closest candidates are:\n\
    \    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp9etl6sqp.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9etl6sqp.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9etl6sqp.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp9etl6sqp.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: Cannot `convert` an object\
    \ of type Bool to an object of type String\n  Closest candidates are:\n    convert(::Type{String},\
    \ !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp9etl6sqp.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9etl6sqp.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9etl6sqp.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = count(x -> x == '(', lst[1])\n    close_parens = count(x -> x == ')', lst[2])\n\
    \    if open_parens == close_parens \n        return \"Yes\"\n    else \n    \
    \    return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_o3wigtx.jl:29\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_o3wigtx.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_o3wigtx.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp_o3wigtx.jl:31\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_o3wigtx.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_o3wigtx.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp_o3wigtx.jl:32\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_o3wigtx.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_o3wigtx.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp_o3wigtx.jl:33\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_o3wigtx.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_o3wigtx.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp_o3wigtx.jl:35\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/c"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_o3wigtx.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = '('\n    close_parens = ')'\n    s1 = lst[1]\n    s2 = lst[2]\n    if (s1[1]\
    \ == close_parens) || (s2[1] == close_parens)\n        return \"No\"\n    end\n\
    \    s = s1 * s2\n    len = length(s)\n    if (len == 0) \n        return \"Yes\"\
    \n    end\n    count = 0\n    for i in 1:len\n        if s[i] == open_parens\n\
    \            count += 1\n        elseif s[i] == close_parens\n            count\
    \ -= 1\n        end\n        if count < 0\n            return \"No\"\n       \
    \ end\n    end\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzvk5ib32.jl:46\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzvk5ib32.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzvk5ib32.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpzvk5ib32.jl:49\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzvk5ib32.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzvk5ib32.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpzvk5ib32.jl:50\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzvk5ib32.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzvk5ib32.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpzvk5ib32.jl:53\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzvk5ib32.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzvk5ib32.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpzvk5ib32.jl:56\n  Expression: candidate([\"(\", \")\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzvk5ib32.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens_available\
    \ = 0\n    for letter in lst[1]\n        if letter == '('\n            open_parens_available\
    \ += 1\n        elseif letter == ')'\n            open_parens_available -= 1\n\
    \        end\n    end\n    println(open_parens_available)\n    close_parens_required\
    \ = 0\n    for letter in lst[2]\n        if letter == ')'\n            close_parens_required\
    \ += 1\n        elseif letter == '('\n            close_parens_required -= 1\n\
    \        end\n    end\n    println(close_parens_required)\n    if open_parens_available\
    \ == close_parens_required\n        return \"Yes\"\n    else\n        return \"\
    No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "1\n1\n-1\n1\n1\n2\n-2\n-2\n-2\n-2\n0\n1\n2\n2\n4\n-1\n0\n-2\n0\n0\ntest\
    \ set: Test Failed at /tmp/tmpa7hzus_1.jl:54\n  Expression: candidate([\")(\"\
    , \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa7hzus_1.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa7hzus_1.jl:44\n1\n1\n-1\n-1\n\
    Test Summary: | Pass  Fail  Total\ntest set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa7hzus_1.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens,\
    \ close_parens = count_parens(lst)\n    if open_parens == close_parens\n     \
    \   return \"Yes\"\n    elseif open_parens > close_parens\n        return find_open_close_parens(lst,\
    \ \")\", \"(\" , open_parens - close_parens)\n    else\n        return find_open_close_parens(lst,\
    \ \"(\", \")\", close_parens - open_parens)\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpdjuvk4fb.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: count_parens\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpdjuvk4fb.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdjuvk4fb.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdjuvk4fb.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpdjuvk4fb.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: count_parens not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpdjuvk4fb.jl:16\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdjuvk4fb.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdjuvk4fb.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpdjuvk4fb.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: count_parens\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpdjuvk4fb.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdjuvk4fb.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdjuvk4fb.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpdjuvk4fb.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: count_parens\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tm"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdjuvk4fb.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    left, right\
    \ = 0, 0\n    for i in 1:length(lst[1])\n        if lst[1][i] == '('\n       \
    \     left += 1\n        else\n            left -= 1\n        end\n    end\n \
    \   for i in 1:length(lst[2])\n        if lst[2][i] == '('\n            right\
    \ += 1\n        else\n            right -= 1\n        end\n    end\n    if (left\
    \ > 0 && right < 0) || (left < 0 && right > 0)\n        return \"No\"\n    else\n\
    \        return \"Yes\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdkx6rk69.jl:42\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdkx6rk69.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdkx6rk69.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpdkx6rk69.jl:43\n  Expression: candidate([\")\", \")\"]) ==\
    \ \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdkx6rk69.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdkx6rk69.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpdkx6rk69.jl:45\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdkx6rk69.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdkx6rk69.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpdkx6rk69.jl:46\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdkx6rk69.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdkx6rk69.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpdkx6rk69.jl:47\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7."
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 11 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdkx6rk69.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s = length(lst[1])\
    \ + length(lst[2])\n    p1 = length(lst[1])\n    p2 = length(lst[2])\n    if p1\
    \ > p2\n        return \"No\"\n    end\n    s_stack = zeros(Int64, s)\n    p1_stack\
    \ = zeros(Int64, p1)\n    p2_stack = zeros(Int64, p2)\n    s_stack_i = 1\n   \
    \ p1_stack_i = 1\n    p2_stack_i = 1\n    for i = 1:length(lst[1])\n        if\
    \ lst[1][i] == '('\n            p1_stack[p1_stack_i] = 1\n            p1_stack_i\
    \ += 1\n        else\n            p1_stack[p1_stack_i] = -1\n            p1_stack_i\
    \ += 1\n        end\n    end\n    for i = 1:length(lst[2])\n        if lst[2][i]\
    \ == '('\n            p2_stack[p2_stack_i] = 1\n            p2_stack_i += 1\n\
    \        else\n            p2_stack[p2_stack_i] = -1\n            p2_stack_i +=\
    \ 1\n        end\n    end\n    for i = 1:length(p1_stack)\n        s_stack[s_stack_i]\
    \ = p1_stack[i]\n        s_stack_i += 1\n    end\n    for i = 1:length(p2_stack)\n\
    \        s_stack[s_stack_i] = p2_stack[i]\n        s_stack_i += 1\n    end\n \
    \   p_counter = 0\n    for i = 1:length(s_stack)\n        if s_stack[i] == 1\n\
    \            p_counter += 1\n        else\n            p_counter -= 1\n      \
    \  end\n        if p_counter < 0\n            return \"No\"\n        end\n   \
    \ end\n    if p_counter == 0\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmw3_9lxz.jl:76\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmw3_9lxz.jl:76 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmw3_9lxz.jl:75\ntest set: Test\
    \ Failed at /tmp/tmpmw3_9lxz.jl:79\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmw3_9lxz.jl:79 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmw3_9lxz.jl:75\ntest set: Test\
    \ Failed at /tmp/tmpmw3_9lxz.jl:80\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmw3_9lxz.jl:80 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmw3_9lxz.jl:75\ntest set: Test\
    \ Failed at /tmp/tmpmw3_9lxz.jl:87\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmw3_9lxz.jl:87 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmw3_9lxz.jl:75\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    8     4     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 8 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmw3_9lxz.jl:73\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    matched\
    \ = \"Yes\"\n    unmatched = \"No\"\n    open = count(p -> p == \"(\", lst[1])\n\
    \    close = count(p -> p == \")\", lst[2])\n    if open == close\n        return\
    \ matched\n    else\n        return unmatched\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_w8h441s.jl:32\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_w8h441s.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_w8h441s.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp_w8h441s.jl:33\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_w8h441s.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_w8h441s.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp_w8h441s.jl:36\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_w8h441s.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_w8h441s.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp_w8h441s.jl:38\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_w8h441s.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_w8h441s.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp_w8h441s.jl:39\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_w8h441s.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Determine\
    \ if it is possible to create a good string from lst.\n    #\n    # If it is not\
    \ possible to create a good string from lst, return 'No'.\n    # If it is possible\
    \ to create a good string from lst, return 'Yes'.\n    #\n    # For example:\n\
    \    # match_parens(['()(', ')']) == 'Yes'\n    # match_parens([')', ')']) ==\
    \ 'No'\n    #\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpmpykhw_l.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpmpykhw_l.jl:1\n\
    in expression starting at /tmp/tmpmpykhw_l.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    Return 'Yes' if the concatenation of the two strings in `lst` is good.\n\
    \    Otherwise, return 'No'.\n    \"\"\"\n    str = string(lst[1], lst[2])\n \
    \   good = true\n    open_count = 0\n    for i in str\n        if i == '('\n \
    \           open_count += 1\n        elseif i == ')'\n            open_count -=\
    \ 1\n        end\n        if open_count < 0\n            good = false\n      \
    \      break\n        end\n    end\n    if good\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8hpv380y.jl:48\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8hpv380y.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8hpv380y.jl:44\ntest set: Test\
    \ Failed at /tmp/tmp8hpv380y.jl:49\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8hpv380y.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8hpv380y.jl:44\ntest set: Test\
    \ Failed at /tmp/tmp8hpv380y.jl:52\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8hpv380y.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8hpv380y.jl:44\ntest set: Test\
    \ Failed at /tmp/tmp8hpv380y.jl:56\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8hpv380y.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8hpv380y.jl:44\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    8     4     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 8 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8hpv380y.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # add all\
    \ open parenthesis at the end of the first string\n    lst[1] = lst[1] * lst[2]\n\
    \    # iterate through the string and return 'Yes' if every open parenthesis\n\
    \    # is closed and 'No' otherwise\n    for i = 1:length(lst[1])\n        if\
    \ (lst[1][i] == '(')\n            if(i == length(lst[1]) || lst[1][i+1] != ')')\n\
    \                return \"No\"\n            end\n        end\n    end\n    return\
    \ \"Yes\"\nend\n \n```\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid \"`\" syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpcc8sr28s.jl:30\nin expression starting at\
    \ /tmp/tmpcc8sr28s.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    Takes a list of strings and returns 'Yes' if there is a way to concatenate\n\
    \    the strings so that the parentheses are balanced. Returns 'No' otherwise.\n\
    \    \"\"\"\n    if length(lst) != 2\n        return \"Error: the function takes\
    \ a list of exactly two strings.\\n\"\n    end\n    if count_parens(lst[1]) ==\
    \ 0 && count_parens(lst[2]) == 0\n        return \"Yes\"\n    end\n    if count_parens(lst[1])\
    \ != 0 && count_parens(lst[2]) != 0\n        first = count_parens(lst[1])\n  \
    \      second = count_parens(lst[2])\n        if first > 0\n            for i\
    \ in 1:length(lst[2])\n                if lst[2][i] == ')'\n                 \
    \   if first == 0\n                        lst[2] = replace(lst[2], i, \"\")\n\
    \                        return match_parens(lst)\n                    else\n\
    \                        first -= 1\n                        lst[2] = replace(lst[2],\
    \ i, \"\")\n                        return match_parens(lst)\n               \
    \     end\n                end\n            end\n        else\n            for\
    \ i in 1:length(lst[1])\n                if lst[1][i] == ')'\n               \
    \     if second == 0\n                        lst[1] = replace(lst[1], i, \"\"\
    )\n                        return match_parens(lst)\n                    else\n\
    \                        second -= 1\n                        lst[1] = replace(lst[1],\
    \ i, \"\")\n                        return match_parens(lst)\n               \
    \     end\n                end\n            end\n        end\n    end\n    if\
    \ count_parens(lst[1]) == 0\n        if lst[2][1] == ')'\n            lst[2] =\
    \ replace(lst[2], 1, \"\")\n            return match_parens(lst)\n        else\n\
    \            return \"No\"\n        end\n    else\n        if lst[1][1] == ')'\n\
    \            lst[1] = replace(lst[1], 1, \"\")\n            return\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplq3texa9.jl:1\nin expression starting at /tmp/tmplq3texa9.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = count(x -> x == '(', lst[1])\n    close_parens = count(x -> x == ')', lst[2])\n\
    \    if open_parens == close_parens\n        return \"Yes\"\n    else\n      \
    \  return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdrelxf95.jl:29\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdrelxf95.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdrelxf95.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpdrelxf95.jl:31\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdrelxf95.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdrelxf95.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpdrelxf95.jl:32\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdrelxf95.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdrelxf95.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpdrelxf95.jl:33\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdrelxf95.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdrelxf95.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpdrelxf95.jl:35\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/c"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdrelxf95.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    You are given a list of two strings, both strings consist of open\n    parentheses\
    \ '(' or close parentheses ')' only.\n    Your job is to check if it is possible\
    \ to concatenate the two strings in\n    some order, that the resulting string\
    \ will be good.\n    A string S is considered to be good if and only if all parentheses\
    \ in S\n    are balanced. For example: the string '(())()' is good, while the\
    \ string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good\
    \ string, and return 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpmtpaybu5.jl:1\nin expression starting at /tmp/tmpmtpaybu5.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    a = count(x\
    \ -> x == '(', lst[1])\n    b = count(x -> x == ')', lst[1])\n    c = count(x\
    \ -> x == '(', lst[2])\n    d = count(x -> x == ')', lst[2])\n    return \"Yes\"\
    \ * ((a >= d) & (c >= b)) * \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpgzdiga9y.jl:27\\n  Test threw\
    \ exception\\n  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\\n  MethodError:\
    \ no method matching *(::String, ::Bool)\\n  Closest candidates are:\\n    *(::Any,\
    \ ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\\\
    n    *(::Union{AbstractChar, AbstractString}, !Matched::Union{AbstractChar, AbstractString}...)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:260\\n    *(::Union{AbstractChar,\
    \ AbstractString}, !Matched::Missing) at /shared/centos7/julia/1.7.3/share/julia/base/missing.jl:183\\\
    n    ...\\n  Stacktrace:\\n   [1] *(::String, ::Bool, ::String)\\n     @ Base\
    \ ./operators.jl:655\\n   [2] match_parens(lst::Vector{String})\\n     @ Main\
    \ /tmp/tmpgzdiga9y.jl:20\\n   [3] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [4] macro expansion\\n     @ /tmp/tmpgzdiga9y.jl:27 [inlined]\\\
    n   [5] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [6] top-level scope\\n     @ /tmp/tmpgzdiga9y.jl:26\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    stack =\
    \ []\n    for str in lst\n        for ch in str\n            if ch == '('\n  \
    \              push!(stack, ch)\n            elseif ch == ')'\n              \
    \  if isempty(stack)\n                    return \"No\"\n                elseif\
    \ top(stack) == '('\n                    pop!(stack)\n                else\n \
    \                   return \"No\"\n                end\n            end\n    \
    \    end\n    end\n    if isempty(stack)\n        return \"Yes\"\n    else\n \
    \       return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjmmiewn6.jl:43\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: top not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpjmmiewn6.jl:24\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjmmiewn6.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjmmiewn6.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpjmmiewn6.jl:45\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: top not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpjmmiewn6.jl:24\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjmmiewn6.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjmmiewn6.jl:42\ntest set:\
    \ Test Failed at /tmp/tmpjmmiewn6.jl:46\n  Expression: candidate([\")())\", \"\
    (()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjmmiewn6.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjmmiewn6.jl:42\ntest set: Error\
    \ During Test at /tmp/tmpjmmiewn6.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n  UndefVarError: top not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpjmmiewn6.jl:24\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjmmiewn6.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    good_str\
    \ = lst[1]\n    for j = 2:length(lst)\n        good_str = join([good_str, lst[j]])\n\
    \    end\n    s = Stack{String}()\n    for i = 1:length(good_str)\n        if\
    \ good_str[i] == '('\n            push!(s, \"\")\n        elseif good_str[i] ==\
    \ ')'\n            if isempty(s)\n                return \"No\"\n            else\n\
    \                pop!(s)\n            end\n        end\n    end\n    if isempty(s)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp62e8s3lt.jl:43\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: Stack\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp62e8s3lt.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp62e8s3lt.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp62e8s3lt.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp62e8s3lt.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: Stack not defined\n  Stacktrace:\n\
    \   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp62e8s3lt.jl:20\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp62e8s3lt.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp62e8s3lt.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp62e8s3lt.jl:45\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: Stack not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp62e8s3lt.jl:20\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp62e8s3lt.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp62e8s3lt.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp62e8s3lt.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: Stack not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp62e8s3lt.jl:20\n\
    \   [2] macro"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp62e8s3lt.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    S1, S2 =\
    \ lst\n    good1 = isgood(S1)\n    good2 = isgood(S2)\n    if good1 && good2\n\
    \        return \"Yes\"\n    elseif good1 && !good2\n        return \"Yes\"\n\
    \    elseif !good1 && good2\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp7gwlpcr1.jl:34\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: isgood\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp7gwlpcr1.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7gwlpcr1.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7gwlpcr1.jl:33\ntest set:\
    \ Error During Test at /tmp/tmp7gwlpcr1.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: isgood not defined\n \
    \ Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp7gwlpcr1.jl:17\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7gwlpcr1.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7gwlpcr1.jl:33\ntest set:\
    \ Error During Test at /tmp/tmp7gwlpcr1.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: isgood not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp7gwlpcr1.jl:17\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7gwlpcr1.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7gwlpcr1.jl:33\ntest set:\
    \ Error During Test at /tmp/tmp7gwlpcr1.jl:37\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: isgood not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp7gwlpcr1.jl:17\n\
    \   [2] m"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7gwlpcr1.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    b1, b2 = count(x -> x == '(', s1), count(x -> x == '(', s2)\n    if\
    \ b1 - count(x -> x == ')', s1) == b2 - count(x -> x == ')', s2)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\n\"\"\"\n    This is\
    \ the same as match_parens function except that it is designed\n    to work on\
    \ console input.\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmpx8nifi_e.jl:24\nin expression starting at /tmp/tmpx8nifi_e.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    x = count(lst[1],\
    \ '(') - count(lst[1], ')')\n    y = count(lst[2], '(') - count(lst[2], ')')\n\
    \    x = x + y\n    if x % 2 == 0\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_n1mqta5.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmp_n1mqta5.jl:16\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp_n1mqta5.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp_n1mqta5.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp_n1mqta5.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_n1mqta5.jl:16\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp_n1mqta5.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp_n1mqta5.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp_n1mqta5.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_n1mqta5.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if length(lst[1])\
    \ == 0\n        return \"Yes\"\n    end\n    for i in 1:length(lst[1])\n     \
    \   if lst[1][i] == '('\n            for j in 1:length(lst[2])\n             \
    \   if lst[2][j] == ')'\n                    append!(lst[1], lst[2][j])\n    \
    \                deleteat!(lst[2], j)\n                    return match_parens(lst)\n\
    \                end\n            end\n        else\n            append!(lst[2],\
    \ lst[1][i])\n            deleteat!(lst[1], i)\n            return match_parens(lst)\n\
    \        end\n    end\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\n\
    candidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t\
    @test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"\
    ())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\
    \t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpgptc9zvp.jl:41\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: no method\
    \ matching append!(::String, ::Char)\n  Closest candidates are:\n    append!(!Matched::BitVector,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:782\n   \
    \ append!(!Matched::AbstractVector, ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1050\n\
    \    append!(!Matched::AbstractVector, ::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1053\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpgptc9zvp.jl:23\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgptc9zvp.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgptc9zvp.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpgptc9zvp.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: no method matching append!(::String,\
    \ ::Char)\n  Closest candidates are:\n    append!(!Matched::BitVector, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:782\n    append!(!Matched::AbstractVector,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1050\n    append!(!Matched::AbstractVector,\
    \ ::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1053\n  Stacktrace:\n\
    \   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpgptc9zvp.jl:29\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgptc9zvp.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgptc9zvp.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpgptc9zvp.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"])"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgptc9zvp.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    str1 = lst[1]\n\
    \    str2 = lst[2]\n    return match_parens_helper(str1, str2)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpay4fxr1a.jl:25\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: match_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpay4fxr1a.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpay4fxr1a.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpay4fxr1a.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpay4fxr1a.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: match_parens_helper not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpay4fxr1a.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpay4fxr1a.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpay4fxr1a.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpay4fxr1a.jl:27\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: match_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpay4fxr1a.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpay4fxr1a.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpay4fxr1a.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpay4fxr1a.jl:28\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: match_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpay4fxr1a.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    str1 = lst[1]\n\
    \    str2 = lst[2]\n    str = str1 * str2\n    open = 0\n    close = 0\n    for\
    \ x in str\n        if x == '('\n            open += 1\n        elseif x == ')'\n\
    \            close += 1\n        end\n        if close > open\n            return\
    \ \"No\"\n        end\n    end\n    if open == close\n        return \"Yes\"\n\
    \    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8t4eenvn.jl:45\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8t4eenvn.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8t4eenvn.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp8t4eenvn.jl:46\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8t4eenvn.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8t4eenvn.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp8t4eenvn.jl:53\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8t4eenvn.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8t4eenvn.jl:41\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8t4eenvn.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n   \n    open_par\
    \ = '('\n    close_par = ')'\n    parens = '('*lst[1]*')'*lst[2] \n    \n    #\
    \ Counter for open parentheses\n    open_counter = 0\n    # Counter for close\
    \ parentheses\n    close_counter = 0\n    \n    for i = 1:length(parens)\n   \
    \     if parens[i] == open_par\n            open_counter += 1\n        elseif\
    \ parens[i] == close_par\n            close_counter += 1\n        end\n      \
    \  \n        if close_counter > open_counter\n            return \"No\"\n    \
    \    end\n    end\n    \n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpidu3fefz.jl:48\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpidu3fefz.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpidu3fefz.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpidu3fefz.jl:49\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpidu3fefz.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpidu3fefz.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpidu3fefz.jl:52\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpidu3fefz.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpidu3fefz.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpidu3fefz.jl:53\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpidu3fefz.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpidu3fefz.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpidu3fefz.jl:56\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/ju"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpidu3fefz.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    parens1\
    \ = count(x -> x == '(', lst[1])\n    parens2 = count(x -> x == '(', lst[2])\n\
    \    if parens1 == parens2\n        return \"Yes\"\n    elseif parens1 > parens2\n\
    \        return \"Yes\" if sum(count(x -> x == ')', lst[1])) + sum(count(x ->\
    \ x == ')', lst[2])) == parens1 - parens2 else \"No\"\n    elseif parens1 < parens2\n\
    \        return \"Yes\" if sum(count(x -> x == ')', lst[1])) + sum(count(x ->\
    \ x == ')', lst[2])) == parens2 - parens1 else \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: unexpected \"if\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpgcs01xgb.jl:21\nin expression starting at /tmp/tmpgcs01xgb.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    parentheses\
    \ = lst[1] + lst[2]\n    str = \"\"\n    for p in parentheses\n        if p ==\
    \ '('\n            push!(str, p)\n        else\n            if length(str) > 0\n\
    \                pop!(str)\n            else\n                return \"No\"\n\
    \            end\n        end\n    end\n    return \"Yes\"\nend\nprintln(match_parens([\"\
    ()(\", \")\"]))\nprintln(match_parens([\")\", \")\"]))\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: MethodError: no method matching +(::String, ::String)\n\
    Closest candidates are:\n  +(::Any, ::Any, !Matched::Any, !Matched::Any...) at\
    \ /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\nStacktrace:\n\
    \ [1] match_parens(lst::Vector{String})\n   @ Main /tmp/tmp8zxbhft9.jl:16\n [2]\
    \ top-level scope\n   @ /tmp/tmp8zxbhft9.jl:31\nin expression starting at /tmp/tmp8zxbhft9.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Use a\
    \ stack to check if parentheses in each string are balanced\n    stck = Vector{Char}()\n\
    \    # Check parentheses in first string\n    for x in lst[1]\n        if x ==\
    \ '('\n            push!(stck, x)\n        else\n            if length(stck) ==\
    \ 0\n                return \"No\"\n            else\n                pop!(stck)\n\
    \            end\n        end\n    end\n    # Check parentheses in second string\n\
    \    for x in lst[2]\n        if x == '('\n            push!(stck, x)\n      \
    \  else\n            if length(stck) == 0\n                return \"No\"\n   \
    \         else\n                pop!(stck)\n            end\n        end\n   \
    \ end\n    # If stack is empty, then parentheses are balanced.\n    if length(stck)\
    \ == 0\n        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqfr7kovk.jl:57\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqfr7kovk.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqfr7kovk.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpqfr7kovk.jl:58\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqfr7kovk.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqfr7kovk.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpqfr7kovk.jl:65\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqfr7kovk.jl:65 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqfr7kovk.jl:53\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqfr7kovk.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    #\
    \ Check if the number of left and right parentheses are the same\n    if length(count_char(lst[1],\
    \ '(')) == length(count_char(lst[2], ')'))\n        \n        return \"Yes\"\n\
    \        \n    else\n        \n        return \"No\"\n        \n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp1uvw0fe4.jl:33\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: count_char\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp1uvw0fe4.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1uvw0fe4.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1uvw0fe4.jl:32\ntest set:\
    \ Error During Test at /tmp/tmp1uvw0fe4.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: count_char not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp1uvw0fe4.jl:18\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1uvw0fe4.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1uvw0fe4.jl:32\ntest set:\
    \ Error During Test at /tmp/tmp1uvw0fe4.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: count_char\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp1uvw0fe4.jl:18\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1uvw0fe4.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1uvw0fe4.jl:32\ntest set:\
    \ Error During Test at /tmp/tmp1uvw0fe4.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: count_char not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp1uvw0fe"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1uvw0fe4.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    for (i,v)\
    \ in enumerate(lst)\n        if count(v, '(') != count(v, ')')\n            return\
    \ \"No\"\n        end\n    end\n    return \"Yes\"\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpa64ny470.jl:28\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpa64ny470.jl:17\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpa64ny470.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpa64ny470.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpa64ny470.jl:29\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpa64ny470.jl:17\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpa64ny470.jl:29 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpa64ny470.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpa64ny470.jl:30\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa64ny470.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    brackets\
    \ = []\n    for s in lst\n        for c in s\n            if c == '('\n      \
    \          push!(brackets, '(')\n            else\n                if !isempty(brackets)\
    \ && brackets[end] == '('\n                    pop!(brackets)\n              \
    \  else\n                    return \"No\"\n                end\n            end\n\
    \        end\n    end\n    if isempty(brackets)\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpy2rlzl7a.jl:44\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy2rlzl7a.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy2rlzl7a.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpy2rlzl7a.jl:45\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy2rlzl7a.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy2rlzl7a.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpy2rlzl7a.jl:52\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy2rlzl7a.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy2rlzl7a.jl:40\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy2rlzl7a.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    @param lst Vector{String}\n    @return String\n    \"\"\"\n    s = join(lst,\
    \ \"\")\n    count = 0\n    for i in s\n        if i == '('\n            count\
    \ += 1\n        elseif i == ')'\n            count -= 1\n        end\n       \
    \ if count < 0\n            return \"No\"\n        end\n    end\n    if count\
    \ == 0\n        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3v8rvi79.jl:46\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3v8rvi79.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3v8rvi79.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp3v8rvi79.jl:47\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3v8rvi79.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3v8rvi79.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp3v8rvi79.jl:54\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3v8rvi79.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3v8rvi79.jl:42\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3v8rvi79.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if (lst[1]==\"\
    \") && (lst[2]==\"\")\n        return \"Yes\"\n    elseif (lst[1]==\"\") && (lst[2]!=\"\
    \")\n        return \"No\"\n    elseif (lst[1]!=\"\") && (lst[2]==\"\")\n    \
    \    return \"No\"\n    elseif lst[1][1]==\"(\"\n        if lst[2][1]==\")\"\n\
    \            return match_parens([lst[1][2:end], lst[2][2:end]])\n        else\n\
    \            return match_parens([lst[1][2:end], lst[2]])\n        end\n    else\n\
    \        return match_parens([lst[1], lst[2][2:end]])\n    end\nend\n\"\"\"\n\
    \    You are given a list of two strings, both strings consist of open\n    parentheses\
    \ '(' or close parentheses ')' only.\n    Your job is to check if it is possible\
    \ to concatenate the two strings in\n    some order, that the resulting string\
    \ will be good.\n    A string S is considered to be good if and only if all parentheses\
    \ in S\n    are balanced. For example: the string '(())()' is good, while the\
    \ string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good\
    \ string, and return 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmphukede7m.jl:32\nin expression starting at\
    \ /tmp/tmphukede7m.jl:32\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if length(lst[1])\
    \ == 0 || length(lst[2]) == 0\n        return \"Yes\"\n    end\n    lst = sort(lst,\
    \ rev=true)\n    for i in 1:2\n        if lst[i][1] == ')'\n            lst[i]\
    \ = \")(\" * lst[i]\n        end\n    end\n    return has_balanced_parens(lst[1]\
    \ * lst[2]) ? \"Yes\" : \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpus2wbdqe.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: has_balanced_parens\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpus2wbdqe.jl:25\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpus2wbdqe.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpus2wbdqe.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpus2wbdqe.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: has_balanced_parens not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpus2wbdqe.jl:25\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpus2wbdqe.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpus2wbdqe.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpus2wbdqe.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: has_balanced_parens\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpus2wbdqe.jl:25\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpus2wbdqe.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpus2wbdqe.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpus2wbdqe.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: has_balanced_parens\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpus2wbdqe.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"*** YOUR\
    \ CODE HERE ***\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpj3i_6z1i.jl:23\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"*** YOUR CODE HERE ***\" == \"Yes\"\
    \nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj3i_6z1i.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj3i_6z1i.jl:22\ntest set: Test\
    \ Failed at /tmp/tmpj3i_6z1i.jl:24\n  Expression: candidate([\")\", \")\"]) ==\
    \ \"No\"\n   Evaluated: \"*** YOUR CODE HERE ***\" == \"No\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj3i_6z1i.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj3i_6z1i.jl:22\ntest set: Test\
    \ Failed at /tmp/tmpj3i_6z1i.jl:25\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"*** YOUR CODE HERE ***\" == \"No\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj3i_6z1i.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj3i_6z1i.jl:22\ntest set: Test\
    \ Failed at /tmp/tmpj3i_6z1i.jl:26\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"*** YOUR CODE HERE ***\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj3i_6z1i.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj3i_6z1i.jl:22\ntest set: Test\
    \ Failed at /tmp/tmpj3i_6z1i.jl:27\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Eva"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 12 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj3i_6z1i.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    return \"\
    Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpubvji9u6.jl:24\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpubvji9u6.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpubvji9u6.jl:22\ntest set: Test\
    \ Failed at /tmp/tmpubvji9u6.jl:25\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpubvji9u6.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpubvji9u6.jl:22\ntest set: Test\
    \ Failed at /tmp/tmpubvji9u6.jl:28\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpubvji9u6.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpubvji9u6.jl:22\ntest set: Test\
    \ Failed at /tmp/tmpubvji9u6.jl:30\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpubvji9u6.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpubvji9u6.jl:22\ntest set: Test\
    \ Failed at /tmp/tmpubvji9u6.jl:31\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpubvji9u6.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    S1, S2 =\
    \ lst\n    A = 0\n    B = 0\n    for c in S1\n        if c == '('\n          \
    \  A += 1\n        else\n            A -= 1\n        end\n    end\n    for c in\
    \ S2\n        if c == '('\n            B += 1\n        else\n            B -=\
    \ 1\n        end\n    end\n    if A == B\n        return \"Yes\"\n    else\n \
    \       return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9yuwlbes.jl:44\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9yuwlbes.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9yuwlbes.jl:43\ntest set: Test\
    \ Failed at /tmp/tmp9yuwlbes.jl:45\n  Expression: candidate([\")\", \")\"]) ==\
    \ \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9yuwlbes.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9yuwlbes.jl:43\ntest set: Test\
    \ Failed at /tmp/tmp9yuwlbes.jl:47\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9yuwlbes.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9yuwlbes.jl:43\ntest set: Test\
    \ Failed at /tmp/tmp9yuwlbes.jl:48\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9yuwlbes.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9yuwlbes.jl:43\ntest set: Test\
    \ Failed at /tmp/tmp9yuwlbes.jl:50\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/juli"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9yuwlbes.jl:41\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    concat\
    \ = string(lst[1], lst[2])\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpztnytpg9.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpztnytpg9.jl:1\n\
    in expression starting at /tmp/tmpztnytpg9.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    if (sum(map(c -> c == '(' ? 1 : -1, s1)) + \n        sum(map(c\
    \ -> c == '(' ? -1 : 1, s2))) == 0\n        return \"Yes\"\n    else\n       \
    \ return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmplb923hnz.jl:29\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  ArgumentError: map(f,\
    \ s::AbstractString) requires f to return AbstractChar; try map(f, collect(s))\
    \ or a comprehension instead\n  Stacktrace:\n   [1] map(f::var\"#1#3\", s::String)\n\
    \     @ Base ./strings/basic.jl:611\n   [2] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmplb923hnz.jl:17\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmplb923hnz.jl:29 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmplb923hnz.jl:28\ntest set:\
    \ Error During Test at /tmp/tmplb923hnz.jl:30\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  ArgumentError: map(f, s::AbstractString)\
    \ requires f to return AbstractChar; try map(f, collect(s)) or a comprehension\
    \ instead\n  Stacktrace:\n   [1] map(f::var\"#1#3\", s::String)\n     @ Base ./strings/basic.jl:611\n\
    \   [2] match_parens(lst::Vector{String})\n     @ Main /tmp/tmplb923hnz.jl:17\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmplb923hnz.jl:30 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmplb923hnz.jl:28\ntest set:\
    \ Error During Test at /tmp/tmplb923hnz.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  ArgumentError: map(f, s::AbstractString)\
    \ requires f to return AbstractChar; try map(f, collect(s)) or a comprehension\
    \ instead\n  Stacktrace:\n   [1] map(f::var\"#1#3\", s::String)\n     @ Base ./strings/basic.jl:611\n\
    \   [2] match_parens(lst::Vector{String})\n     @ Main /tmp/tmplb923hnz.jl:17\n\
    \   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplb923hnz.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    @assert\
    \ iseven(length(lst))\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp5qc4gr8g.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp5qc4gr8g.jl:1\n\
    in expression starting at /tmp/tmp5qc4gr8g.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    #Concatenate\
    \ strings \n    s = string(lst[1], lst[2])\n    #If 0 is not in the list, the\
    \ number of open and closed parentheses are equal\n    if 0 in [s[i] == '(' ?\
    \ 1 : -1 for i in 1:length(s)]\n        return \"Yes\"\n    else \n        return\
    \ \"No\"\n    end\nend \nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsld6k1td.jl:30\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsld6k1td.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsld6k1td.jl:29\ntest set: Test\
    \ Failed at /tmp/tmpsld6k1td.jl:33\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsld6k1td.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsld6k1td.jl:29\ntest set: Test\
    \ Failed at /tmp/tmpsld6k1td.jl:34\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsld6k1td.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsld6k1td.jl:29\ntest set: Test\
    \ Failed at /tmp/tmpsld6k1td.jl:36\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsld6k1td.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsld6k1td.jl:29\ntest set: Test\
    \ Failed at /tmp/tmpsld6k1td.jl:40\n  Expression: candidate([\"(\", \")\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/jul"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsld6k1td.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if length(lst[1])\
    \ == 0 && length(lst[2]) == 0\n        return \"Yes\"\n    elseif length(lst[1])\
    \ == 0\n        if lst[2][1] == ')'\n            return \"No\"\n        else\n\
    \            return match_parens([lst[1], lst[2][2:end]])\n        end\n    elseif\
    \ length(lst[2]) == 0\n        if lst[1][end] == '('\n            return \"No\"\
    \n        else\n            return match_parens([lst[1][1:end-1], lst[2]])\n \
    \       end\n    else\n        if lst[1][end] == '(' && lst[2][1] == ')'\n   \
    \         return match_parens([lst[1][1:end-1], lst[2][2:end]])\n        elseif\
    \ lst[1][end] == '('\n            return match_parens([lst[1][1:end-1], lst[2]])\n\
    \        elseif lst[2][1] == ')'\n            return match_parens([lst[1], lst[2][2:end]])\n\
    \        else\n            return \"No\"\n        end\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp54tndpm2.jl:47\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp54tndpm2.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp54tndpm2.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp54tndpm2.jl:48\n  Expression: candidate([\")\", \")\"]) ==\
    \ \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp54tndpm2.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp54tndpm2.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp54tndpm2.jl:50\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp54tndpm2.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp54tndpm2.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp54tndpm2.jl:51\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp54tndpm2.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp54tndpm2.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp54tndpm2.jl:53\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/juli"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp54tndpm2.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = '('\n    close_parens = ')'\n    is_good = 'Yes'\n    good_str = \"\"\n  \
    \  for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if (lst[i][j]\
    \ == open_parens)\n                push!(good_str, lst[i][j])\n            elseif\
    \ (lst[i][j] == close_parens)\n                if (length(good_str) == 0)\n  \
    \                  is_good = 'No'\n                    break\n               \
    \ else\n                    pop!(good_str)\n                end\n            end\n\
    \        end\n    end\n    if (length(good_str) != 0)\n        is_good = 'No'\n\
    \    end\n    return is_good\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpa5ut0k0x.jl:18\nin expression\
    \ starting at /tmp/tmpa5ut0k0x.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # create\
    \ a counter that keeps track of open and close parentheses\n    open = 0\n   \
    \ for ch in lst[1]\n        if ch == '('\n            open += 1\n        elseif\
    \ ch == ')'\n            open -= 1\n        end\n    end\n    close = 0\n    for\
    \ ch in lst[2]\n        if ch == '('\n            close += 1\n        elseif ch\
    \ == ')'\n            close -= 1\n        end\n    end\n    # if there are any\
    \ open/close parenthesis remaining and both strings\n    # have the same number\
    \ of parentheses, 'Yes' is returned, else 'No'\n    if open == 0 && close == 0\
    \ && length(lst[1]) == length(lst[2])\n        return \"Yes\"\n    else\n    \
    \    return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnln4dni6.jl:46\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnln4dni6.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnln4dni6.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpnln4dni6.jl:49\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnln4dni6.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnln4dni6.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpnln4dni6.jl:50\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnln4dni6.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnln4dni6.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpnln4dni6.jl:52\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnln4dni6.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnln4dni6.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpnln4dni6.jl:55\n  Expression: candidate([\")(\", \")(\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/ju"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnln4dni6.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    string1\
    \ = lst[1]\n    string2 = lst[2]\n    if length(string1) % 2 != 0 || length(string2)\
    \ % 2 != 0\n        return \"No\"\n    end\n    if string1[1] == \")\" || string2[1]\
    \ == \")\"\n        return \"No\"\n    end\n    counter = 0\n    for ch in string1\n\
    \        if ch == \"(\"\n            counter += 1\n        else\n            counter\
    \ -= 1\n        end\n        if counter < 0\n            return \"No\"\n     \
    \   end\n    end\n    if counter == 0\n        return \"Yes\"\n    end\n    counter\
    \ = 0\n    for ch in string2\n        if ch == \"(\"\n            counter += 1\n\
    \        else\n            counter -= 1\n        end\n        if counter < 0\n\
    \            return \"No\"\n        end\n    end\n    if counter == 0\n      \
    \  return \"Yes\"\n    end\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4slpgua8.jl:59\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4slpgua8.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4slpgua8.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp4slpgua8.jl:62\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4slpgua8.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4slpgua8.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp4slpgua8.jl:63\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4slpgua8.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4slpgua8.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp4slpgua8.jl:65\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4slpgua8.jl:65 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4slpgua8.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp4slpgua8.jl:69\n  Expression: candidate([\"(\", \")\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/jul"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4slpgua8.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s = lst[1]\n\
    \    t = lst[2]\n    sct = 0\n    tct = 0\n    for ss in s\n        if ss == '('\n\
    \            sct += 1\n        else\n            sct -= 1\n        end\n    end\n\
    \    for tt in t\n        if tt == '('\n            tct += 1\n        else\n \
    \           tct -= 1\n        end\n    end\n    if sct == 0 && tct == 0\n    \
    \    return \"Yes\"\n    elseif (sct == 1 && tct == -1) || (sct == -1 && tct ==\
    \ 1)\n        return \"Yes\"\n    elseif sct == 0 && tct == -2\n        return\
    \ \"Yes\"\n    elseif sct == 0 && tct == 2\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgmwmqx59.jl:54\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgmwmqx59.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgmwmqx59.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpgmwmqx59.jl:55\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgmwmqx59.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgmwmqx59.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpgmwmqx59.jl:57\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgmwmqx59.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgmwmqx59.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpgmwmqx59.jl:59\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgmwmqx59.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgmwmqx59.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpgmwmqx59.jl:60\n  Expression: candidate([\")(\", \")(\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgmwmqx59.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    len1 = length(lst[1])\n\
    \    len2 = length(lst[2])\n    if len1 == 0 && len2 == 0\n        return \"Yes\"\
    \n    end\n    count = 0\n    for i in 1:len1\n        if lst[1][i] == '('\n \
    \           count += 1\n        else\n            count -= 1\n        end\n  \
    \      if count < 0\n            return \"No\"\n        end\n    end\n    count1\
    \ = 0\n    for i in 1:len2\n        if lst[2][i] == '('\n            count1 +=\
    \ 1\n        else\n            count1 -= 1\n        end\n        if count1 < 0\n\
    \            return \"No\"\n        end\n    end\n    if count == count1\n   \
    \     return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcmw24i8w.jl:54\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcmw24i8w.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcmw24i8w.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpcmw24i8w.jl:57\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcmw24i8w.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcmw24i8w.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpcmw24i8w.jl:58\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcmw24i8w.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcmw24i8w.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpcmw24i8w.jl:60\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcmw24i8w.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcmw24i8w.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpcmw24i8w.jl:64\n  Expression: candidate([\"(\", \")\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/jul"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcmw24i8w.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Your code\
    \ here\nend\n```\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid \"`\" syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpvqk0h6t0.jl:18\nin expression starting at\
    \ /tmp/tmpvqk0h6t0.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # change\
    \ the strings to vectors of characters to manipulate\n    a = collect(lst[1])\n\
    \    b = collect(lst[2])\n    # if the first string is already good, just check\
    \ if the second one can\n    # be made good by adding the new characters\n   \
    \ if is_balanced(a) && is_balanced(b)\n        return \"Yes\"\n    elseif is_balanced(a)\
    \ && !is_balanced(b)\n        stack = [b[1]]\n        for char in b[2:end]\n \
    \           if char == \")\"\n                pop!(stack)\n            else\n\
    \                push!(stack, char)\n            end\n        end\n        if\
    \ length(stack) > 0\n            return \"No\"\n        else\n            return\
    \ \"Yes\"\n        end\n    elseif !is_balanced(a) && is_balanced(b)\n       \
    \ # same reasoning as the other case\n        stack = [a[1]]\n        for char\
    \ in a[2:end]\n            if char == \")\"\n                pop!(stack)\n   \
    \         else\n                push!(stack, char)\n            end\n        end\n\
    \        if length(stack) > 0\n            return \"No\"\n        else\n     \
    \       return \"Yes\"\n        end\n    elseif !is_balanced(a) && !is_balanced(b)\n\
    \        stack = [a[1]]\n        for char in a[2:end]\n            if char ==\
    \ \")\"\n                pop!(stack)\n            else\n                push!(stack,\
    \ char)\n            end\n        end\n        # now the first string is balanced\n\
    \        # we need to check if the second string can be balanced with the\n  \
    \      # rest of the stack from the first string\n        for char in b\n    \
    \        if char == \")\"\n                pop!(stack)\n            else\n   \
    \             push!(stack, char)\n            end\n        end\n        if length(stack)\
    \ > 0\n            return \"No\"\n        else\n            return \"Yes\"\n \
    \       end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpq6p6pzmm.jl:83\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_balanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpq6p6pzmm.jl:21\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq6p6pzmm.jl:83 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq6p6pzmm.jl:82\ntest set:\
    \ Error During Test at /tmp/tmpq6p6pzmm.jl:84\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_balanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpq6p6pzmm.jl:21\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq6p6pzmm.jl:84 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq6p6pzmm.jl:82\ntest set:\
    \ Error During Test at /tmp/tmpq6p6pzmm.jl:85\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_balanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpq6p6pzmm.jl:21\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq6p6pzmm.jl:85 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq6p6pzmm.jl:82\ntest set:\
    \ Error During Test at /tmp/tmpq6p6pzmm.jl:86\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_balanced not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpq6p"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq6p6pzmm.jl:80\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    Input:\n    lst: A list of two strings, both strings consist of open parentheses\
    \ '('\n    or close parentheses ')' only.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd6m_33pt.jl:1\nin expression starting at /tmp/tmpd6m_33pt.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    Returns 'Yes' if there's a way to concatenate string s1 and s2 such that\n\
    \    the resulting string is good, otherwise 'No'.\n    \"\"\"\n    s1, s2 = lst\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpeix011uv.jl:15\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpeix011uv.jl:1\n\
    in expression starting at /tmp/tmpeix011uv.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    a = lst[1]\n\
    \    b = lst[2]\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_6igwzp9.jl:25\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_6igwzp9.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_6igwzp9.jl:24\ntest set: Test\
    \ Failed at /tmp/tmp_6igwzp9.jl:28\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_6igwzp9.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_6igwzp9.jl:24\ntest set: Test\
    \ Failed at /tmp/tmp_6igwzp9.jl:29\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_6igwzp9.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_6igwzp9.jl:24\ntest set: Test\
    \ Failed at /tmp/tmp_6igwzp9.jl:31\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_6igwzp9.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_6igwzp9.jl:24\ntest set: Test\
    \ Failed at /tmp/tmp_6igwzp9.jl:35\n  Expression: candidate([\"(\", \")\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/jul"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_6igwzp9.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \n    #\
    \ Get the first string\n    one = lst[1]\n    \n    # Get the second string\n\
    \    two = lst[2]\n    \n    # Define the variable that will be changed to true\n\
    \    # if the strings are 'good'\n    good = false\n    \n    # Call the function\
    \ that\n    # checks if there are balanced parantheses\n    if check_parens(one\
    \ * two)\n        good = true\n    end\n    \n    # Check if there is a solution\n\
    \    if good\n        \"Yes\"\n    else\n        \"No\"\n    end\n    \nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpgudbexsl.jl:46\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: check_parens\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpgudbexsl.jl:29\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgudbexsl.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgudbexsl.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpgudbexsl.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: check_parens not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpgudbexsl.jl:29\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgudbexsl.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgudbexsl.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpgudbexsl.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: check_parens\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpgudbexsl.jl:29\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgudbexsl.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgudbexsl.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpgudbexsl.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: check_parens\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tm"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgudbexsl.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    for i =\
    \ 1:length(lst[1])\n        if lst[1][i] == '(' && lst[2][i] == ')'\n        \
    \    return \"Yes\"\n        elseif lst[1][i] == ')' && lst[2][i] == '('\n   \
    \         return \"Yes\"\n        elseif lst[1][i] == ')' && lst[2][i] == ')'\n\
    \            return \"No\"\n        elseif lst[1][i] == '(' && lst[2][i] == '('\n\
    \            return \"No\"\n        end\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvdi_0f4x.jl:37\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvdi_0f4x.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvdi_0f4x.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpvdi_0f4x.jl:39\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvdi_0f4x.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvdi_0f4x.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpvdi_0f4x.jl:41\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvdi_0f4x.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvdi_0f4x.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvdi_0f4x.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"Check\
    \ if parens can be concatenated to form a balanced parenthesis\n    string.\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpwu7yeq1j.jl:1\nin expression starting at /tmp/tmpwu7yeq1j.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    mylst =\
    \ lst[1] * lst[2]\n    while length(findin(mylst, \")\")) != 0\n        idx =\
    \ findnext(mylst, \")\")\n        if length(findin(mylst[1:idx-1], \"(\")) ==\
    \ 0\n            return \"No\"\n        end\n        mylst = mylst[1:findnext(mylst[1:idx-1],\
    \ \"(\")-1] * mylst[idx+1:end]\n    end\n    return \"Yes\"\nend\n\"\"\"\n   \
    \ You are given a list of two strings, both strings consist of open\n    parentheses\
    \ '(' or close parentheses ')' only.\n    Your job is to check if it is possible\
    \ to concatenate the two strings in\n    some order, that the resulting string\
    \ will be good.\n    A string S is considered to be good if and only if all parentheses\
    \ in S\n    are balanced. For example: the string '(())()' is good, while the\
    \ string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good\
    \ string, and return 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpx1uj9u10.jl:26\nin expression starting at\
    \ /tmp/tmpx1uj9u10.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    input1 =\
    \ lst[1]\n    input2 = lst[2]\n    # your code here\n    input1 = collect(input1)\n\
    \    input2 = collect(input2)\n    if length(input1) > length(input2)\n      \
    \  smaller_input = input2\n        bigger_input = input1\n    else\n        smaller_input\
    \ = input1\n        bigger_input = input2\n    end\n    result = []\n    counter\
    \ = 0\n    for i in bigger_input\n        if i == '('\n            push!(result,\
    \ i)\n            counter += 1\n        else\n            if counter != 0\n  \
    \              pop!(result)\n                counter -= 1\n            else\n\
    \                push!(result, i)\n            end\n        end\n    end\n   \
    \ for i in smaller_input\n        if i == '('\n            push!(result, i)\n\
    \            counter += 1\n        else\n            if counter != 0\n       \
    \         pop!(result)\n                counter -= 1\n            else\n     \
    \           push!(result, i)\n            end\n        end\n    end\n    if isempty(result)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppsisvgz8.jl:73\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppsisvgz8.jl:73 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppsisvgz8.jl:66\ntest set: Test\
    \ Failed at /tmp/tmppsisvgz8.jl:77\n  Expression: candidate([\"(\", \")\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppsisvgz8.jl:77 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppsisvgz8.jl:66\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   10     2     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 10 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppsisvgz8.jl:64\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if first(lst)\
    \ == ')' || last(lst) == '('\n        return \"No\"\n    end\n    op = count(x\
    \ -> x == '(', first(lst))\n    cp = count(x -> x == ')', last(lst))\n    if op\
    \ == cp\n        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwb11ki61.jl:32\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwb11ki61.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwb11ki61.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpwb11ki61.jl:34\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwb11ki61.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwb11ki61.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpwb11ki61.jl:35\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwb11ki61.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwb11ki61.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpwb11ki61.jl:36\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwb11ki61.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwb11ki61.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpwb11ki61.jl:38\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/c"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwb11ki61.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    lst1 = lst[1]\n\
    \    lst2 = lst[2]\n    if length(lst1) < length(lst2)\n        if checkbalance(lst1)\n\
    \            match_parens(append!(lst1, lst2[1]))\n        else\n            return\
    \ \"No\"\n        end\n    elseif length(lst1) > length(lst2)\n        if checkbalance(lst2)\n\
    \            match_parens(append!(lst2, lst1[1]))\n        else\n            return\
    \ \"No\"\n        end\n    else\n        if checkbalance(lst1)\n            return\
    \ \"Yes\"\n        else\n            return \"No\"\n        end\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpa6rzmko5.jl:43\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: checkbalance\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpa6rzmko5.jl:25\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpa6rzmko5.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpa6rzmko5.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpa6rzmko5.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: checkbalance not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpa6rzmko5.jl:31\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpa6rzmko5.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpa6rzmko5.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpa6rzmko5.jl:45\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: checkbalance\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpa6rzmko5.jl:25\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpa6rzmko5.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpa6rzmko5.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpa6rzmko5.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: checkbalance\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tm"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa6rzmko5.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    str1 = lst[1]\n\
    \    str2 = lst[2]\n    open_parens = '('\n    closed_parens = ')'\n    if starts_with(str1,\
    \ open_parens)\n        if !starts_with(str2, open_parens)\n            if ends_with(str2,\
    \ closed_parens)\n                return \"Yes\"\n            else\n         \
    \       return \"No\"\n            end\n        else\n            return \"No\"\
    \n        end\n    else\n        if starts_with(str2, open_parens)\n         \
    \   if ends_with(str1, closed_parens)\n                return \"Yes\"\n      \
    \      else\n                return \"No\"\n            end\n        else\n  \
    \          return \"No\"\n        end\n    end\nend\nmatch_parens(['()(', ')'])\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmpvbtr8dli.jl:42\nin expression\
    \ starting at /tmp/tmpvbtr8dli.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    parens1\
    \ = lst[1]\n    parens2 = lst[2]\n    count1 = 0\n    count2 = 0\n    for p in\
    \ parens1\n        if p == '('\n            count1 += 1\n        else\n      \
    \      count1 -= 1\n        end\n    end\n    for p in parens2\n        if p ==\
    \ '('\n            count2 += 1\n        else\n            count2 -= 1\n      \
    \  end\n    end\n    if count1 + count2 == 0\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmw2vz8nt.jl:54\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmw2vz8nt.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmw2vz8nt.jl:44\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmw2vz8nt.jl:42\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens,\
    \ close_parens = lst\n    if isempty(open_parens) && isempty(close_parens)\n \
    \       return \"Yes\"\n    end\n    if isempty(open_parens) && !isempty(close_parens)\n\
    \        return \"No\"\n    end\n    if length(open_parens) == 1 && length(close_parens)\
    \ == 1\n        return \"Yes\"\n    end\n    if open_parens[1] == '(' && close_parens[1]\
    \ == ')'\n        return match_parens([open_parens[2:end], close_parens[2:end]])\n\
    \    end\n    if open_parens[1] == '(' && close_parens[1] != ')'\n        return\
    \ match_parens([open_parens[2:end], close_parens])\n    end\n    if open_parens[1]\
    \ != '(' && close_parens[1] == ')'\n        return match_parens([open_parens,\
    \ close_parens[2:end]])\n    end\n    return \"No\"\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpqcy4ujmj.jl:42\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  BoundsError: attempt\
    \ to access empty String at index [1]\n  Stacktrace:\n   [1] checkbounds\n   \
    \  @ ./strings/basic.jl:216 [inlined]\n   [2] codeunit\n     @ ./strings/string.jl:102\
    \ [inlined]\n   [3] getindex\n     @ ./strings/string.jl:223 [inlined]\n   [4]\
    \ match_parens(lst::Vector{String})\n     @ Main /tmp/tmpqcy4ujmj.jl:32\n   [5]\
    \ match_parens(lst::Vector{String})\n     @ Main /tmp/tmpqcy4ujmj.jl:27\n   [6]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpqcy4ujmj.jl:42 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpqcy4ujmj.jl:41\ntest set:\
    \ Test Failed at /tmp/tmpqcy4ujmj.jl:43\n  Expression: candidate([\")\", \")\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqcy4ujmj.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqcy4ujmj.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpqcy4ujmj.jl:45\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqcy4ujmj.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqcy4ujmj.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpqcy4ujmj.jl:46\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n ["
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 4 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqcy4ujmj.jl:39\n"
  exit_code: 1
  status: SyntaxError
