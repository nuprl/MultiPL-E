name: HumanEval_145_order_by_points
language: jl
prompt: "\"\"\"\n    Write a function which sorts the given list of integers\n   \
  \ in ascending order according to the sum of their digits.\n    Note: if there are\
  \ several items with similar sum of their digits,\n    order them based on their\
  \ index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1,\
  \ -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\
  \"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
  \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463,\
  \ 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423,\
  \ 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
  \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) ==\
  \ [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8,\
  \ 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6,\
  \ 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
completions: ["    return nums[sortperm(map(x -> sum(digits(x)), nums))]\nend", " \
    \   # Input: Vector of integers\n    # Output: Vector of integers ordered by the\
    \ sum of the digits (lowest to highest)\n    # Example: order_by_points([1, 11,\
    \ -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    out = copy(nums)\n    inds = 1:length(nums)\n\
    \    tmp = sortperm(digit_sum.(nums))\n    return out[tmp]\nend", "    order_by_points(nums,\
    \ n -> sum(digits(n)))\nend", "    merge_sort!(nums, 1, length(nums))\n    return\
    \ nums\nend", "    sort(nums, by=x->(tuple(sum(digits(x)), i) for i=1:length(nums)))\n\
    end", "    if length(nums) == 0\n        return []\n    end\n    x = []\n    for\
    \ i = 1:length(nums)\n        push!(x, sum(digits(nums[i])))\n    end\n    sortperm(x,\
    \ rev=true)\nend", "    # get the sorted vector of abs(x)\n    lens = [sum_of_digits(abs(x))\
    \ for x in nums]\n    # get the indices of the sorted vector\n    ind = sortperm(lens)\n\
    \    # return the original vector, sorted by the indices\n    return nums[ind]\n\
    end", "    if nums == []\n        return []\n    end\n    ind = collect(1:length(nums))\n\
    \    j = 0\n    for i in ind\n        j = j + nums[i]\n    end\n    ind2 = collect(1:length(nums))\n\
    \    for i in ind\n        if nums[i] > 0\n            ind2[i] = sum(digits(nums[i]))\n\
    \        elseif nums[i] < 0\n            ind2[i] = -sum(digits(nums[i]))\n   \
    \     else\n            ind2[i] = 0\n        end\n    end\n    ind3 = sortperm(ind2)\n\
    \    nums_sorted = Vector{Int64}(length(nums))\n    for i in ind\n        nums_sorted[i]\
    \ = nums[ind3[i]]\n    end\n    return nums_sorted\nend", "    \"\"\"\n    Returns\
    \ a sorted list of integers in ascending order according to \n    the sum of their\
    \ digits.\n    \"\"\"\n    # Create a dictionary of every entry in nums, with\
    \ the sum of its digits as the key\n    sums = Dict{Int64, Int64}()\n    for i\
    \ in nums\n        sums[sum(digits(i))] = i\n    end\n    \n    # Sort the keys\
    \ and return the corresponding values\n    return [sums[key] for key in sort(collect(keys(sums)))]\n\
    end", "    # vector of sum of digits in every integer\n    digits_sum = Int64[]\n\
    \    # vector of indices corresponding to integers in nums\n    indices = Int64[]\n\
    \    # filling the vectors with indices and corresponding digits_sum\n    for\
    \ (index, num) in enumerate(nums)\n        # append sum of the digits to digits_sum\
    \ vector\n        push!(digits_sum, sum(digits(num)))\n        # append the index\
    \ of the number to indices vector\n        push!(indices, index)\n    end\n  \
    \  # sort the indices from lowest to highest values in digits_sum\n    sorted_indices\
    \ = sortperm(digits_sum)\n    # return a new vector of sorted numbers in nums\
    \ by sorted_indices\n    sorted_nums = [nums[i] for i in sorted_indices]\n   \
    \ return sorted_nums\nend", "    \n    sumlist = []\n    for i in nums\n     \
    \   sumlist = [sumlist; i => sum(digits(i))]\n    end\n    sortedlist = sort(sumlist,\
    \ by = x -> x[2])\n    indexlist = map(x -> (x[1]), sortedlist)\n    return indexlist\n\
    end", "    # Your code goes here\nend", "    \n    temp = zeros(length(nums))\n\
    \    for i = 1:length(nums)\n        temp[i] = sum(digits(nums[i]))\n    end\n\
    \    sortperm(temp, rev=true)\nend", "    nums, sort(nums, by=x->sum(digits(x)))\n\
    end", "    len_nums = length(nums)\n    if len_nums < 2\n        return nums\n\
    \    end\n    # \u5B9A\u4E49\u4E00\u4E2A\u6570\u7EC4\u8BB0\u5F55\u5404\u5143\u7D20\
    \u7684\u548C\n    sum_num = zeros(len_nums)\n    for i in 1:len_nums\n       \
    \ # \u8BA1\u7B97\u5404\u5143\u7D20\u7684\u548C\n        sum_num[i] = sum_num_digit(nums[i])\n\
    \    end\n    # \u5BF9\u548C\u8FDB\u884C\u6392\u5E8F\uFF0C\u5E76\u4FDD\u7559\u4E0B\
    \u6807\n    index = sortperm(sum_num)\n    # \u5BF9\u6570\u7EC4\u5143\u7D20\u8FDB\
    \u884C\u6392\u5E8F\n    nums = nums[index]\n    return nums\nend", "    sorted\
    \ = sort(nums, \n                  by = x -> sum(digits(x))\n                \
    \  )\n    return sorted\nend", "    n = length(nums)\n    if n == 0\n        return\
    \ []\n    end\n    res = zeros(Int64, n)\n    pos = zeros(Int64, n)\n    digits\
    \ = zeros(Int64, n)\n    for i = 1:n\n        pos[i] = i\n        if nums[i] ==\
    \ 0\n            digits[i] = 0\n        else\n            digits[i] = abs(nums[i])\n\
    \        end\n    end\n    s = length(digits)\n    for i = 1:s\n        for j\
    \ = 1:s-i\n            if digits[j] == digits[j+1]\n                continue\n\
    \            end\n            if digits[j]>digits[j+1]\n                digits[j],\
    \ digits[j+1] = digits[j+1], digits[j]\n                pos[j], pos[j+1] = pos[j+1],\
    \ pos[j]\n            end\n        end\n    end\n    for i = 1:n\n        res[i]\
    \ = nums[pos[i]]\n    end\n    return res\nend", "    sums = map(x -> sum(digits(x)),\
    \ nums)\n    return sortperm(sums, by=nums)\nend", "    sums = [sum(digits(num))\
    \ for num in nums]\n    idx = sortperm(sums)\n    return nums[idx]\nend", "  \
    \  nums_sort = sort(collect(1:length(nums)), by = (i->sum(digits(nums[i]))))\n\
    \    return [nums[i] for i in nums_sort]\nend", "    return sortperm(sum.(digits.(nums)))\n\
    end", "    dic = Dict()\n    for num in nums\n        n = sum(abs.(digits(num)))\n\
    \        if !haskey(dic, n)\n            dic[n] = Vector()\n        end\n    \
    \    push!(dic[n], num)\n    end\n    res = Vector()\n    for key in sort(collect(keys(dic)))\n\
    \        push!(res, dic[key])\n    end\n    return res\nend", "    sum_digits(n)\
    \ = sum(map(x -> parse(Int64, x), split(string(n), \"\")))\n    if length(nums)\
    \ == 0 return nums end\n    key_value_pairs = Dict()\n    for n in nums\n    \
    \    key_value_pairs[n] = sum_digits(n)\n    end\n    @assert key_value_pairs[1]\
    \ == 2\n    sorted_keys = sort(collect(keys(key_value_pairs)), by = key -> key_value_pairs[key])\n\
    \    @assert sorted_keys[1] == -1\n    return sorted_keys\nend", "    points =\
    \ map(x -> sum(digits(x)), nums)\n    return[nums[i] for i in sortperm(points)]\n\
    end", "    return sortperm(abs.(nums))\nend", "    return sort(nums, by = x ->\
    \ sum(digits(x)))\nend", "    if isempty(nums)\n        return []\n    end\n \
    \   sums = [sum(digits(x)) for x in nums]\n    idx = sortperm(sums)\n    return\
    \ nums[idx]\nend", "    # TODO: Implement me!\n    # hint: you may use sort, by_sum,\
    \ sum, count and collect functions\nend", "    nums_plus_sum_of_digits = map(x\
    \ -> (x, sum(digits(x))), nums)\n    nums_plus_sum_of_digits = sort(nums_plus_sum_of_digits,\
    \ by = x -> x[2])\n    map(x -> x[1], nums_plus_sum_of_digits)\nend", "    if\
    \ isempty(nums)\n        return []\n    end\n    if length(nums) == 1\n      \
    \  return nums\n    end\n    sort(collect(zip(nums, sum_digits.(nums))), by=x->(x[2],\
    \ x[1]))[:,1]\nend\n@testset \"Testing order_by_points\" begin\n    @test order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    @test order_by_points([]) ==\
    \ []\nend", "    # your code goes here\nend", "    return sort(nums, lt = (n1,\
    \ n2) -> sum(digits(n1)) < sum(digits(n2)))\nend", "    if length(nums) == 0\n\
    \        return nums\n    end\n    orders = [sum(digits(num)) for num in nums]\n\
    \    sort_by_order!(nums, orders)\n    return nums\nend", "    sort(nums, by=x->sum(digits(x)))\n\
    end", "    if length(nums) == 0\n        return []\n    end\n    # sort by sum\
    \ of digit, if the sum is the same, then sort by the original order\n    return\
    \ sort!(nums, (x, y) -> ((x - y) % 10 + 10 * ((x - y) % 100 - (x - y) % 10) +\
    \ 100 * ((x - y) % 1000 - (x - y) % 100)) < 0)\nend\n \norder_by_points([1, 11,\
    \ -1, -11, -12]) == [-1, -11, 1, -12, 11]\norder_by_points([]) == []", "    pairs\
    \ = zip(nums, sum.(digit_sum, nums))\n    sort(pairs, by = x -> (x[2], x[1]))[:,1]\n\
    end\n# There is also a function `order` in Julia.", "    if nums == [] \n    \
    \    return []\n    end\n    return sort(nums, by = x -> sum(digits(x)))\nend",
  "    sums = [sum(digits(x)) for x in nums]\n    sort(nums, by=s -> sum(digits(s)))\n\
    end", "    return sort(nums, by=x->(sum(digits(x)), findall(nums .== x)[1]))\n\
    end", "    indices = sortperm(sum(digits.(nums)) .* 10 .+ collect(1:length(nums)))\n\
    \    return nums[indices]\nend", "    points = [sum(int(i) for i in digits(abs(num)))\
    \ for num in nums]\n    return [nums[i] for i in sortperm(points)]\nend", "  \
    \  n = length(nums)\n    points = [sum(digits(nums[i])) for i in 1:n]\n    nums_copy\
    \ = deepcopy(nums)\n    for i in 1:n\n        idx = argmin(points)\n        nums[i]\
    \ = nums_copy[idx]\n        points[idx] = Inf\n    end\n    return nums\nend\n\
    \    ", "    # TODO: implement!\nend", "    num_sum = [sum(digits(x)) for x in\
    \ nums]\n    sort!(zip(num_sum, nums))\n    return [x[2] for x in sort(zip(num_sum,\
    \ nums))]\nend", "    nums_w_sum = [(i, sum(digits(i))) for i in nums]\n    sorted_nums\
    \ = sort(nums_w_sum, by=x->x[2])\n    return [num[1] for num in sorted_nums]\n\
    end\nprintln(order_by_points([1, 11, -1, -11, -12]))", "    nums = sort([(sum(digits(n)),\
    \ n) for n in nums])\n    return [v[2] for v in nums]\nend", "    res = []\n \
    \   for i in 1:length(nums)\n        sum = 0\n        for j in nums[i] \n    \
    \        sum += j\n        end\n        push!(res, [nums[i], sum])\n    end\n\
    \    return sort!(res, by = x -> x[2])\nend", "    nums_as_string = map(num ->\
    \ string(num), nums)\n    nums_as_string_int = map(num -> parse(Int64, num), nums_as_string)\n\
    \    nums_as_string_vec = map(num -> vec(string(num)), nums_as_string_int)\n \
    \   sum_of_nums = map(num -> sum(num), nums_as_string_vec)\n    sum_of_nums_with_index\
    \ = enumerate(sum_of_nums)\n    sorted_by_sum = sort(sum_of_nums_with_index, by\
    \ = x -> x[2])\n    sorted_nums = map(x -> x[1], sorted_by_sum)\n    return nums[sorted_nums]\n\
    end", "    @assert !isempty(nums) \"Cannot order an empty vector.\"\n    sums\
    \ = [sum(collect(digits(x))) for x in nums]\n    return sortperm(sums, by=nums)\n\
    end", "    return sort(1:length(nums), by=digitsum)\nend", "    return sort!(copy(nums),\
    \ by = x -> (x,x), rev = true)[end:-1:1]\nend", "    sorted_nums = []\n    for\
    \ (i, num) in enumerate(nums)\n        sorted_nums = push!(sorted_nums, (sum(div.(num,\
    \ 10)), i, num))\n    end\n    sorted_nums = sort(sorted_nums, by = x -> x[1:2])\n\
    \    nums = map(x -> x[3], sorted_nums)\n    return nums\nend", "    if length(nums)\
    \ == 0\n        return []\n    end\n    sort!(nums, by = sum(digits(abs(nums))))\n\
    \    return nums\nend", "    digits_list = map(x -> sum(digits(x)), nums)\n  \
    \  sortperm(digits_list)\nend", "    if nums == []\n        return []\n    end\n\
    \    sums = []\n    for num in nums\n        sum = 0\n        for digit in digits(num)\n\
    \            sum += digit\n        end\n        push!(sums, sum)\n    end\n  \
    \  sorted = sortperm(sums)\n    nums[sorted]\nend", "    idx = sortperm(sum.(nums)\
    \ .* length(nums) .+ collect(1:length(nums)))\n    nums[idx]\nend\n    \n    \n\
    println(order_by_points([1, 11, -1, -11, -12]))\nprintln(order_by_points([]))",
  "    if nums == []\n        return []\n    end\n    if length(nums) == 1\n     \
    \   return nums\n    end\n    sums = []\n    for num in nums\n        sums = append!(sums,\
    \ sum(digits(num)))\n    end\n    nums = nums[sortperm(sums)]\n    return nums\n\
    end", "    return sortperm(sum.(split.(string.(nums), \"\")))\nend", "    v =\
    \ sortperm(sum(digits.(nums)), sortalg=InsertionSort)\n    return (nums[v])\n\
    end", "    \n    sum_digits(x) = sum(digits(x))\n    \n    return sort(nums, by=sum_digits)\n\
    end", "    points = []\n    for num in nums\n        push!(points, sum(digits(num)))\n\
    \    end\n    sortperm(points, by=identity)\nend", "    ord = sort(zip(1:length(nums),\
    \ nums), by = x -> sum(digits(x[2])))\n    return ord[:,2]\nend", "    # nums\
    \ is an array of integers\n    # your code here\nend", "    sums = [sum(map(x\
    \ -> parse(Int64, x), collect(string(i)))) for i in nums]\n    return [x[1] for\
    \ x in sort(zip(nums, sums), by = x -> x[2])]\nend", "    sums = [sum(map(parse,\
    \ collect(n))) for n in collect(num2str.(nums))]\n    sorted_nums = sort(nums,\
    \ by = x -> (sums[findall(x->x==nums[x], 1:length(nums))[1]], findall(x->x==nums[x],\
    \ 1:length(nums))[1]))\n    return sorted_nums\nend", "    # TODO\nend\n\"\"\"\
    \nWrite a function which will take an array of integers and return \nan array\
    \ of integers with removed duplicates in the same order.", "    n = length(nums)\n\
    \    num_digit_sum = zeros(Int64, n)\n    for i = 1:n\n        num_digit_sum[i]\
    \ = sum(digits(nums[i]))\n    end\n    sort!(num_digit_sum)\n    min_num_digit_sum\
    \ = minimum(num_digit_sum)\n    max_num_digit_sum = maximum(num_digit_sum)\n \
    \   digit_sum_to_index = Dict()\n    for i = min_num_digit_sum:max_num_digit_sum\n\
    \        digit_sum_to_index[i] = []\n    end\n    for i = 1:n\n        push!(digit_sum_to_index[num_digit_sum[i]],\
    \ i)\n    end\n    ret = zeros(Int64, n)\n    pos = 1\n    for i = min_num_digit_sum:max_num_digit_sum\n\
    \        for j = 1:length(digit_sum_to_index[i])\n            ret[pos] = nums[digit_sum_to_index[i][j]]\n\
    \            pos += 1\n        end\n    end\n    return ret\nend", "    \n   \
    \ return [num for (ind, num) in sort(zip(collect(1:length(nums)), nums), by=x->(sum(digits(x[2])),\
    \ x[1]))]\nend", "  l = length(nums)\n  d = zeros(Int64, l)\n  p = zeros(Int64,\
    \ l)\n  for i in 1:l\n    d[i] = digitsum(nums[i])\n    p[i] = i\n  end\n  s =\
    \ sortperm(d)\n  return nums[s]\nend\n \n@test order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n@test order_by_points([]) == []", "    return\
    \ sort(nums, by=n->sum(digits(n)))\nend", "    if length(nums) == 0 \n       \
    \ return []\n    end\n    return sort(nums, lt = (a, b) -> sum(digits(a)) < sum(digits(b)))\n\
    end", "    function sum_of_digits(x::Int64)::Int64\n        x == 0 && return 0\n\
    \        abs(x) < 10 && return abs(x)\n        sum_of_digits(div(abs(x), 10))\
    \ + rem(abs(x), 10)\n    end\n    nums[sortperm(sum_of_digits.(nums))]\nend",
  "    len = length(nums)\n    nums_inds = [(i, nums[i]) for i in 1:len]\n    nums_inds_abs\
    \ = [(i, sum(digits(abs(nums[i])))) for i in 1:len]\n    nums_inds_abs_sorted\
    \ = sort(nums_inds_abs, by = x -> x[2])\n    nums_inds_sorted = [nums_inds[nums_inds_abs_sorted[i][1]]\
    \ for i in 1:len]\n    return [nums_inds_sorted[i][2] for i in 1:len]\nend", " \
    \   # your code here\nend\n ", "    return sort(nums, lt=(x,y) -> sum(digits(x))\
    \ < sum(digits(y)))\nend", "    points = [digit_sum(num) for num in nums]\n  \
    \  return sortperm(points)\nend", "    if length(nums) == 0\n        return nums\n\
    \    end\n    x_func(n) = sum(digits(n))\n    return sort(nums, by = x_func)\n\
    end", "    # convert to Vector{Tuple{Int64, Int64}}\n    # where first value is\
    \ sum of digits, second is original index\n    tmp = [Tuple(reduce(x->x+y, digits(x),\
    \ 0), i) for (i, x) in enumerate(nums)]\n    # sort\n    sort!(tmp, by=first)\n\
    \    # return sorted original list\n    return [nums[second(t)] for t in tmp]\n\
    end", "    digit_sums = [sum(digits(num)) for num in nums]\n    return nums[sortperm(digit_sums)]\n\
    end", "    distances = [sum(digits(x)) for x in nums]\n    pairs = [d * 100000\
    \ + i for (i, d) in enumerate(distances)]\n    pairs_sorted = sort(pairs)\n  \
    \  pairs_sorted_index = [p % 100000 for p in pairs_sorted]\n    return [nums[i]\
    \ for i in pairs_sorted_index]\nend", "    return sort(nums, by=x->sum(digits(x)))\n\
    end", "    # there are no duplicates in the input, so we can simply sort without\
    \ worrying about that\n    # sort by the sum of digits, then by index\n    sorted_nums\
    \ = sort(nums, by = (d->sum(digits(d))), rev=true)\n    return sorted_nums\nend",
  "    return sort(nums, by=x->(sum(digits(x)),x))\nend", "    sums = map(sum, digits.(nums))\n\
    \    s = sortperm(sums)\n    return nums[s]\nend", "    sorted_index = sortperm(sum(digits.(nums)),1:length(nums))\n\
    \    return nums[sorted_index]\nend", "    return sort(collect(1:length(nums)),\
    \ by=n->nums[n], lt=reduce(+,nums)->nums[n])\nend", "    sort(nums, by=x->(sum(digits(x)),\
    \ x))\nend", "    @assert typeof(nums)==Array{Int64,1} \"First argument must be\
    \ an Array{Int64,1}\"\n    out = deepcopy(nums)\n    sort!(out, by=x->sum(digits(x)))\n\
    \    return out\nend", "    sums = [sum(digits(i)) for i in nums]\n    sorted\
    \ = sortperm(sums)\n    return nums[sorted]\nend", "    results = []\n    for\
    \ (i, num) in enumerate(nums)\n        digits = Dict()\n        for d in digits(num)\n\
    \            if haskey(digits, d)\n                digits[d] += 1\n          \
    \  else\n                digits[d] = 1\n            end\n        end\n       \
    \ push!(results, (i, num, sum(values(digits))))\n    end\n    sort!(results, by=x->x[3])\n\
    \    results = map(result->result[2], results)\n    return results\nend", "  \
    \  sums_indices = [(sum([x for x in digits(abs(num))]), num, index) for (index,\
    \ num) in enumerate(nums)]\n    sorted_sums_indices = sort(sums_indices, rev=true)\n\
    \    return [num for (_, num, _) in sorted_sums_indices]\nend", "    # we want\
    \ to sort the vector by the sum of their digits. To do that,\n    # we will first\
    \ create a dictionary with the sum of digits as key\n    # and the index of the\
    \ number in the original vector as value\n    sums = Dict()\n    for i in 1:length(nums)\n\
    \        key = sum(digits(nums[i]))\n        if !haskey(sums, key)\n         \
    \   sums[key] = [i]\n        else\n            push!(sums[key], i)\n        end\n\
    \    end\n    # we then sort the dictionary by key and loop through it to get\n\
    \    # the value (which is the index) in order and we return the new\n    # vector\
    \ with the numbers in the ordered index\n    sorted_sums = sort(collect(keys(sums)))\n\
    \    sorted_vec = []\n    for i in 1:length(sorted_sums)\n        for j in 1:length(sums[sorted_sums[i]])\n\
    \            push!(sorted_vec, nums[sums[sorted_sums[i]][j]])\n        end\n \
    \   end\n    return sorted_vec\nend", "    if length(nums) == 0\n        return\
    \ nums\n    end\n    sorted_nums = zeros(length(nums))\n    sums = zeros(length(nums))\n\
    \    for i = 1:length(nums)\n        sums[i] = sum(get_digit(nums[i]))\n    end\n\
    \    sort!(sums)\n    sorted_nums[1] = nums[1]\n    for i = 2:length(nums)\n \
    \       for j = 2:length(nums)\n            if sum(get_digit(nums[j])) == sums[i]\n\
    \                sorted_nums[i] = nums[j]\n                nums[j] = -1\n    \
    \            break\n            end\n        end\n    end\n    return sorted_nums\n\
    end", "    # nums_with_digits = [reduce(+,digits(nums[i])) for i in 1:length(nums)]\n\
    \    # return sort(nums, by = nums_with_digits)\n    \n    nums_with_digits =\
    \ [(reduce(+,digits(nums[i])), nums[i]) for i in 1:length(nums)]\n    sort!(nums_with_digits,\
    \ by = x -> x[1])\n    return [nums_with_digits[i][2] for i in 1:length(nums)]\n\
    end", "    # find sum of digits per element in the given array\n    sums = [sum(int(i)\
    \ for i in string(num)) for num in nums]\n    # sort array of sums and retreive\
    \ indices of the sorted sum array\n    indices = sortperm(sums)\n    # return\
    \ sorted array of original array elements based on sum\n    return [nums[i] for\
    \ i in indices]\nend", "    \n    function sum_digits(n::Int64)::Int64\n     \
    \   q, r = divrem(n, 10)\n        if q == 0\n            return r\n        else\n\
    \            return r + sum_digits(q)\n        end\n    end\n    \n    indices\
    \ = sortperm(sum_digits.(nums))\n    return nums[indices]\nend", "    return sort(nums,\
    \ by =  x -> (sum(digits(x)), x))\nend", "    sums = [sum(digits(n)) for n in\
    \ nums]\n    new_arr = copy(nums)\n    # insertion sort\n    for i in 1:length(new_arr)\n\
    \        temp = new_arr[i]\n        index = i\n        # find index\n        for\
    \ j in i:length(new_arr)\n            if sums[i] > sums[j]\n                index\
    \ = j\n            end\n        end\n        # shift\n        for j in index:i\n\
    \            new_arr[j+1] = new_arr[j]\n        end\n        new_arr[index] =\
    \ temp\n    end\n    return new_arr\nend", "    #We will use the sum function\
    \ provided by Julia to generate the sums for the list of integers.\n    sums =\
    \ sum.(nums) #Returns an array of the sums of the integers in the list\n    nums_sorted\
    \ = sortperm(sums) #Returns an array of the indices of the numbers in the list\
    \ sorted by their sums.\n    return nums[nums_sorted] #Return the sorted list.\n\
    end", "    # Dictionary for mapping each index to the sum of its digits\n    digdict\
    \ = Dict()\n    for (i, n) in enumerate(nums)\n        sum = 0\n        str =\
    \ string(n)\n        for c in str\n            sum += parse(Int64, c)\n      \
    \  end\n        digdict[n] = sum\n    end\n    return sort(nums, by = x -> digdict[x])\n\
    end", "    return sortperm(sum.(nums))\nend", "    if length(nums) == 0\n    \
    \    return []\n    end\n    sums = [sum(digits(n)) for n in nums]\n    return\
    \ [nums[i] for i in sortperm(sums)]\nend", "    s = [sum(digits(x)) for x in nums]\n\
    \    i = sortperm(s)\n    return nums[i]\nend", "    indices = 1:length(nums)\n\
    \    scores = [sum(digits(n)) for n in nums]\n    sortedindices = sortperm(scores)\n\
    \    sortednums = nums[sortedindices]\n    return sortednums\nend", "    sorted\
    \ = sort(nums, by=x->sum(abs.(digits(x))))\n    return sorted\nend\n@testset \"\
    test\" begin\n    @test order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1,\
    \ -12, 11]\n    @test order_by_points([]) == []\nend", "    sort(nums, by=x->(sum(digits(x)),x))\n\
    end", "    return sortperm(sum.(digits.(nums)) .+ 1e-6 .* collect(1:length(nums)),\
    \ rev=true)\nend", "    sums = map(sum, nums)\n    return nums[sortperm(sums)]\n\
    end", "    temp = zeros(size(nums))\n    for i in range(1, size(nums)[1])\n  \
    \      temp[i] = sum(digits(nums[i]))\n    end\n    return sortperm(temp)\nend",
  "    sorted_nums = sort(collect(1:length(nums)), by = x -> sum(digits(nums[x])))\n\
    \    return [nums[x] for x in sorted_nums]\nend", "    nums_points = [sum(digits(x))\
    \ for x in nums]\n    sorted_index = sortperm(nums_points)\n    return nums[sorted_index]\n\
    end", "    return sort(nums, by=n->sum(digits(n)))\nend", "    return sortperm(sum(digits.(nums)),\
    \ nums)\nend", "    ind = [sum(digits(x)) for x in nums]\n    ind = [ind[i] for\
    \ i in sortperm(ind)]\n    return ind\nend", "    nums_with_sum = [(x, sum(digits(x)))\
    \ for x in nums]\n    @assert length(unique(nums_with_sum)) == length(nums)\n\
    \    sorted_nums = sort(nums_with_sum, by = t -> t[2])\n    sorted_nums[:,1]\n\
    end\n@testset \"basic test\" begin\n    @test order_by_points([1, 11, -1, -11,\
    \ -12]) == [-1, -11, 1, -12, 11]\n    @test order_by_points([]) == []\nend", " \
    \   return sort(nums, by=n -> sum(digits(n)))\nend", "    lengths = [sum(digits(num))\
    \ for num in nums]\n    return sortperm(lengths)\nend", "    new_nums = sort(collect(1:length(nums)),\
    \ by = x -> sum(digits(nums[x])))\n    return [nums[i] for i in new_nums]\nend",
  "    \"\"\"\n    Given vector of integers, return it sorted in ascending order\n\
    \    by the sum of its digits.\n    \"\"\"\n    if isempty(nums)\n        return\
    \ []\n    end\n    sorted_nums = sort(nums, by= x -> sum(digits(x)))\n    return\
    \ sorted_nums\nend", "    # this is lame, but I'm tired of thinking about this\
    \ problem.\n    # I'll revisit it tomorrow.\n    vals = sort([(sum([parse(Int,\
    \ c) for c in string(x)]), x) for x in nums])\n    return [x[2] for x in vals]\n\
    end", "    points = [sum(digits(n)) for n in nums]\n    order = sortperm(points)\n\
    \    return nums[order]\nend\nprintln(order_by_points([1, 11, -1, -11, -12]))\n\
    println(order_by_points([]))", "    sorted_ints = []\n    while !isempty(nums)\n\
    \        push!(sorted_ints, pop!(nums, indmin(sum.(nums))))\n    end\n    return\
    \ sorted_ints\nend\n \norder_by_points([1, 11, -1, -11, -12])", "    (a = [(sum(digits(num)),\
    \ i, num) for (i, num) in enumerate(nums)]) == sort(a, by = (a) -> (a[1], a[2]))[:,\
    \ 3]\nend", "    return sort(nums, by=x->(digits(x), x))\nend", "    sums = Vector{Int64}(undef,length(nums))\n\
    \    for i in 1:length(nums)\n        if nums[i] >= 0\n            sums[i] = sum(digits(nums[i]))\n\
    \        else\n            sums[i] = sum(digits(-nums[i]))\n        end\n    end\n\
    \    sorted = sortperm(sums)\n    return nums[sorted]\nend", "    x = length(nums)\n\
    \    y = zeros(Int64, x)\n    for i = 1:x\n        y[i] = sum(digits(nums[i]))\n\
    \    end\n    y = y .+ 1e6*findall(x -> x < 0, nums)\n    return nums[sortperm(y)]\n\
    end", "    # your code here\nend", "    \n    # returns the sum of the digits\
    \ in a number\n    function sum_digits(n::Int64)::Int64\n        if n < 0\n  \
    \          n = -n\n        end\n        s = 0\n        while n > 0\n         \
    \   s += n % 10\n            n = div(n, 10)\n        end\n        return s\n \
    \   end\n    \n    # sorts two numbers and\n    # returns the number with the\
    \ lower sum of digits\n    function bubble_sort(i::Int64, j::Int64)::Int64\n \
    \       if i < 0\n            i = -i\n        end\n        if j < 0\n        \
    \    j = -j\n        end\n        si = sum_digits(i)\n        sj = sum_digits(j)\n\
    \        if si < sj\n            return i\n        elseif si > sj\n          \
    \  return j\n        else\n            if i < j\n                return i\n  \
    \          else\n                return j\n            end\n        end\n    end\n\
    \    \n    # sorts array of numbers\n    function order_by_points_inner(nums::Vector{Int64})::Vector{Int64}\n\
    \        n = length(nums)\n        if n == 0\n            return nums\n      \
    \  end\n        for i = 1:n\n            for j = 1:n-1\n                nums[j]\
    \ = bubble_sort(nums[j], nums[j+1])\n            end\n        end\n        return\
    \ nums\n    end\n    return order_by_points_inner(nums)\nend", "    for i in eachindex(nums)\n\
    \        nums[i] = (sum_of_digits(nums[i]), i, nums[i])\n    end\n    sort!(nums)\n\
    \    collect(eachindex(nums)) do i\n        nums[i][3]\n    end\nend", "    points\
    \ = Dict()\n    for (i,n) in enumerate(nums)\n        if n < 0\n            n\
    \ *= -1\n        end\n        p = 0\n        while n > 0\n            p += n %\
    \ 10\n            n = n // 10\n        end\n        if haskey(points, p)\n   \
    \         push!(points[p], i)\n        else\n            points[p] = [i]\n   \
    \     end\n    end\n    res = zeros(Int64, length(nums))\n    i = 1\n    for (k,\
    \ v) in sort(collect(points))\n        for vi in v\n            res[i] = nums[vi]\n\
    \            i += 1\n        end\n    end\n    return res\nend", "    nums\nend",
  "    nums, ind = sort(nums)\n    nums, ind = sort(nums, by=get_sum_of_digits, rev=true)\n\
    \    nums[sortperm(ind)]\nend", "    n = length(nums)\n    sum_nums = zeros(Int64,\
    \ n)\n    for i in 1:n\n        a = nums[i]\n        while (a < 0)\n         \
    \   a = -a\n        end\n        while (a > 0)\n            sum_nums[i] += a %\
    \ 10\n            a = a // 10\n        end\n    end\n    sorted_nums = sortperm(sum_nums)\n\
    \    sorted_nums = [nums[sorted_nums[i]] for i in 1:n]\n    return sorted_nums\n\
    end", "    nums_sort = sort(nums, by = x -> sum(digits(x)), rev = false)\n   \
    \ # print(nums_sort)\n    # print(nums)\n    return nums_sort\nend", "    x =\
    \ [(sum(digits(nums[i])), i) for i in 1:length(nums)]\n    x = sort(x, by = (a)\
    \ -> a[1])\n    y = [x[i][2] for i in 1:length(x)]\n    return [nums[y[i]] for\
    \ i in 1:length(y)]\nend", "    res = zeros(Int64, length(nums))\n    for i =\
    \ 1:length(nums)\n        sum_digits = 0\n        num = nums[i]\n        if num\
    \ < 0\n            num = -num\n        end\n        while num > 0\n          \
    \  sum_digits += rem(num, 10)\n            num = div(num, 10)\n        end\n \
    \       res[i] = sum_digits\n    end\n    return sortperm(res)\nend\norder_by_points([1,\
    \ 11, -1, -11, -12])\norder_by_points([])", "    if isempty(nums)\n        return\
    \ nums\n    end\n    nums_with_sum = map(x -> [x, sum(digits(x))], nums)\n   \
    \ sort!(nums_with_sum, by = x -> x[2])\n    return map(x -> x[1], nums_with_sum)\n\
    end", "    return sort(nums, by=x->(sum(digits(x)),x))\nend", "    sumdigit(x)\
    \ = sum(digits(x))\n    idx = sortperm(collect(sumdigit, nums))\n    return nums[idx]\n\
    end\n \n@test order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n\
    @test order_by_points([]) == []\n \n \n\"\"\"\n    Write a function which returns\
    \ whether the number is prime.\n    The function should return true if the number\
    \ is prime and false otherwise.", "    sorted = sortperm(digit_sum.(nums))\n \
    \   return[nums[i] for i in sorted]\nend", "    sortperm(sum.(digits.(nums)),\
    \ collect(1:length(nums)))\nend", "    tmp = sort([(sum(abs.(digits(i))), i) for\
    \ i in nums])\n    return [i[2] for i in tmp]\nend", "    temp_list = []\n   \
    \ temp_dict = Dict()\n    for (index, elem) in enumerate(nums)\n        temp_sum\
    \ = 0\n        for digit in string(elem)\n            temp_sum += Int64(digit)\n\
    \        end\n        push!(temp_list, (temp_sum, index))\n    end\n    sort!(temp_list,\
    \ by = x -> x[1])\n    temp_dict = Dict(temp_list)\n    temp_dict_sort = sort(temp_dict,\
    \ by = x -> x[1])\n    return [nums[x[2]] for x in temp_dict_sort]\nend", "  \
    \  \"\"\"\n    The function sorts the given list of integers in ascending order\n\
    \    according to the sum of their digits.\n    Note: if there are several items\
    \ with similar sum of their digits,\n    order them based on their index in original\
    \ list.\n    \"\"\"\n    return sortperm(sum.(digits.(nums)), alg=MergeSort)[1]\n\
    end", "    i = 0\n    t = []\n    while (i < length(nums))\n        push!(t, (sum(digits(nums[i+1])),\
    \ nums[i+1], i+1))\n        i = i + 1\n    end\n    sort!(t)\n    out = []\n \
    \   for i in t\n        push!(out, i[2])\n    end\n    return out\nend", "   \
    \ \n    lengths = zeros(Int64, length(nums))\n    for i in eachindex(nums)\n \
    \       lengths[i] = sum(digits(nums[i]))\n    end\n    \n    for i in 1:length(nums)\n\
    \        for j in 1:length(nums)-1\n            if lengths[j]>lengths[j+1] ||\
    \ (lengths[j]==lengths[j+1] && nums[j]>nums[j+1])\n                (lengths[j],lengths[j+1])\
    \ = (lengths[j+1],lengths[j])\n                (nums[j],nums[j+1]) = (nums[j+1],nums[j])\n\
    \            end\n        end\n    end\n    return nums\nend", "    if length(nums)\
    \ == 0\n        return nums\n    end\n    ind = zeros(Int64, length(nums))\n \
    \   for i in 1:length(nums)\n        s = 0\n        for j in 1:length(string(nums[i]))\n\
    \            s += Int64(string(nums[i])[j]) - 48\n        end\n        ind[i]\
    \ = s\n    end\n    ind, nums = sortperm(ind, nums)\n    return nums\nend", " \
    \   if length(nums) < 2\n        return nums\n    end\n    points = map(x -> round(Int64,\
    \ sum(digits(x))), nums)\n    perm = sortperm(points)\n    return nums[perm]\n\
    end", "    n = length(nums)\n    d = Dict{Int64, Int64}()\n    for i in 1:n\n\
    \        d[nums[i]] = sum(digits(nums[i]))\n    end\n    sort(collect(keys(d)),\
    \ by=d)\nend", "    \"\"\"\n    Input: vector of integers\n    Output: vector\
    \ of integers sorted by sum of digits\n    \"\"\"\n    # create a list of tuples\n\
    \    # each tuple has a number and a sum of digits of this number\n    sums =\
    \ map(n -> (n, sum(digits(n))), nums)\n    # sort the list of tuples by the sum\
    \ of digits and by index\n    sort(sums, by = x -> (x[2], x[1]))[:,1]\nend", " \
    \   indices = sortperm(sum(digits(nums)));\n    nums[indices]\nend", "    return\
    \ sort(nums, by = sum_of_digits)\nend", "    n = length(nums)\n    if n == 0\n\
    \        return []\n    end\n    inds = sortperm(nums, by=x->sum(digits(x)))\n\
    \    return inds\nend", "    return sort(nums, by = digits_sum)\nend", "    if\
    \ isempty(nums)\n        return []\n    end\n    if length(nums) == 1\n      \
    \  return nums\n    end\n    sums = [sum(abs.(int2big.(nums))...)]\n    sorted_sum_index\
    \ = sortperm(sums)\n    return nums[sorted_sum_index]\nend", "    return sort(nums,\
    \ by=x->(x, abs(x)))\nend\n@testset \"order_by_points\" begin\n    @test order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    @test order_by_points([]) ==\
    \ []\nend;", "    a = zeros(length(nums))\n    for i in 1:length(nums)\n     \
    \   a[i] = sum(split(num2str(nums[i])))\n    end\n    sort(nums, by=a)\nend",
  "    return sortperm(sum.(nums))\nend", "    ordered = sort(nums, by=x->sum(digits(x)))\n\
    \    ordered\nend", "    if isempty(nums)\n        return nums\n    end\n    return\
    \ sort(nums, by=x->(sum(digits(x)), findall(nums .== x)[1]))\nend", "    # your\
    \ code here\nend", "    if isempty(nums)\n        return nums\n    end\n    s\
    \ = sort([x > 0 ? x : -x for x in nums])\n    m = maximum(s)\n    r = m > 10 ?\
    \ log10(m) + 1 : 1\n    o = zeros(length(s), Int64)\n    for i in 1:length(s)\n\
    \        o[i] = s[i] < 0 ? -s[i] : s[i]\n    end\n    for i in 1:r\n        p\
    \ = Int64(10^(i-1))\n        j = 1\n        while j <= length(s)\n           \
    \ k = j\n            while k <= length(s) && o[k] % (10*p) / p == o[j] % (10*p)\
    \ / p\n                k += 1\n            end\n            sort!(o[j:k-1], rev=true)\n\
    \            j = k\n        end\n    end\n    for i in 1:length(s)\n        s[i]\
    \ = s[i] < 0 ? -o[i] : o[i]\n    end\n    return s\nend", "    # TODO: write your\
    \ solution to the task here\n    function sum_of_digits(num::Int64)::Int64\n \
    \       sum = 0\n        while num != 0\n            sum += num % 10\n       \
    \     num = num // 10\n        end\n        return sum\n    end\n    return sort(nums,\
    \ by=x->(sum_of_digits(x), x))\nend", "    \"\"\"Order an array of integers based\
    \ on the sum of their digits\"\"\"\n    n = length(nums)\n    if n == 0\n    \
    \    return nums\n    end\n    # Initialise the indices vector\n    indices =\
    \ 1:n\n    # Sort by the sum of the digits first and then by the original position\n\
    \    indices = sort(indices, by = [i -> sum(digits(nums[i])), i -> i])\n    return\
    \ [nums[i] for i in indices]\nend", "    sums = zeros(length(nums))\n    for i\
    \ = 1:length(nums)\n        num = nums[i]\n        while num != 0\n          \
    \  digit = num % 10\n            sums[i] += digit\n            num = div(num,\
    \ 10)\n        end\n    end\n    sorted_inds = sortperm(sums)\n    sorted_nums\
    \ = zeros(length(nums))\n    for i = 1:length(nums)\n        sorted_nums[i] =\
    \ nums[sorted_inds[i]]\n    end\n    return sorted_nums\nend", "    r = [i for\
    \ i in enumerate(nums)]\n    sort!(r, by = x -> sum(digits(x[2])))\n    r = [i[2]\
    \ for i in r]\n    return r\nend", "    sorted = sort(nums, by=x->(sum(digits(x)),\
    \ x))\n    return sorted\nend", "    if length(nums) == 0\n        return nums\n\
    \    end\n    (x, y) = sort(nums, by = sum)\n    return y\nend\n@testset \"Testing\
    \ order_by_points\" begin\n    @test order_by_points([1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11]\n    @test order_by_points([]) == []\nend", "    if length(nums)\
    \ == 0\n        return []\n    end\n    nums_copy = nums\n    index_copy = 1:length(nums)\n\
    \    sorted_nums = []\n    sorted_index = []\n    while length(nums_copy) != 0\n\
    \        curr_min = minimum(map(num->sum_digits(num), nums_copy))\n        for\
    \ i in 1:length(nums_copy)\n            if sum_digits(nums_copy[i]) == curr_min\n\
    \                push!(sorted_nums, nums_copy[i])\n                push!(sorted_index,\
    \ index_copy[i])\n                nums_copy = deleteat!(nums_copy, i)\n      \
    \          index_copy = deleteat!(index_copy, i)\n                break\n    \
    \        end\n        end\n    end\n    sorted_nums\nend", "    # replace the\
    \ line below by your implementation\n    return sort(nums, by=x->(x<0 ? -x : x))\n\
    end", "    sum_of_digits = [sum(digits(x)) for x in nums]\n    return sortperm(sum_of_digits)\n\
    end", "    sums_indices = Int64[]\n    for (i, num) in enumerate(nums)\n     \
    \   sums_indices = append!(sums_indices, digitsum(num)*10000 + i)\n    end\n \
    \   sorted_idx = sort(sums_indices)\n    return [nums[sorted_idx[i]%10000+1] for\
    \ i=1:length(sorted_idx)]\nend", "    nums = sort([(x, sum(digits(x)), i) for\
    \ (i, x) in enumerate(nums)])\n    nums = map(i -> i[1], nums)\n    return nums\n\
    end\n ", "    \n    zero_to_n(n) = collect(0:n)\n    \n    indices_by_digit_sum(digit_sum)\
    \ = [i-1 for i in zero_to_n(length(nums)) if sum(digits(nums[i])) == digit_sum]\n\
    \    digit_sums = sort(Set([sum(digits(num)) for num in nums]))\n    \n    ordered_indices\
    \ = [indices_by_digit_sum(digit_sum) for digit_sum in digit_sums]\n    ordered_indices\
    \ = [index for sublist in ordered_indices for index in sublist]\n    \n    return\
    \ [nums[index] for index in ordered_indices]\nend", "    i = 0\n    n = length(nums)\n\
    \    while i < n\n        j = i + 1\n        while j < n\n            if nums[i]\
    \ > nums[j]\n                nums[i], nums[j] = nums[j], nums[i]\n           \
    \ end\n            j += 1\n        end\n        i += 1\n    end\n    return nums\n\
    end", "    \"\"\"\n    Function which sorts the given list of integers\n    in\
    \ ascending order according to the sum of their digits.\n    Note: if there are\
    \ several items with similar sum of their digits,\n    order them based on their\
    \ index in original list.\n    \"\"\"\n    N = length(nums)\n    if N == 0\n \
    \       return Vector{Int64}(0)\n    end\n    nums_abs = abs.(nums)\n    sorted_nums\
    \ = sort(nums_abs)\n    indices = zeros(Int64, length(nums))\n    for i in 1:length(nums)\n\
    \        indices[i] = findfirst(nums_abs, sorted_nums[i])\n    end\n    return\
    \ nums[indices]\nend", "    \n    points = Dict()\n    for (i, num) in enumerate(nums)\n\
    \        digits = map(Int64, str(num))\n        points[num] = sum(digits)\n  \
    \  end\n    \n    output = sort(collect(keys(points)), by=x->points[x])\n    \n\
    \    return output\nend", "    # create a table with a sum of digits and the index\n\
    \    # sort that table by the sum, then extract the indexes\n    tmp = zeros(size(nums,\
    \ 1), 2)\n    for i in eachindex(nums)\n        num = nums[i]\n        sum = 0\n\
    \        while num > 0\n            sum += num % 10\n            num = trunc(Int64,\
    \ num / 10)\n        end\n        tmp[i, 1] = sum\n        tmp[i, 2] = i\n   \
    \ end\n    tmp = sortrows(tmp, 1)\n    indices = zeros(size(nums, 1))\n    for\
    \ i in eachindex(indices)\n        indices[i] = tmp[i, 2]\n    end\n    return\
    \ permutedims(nums[indices])\nend", "    if length(nums) == 0\n        return\
    \ []\n    end\n    indexs = [1:length(nums)]\n    dic = Dict()\n    for i in 1:length(nums)\n\
    \        dic[i] = sum(digits(nums[i]))\n    end\n    sort!(indexs, by = x -> dic[x])\n\
    \    res = []\n    for i in indexs\n        push!(res, nums[i])\n    end\n   \
    \ return res\nend", "    \"\"\" \n    >>>> order_by_points([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11]\n    >>>> order_by_points([]) == []\n    \"\"\"\n \
    \   tmp = [(sum(digits(i)), i) for i in nums]\n    sort!(tmp, by = x -> x[1])\n\
    \    return [i[2] for i in tmp]\nend", "    if length(nums) == 0\n        return\
    \ []\n    end\n    # \u0441\u043D\u0430\u0447\u0430\u043B\u0430 \u043D\u0430\u0445\
    \u043E\u0434\u0438\u043C \u0441\u0443\u043C\u043C\u0443 \u0446\u0438\u0444\u0440\
    \ \u043A\u0430\u0436\u0434\u043E\u0433\u043E \u0447\u0438\u0441\u043B\u0430 \u0438\
    \ \u0438\u043D\u0434\u0435\u043A\u0441\n    # \u0437\u0430\u0442\u0435\u043C \u0441\
    \u043E\u0440\u0442\u0438\u0440\u0443\u0435\u043C \u043F\u043E \u0441\u0443\u043C\
    \u043C\u0435 \u0446\u0438\u0444\u0440\n    # \u0437\u0430\u0442\u0435\u043C \u0441\
    \u043E\u0440\u0442\u0438\u0440\u0443\u0435\u043C \u043F\u043E \u0438\u043D\u0434\
    \u0435\u043A\u0441\u0443, \u0435\u0441\u043B\u0438 \u0441\u0443\u043C\u043C\u0430\
    \ \u0446\u0438\u0444\u0440 \u043E\u0434\u0438\u043D\u0430\u043A\u043E\u0432\u0430\
    \u044F\n    # \u043D\u0430\u043A\u043E\u043D\u0435\u0446, \u043E\u0442\u0431\u0440\
    \u0430\u0441\u044B\u0432\u0430\u0435\u043C \u0438\u043D\u0434\u0435\u043A\u0441\
    \n    return sort(nums, by=tuple->(digits_sum(tuple), tuple, 1))\nend", "    tsort(nums,\
    \ by=x->sum(digits(x)))\nend", "    len = length(nums)\n    if len == 0\n    \
    \    return nums\n    end\n    sort(nums, by = x -> (sum(digits(x)),x))\nend",
  "    sum(int(digit) for digit in string(abs(n))) for n in nums\nend", "    if length(nums)\
    \ == 0 \n        return nums\n    end\n    v = [[sum(map(x -> parse(Int64, x),collect(str(abs(i))))),i]\
    \ for i in nums]\n    sorted = sort(v, rev=true)\n    sorted = reverse(sorted)\n\
    \    [sorted[i][2] for i in 1:length(sorted)]\nend", "    ordering = sort(collect(1:length(nums)),\
    \ by = x -> sum(digits(nums[x])))\n    [nums[x] for x in ordering]\nend", "  \
    \  if isempty(nums)\n        return nums\n    end\n    sums = map(n -> sum(digits(n)),\
    \ nums)\n    sortperm(sums) |> permutedims(nums)\nend", "    unsorted = copy(nums)\n\
    \    sorted = zeros(Int64, length(nums))\n    j = 1\n    for i in 1:length(nums)\n\
    \        sums = sort([(abs(x),x,i) for x in unsorted])\n        sorted[j] = sums[1][2]\n\
    \        unsorted[sums[1][3]] = Inf\n        j += 1\n    end\n    return sorted\n\
    end", "    # sorting the input numbers according to their digits\n    indices\
    \ = sortperm(sum.(map(parse, map(string, nums))));\n    # reordering in line with\
    \ the sorting order \n    return [nums[i] for i in indices];\nend", "    ind_sort\
    \ = sortperm(sum.(abs.(nums)));\n    return nums[ind_sort];\nend;", "    nums_with_points\
    \ = [(n, sum(digits(n))) for n in nums]\n    sorted_by_points = sort(nums_with_points,\
    \ by=x -> x[2])\n    return [n for (n, _) in sorted_by_points]\nend\n ", "   \
    \ if length(nums) == 0\n        return nums\n    end\n    nums_with_digits_sum\
    \ = zip(nums, map(digits_sum, nums))\n    sort!(nums_with_digits_sum, by = x ->\
    \ x[2])\n    return collect(map(x -> x[1], nums_with_digits_sum))\nend", "   \
    \ if length(nums) == 0 \n        return Vector{Int64}()\n    end\n    if length(nums)\
    \ == 1 \n        return nums \n    end\n    sorted_digits = sort(nums, \n    by=x->sum(digits(x)),\
    \ rev=true)\n    return sorted_digits\nend", "    return sort(nums, by=x->(x,sum(digits(x))))\n\
    end", "    n = length(nums)\n    nums_index = [(i, sum(digits(abs(j)))) for (i,\
    \ j) in enumerate(nums)]\n    sorted_index = sort(nums_index, by = x -> x[2])\n\
    \    sorted_nums = zeros(Int64, n)\n    for i in 1:n\n        sorted_nums[i] =\
    \ nums[sorted_index[i][1]]\n    end\n    return sorted_nums\nend", "    if isempty(nums)\n\
    \        return nums\n    end\n    mapping = Dict()\n    for (i,num) in enumerate(nums)\n\
    \        if haskey(mapping, sum(digits(num)))\n            mapping[sum(digits(num))]\
    \ = vcat(mapping[sum(digits(num))], [i,num])\n        else\n            mapping[sum(digits(num))]\
    \ = [i,num]\n        end\n    end\n    keys_sorted = sort(collect(keys(mapping)))\n\
    \    output = Vector{Int64}()\n    for key in keys_sorted\n        for i in 1:size(mapping[key],1)\n\
    \            push!(output, mapping[key][i,2])\n        end\n    end\n    return\
    \ output\nend", "    if isempty(nums)\n        return []\n    end\n    return\
    \ sortperm(sum.(digits.(nums)), [1,2,3,4,5,6,7,8,9,10])\nend", "    if isempty(nums)\n\
    \        return []\n    end\n    sums = zeros(Int64, length(nums))\n    for i\
    \ in 1:length(nums)\n        num = abs(nums[i])\n        while num > 0\n     \
    \       sums[i] += num % 10\n            num = div(num, 10)\n        end\n   \
    \ end\n    return [val for val in nums[sortperm(sums)]]\nend", "    N = length(nums)\n\
    \    indices = collect(1:N)\n    sums = map(x -> sum(digits(x)), nums)\n    combined\
    \ = zip(sums, nums, indices)\n    sorted = sort(combined, by=x -> (x[1], -x[3]))\n\
    \    newnums = map(x -> x[2], sorted)\n    return newnums\nend", "    return by(nums,\
    \ nums, i -> sum(digits(i)))\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
