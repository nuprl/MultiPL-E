name: HumanEval_125_split_words
language: ts
prompt: "//Given a string of words, return a list of words split on whitespace, if\
  \ no whitespaces exists in the text you\n// should split on commas ',' if no commas\
  \ exists you should return the number of lower-case letters with odd order in the\n\
  // alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// >>>\
  \ split_words(\"Hello world!\")\n// [\"Hello\", \"world!\"]\n// >>> split_words(\"\
  Hello,world!\")\n// [\"Hello\", \"world!\"]\n// >>> split_words(\"abcdef\")\n//\
  \ 3\nfunction split_words(txt: string): string[]| number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = split_words;\n  assert.deepEqual(candidate(\"Hello\
  \ world!\"),[\"Hello\", \"world!\"]);\n  assert.deepEqual(candidate(\"Hello,world!\"\
  ),[\"Hello\", \"world!\"]);\n  assert.deepEqual(candidate(\"Hello world,!\"),[\"\
  Hello\", \"world,!\"]);\n  assert.deepEqual(candidate(\"Hello,Hello,world !\"),[\"\
  Hello,Hello,world\", \"!\"]);\n  assert.deepEqual(candidate(\"abcdef\"),3);\n  assert.deepEqual(candidate(\"\
  aaabb\"),2);\n  assert.deepEqual(candidate(\"aaaBb\"),1);\n  assert.deepEqual(candidate(\"\
  \"),0);\n}\n\ntest();"
completions: ["  let words = txt.trim().split(/\\s+/);\n  if (words.length === 0)\
    \ {\n    return words;\n  }\n  if (words.length === 1) {\n    return words;\n\
    \  }\n  let letters = words[0].split('');\n  let odd_letters = 0;\n  for (let\
    \ i = 0; i < letters.length; i++) {\n    if (letters[i] === 'a') {\n      odd_letters\
    \ += 1;\n    }\n  }\n  return odd_letters;\n}\n", "  const words = txt.split(/\\\
    s+/);\n  return words.length ? words : words.split(',');\n}\n", "  const words\
    \ = txt.trim().split(/\\s+/);\n  if (words.length === 0) return 0;\n  if (words.length\
    \ === 1) return words[0];\n  return words.filter(w => w.length > 0).map(w => w.toLowerCase());\n\
    }\n", "  const words = txt.trim().split(/\\s+/);\n  return words.length ? words\
    \ : words.map(word => word.toLowerCase());\n}\n", "  let words = txt.trim().split(/\\\
    s+/);\n  if (words.length === 0) {\n    return words;\n  }\n  if (words.length\
    \ === 1) {\n    return words;\n  }\n  let letters = words[0].split('');\n  let\
    \ count = 0;\n  for (let i = 0; i < letters.length; i++) {\n    if (letters[i]\
    \ === 'a') {\n      count++;\n    }\n  }\n  if (count % 2 === 1) {\n    return\
    \ words;\n  }\n  return letters;\n}\n", "  const words = txt.trim().split(/\\\
    s+/);\n  if (words.length === 0) return 0;\n  if (words.length === 1) return words[0];\n\
    \  if (words.length === 2) return [words[0], words[1]];\n  const letters = words[0].split('');\n\
    \  const odd = letters.filter(letter => letter === 'a' || letter === 'b' || letter\
    \ === 'c' || letter === 'd' || letter === 'e' || letter === 'f' || letter ===\
    \ 'g' || letter === 'h' || letter === 'i' || letter === 'j' || letter === 'k'\
    \ || letter === 'l' || letter === 'm' || letter === 'n' || letter === 'o' || letter\
    \ === 'p' || letter === 'q' || letter === 'r' || letter === 's' || letter ===\
    \ 't' || letter === 'u' || letter === 'v' || letter === 'w' || letter === 'x'\
    \ || letter === 'y' || letter === 'z').length;\n  return odd ? words.length -\
    \ 1 : words.length;\n}\n", "  const words = txt.trim().split(/\\s+/);\n  if (words.length\
    \ === 0) return 0;\n  if (words.length === 1) return words[0];\n  const letters\
    \ = words.map(w => w.toLowerCase());\n  const letterCount = letters.reduce((acc,\
    \ letter) => {\n    if (acc[letter] === undefined) acc[letter] = 1;\n    else\
    \ acc[letter]++;\n    return acc;\n  }, {});\n  const oddLetters = Object.keys(letterCount).filter(k\
    \ => letterCount[k] % 2 === 1);\n  return oddLetters.length;\n}\n", "  const words\
    \ = txt.trim().split(/\\s+/);\n  if (words.length === 0) {\n    return words;\n\
    \  }\n  const lastWord = words[words.length - 1];\n  if (lastWord.length === 0)\
    \ {\n    return words;\n  }\n  const lastWordChar = lastWord.charCodeAt(0);\n\
    \  if (lastWordChar === 9 || lastWordChar === 13) {\n    return words;\n  }\n\
    \  const lastWordLowerCase = lastWord.toLowerCase();\n  const numLowercaseLetters\
    \ = lastWordLowerCase.length - 1;\n  if (numLowercaseLetters % 2 === 0) {\n  \
    \  return words;\n  }\n  const numUppercaseLetters = numLowercaseLetters / 2;\n\
    \  const numLetters = words.length;\n  if (numLetters % 2 === 0) {\n    return\
    \ words;\n  }\n  const numLettersWithOddOrder = numLetters / 2;\n  const numLettersWithEvenOrder\
    \ = numLettersWithOddOrder + 1;\n  const numLettersWithOddOrderAndEvenOrder =\
    \ numLettersWithOddOrder + numLowercaseLetters;\n  const numLettersWithEvenOrderAndOddOrder\
    \ = numLettersWithEvenOrder + numUppercaseLetters;\n  if (numLettersWithOddOrder\
    \ === numLettersWithEvenOrder) {\n    return words;\n  }\n  if (numLettersWithOddOrderAndEvenOrder\
    \ === numLettersWithOddOrderAndEvenOrder) {\n    return words;\n  }\n  if (numLettersWithOddOrderAndEvenOrder\
    \ === numLettersWithEvenOrderAndOddOrder) {\n    return words;\n  }\n  return\
    \ [...Array(numLettersWithOddOrderAndEvenOrder).keys()].map(i => words[i]);\n\
    }\n", "  const words = txt.trim().split(/\\s+/);\n  if (words.length === 0) return\
    \ 0;\n  if (words.length === 1) return words[0];\n  const letters = words.map(word\
    \ => word.toLowerCase());\n  const counts = letters.reduce((acc, letter, index)\
    \ => {\n    if (letter === letters[index - 1]) {\n      acc++;\n    } else {\n\
    \      acc = 0;\n    }\n    return acc;\n  }, 0);\n  return counts % 2 === 1 ?\
    \ letters.length : letters.length;\n}\n", "  const words = txt.split(/\\s+/);\n\
    \  return words.filter(w => w.length > 0).map(w => w.toLowerCase());\n}\n", " \
    \ return txt.split(/\\s+/);\n}\n", "\tconst words = txt.split(/\\s+/);\n\treturn\
    \ words.length > 0 ? words : words.map(word => word.toLowerCase());\n}\n", " \
    \ const words = txt.trim().split(/\\s+/);\n  if (words.length === 0) {\n    return\
    \ words;\n  }\n  const letters = txt.split('');\n  const counts: number[] = [];\n\
    \  for (let i = 0; i < letters.length; i++) {\n    const letter = letters[i];\n\
    \    if (letter === ',' || letter === ' ') {\n      counts.push(letters.length);\n\
    \    }\n  }\n  return counts;\n}\n", "  const words = txt.trim().split(/\\s+/);\n\
    \  if (words.length === 0) return 0;\n  if (words.length === 1) return words[0];\n\
    \  const letters = words[0].split('');\n  const numbers = words[1].split('');\n\
    \  const result = letters.length;\n  for (let i = 0; i < letters.length; i++)\
    \ {\n    if (letters[i] === 'a') {\n      result += numbers[numbers.length - i\
    \ - 1] % 2 === 1 ? 1 : 0;\n    }\n  }\n  return result;\n}\n", "  const words\
    \ = txt.split(/\\s+/);\n  if (words.length === 0) {\n    return words;\n  }\n\
    \  const commaIndex = words.indexOf(',');\n  if (commaIndex === -1) {\n    return\
    \ words;\n  }\n  const commaWords = words.slice(0, commaIndex);\n  const evenWords\
    \ = words.slice(commaIndex + 1);\n  return evenWords.length % 2 === 1 ? commaWords\
    \ : evenWords;\n}\n", "  return txt.split(/\\s+/);\n}\n", "  const words = txt.trim().split(/\\\
    s+/);\n  if (words.length === 0) {\n    return [];\n  }\n  if (words.length ===\
    \ 1) {\n    return words;\n  }\n  const letters = words.map(word => word.toLowerCase());\n\
    \  const letterCount = letters.reduce((acc, letter) => {\n    return acc + letterCount(letter);\n\
    \  }, 0);\n  if (letterCount % 2 === 1) {\n    return words;\n  }\n  return letters;\n\
    }\n", "  return txt.split(/\\s+/);\n}\n", "  const words = txt.trim().split(/\\\
    s+/);\n  if (words.length === 0) return 0;\n  if (words.length === 1) return words[0];\n\
    \  const lower = words.map(word => word.toLowerCase());\n  const count = lower.filter(word\
    \ => word.length > 1).length;\n  return count % 2 === 1 ? count : count + 1;\n\
    }\n", "  const words = txt.trim().split(/\\s+/);\n  return words.filter(w => w.length\
    \ > 0).map(w => w.toLowerCase());\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
