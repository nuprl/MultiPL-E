name: HumanEval_58_common
language: ts
prompt: "//Return sorted unique common elements for two lists.\n// >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5,\
  \ 3, 2, 8], [3, 2])\n// [2, 3]\nfunction common(l1: number[], l2: number[]): number[]\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = common;\n  assert.deepEqual(candidate([1, 4, 3, 34,\
  \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]),[1, 5, 653]);\n  assert.deepEqual(candidate([5,\
  \ 3, 2, 8], [3, 2]),[2, 3]);\n  assert.deepEqual(candidate([4, 3, 2, 8], [3, 2,\
  \ 4]),[2, 3, 4]);\n  assert.deepEqual(candidate([4, 3, 2, 8], []),[]);\n}\n\ntest();"
completions: ["  const l: number[] = [];\n  for (let i = 0; i < l1.length; i++) {\n\
    \    if (l2.indexOf(l1[i]) === -1) {\n      l.push(l1[i]);\n    }\n  }\n  return\
    \ l;\n}\n", "  const l: number[] = [];\n  for (let i = 0; i < l1.length; i++)\
    \ {\n    if (l2.indexOf(l1[i]) === -1) {\n      l.push(l1[i]);\n    }\n  }\n \
    \ return l;\n}\n", "  const result = [];\n  let j = 0;\n  for (let i = 0; i <\
    \ l1.length; i++) {\n    while (j < l2.length && l2[j] === l1[i]) {\n      j++;\n\
    \    }\n    if (j === l2.length) {\n      result.push(l1[i]);\n    }\n  }\n  return\
    \ result;\n}\n", "  const l: number[] = [];\n  for (let i = 0; i < l1.length;\
    \ i++) {\n    const found: boolean = l2.indexOf(l1[i]) !== -1;\n    if (!found)\
    \ {\n      l.push(l1[i]);\n    }\n  }\n  return l;\n}\n", "  const l: number[]\
    \ = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) ===\
    \ -1) {\n      l.push(l1[i]);\n    }\n  }\n  return l;\n}\n", "  const set1 =\
    \ new Set(l1);\n  const set2 = new Set(l2);\n  const result = [];\n  for (const\
    \ item of set1) {\n    if (set2.has(item)) {\n      result.push(item);\n    }\n\
    \  }\n  return result;\n}\n", "  const l: number[] = [];\n  for (let i = 0; i\
    \ < l1.length; i++) {\n    if (l2.indexOf(l1[i]) !== -1) {\n      l.push(l1[i]);\n\
    \    }\n  }\n  return l;\n}\n", "  const l: number[] = [];\n  for (let i = 0;\
    \ i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) === -1) {\n      l.push(l1[i]);\n\
    \    }\n  }\n  return l;\n}\n", "  const l: number[] = [];\n  const sortedL1 =\
    \ l1.sort((a, b) => a - b);\n  const sortedL2 = l2.sort((a, b) => a - b);\n  let\
    \ j = 0;\n  let k = 0;\n  while (j < sortedL1.length && k < sortedL2.length) {\n\
    \    if (sortedL1[j] === sortedL2[k]) {\n      l.push(sortedL1[j]);\n      j++;\n\
    \      k++;\n    } else if (sortedL1[j] < sortedL2[k]) {\n      j++;\n    } else\
    \ {\n      k++;\n    }\n  }\n  return l;\n}\n", "  const l: number[] = [];\n \
    \ let i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i] === l2[i])\
    \ {\n      l.push(l1[i]);\n      i++;\n    } else {\n      break;\n    }\n  }\n\
    \  return l;\n}\n", "  const l: number[] = [];\n  for (let i = 0; i < l1.length;\
    \ i++) {\n    if (l2.indexOf(l1[i]) === -1) {\n      l.push(l1[i]);\n    }\n \
    \ }\n  return l;\n}\n", "  const l: number[] = [];\n  for (let i = 0; i < l1.length;\
    \ i++) {\n    if (l2.indexOf(l1[i]) !== -1) {\n      l.push(l1[i]);\n    }\n \
    \ }\n  return l;\n}\n", "  const l: number[] = [];\n  for (let i = 0; i < l1.length;\
    \ i++) {\n    if (l2.indexOf(l1[i]) !== -1) {\n      l.push(l1[i]);\n    }\n \
    \ }\n  return l;\n}\n", "  const l: number[] = [];\n  for (let i = 0; i < l1.length;\
    \ i++) {\n    if (l2.indexOf(l1[i]) === -1) {\n      l.push(l1[i]);\n    }\n \
    \ }\n  return l;\n}\n", "  const l: number[] = [];\n  for (let i = 0; i < l1.length;\
    \ i++) {\n    const found = false;\n    for (let j = 0; j < l2.length; j++) {\n\
    \      if (l1[i] === l2[j]) {\n        l.push(l1[i]);\n        found = true;\n\
    \        break;\n      }\n    }\n    if (!found) {\n      l.push(l1[i]);\n   \
    \ }\n  }\n  return l;\n}\n", "  const l1Len = l1.length;\n  const l2Len = l2.length;\n\
    \  if (l1Len === 0 || l2Len === 0) {\n    return [];\n  }\n  const result: number[]\
    \ = [];\n  let i = 0;\n  let j = 0;\n  while (i < l1Len && j < l2Len) {\n    if\
    \ (l1[i] === l2[j]) {\n      result.push(l1[i]);\n      i++;\n      j++;\n   \
    \ } else if (l1[i] < l2[j]) {\n      i++;\n    } else {\n      j++;\n    }\n \
    \ }\n  return result;\n}\n", "  const result = [];\n  const hashMap = new Map();\n\
    \  for (let i = 0; i < l1.length; i++) {\n    const key = l1[i];\n    if (!hashMap.has(key))\
    \ {\n      hashMap.set(key, true);\n      result.push(key);\n    }\n  }\n  for\
    \ (let i = 0; i < l2.length; i++) {\n    const key = l2[i];\n    if (!hashMap.has(key))\
    \ {\n      hashMap.set(key, true);\n      result.push(key);\n    }\n  }\n  return\
    \ result;\n}\n", "  const l1 = l1 || [];\n  const l2 = l2 || [];\n  const result\
    \ = [];\n  let i = 0;\n  while (i < l1.length && i < l2.length) {\n    if (l1[i]\
    \ === l2[i]) {\n      result.push(l1[i]);\n      i++;\n    } else {\n      break;\n\
    \    }\n  }\n  return result;\n}\n", "  var result = [];\n  var lLen1 = l1.length;\n\
    \  var lLen2 = l2.length;\n  if (lLen1 === 0 || lLen2 === 0) {\n    return result;\n\
    \  }\n  var tIndex = 0;\n  var lIndex = 0;\n  while (lIndex < lLen1 && tIndex\
    \ < lLen2) {\n    if (l1[lIndex] === l2[tIndex]) {\n      result.push(l1[lIndex]);\n\
    \      lIndex++;\n      tIndex++;\n    } else if (l1[lIndex] < l2[tIndex]) {\n\
    \      lIndex++;\n    } else {\n      tIndex++;\n    }\n  }\n  return result;\n\
    }\n", "  const l: number[] = [];\n  for (let i = 0; i < l1.length; i++) {\n  \
    \  const found = false;\n    for (let j = 0; j < l2.length; j++) {\n      if (l1[i]\
    \ === l2[j]) {\n        found = true;\n        break;\n      }\n    }\n    if\
    \ (!found) {\n      l.push(l1[i]);\n    }\n  }\n  return l;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
