name: HumanEval_126_is_sorted
language: ts
prompt: "//Given a list of numbers, return whether or not they are sorted\n// in ascending\
  \ order. If list has more than 1 duplicate of the same\n// number, return False.\
  \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([5])\n\
  // true\n// >>> is_sorted([1, 2, 3, 4, 5])\n// true\n// >>> is_sorted([1, 3, 2,\
  \ 4, 5])\n// false\n// >>> is_sorted([1, 2, 3, 4, 5, 6])\n// true\n// >>> is_sorted([1,\
  \ 2, 3, 4, 5, 6, 7])\n// true\n// >>> is_sorted([1, 3, 2, 4, 5, 6, 7])\n// false\n\
  // >>> is_sorted([1, 2, 2, 3, 3, 4])\n// true\n// >>> is_sorted([1, 2, 2, 2, 3,\
  \ 4])\n// false\nfunction is_sorted(lst: number[]): boolean {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = is_sorted;\n  assert.deepEqual(candidate([5]),true);\n\
  \  assert.deepEqual(candidate([1, 2, 3, 4, 5]),true);\n  assert.deepEqual(candidate([1,\
  \ 3, 2, 4, 5]),false);\n  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6]),true);\n\
  \  assert.deepEqual(candidate([1, 2, 3, 4, 5, 6, 7]),true);\n  assert.deepEqual(candidate([1,\
  \ 3, 2, 4, 5, 6, 7]),false);\n  assert.deepEqual(candidate([]),true);\n  assert.deepEqual(candidate([1]),true);\n\
  \  assert.deepEqual(candidate([3, 2, 1]),false);\n  assert.deepEqual(candidate([1,\
  \ 2, 2, 2, 3, 4]),false);\n  assert.deepEqual(candidate([1, 2, 3, 3, 3, 4]),false);\n\
  \  assert.deepEqual(candidate([1, 2, 2, 3, 3, 4]),true);\n  assert.deepEqual(candidate([1,\
  \ 2, 3, 4]),true);\n}\n\ntest();"
completions: ["  if (lst.length <= 1) return true;\n  const map = new Map<number,\
    \ boolean>();\n  for (const num of lst) {\n    const exists = map.get(num);\n\
    \    if (exists) return false;\n    map.set(num, true);\n  }\n  return true;\n\
    }\n", "  if (lst.length < 2) {\n    return true;\n  }\n  const map = new Map<number,\
    \ boolean>();\n  for (let i = 0; i < lst.length; i++) {\n    const key = lst[i];\n\
    \    if (map.has(key)) {\n      return false;\n    }\n    map.set(key, true);\n\
    \  }\n  return true;\n}\n", "  if (lst.length <= 1) {\n    return true;\n  }\n\
    \  const hashMap = new Map<number, boolean>();\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const val = lst[i];\n    if (hashMap.has(val)) {\n      return false;\n\
    \    }\n    hashMap.set(val, true);\n  }\n  return true;\n}\n", "  if (lst.length\
    \ < 2) {\n    return true;\n  }\n  for (let i = 0; i < lst.length - 1; i++) {\n\
    \    if (lst[i] === lst[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n\
    }\n", "  if (lst.length <= 1) return true;\n  const seen = new Set<number>();\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (seen.has(lst[i])) return false;\n\
    \    seen.add(lst[i]);\n  }\n  return true;\n}\n", "\tlet sorted: boolean = true;\n\
    \tfor (let i = 0; i < lst.length; i++) {\n\t\tlet num: number = lst[i];\n\t\t\
    let j: number = i;\n\t\twhile (j > 0 && lst[j - 1] > num) {\n\t\t\tlst[j] = lst[j\
    \ - 1];\n\t\t\tj--;\n\t\t}\n\t\tlst[j] = num;\n\t}\n\treturn sorted;\n}\n", " \
    \ if (lst.length < 2) {\n    return true;\n  }\n  const map = new Map<number,\
    \ number>();\n  for (let i = 0; i < lst.length; i++) {\n    const key = lst[i];\n\
    \    if (map.has(key)) {\n      return false;\n    }\n    map.set(key, i);\n \
    \ }\n  return true;\n}\n", "  if (lst.length < 2) {\n    return true;\n  }\n \
    \ const last = lst[lst.length - 1];\n  for (let i = 0; i < lst.length - 1; i++)\
    \ {\n    if (lst[i] === last) {\n      return false;\n    }\n  }\n  return true;\n\
    }\n", "  if (lst.length <= 1) return true;\n  for (let i = 0; i < lst.length -\
    \ 1; i++) {\n    if (lst[i] === lst[i + 1]) return false;\n  }\n  return true;\n\
    }\n", "  if (lst.length <= 1) {\n    return true;\n  }\n  const map = new Map();\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const key = lst[i];\n    if (map.has(key))\
    \ {\n      return false;\n    }\n    map.set(key, true);\n  }\n  return true;\n\
    }\n", "  if (lst.length <= 1) return true;\n  let last: number[] = [];\n  for\
    \ (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[last[i]]) {\n   \
    \   return false;\n    }\n    last[i] = lst[i];\n  }\n  return true;\n}\n", " \
    \ if (lst.length <= 1) {\n    return true;\n  }\n  let hashmap = new Map<number,\
    \ boolean>();\n  for (let i = 0; i < lst.length; i++) {\n    if (hashmap.has(lst[i]))\
    \ {\n      return false;\n    }\n    hashmap.set(lst[i], true);\n  }\n  return\
    \ true;\n}\n", "  if (lst.length <= 1) {\n    return lst.length <= 1;\n  }\n \
    \ const last = lst[lst.length - 1];\n  for (let i = 0; i < lst.length - 1; i++)\
    \ {\n    if (lst[i] === last) {\n      return false;\n    }\n  }\n  return true;\n\
    }\n", "  if (lst.length <= 1) return true;\n  for (let i = 0; i < lst.length -\
    \ 1; i++) {\n    if (lst[i] === lst[i + 1]) return false;\n  }\n  return true;\n\
    }\n", "  if (lst.length <= 1) return true\n  const last = lst.pop()\n  for (const\
    \ num of lst) {\n    if (num === last) return false\n  }\n  return true\n}\n",
  "  if (lst.length <= 1) return true;\n  const map = new Map<number, number>();\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const val = lst[i];\n    if (map.has(val))\
    \ {\n      return false;\n    }\n    map.set(val, i);\n  }\n  return true;\n}\n",
  "  if (lst.length < 2) return true;\n  for (let i = 0; i < lst.length - 1; i++)\
    \ {\n    if (lst[i] === lst[i + 1]) return false;\n  }\n  return true;\n}\n",
  "  if (lst.length < 2) {\n    return true;\n  }\n  const map = new Map<number, boolean>();\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (map.has(num))\
    \ {\n      return false;\n    }\n    map.set(num, true);\n  }\n  return true;\n\
    }\n", "  const len = lst.length;\n  if (len < 2) return true;\n  const map = new\
    \ Map<number, number>();\n  for (let i = 0; i < len; i++) {\n    const item =\
    \ lst[i];\n    if (map.has(item)) {\n      return false;\n    }\n    map.set(item,\
    \ i);\n  }\n  return true;\n}\n", "  if (lst.length <= 1) return true;\n  const\
    \ map = new Map<number, boolean>();\n  for (let i = 0; i < lst.length; i++) {\n\
    \    const num = lst[i];\n    if (map.has(num)) {\n      return false;\n    }\n\
    \    map.set(num, true);\n  }\n  return true;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
