name: HumanEval_115_max_fill
language: ts
prompt: "//You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n// and each 1 in a row represents a single unit of water.\n// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n// and\
  \ all buckets have the same capacity.\n// Your task is to use the buckets to empty\
  \ the wells.\n// Output the number of times you need to lower the buckets.\n// Example\
  \ 1:\n// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n// 6\n// Example\
  \ 2:\n// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
  \ 2)\n// 5\n// Example 3:\n// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n// 0\n//\
  \ Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n\
  // * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity\
  \ <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0,\
  \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0,\
  \ 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n\
  }\n\ntest();"
completions: ["    let max = 0;\n    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count++;\n                let bucket = grid[i][j];\n\
    \                for (let k = bucket; k >= 1; k--) {\n                    grid[i][j]\
    \ = 0;\n                }\n                grid[i][j] = bucket;\n            \
    \    max = Math.max(max, count);\n                count = 0;\n            }\n\
    \        }\n    }\n    return max;\n}\n", "    const n = grid.length\n    const\
    \ m = grid[0].length\n    const buckets = new Array(n)\n    for (let i = 0; i\
    \ < n; i++) {\n        buckets[i] = new Array(m)\n    }\n    for (let i = 0; i\
    \ < n; i++) {\n        for (let j = 0; j < m; j++) {\n            buckets[i][j]\
    \ = grid[i][j] ? capacity : 0\n        }\n    }\n    let count = 0\n    for (let\
    \ i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if\
    \ (buckets[i][j] > 0) {\n                buckets[i][j] -= 1\n                count\
    \ += 1\n            }\n        }\n    }\n    return count\n}\n", "    let result\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n            \
    \    let bucket = grid[i][j];\n                for (let k = j; k < grid[i].length;\
    \ k++) {\n                    grid[i][k] = 0;\n                }\n           \
    \     for (let k = j; k < bucket; k++) {\n                    grid[i][k] = 1;\n\
    \                }\n                for (let k = j + 1; k < bucket; k++) {\n \
    \                   grid[i][k] = 1;\n                }\n                for (let\
    \ k = j + 1; k < grid[i].length; k++) {\n                    grid[i][k] = 0;\n\
    \                }\n                for (let k = j + 1; k < bucket; k++) {\n \
    \                   grid[i][k] = 1;\n                }\n                for (let\
    \ k = j + 1; k < bucket; k++) {\n                    grid[i][k] = 1;\n       \
    \         }\n                for (let k = j + 1; k < bucket; k++) {\n        \
    \            grid[i][k] = 0;\n                }\n                for (let k =\
    \ j + 1; k < bucket; k++) {\n                    grid[i][k] = 1;\n           \
    \     }\n                for (let k = j + 1; k < bucket; k++) {\n            \
    \        grid[i][k] = 1;\n                }\n                for (let k = j +\
    \ 1; k < bucket; k++) {\n                    grid[i][k] = 0;\n               \
    \ }\n                for (let k = j + 1; k < bucket; k++) {\n                \
    \    grid[i][k] = 1;\n                }\n                for (let k = j + 1; k\
    \ < bucket; k++) {\n                    grid[i][k] = 1;\n                }\n \
    \               for (let k = j + 1; k < bucket; k++) {\n                    grid[i][k]\
    \ = 0;\n                }\n                for (let k = j + 1; k < bucket; k++)\
    \ {\n                    grid[i][k] = 1;\n                }\n                for\
    \ (let k = j + 1; k < bucket; k++) {\n                    grid[i][k] = 1;\n  \
    \              }\n                for (let k = j + 1; k < bucket; k++) {\n   \
    \                 grid[i][k] = 0;\n                }\n                for (let\
    \ k = j + 1; k < bucket; k++) {\n                    grid[i][k] = 1;\n       \
    \         }\n                for (let k = j + 1; k < bucket; k++) {\n        \
    \            grid[i][k] = 1;\n                }\n                for (let k =\
    \ j + 1; k < bucket; k++) {\n                    grid[i][k] = 0;\n           \
    \     }\n                for (let k = j + 1; k < bucket; k++) {\n            \
    \        grid[i][k] = 1;\n                }\n                for (let k = j +\
    \ 1; k < bucket; k++) {\n                    grid[i][k] = 1;\n               \
    \ }\n                for (let k = j + 1; k < bucket; k++) {\n                \
    \    grid[i][k] = 0;\n                }\n                for (let k = ", "   \
    \ let count = 0;\n    let minCapacity = grid[0].length;\n    for (let i = 0; i\
    \ < grid.length; i++) {\n        let buckets = grid[i];\n        for (let j =\
    \ 0; j < buckets.length; j++) {\n            if (buckets[j] > 0) {\n         \
    \       buckets[j] -= 1;\n                if (buckets[j] < minCapacity) {\n  \
    \                  minCapacity = buckets[j];\n                }\n            }\n\
    \        }\n    }\n    for (let i = 0; i < minCapacity; i++) {\n        count\
    \ += minCapacity - i;\n    }\n    return count;\n}\n", "    let result = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                let bucket = grid[i][j];\n\
    \                for (let k = 0; k < bucket; k++) {\n                    grid[i][j]\
    \ = 0;\n                }\n                result += 1;\n            }\n     \
    \   }\n    }\n    return result;\n}\n", "    let max = 0;\n    for (let i = 0;\
    \ i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (grid[i][j] === 1) {\n                let bucket = grid[i][j];\n\
    \                for (let k = i; k < i + bucket; k++) {\n                    for\
    \ (let l = j; l < j + bucket; l++) {\n                        grid[k][l] = 0;\n\
    \                    }\n                }\n                for (let k = i; k <\
    \ i + bucket; k++) {\n                    for (let l = j; l < j + bucket; l++)\
    \ {\n                        grid[k][l] = 1;\n                    }\n        \
    \        }\n                for (let k = i; k < i + bucket; k++) {\n         \
    \           for (let l = j; l < j + bucket; l++) {\n                        grid[k][l]\
    \ = bucket;\n                    }\n                }\n                max +=\
    \ bucket - 1;\n            }\n        }\n    }\n    return max;\n}\n", "    let\
    \ max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j =\
    \ 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n       \
    \         let bucket = grid[i][j];\n                let count = 0;\n         \
    \       while (bucket > 0) {\n                    bucket = bucket - 1;\n     \
    \               count++;\n                }\n                if (count > max)\
    \ {\n                    max = count;\n                }\n            }\n    \
    \    }\n    }\n    return max;\n}", "    let result = 0;\n    for (let i = 0;\
    \ i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (grid[i][j] === 1) {\n                let bucket = grid[i][j];\n\
    \                let count = 0;\n                for (let x = i - 1; x <= i +\
    \ 1; x++) {\n                    for (let y = j - 1; y <= j + 1; y++) {\n    \
    \                    if (x >= 0 && x < grid.length && y >= 0 && y < grid[x].length)\
    \ {\n                            if (grid[x][y] === bucket) {\n              \
    \                  count++;\n                            }\n                 \
    \       }\n                    }\n                }\n                if (count\
    \ > capacity) {\n                    result = Math.max(result, count - capacity);\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\n",
  "    const n = grid.length;\n    const m = grid[0].length;\n    let count = 0;\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n  \
    \          if (grid[i][j] === 1) {\n                let bucket = grid[i][j];\n\
    \                while (bucket > 0) {\n                    grid[i][j] = 0;\n \
    \                   bucket--;\n                    count++;\n                }\n\
    \            }\n        }\n    }\n    return count;\n}\n", "    let result = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        let bucket = grid[i][0];\n\
    \        for (let j = 0; j < grid[i].length; j++) {\n            if (bucket <\
    \ capacity) {\n                bucket += grid[i][j];\n                result +=\
    \ 1;\n            }\n        }\n    }\n    return result;\n}\n", "    let buckets:\
    \ number[][] = [];\n    for (let i = 0; i < grid.length; i++) {\n        buckets[i]\
    \ = [];\n        for (let j = 0; j < grid[i].length; j++) {\n            buckets[i][j]\
    \ = grid[i][j];\n        }\n    }\n    let count = 0;\n    for (let i = 0; i <\
    \ buckets.length; i++) {\n        for (let j = 0; j < buckets[i].length; j++)\
    \ {\n            if (buckets[i][j] === 0) {\n                count++;\n      \
    \          for (let k = j + 1; k < buckets[i].length; k++) {\n               \
    \     buckets[i][k] = 0;\n                }\n            }\n        }\n    }\n\
    \    return count;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                let bucket = grid[i][j];\n                while (bucket\
    \ > 0) {\n                    grid[i][j] = 0;\n                    bucket--;\n\
    \                    count++;\n                }\n            }\n        }\n \
    \   }\n    return count;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let buckets = new Array(capacity);\n    for (let i = 0; i < buckets.length;\
    \ i++) {\n        buckets[i] = 0;\n    }\n    for (let i = 0; i < n; i++) {\n\
    \        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n\
    \                buckets[grid[i][j]] += 1;\n            }\n        }\n    }\n\
    \    let ans = 0;\n    for (let i = 0; i < buckets.length; i++) {\n        if\
    \ (buckets[i] > 0) {\n            ans += buckets[i];\n            buckets[i] -=\
    \ 1;\n        }\n    }\n    return ans;\n}\n", "    let max = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                let bucket = grid[i][j];\n\
    \                for (let k = i; k < grid.length; k++) {\n                   \
    \ for (let l = j; l < grid[k].length; l++) {\n                        if (grid[k][l]\
    \ === 0) {\n                            bucket -= 1;\n                       \
    \     if (bucket === 0) {\n                                max = Math.max(max,\
    \ k - i);\n                                max = Math.max(max, l - j);\n     \
    \                       }\n                        }\n                    }\n\
    \                }\n            }\n        }\n    }\n    return max;\n}\n", " \
    \   let max = 0;\n    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                let bucket = grid[i][j];\n                while (bucket\
    \ > 0) {\n                    bucket--;\n                    count++;\n      \
    \          }\n            }\n        }\n    }\n    max = count;\n    return max;\n\
    }", "    let result = 0;\n    for (let i = 0; i < grid.length; i++) {\n      \
    \  for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] ===\
    \ 1) {\n                for (let k = 0; k < capacity; k++) {\n               \
    \     grid[i][j] = 0;\n                }\n                result += 1;\n     \
    \       }\n        }\n    }\n    return result;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let buckets = new Array(n);\n    for (let i\
    \ = 0; i < n; i++) {\n        buckets[i] = new Array(m);\n        for (let j =\
    \ 0; j < m; j++) {\n            buckets[i][j] = grid[i][j] ? capacity : 0;\n \
    \       }\n    }\n    let count = 0;\n    for (let i = 0; i < n; i++) {\n    \
    \    for (let j = 0; j < m; j++) {\n            if (buckets[i][j] > 0) {\n   \
    \             buckets[i][j] -= 1;\n                count += 1;\n            }\n\
    \        }\n    }\n    return count;\n}", "    const n = grid.length;\n    if\
    \ (n === 0) {\n        return 0;\n    }\n    const m = grid[0].length;\n    if\
    \ (m === 0) {\n        return 0;\n    }\n    const buckets = new Array(capacity).fill(0);\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n  \
    \          if (grid[i][j] === 1) {\n                buckets[grid[i][j]] += 1;\n\
    \            }\n        }\n    }\n    let count = 0;\n    for (let i = 0; i <\
    \ buckets.length; i++) {\n        if (buckets[i] === 0) {\n            count +=\
    \ 1;\n        }\n    }\n    return count;\n}\n", "    let result = 0;\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        let buckets = grid[i];\n      \
    \  for (let j = 0; j < buckets.length; j++) {\n            if (buckets[j] > 0)\
    \ {\n                buckets[j]--;\n                result += 1;\n           \
    \ }\n        }\n    }\n    return result;\n}", "    let result = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                let bucket = grid[i][j];\n\
    \                let count = 0;\n                for (let k = i; k < i + bucket;\
    \ k++) {\n                    for (let l = j; l < j + bucket; l++) {\n       \
    \                 if (grid[k][l] === 1) {\n                            count++;\n\
    \                        }\n                    }\n                }\n       \
    \         if (count > capacity) {\n                    result = Math.max(result,\
    \ count - capacity);\n                }\n            }\n        }\n    }\n   \
    \ return result;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
