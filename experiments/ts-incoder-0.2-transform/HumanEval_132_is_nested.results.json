{
  "language": "ts",
  "name": "HumanEval_132_is_nested",
  "results": [
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] == \"[\") {\n            stack.push(string[i]);\n        } else if (string[i] == \"]\") {\n            if (stack.length == 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    if (stack.length != 0) {\n        return false;\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpz3iq64q4.js:39:12)\n    at Object.<anonymous> (/tmp/tmpz3iq64q4.js:52:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333962
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_parens: number[] = [];\n\tlet close_parens: number[] = [];\n\tlet open_parens_stack: number[] = [];\n\tlet close_parens_stack: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_parens_stack_string: string = \"\";\n\tlet close_parens_stack_string: string = \"\";\n\tlet open_brackets_stack_string: string = \"\";\n\tlet close_brackets_stack_string: string = \"\";\n\tlet open_parens_stack_string_index: number = 0;\n\tlet close_parens_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_parens_stack_string_index: number = 0;\n\tlet close_parens_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_parens_stack_string_index: number = 0;\n\tlet close_parens_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_parens_stack_string_index: number = 0;\n\tlet close_parens_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_parens_stack_string_index: number = 0;\n\tlet close_parens_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_parens_stack_string_index: number = 0;\n\tlet close_parens_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_parens_stack_string_index: number = 0;\n\tlet close_parens_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_parens_stack_string_index\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp1dbois9v.ts(81,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333961
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet opening_brackets: number[] = [];\n\tlet closing_brackets: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_char_index: number[] = [];\n\tlet closing_char_index: number[] = [];\n\tlet opening_char_index2: number[] = [];\n\tlet closing_char_index2: number[] = [];\n\tlet opening_char_index3: number[] = [];\n\tlet closing_char_index3: number[] = [];\n\tlet opening_char_index4: number[] = [];\n\tlet closing_char_index4: number[] = [];\n\tlet opening_char_index5: number[] = [];\n\tlet closing_char_index5: number[] = [];\n\tlet opening_char_index6: number[] = [];\n\tlet closing_char_index6: number[] = [];\n\tlet opening_char_index7: number[] = [];\n\tlet closing_char_index7: number[] = [];\n\tlet opening_char_index8: number[] = [];\n\tlet closing_char_index8: number[] = [];\n\tlet opening_char_index9: number[] = [];\n\tlet closing_char_index9: number[] = [];\n\tlet opening_char_index10: number[] = [];\n\tlet closing_char_index10: number[] = [];\n\tlet opening_char_index11: number[] = [];\n\tlet closing_char_index11: number[] = [];\n\tlet opening_char_index12: number[] = [];\n\tlet closing_char_index12: number[] = [];\n\tlet opening_char_index13: number[] = [];\n\tlet closing_char_index13: number[] = [];\n\tlet opening_char_index14: number[] = [];\n\tlet closing_char_index14: number[] = [];\n\tlet opening_char_index15: number[] = [];\n\tlet closing_char_index15: number[] = [];\n\tlet opening_char_index16: number[] = [];\n\tlet closing_char_index16: number[] = [];\n\tlet opening_char_index17: number[] = [];\n\tlet closing_char_index17: number[] = [];\n\tlet opening_char_index18: number[] = [];\n\tlet closing_char_index18: number[] = [];\n\tlet opening_char_index19: number[] = [];\n\tlet closing_char_index19: \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpxl0ot3v4.ts(62,9): error TS1005: ',' expected.\n../../../../tmp/tmpxl0ot3v4.ts(84,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333962
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let open_brackets: number[] = [];\n    let closed_brackets: number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        let char = string[i];\n        if (char === '[') {\n            open_brackets.push(i);\n        } else if (char === ']') {\n            closed_brackets.push(i);\n        }\n    }\n    if (open_brackets.length !== closed_brackets.length) {\n        return false;\n    }\n    for (let i = 0; i < open_brackets.length; i++) {\n        let open_bracket = open_brackets[i];\n        let closed_bracket = closed_brackets[i];\n        if (open_bracket === closed_bracket) {\n            continue;\n        }\n        let open_brackets_count = open_brackets.length;\n        let closed_brackets_count = closed_brackets.length;\n        let open_brackets_index = open_bracket;\n        let closed_brackets_index = closed_bracket;\n        while (open_brackets_count > 0) {\n            let open_brackets_index = open_brackets[open_brackets_index - 1];\n            let closed_brackets_index = closed_brackets[closed_brackets_index - 1];\n            if (open_brackets_index === closed_brackets_index) {\n                open_brackets_count--;\n                closed_brackets_count--;\n            } else {\n                break;\n            }\n        }\n        if (open_brackets_count === 0 && closed_brackets_count === 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpzbe9esl8.ts(41,53): error TS2448: Block-scoped variable 'open_brackets_index' used before its declaration.\n../../../../tmp/tmpzbe9esl8.ts(42,57): error TS2448: Block-scoped variable 'closed_brackets_index' used before its declaration.\n",
      "timestamp": 1660333962
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: number[] = [];\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        let c = string[i];\n        if (c === \"[\") {\n            brackets.push(i);\n            open_brackets.push(i);\n        } else if (c === \"]\") {\n            close_brackets.push(i);\n        } else if (c === \"[\") {\n            open_brackets.push(i);\n        } else if (c === \"]\") {\n            brackets.push(i);\n        }\n    }\n    if (brackets.length === 0) {\n        return false;\n    }\n    for (let i = 0; i < brackets.length; i++) {\n        let start = brackets[i];\n        let end = close_brackets[i];\n        if (start === end) {\n            continue;\n        }\n        let open = open_brackets[i];\n        let close = close_brackets[i];\n        if (open === end) {\n            return false;\n        }\n        if (open < end) {\n            let left_bracket = string.substring(open, start);\n            let right_bracket = string.substring(end, close);\n            if (left_bracket.includes(\"[\")) {\n                return false;\n            }\n            if (right_bracket.includes(\"[\")) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpw9sw5o20.js:67:12)\n    at Object.<anonymous> (/tmp/tmpw9sw5o20.js:81:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333962
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            stack.push(string[i]);\n        } else if (string[i] === \"]\") {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpzojs0i1x.js:36:12)\n    at Object.<anonymous> (/tmp/tmpzojs0i1x.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333962
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let bracketCount = 0;\n    let openingBracketCount = 0;\n    let closingBracketCount = 0;\n    let openingBrackets: number[] = [];\n    let closingBrackets: number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        const char = string[i];\n        if (char === '[') {\n            openingBracketCount++;\n            openingBrackets.push(openingBracketCount);\n        } else if (char === ']') {\n            closingBracketCount++;\n            closingBrackets.push(closingBracketCount);\n        } else if (char === '[' && openingBracketCount > closingBracketCount) {\n            openingBracketCount--;\n            openingBrackets.push(openingBracketCount);\n        } else if (char === ']' && openingBracketCount < closingBracketCount) {\n            closingBracketCount--;\n            closingBrackets.push(closingBracketCount);\n        }\n    }\n    for (let i = 0; i < openingBrackets.length; i++) {\n        if (closingBrackets[i] === openingBrackets[i] - 1) {\n            return true;\n        }\n    }\n    return false;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmplmoakxrc.js:51:12)\n    at Object.<anonymous> (/tmp/tmplmoakxrc.js:66:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333962
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet opening_brackets: number[] = [];\n\tlet closing_brackets: number[] = [];\n\tlet opening_square_brackets: number[] = [];\n\tlet closing_square_brackets: number[] = [];\n\tlet opening_curly_brackets: number[] = [];\n\tlet closing_curly_brackets: number[] = [];\n\tlet opening_angle_brackets: number[] = [];\n\tlet closing_angle_brackets: number[] = [];\n\tlet opening_parenthesis: number[] = [];\n\tlet closing_parenthesis: number[] = [];\n\tlet opening_square_parenthesis: number[] = [];\n\tlet closing_square_parenthesis: number[] = [];\n\tlet opening_curly_parenthesis: number[] = [];\n\tlet closing_curly_parenthesis: number[] = [];\n\tlet opening_angled_brackets: number[] = [];\n\tlet closing_angled_brackets: number[] = [];\n\tlet opening_parenthesis_brackets: number[] = [];\n\tlet closing_parenthesis_brackets: number[] = [];\n\tlet opening_square_parenthesis_brackets: number[] = [];\n\tlet closing_square_parenthesis_brackets: number[] = [];\n\tlet opening_curly_parenthesis_brackets: number[] = [];\n\tlet closing_curly_parenthesis_brackets: number[] = [];\n\tlet opening_angled_brackets_brackets: number[] = [];\n\tlet closing_angled_brackets_brackets: number[] = [];\n\tlet opening_parenthesis_brackets_brackets: number[] = [];\n\tlet closing_parenthesis_brackets_brackets: number[] = [];\n\tlet opening_square_parenthesis_brackets_brackets: number[] = [];\n\tlet closing_square_parenthesis_brackets_brackets: number[] = [];\n\tlet opening_curly_parenthesis_brackets_brackets: number[] = [];\n\tlet closing_curly_parenthesis_brackets_brackets: number[] = [];\n\tlet opening_angled_brackets_brackets_brackets: number[] = [];\n\tlet closing_angled_brackets_brackets_brackets: number[] = [];\n\tlet opening_parenthesis_brackets_brackets_brackets: number[] = [];\n\tlet closing_parenthesis_brackets_brackets_brackets: number[] = [];\n\tlet opening_square_parenthesis_brackets_brackets_brackets: number[] = [];\n\tlet closing_square_parenthesis_brackets_brackets_brackets: number\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp41pyvp43.ts(76,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333962
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_brackets_size: number = 0;\n\tlet close_brackets_size: number = 0;\n\tlet open_brackets_index = 0;\n\tlet close_brackets_index = 0;\n\tlet open_brackets_index_in_string = 0;\n\tlet close_brackets_index_in_string = 0;\n\tlet open_brackets_index_in_string2 = 0;\n\tlet close_brackets_index_in_string2 = 0;\n\tlet open_brackets_index_in_string3 = 0;\n\tlet close_brackets_index_in_string3 = 0;\n\tlet open_brackets_index_in_string4 = 0;\n\tlet close_brackets_index_in_string4 = 0;\n\tlet open_brackets_index_in_string5 = 0;\n\tlet close_brackets_index_in_string5 = 0;\n\tlet open_brackets_index_in_string6 = 0;\n\tlet close_brackets_index_in_string6 = 0;\n\tlet open_brackets_index_in_string7 = 0;\n\tlet close_brackets_index_in_string7 = 0;\n\tlet open_brackets_index_in_string8 = 0;\n\tlet close_brackets_index_in_string8 = 0;\n\tlet open_brackets_index_in_string9 = 0;\n\tlet close_brackets_index_in_string9 = 0;\n\tlet open_brackets_index_in_string10 = 0;\n\tlet close_brackets_index_in_string10 = 0;\n\tlet open_brackets_index_in_string11 = 0;\n\tlet close_brackets_index_in_string11 = 0;\n\tlet open_brackets_index_in_string12 = 0;\n\tlet close_brackets_index_in_string12 = 0;\n\tlet open_brackets_index_in_string13 = 0;\n\tlet close_brackets_index_in_string13 = 0;\n\tlet open_brackets_index_in_string14 = 0;\n\tlet close_brackets_index_in_string14 = 0;\n\tlet open_brackets_index_in_string15 = 0;\n\tlet close_brackets_index_in_string15 = 0;\n\tlet open_brackets_index_in_string16 = 0;\n\tlet close_brackets_index_in_string16 = 0;\n\tlet open_brackets_index_in_string17 = 0;\n\tlet close\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpam5etfu2.ts(81,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333962
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    if (string === \"\") {\n        return false;\n    }\n    let brackets = 0;\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            brackets++;\n        }\n        if (string[i] === \"]\") {\n            brackets--;\n        }\n    }\n    return brackets === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpr5pi57mu.js:36:12)\n    at Object.<anonymous> (/tmp/tmpr5pi57mu.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333962
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_size: number[] = [];\n\tlet close_brackets_size: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpqkuai67v.ts(61,9): error TS1005: ',' expected.\n../../../../tmp/tmpqkuai67v.ts(83,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333962
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet closed_brackets: number[] = [];\n\tlet open_chars: number[] = [];\n\tlet close_chars: number[] = [];\n\tlet open_char_index: number[] = [];\n\tlet close_char_index: number[] = [];\n\tlet open_brackets_index: number[] = [];\n\tlet closed_brackets_index: number[] = [];\n\tlet open_char_indexes: number[] = [];\n\tlet close_char_indexes: number[] = [];\n\tlet open_brackets_indexes: number[] = [];\n\tlet closed_brackets_indexes: number[] = [];\n\tlet open_char_indexes_count: number[] = [];\n\tlet close_char_indexes_count: number[] = [];\n\tlet open_brackets_indexes_count: number[] = [];\n\tlet closed_brackets_indexes_count: number[] = [];\n\tlet open_char_indexes_count: number[] = [];\n\tlet close_char_indexes_count: number[] = [];\n\tlet open_brackets_indexes_count: number[] = [];\n\tlet closed_brackets_indexes_count: number[] = [];\n\tlet open_char_indexes_count: number[] = [];\n\tlet close_char_indexes_count: number[] = [];\n\tlet open_brackets_indexes_count: number[] = [];\n\tlet closed_brackets_indexes_count: number[] = [];\n\tlet open_char_indexes_count: number[] = [];\n\tlet close_char_indexes_count: number[] = [];\n\tlet open_brackets_indexes_count: number[] = [];\n\tlet closed_brackets_indexes_count: number[] = [];\n\tlet open_char_indexes_count: number[] = [];\n\tlet close_char_indexes_count: number[] = [];\n\tlet open_brackets_indexes_count: number[] = [];\n\tlet closed_brackets_indexes_count: number[] = [];\n\tlet open_char_indexes_count: number[] = [];\n\tlet close_char_indexes_count: number[] = [];\n\tlet open_brackets_indexes_count: number[] = [];\n\tlet closed_brackets_indexes_count: number[] = [];\n\tlet open_char_indexes_count: number[] = [];\n\tlet close_char_indexes_count: number[] = [];\n\tlet open_brackets_indexes_count: number[] = [];\n\tlet closed_brackets_indexes_count: number[] = [];\n\tlet open_char_indexes_count: number[] = [];\n\tlet close_char_indexes_count: number[] = [];\n\tlet open_brackets_indexes_count: \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp7r5w9smq.ts(61,9): error TS1005: ',' expected.\n../../../../tmp/tmp7r5w9smq.ts(83,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333962
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number = 0;\n\tlet close_brackets: number = 0;\n\tlet open_brackets_stack: string[] = [];\n\tlet close_brackets_stack: string[] = [];\n\tlet open_brackets_length: number = 0;\n\tlet close_brackets_length: number = 0;\n\tlet open_brackets_stack_index: number = 0;\n\tlet close_brackets_stack_index: number = 0;\n\tlet open_brackets_length_index: number = 0;\n\tlet close_brackets_length_index: number = 0;\n\tlet open_brackets_stack_string: string = \"\";\n\tlet close_brackets_stack_string: string = \"\";\n\tlet open_brackets_length_string: string = \"\";\n\tlet close_brackets_length_string: string = \"\";\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_brackets_length_string_index: number = 0;\n\tlet close_brackets_length_string_index: number = 0;\n\tlet open_brackets_stack_indexed_string: string = \"\";\n\tlet close_brackets_stack_indexed_string: string = \"\";\n\tlet open_brackets_length_indexed_string: string = \"\";\n\tlet close_brackets_length_indexed_string: string = \"\";\n\tlet open_brackets_stack_indexed_string_index: number = 0;\n\tlet close_brackets_stack_indexed_string_index: number = 0;\n\tlet open_brackets_length_indexed_string_index: number = 0;\n\tlet close_brackets_length_indexed_string_index: number = 0;\n\tlet open_brackets_stack_indexed_string_indexed_string: string = \"\";\n\tlet close_brackets_stack_indexed_string_indexed_string: string = \"\";\n\tlet open_brackets_length_indexed_string_indexed_string: string = \"\";\n\tlet close_brackets_length_indexed_string_indexed_string: string = \"\";\n\tlet open_brackets_stack_indexed_string_indexed_string_index: number = 0;\n\tlet close_brackets_stack_indexed_string_indexed_string_index: number = 0;\n\tlet open_brackets_length_indexed_string_indexed_string_index: number = 0;\n\tlet close_brackets_length_indexed_string_indexed_string_index: number = 0;\n\tlet open_brackets_stack_indexed_string_indexed_string_indexed_string: string = \"\";\n\tlet close_b\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpoa1itipd.ts(75,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333962
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_parens: number[] = [];\n\tlet close_parens: number[] = [];\n\tlet bracket_count: string[] = [];\n\tlet paren_count: string[] = [];\n\tlet bracket_stack: string[] = [];\n\tlet paren_stack: string[] = [];\n\tlet bracket_open: string[] = [];\n\tlet paren_open: string[] = [];\n\tlet bracket_close: string[] = [];\n\tlet paren_close: string[] = [];\n\tlet bracket_open_index: number[] = [];\n\tlet paren_open_index: number[] = [];\n\tlet bracket_close_index: number[] = [];\n\tlet paren_close_index: number[] = [];\n\tlet bracket_open_count: string[] = [];\n\tlet paren_open_count: string[] = [];\n\tlet bracket_close_count: string[] = [];\n\tlet paren_close_count: string[] = [];\n\tlet bracket_open_index: number[] = [];\n\tlet paren_open_index: number[] = [];\n\tlet bracket_close_index: number[] = [];\n\tlet paren_close_index: number[] = [];\n\tlet bracket_open_count: string[] = [];\n\tlet paren_open_count: string[] = [];\n\tlet bracket_close_count: string[] = [];\n\tlet paren_close_count: string[] = [];\n\tlet bracket_open_index: number[] = [];\n\tlet paren_open_index: number[] = [];\n\tlet bracket_close_index: number[] = [];\n\tlet paren_close_index: number[] = [];\n\tlet bracket_open_count: string[] = [];\n\tlet paren_open_count: string[] = [];\n\tlet bracket_close_count: string[] = [];\n\tlet paren_close_count: string[] = [];\n\tlet bracket_open_index: number[] = [];\n\tlet paren_open_index: number[] = [];\n\tlet bracket_close_index: number[] = [];\n\tlet paren_close_index: number[] = [];\n\tlet bracket_open_count: string[] = [];\n\tlet paren_open_count: string[] = [];\n\tlet bracket_close_count: string[] = [];\n\tlet paren_close_count: string[] = [];\n\tlet bracket_open_index: number[] = [];\n\tlet paren_open_index: number[] = [];\n\tlet bracket_close_index: number[] = [];\n\tlet paren\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpjxs6a77l.ts(88,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333962
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: string[] = string.split(\"\");\n    let stack: string[] = [];\n    for (let i = 0; i < brackets.length; i++) {\n        if (brackets[i] == \"[\" || brackets[i] == \"(\") {\n            stack.push(brackets[i]);\n        } else if (brackets[i] == \"]\") {\n            if (stack.length == 0) {\n                return false;\n            }\n            stack.pop();\n        } else if (brackets[i] == \")\") {\n            if (stack.length == 0) {\n                return false;\n            }\n            stack.pop();\n        } else {\n            if (stack.length != 0) {\n                return false;\n            }\n        }\n    }\n    return stack.length == 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmp_hqv3mcx.js:48:12)\n    at Object.<anonymous> (/tmp/tmp_hqv3mcx.js:61:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333962
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_stack: number[] = [];\n\tlet close_stack: number[] = [];\n\tlet open_stack_index: number = 0;\n\tlet close_stack_index: number = 0;\n\tlet open_stack_string: string = \"\";\n\tlet close_stack_string: string = \"\";\n\tlet open_stack_string_index: number = 0;\n\tlet close_stack_string_index: number = 0;\n\tlet open_stack_string_len: number = 0;\n\tlet close_stack_string_len: number = 0;\n\tlet open_stack_string_len_index: number = 0;\n\tlet close_stack_string_len_index: number = 0;\n\tlet open_stack_string_len_len: number = 0;\n\tlet close_stack_string_len_len: number = 0;\n\tlet open_stack_string_len_index: number = 0;\n\tlet close_stack_string_len_index: number = 0;\n\tlet open_stack_string_len_len: number = 0;\n\tlet close_stack_string_len_len: number = 0;\n\tlet open_stack_string_len_index: number = 0;\n\tlet close_stack_string_len_index: number = 0;\n\tlet open_stack_string_len_len: number = 0;\n\tlet close_stack_string_len_len: number = 0;\n\tlet open_stack_string_len_index: number = 0;\n\tlet close_stack_string_len_index: number = 0;\n\tlet open_stack_string_len_len: number = 0;\n\tlet close_stack_string_len_len: number = 0;\n\tlet open_stack_string_len_index: number = 0;\n\tlet close_stack_string_len_index: number = 0;\n\tlet open_stack_string_len_len: number = 0;\n\tlet close_stack_string_len_len: number = 0;\n\tlet open_stack_string_len_index: number = 0;\n\tlet close_stack_string_len_index: number = 0;\n\tlet open_stack_string_len_len: number = 0;\n\tlet close_stack_string_len_len: number = 0;\n\tlet open_stack_string_len_index: number = 0;\n\tlet close_stack_string_len_index: number = 0;\n\tlet open_stack_string_len_len: number = 0;\n\tlet close_stack_string_len_len: number = 0;\n\tlet open_stack_string_len_index: number = 0;\n\tlet close_stack_string_len_index: number = 0;\n\tlet open_stack_string_len_len: number = 0;\n\tlet close_stack_string_len: number = 0;\n\tlet open_stack_string_len_index: number = 0;\n\tlet close_stack_string_len_index: number = 0;\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmprz3c2nt8.ts(87,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333962
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    if (string.length <= 1) {\n        return false;\n    }\n    let opening_brackets: number[] = [];\n    let closing_brackets: number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            opening_brackets.push(i);\n        } else if (string[i] === \"]\") {\n            closing_brackets.push(i);\n        }\n    }\n    if (opening_brackets.length < closing_brackets.length) {\n        return false;\n    }\n    for (let i = 0; i < opening_brackets.length; i++) {\n        let opening_bracket = opening_brackets[i];\n        let closing_bracket = closing_brackets[i];\n        for (let j = opening_bracket; j < closing_bracket; j++) {\n            if (string[j] === \"[\") {\n                if (is_nested(string[j + 1])\n                    || is_nested(string[j + 2])) {\n                    return true;\n                }\n            } else if (string[j] === \"]\") {\n                if (is_nested(string[j + 1])\n                    || is_nested(string[j + 2])) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "Exception",
      "stderr": "/tmp/tmpw9aox53k.js:17\n    if (string.length <= 1) {\n               ^\n\nTypeError: Cannot read properties of undefined (reading 'length')\n    at is_nested (/tmp/tmpw9aox53k.js:17:16)\n    at is_nested (/tmp/tmpw9aox53k.js:45:24)\n    at test (/tmp/tmpw9aox53k.js:56:22)\n    at Object.<anonymous> (/tmp/tmpw9aox53k.js:71:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333962
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    if (string.length <= 1) {\n        return false;\n    }\n    let open_brackets = 0;\n    let closed_brackets = 0;\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            open_brackets++;\n        } else if (string[i] === \"]\") {\n            closed_brackets++;\n        }\n    }\n    return open_brackets <= closed_brackets;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpjoe_c6q9.js:36:12)\n    at Object.<anonymous> (/tmp/tmpjoe_c6q9.js:50:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333962
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    // Create a stack to keep track of brackets\n    let stack: string[] = [];\n\n    // Iterate through each character in the string\n    for (let i = 0; i < string.length; i++) {\n        // If the current character is a bracket then push it to the stack\n        if (string[i] === \"[\") {\n            stack.push(string[i]);\n        }\n        // If the current character is a closing bracket then pop brackets from the stack\n        else if (string[i] === \"]\") {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n\n    // If there are any brackets left in the stack then there must be a nested bracket\n    if (stack.length > 0) {\n        return true;\n    }\n\n    // Otherwise there must be a valid subsequence of brackets\n    return false;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmpwerqt5rg.js:43:12)\n    at Object.<anonymous> (/tmp/tmpwerqt5rg.js:58:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333962
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: string[] = string.split(/\\[|\\]/);\n    let nestings: boolean[] = [];\n    for (let i = 0; i < brackets.length; i++) {\n        let bracket: string = brackets[i];\n        let opening: boolean = bracket.search(/\\[/) >= 0;\n        let closing: boolean = bracket.search(/\\]/) >= 0;\n        if (opening && closing) {\n            nestings.push(true);\n        } else if (opening) {\n            nestings.push(false);\n        } else if (closing) {\n            nestings.pop();\n        }\n    }\n    return nestings.indexOf(true) >= 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmptfg8sbli.js:38:12)\n    at Object.<anonymous> (/tmp/tmptfg8sbli.js:53:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333962
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number[] = [];\n\tlet closed_brackets: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet closed_brackets_stack: number[] = [];\n\tlet open_brackets_length = 0;\n\tlet closed_brackets_length = 0;\n\tlet open_brackets_index = 0;\n\tlet closed_brackets_index = 0;\n\tlet open_brackets_index_in_string = 0;\n\tlet closed_brackets_index_in_string = 0;\n\tlet open_brackets_index_in_string_in_string = 0;\n\tlet closed_brackets_index_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string = 0;\n\tlet closed_brackets_index_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet closed_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet closed_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet closed_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet closed_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet closed_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet closed_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet closed_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet closed_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet closed_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet closed_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet closed_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpgb9oqlxt.ts(76,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333962
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_curly: number[] = [];\n\tlet close_curly: number[] = [];\n\tlet open_curly_stack: number[] = [];\n\tlet close_curly_stack: number[] = [];\n\tlet open_paren: number[] = [];\n\tlet close_paren: number[] = [];\n\tlet open_paren_stack: number[] = [];\n\tlet close_paren_stack: number[] = [];\n\tlet open_paren_stack_string: string[] = [];\n\tlet close_paren_stack_string: string[] = [];\n\tlet open_curly_stack_string: string[] = [];\n\tlet close_curly_stack_string: string[] = [];\n\tlet open_paren_stack_string: string[] = [];\n\tlet close_paren_stack_string: string[] = [];\n\tlet open_curly_stack_string: string[] = [];\n\tlet close_curly_stack_string: string[] = [];\n\tlet open_paren_stack_string: string[] = [];\n\tlet close_paren_stack_string: string[] = [];\n\tlet open_curly_stack_string: string[] = [];\n\tlet close_curly_stack_string: string[] = [];\n\tlet open_paren_stack_string: string[] = [];\n\tlet close_paren_stack_string: string[] = [];\n\tlet open_curly_stack_string: string[] = [];\n\tlet close_curly_stack_string: string[] = [];\n\tlet open_paren_stack_string: string[] = [];\n\tlet close_paren_stack_string: string[] = [];\n\tlet open_curly_stack_string: string[] = [];\n\tlet close_curly_stack_string: string[] = [];\n\tlet open_paren_stack_string: string[] = [];\n\tlet close_paren_stack_string: string[] = [];\n\tlet open_curly_stack_string: string[] = [];\n\tlet close_curly_stack_string: string[] = [];\n\tlet open_paren_stack_string: string[] = [];\n\tlet close_paren_stack_string: string[] = [];\n\tlet open_curly_stack_string: string[] = [];\n\tlet close_curly_stack_string: string[] = [];\n\tlet open_paren_stack_string: string[] = [];\n\tlet close_paren_stack_string: string[] = [];\n\tlet open_curly_stack_string: string[] = [];\n\tlet close_curly_stack_string: string[] = [];\n\tlet open_paren_stack_string: string[] = [];\n\tlet close_paren_stack_string: string[] = [];\n\t\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp4m__u42m.ts(87,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333962
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            stack.push(\"[\")\n        } else if (string[i] === \"]\") {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.pop();\n        } else if (string[i] === \"[\") {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.push(\"[\")\n        } else if (string[i] === \"]\") {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    if (stack.length === 0) {\n        return true;\n    }\n    return false;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpma60vx7z.js:51:12)\n    at Object.<anonymous> (/tmp/tmpma60vx7z.js:64:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333962
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: string[] = string.split(\"\");\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_parens: number[] = [];\n\tlet close_parens: number[] = [];\n\tlet open_brackets_size: number = 0;\n\tlet close_brackets_size: number = 0;\n\tlet open_parens_size: number = 0;\n\tlet close_parens_size: number = 0;\n\tfor (let i = 0; i < brackets.length; i++) {\n\t\tif (brackets[i] == \"[\") {\n\t\t\topen_brackets.push(open_brackets_size);\n\t\t\tclose_brackets.push(close_brackets_size);\n\t\t\topen_parens.push(open_parens_size);\n\t\t\tclose_parens.push(close_parens_size);\n\t\t\topen_brackets_size++;\n\t\t} else if (brackets[i] == \"]\") {\n\t\t\topen_brackets_size--;\n\t\t\tclose_brackets_size--;\n\t\t\topen_parens_size--;\n\t\t\tclose_parens_size--;\n\t\t} else if (brackets[i] == \"(\") {\n\t\t\topen_brackets_size++;\n\t\t\topen_parens_size++;\n\t\t} else if (brackets[i] == \")\") {\n\t\t\tclose_brackets_size++;\n\t\t\tclose_parens_size++;\n\t\t}\n\t}\n\tif (open_brackets_size == 0 && close_brackets_size == 0 && open_parens_size == 0 && close_parens_size == 0) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmp9xdkqiw3.js:59:12)\n    at Object.<anonymous> (/tmp/tmp9xdkqiw3.js:74:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333965
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets = string.match(/\\[.*?\\]/g);\n    return brackets && brackets.length > 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpdgwxojgk.js:24:12)\n    at Object.<anonymous> (/tmp/tmpdgwxojgk.js:38:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333965
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number = 0;\n\tlet closed_brackets: number = 0;\n\tlet open_brackets_stack: string[] = [];\n\tlet closed_brackets_stack: string[] = [];\n\tlet open_brackets_length: number = 0;\n\tlet closed_brackets_length: number = 0;\n\tlet open_brackets_string: string = \"\";\n\tlet closed_brackets_string: string = \"\";\n\tlet open_brackets_string_index: number = 0;\n\tlet closed_brackets_string_index: number = 0;\n\tlet open_brackets_string_index2: number = 0;\n\tlet closed_brackets_string_index2: number = 0;\n\tlet open_brackets_string_index3: number = 0;\n\tlet closed_brackets_string_index3: number = 0;\n\tlet open_brackets_string_index4: number = 0;\n\tlet closed_brackets_string_index4: number = 0;\n\tlet open_brackets_string_index5: number = 0;\n\tlet closed_brackets_string_index5: number = 0;\n\tlet open_brackets_string_index6: number = 0;\n\tlet closed_brackets_string_index6: number = 0;\n\tlet open_brackets_string_index7: number = 0;\n\tlet closed_brackets_string_index7: number = 0;\n\tlet open_brackets_string_index8: number = 0;\n\tlet closed_brackets_string_index8: number = 0;\n\tlet open_brackets_string_index9: number = 0;\n\tlet closed_brackets_string_index9: number = 0;\n\tlet open_brackets_string_index10: number = 0;\n\tlet closed_brackets_string_index10: number = 0;\n\tlet open_brackets_string_index11: number = 0;\n\tlet closed_brackets_string_index11: number = 0;\n\tlet open_brackets_string_index12: number = 0;\n\tlet closed_brackets_string_index12: number = 0;\n\tlet open_brackets_string_index13: number = 0;\n\tlet closed_brackets_string_index13: number = 0;\n\tlet open_brackets_string_index14: number = 0;\n\tlet closed_brackets_string_index14: number = 0;\n\tlet open_brackets_string_index15: number = 0;\n\tlet closed_brackets_string_index15: number = 0;\n\tlet open_brackets_string_index16: number = 0;\n\tlet closed_brackets_string_index16: number = 0;\n\tlet open_b\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpy58t9e0f.ts(80,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333965
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: number[] = [];\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    let open_parens: number[] = [];\n    let close_parens: number[] = [];\n    let open_brackets_stack: number[] = [];\n    let close_brackets_stack: number[] = [];\n    let open_parens_stack: number[] = [];\n    let close_parens_stack: number[] = [];\n    let open_brackets_size: number[] = [];\n    let close_brackets_size: number[] = [];\n    let open_parens_size: number[] = [];\n    let close_parens_size: number[] = [];\n    let open_brackets_index: number[] = [];\n    let close_brackets_index: number[] = [];\n    let open_parens_index: number[] = [];\n    let close_parens_index: number[] = [];\n    let open_brackets_index_stack: number[] = [];\n    let close_brackets_index_stack: number[] = [];\n    let open_parens_index_stack: number[] = [];\n    let close_parens_index_stack: number[] = [];\n    let open_brackets_index_size: number[] = [];\n    let close_brackets_index_size: number[] = [];\n    let open_parens_index_size: number[] = [];\n    let close_parens_index_size: number[] = [];\n    let open_brackets_index_index: number[] = [];\n    let close_brackets_index_index: number[] = [];\n    let open_parens_index_index: number[] = [];\n    let close_parens_index_index: number[] = [];\n    let open_brackets_index_index_stack: number[] = [];\n    let close_brackets_index_index_stack: number[] = [];\n    let open_parens_index_index_stack: number[] = [];\n    let close_parens_index_index_stack: number[] = [];\n    let open_brackets_index_index_size: number[] = [];\n    let close_brackets_index_index_size: number[] = [];\n    let open_parens_index_index_size: number[] = [];\n    let close_parens_index_index_size: number[] = [];\n    let open_brackets_index_index_index: number[] = [];\n    let close_brackets_index_index_index: number[] = [];\n    let open_parens_index_index_index: number[] = [];\n    let close_parens_index_index_index: number[] = [];\n    let open_brackets_index_index_index_stack: number[] = [];\n    let close_brackets_index_index_index_stack: number[] = [];\n    let open_parens_index_index_index_stack: number[] = [];\n    let close_parens_index_index_index_stack: number[] = [];\n    let open_bracket\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp3szfm323.ts(85,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333965
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: string[] = string.split(\"\");\n\tlet open_brackets: number[] = [];\n\tlet closed_brackets: number[] = [];\n\tlet open_brackets_index = 0;\n\tlet closed_brackets_index = 0;\n\tfor (let i = 0; i < brackets.length; i++) {\n\t\tif (brackets[i] == \"[\") {\n\t\t\topen_brackets[open_brackets_index] = i;\n\t\t\topen_brackets_index++;\n\t\t} else if (brackets[i] == \"]\") {\n\t\t\tclosed_brackets[closed_brackets_index] = i;\n\t\t\tclosed_brackets_index++;\n\t\t}\n\t}\n\tif (open_brackets_index != closed_brackets_index) {\n\t\treturn false;\n\t}\n\tfor (let i = 0; i < open_brackets.length; i++) {\n\t\tlet open_bracket = open_brackets[i];\n\t\tlet closed_bracket = closed_brackets[i];\n\t\tlet open_brackets_count = open_brackets[open_bracket];\n\t\tlet closed_brackets_count = closed_brackets[closed_bracket];\n\t\tif (open_brackets_count != closed_brackets_count) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmpx7clwrw7.js:49:12)\n    at Object.<anonymous> (/tmp/tmpx7clwrw7.js:64:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333965
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            stack.push(string[i]);\n        } else if (string[i] === \"]\") {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    if (stack.length === 0) {\n        return true;\n    }\n    return false;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmp6tnjs2bh.js:39:12)\n    at Object.<anonymous> (/tmp/tmp6tnjs2bh.js:52:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333966
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    const stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        const char = string[i];\n        if (char === '[') {\n            stack.push(char);\n        } else if (char === ']') {\n            if (stack.length === 0) {\n                return false;\n            }\n            const openBracket = stack.pop();\n            if (openBracket !== '[') {\n                return false;\n            }\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpck4rf7gc.js:40:12)\n    at Object.<anonymous> (/tmp/tmpck4rf7gc.js:53:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333965
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number[] = [];\n\tlet closed_brackets: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet closed_brackets_stack: number[] = [];\n\tlet open_brackets_length = 0;\n\tlet closed_brackets_length = 0;\n\tlet open_brackets_index = 0;\n\tlet closed_brackets_index = 0;\n\tlet open_brackets_stack_index = 0;\n\tlet closed_brackets_stack_index = 0;\n\tlet open_brackets_stack_string = \"\";\n\tlet closed_brackets_stack_string = \"\";\n\tlet open_brackets_string = \"\";\n\tlet closed_brackets_string = \"\";\n\tlet open_brackets_string_index = 0;\n\tlet closed_brackets_string_index = 0;\n\tlet open_brackets_string_index2 = 0;\n\tlet closed_brackets_string_index2 = 0;\n\tlet open_brackets_string_index3 = 0;\n\tlet closed_brackets_string_index3 = 0;\n\tlet open_brackets_string_index4 = 0;\n\tlet closed_brackets_string_index4 = 0;\n\tlet open_brackets_string_index5 = 0;\n\tlet closed_brackets_string_index5 = 0;\n\tlet open_brackets_string_index6 = 0;\n\tlet closed_brackets_string_index6 = 0;\n\tlet open_brackets_string_index7 = 0;\n\tlet closed_brackets_string_index7 = 0;\n\tlet open_brackets_string_index8 = 0;\n\tlet closed_brackets_string_index8 = 0;\n\tlet open_brackets_string_index9 = 0;\n\tlet closed_brackets_string_index9 = 0;\n\tlet open_brackets_string_index10 = 0;\n\tlet closed_brackets_string_index10 = 0;\n\tlet open_brackets_string_index11 = 0;\n\tlet closed_brackets_string_index11 = 0;\n\tlet open_brackets_string_index12 = 0;\n\tlet closed_brackets_string_index12 = 0;\n\tlet open_brackets_string_index13 = 0;\n\tlet closed_brackets_string_index13 = 0;\n\tlet open_brackets_string_index14 = 0;\n\tlet closed_brackets_string_index14 = 0;\n\tlet open_brackets_string_index15 = 0;\n\tlet closed_brackets_string_index15 = 0;\n\tlet open_brackets_string_index16 = 0;\n\tlet closed_brackets_string_index16 = 0;\n\tlet open_brackets_string_index\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp7s_2zfpw.ts(86,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333965
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        let char = string[i];\n        if (char === '[') {\n            stack.push(\"[\" + char);\n        } else if (char === ']') {\n            if (stack.length == 0) {\n                return false;\n            }\n            let openBracket = stack.pop();\n            if (openBracket !== '[') {\n                return false;\n            }\n        } else if (char === '\\'') {\n            stack.push(\"'\" + char);\n        } else if (char === '\"') {\n            stack.push('\"' + char);\n        } else if (char === '{') {\n            stack.push(\"{\" + char);\n        } else if (char === '}') {\n            if (stack.length == 0) {\n                return false;\n            }\n            let openBracket = stack.pop();\n            if (openBracket !== '}') {\n                return false;\n            }\n        } else if (char === '\\\\') {\n            stack.push(char);\n        } else if (char === '\\n') {\n            if (stack.length == 0) {\n                return false;\n            }\n            let openBracket = stack.pop();\n            if (openBracket !== '\\n') {\n                return false;\n            }\n        } else if (char === '\\r') {\n            if (stack.length == 0) {\n                return false;\n            }\n            let openBracket = stack.pop();\n            if (openBracket !== '\\r') {\n                return false;\n            }\n        } else if (char === '\\t') {\n            if (stack.length == 0) {\n                return false;\n            }\n            let openBracket = stack.pop();\n            if (openBracket !== '\\t') {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n    if (stack.length != 0) {\n        return false;\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmpvsbw5jlv.js:92:12)\n    at Object.<anonymous> (/tmp/tmpvsbw5jlv.js:107:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333966
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    // Your code here\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpbsic2hck.ts(16,37): error TS2355: A function whose declared type is neither 'void' nor 'any' must return a value.\n",
      "timestamp": 1660333965
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number = 0;\n\tlet closed_brackets: number = 0;\n\tlet open_brackets_stack: string[] = [];\n\tlet closed_brackets_stack: string[] = [];\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlet char = string[i];\n\t\tif (char === '[') {\n\t\t\topen_brackets++;\n\t\t\topen_brackets_stack.push(char);\n\t\t} else if (char === ']') {\n\t\t\tclosed_brackets++;\n\t\t\tclosed_brackets_stack.push(char);\n\t\t} else if (char === '[' && open_brackets > 0 && closed_brackets > 0) {\n\t\t\topen_brackets--;\n\t\t\tclosed_brackets--;\n\t\t\tif (open_brackets === 0 && closed_brackets === 0) {\n\t\t\t\topen_brackets_stack.pop();\n\t\t\t\tclosed_brackets_stack.pop();\n\t\t\t\tif (open_brackets_stack.length > 0 && closed_brackets_stack.length > 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (char === ']' && open_brackets > 0 && closed_brackets > 0) {\n\t\t\topen_brackets--;\n\t\t\tclosed_brackets--;\n\t\t\tif (open_brackets === 0 && closed_brackets === 0) {\n\t\t\t\topen_brackets_stack.pop();\n\t\t\t\tclosed_brackets_stack.pop();\n\t\t\t\tif (open_brackets_stack.length > 0 && closed_brackets_stack.length > 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmppfm0b84y.js:59:12)\n    at Object.<anonymous> (/tmp/tmppfm0b84y.js:74:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333965
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets = string.match(/[\\[\\]]/g);\n\tlet nesting = false;\n\tlet nestingCount = 0;\n\tlet nestingDepth = 0;\n\tlet nestingDepthCount = 0;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\tlet nestingDepthCountMin = 2;\n\tlet nestingDepthCountMax = 20;\n\t\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpqfkodpb9.ts(92,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333965
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_index = 0;\n\tlet close_brackets_index = 0;\n\tlet open_brackets_length = 0;\n\tlet close_brackets_length = 0;\n\tlet brackets_length = 0;\n\tlet open_brackets_index_in_string = 0;\n\tlet close_brackets_index_in_string = 0;\n\tlet open_brackets_length_in_string = 0;\n\tlet close_brackets_length_in_string = 0;\n\tlet brackets_length_in_string = 0;\n\tlet open_brackets_index_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string = 0;\n\tlet open_brackets_length_in_string_in_string = 0;\n\tlet close_brackets_length_in_string_in_string = 0;\n\tlet brackets_length_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_length_in_string_in_string_in_string = 0;\n\tlet close_brackets_length_in_string_in_string_in_string = 0;\n\tlet brackets_length_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_length_in_string_in_string_in_string = 0;\n\tlet close_brackets_length_in_string_in_string_in_string = 0;\n\tlet brackets_length_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string_in_string_in_string = 0;\n\tlet open_brackets_length_in_string_in_string_in_string_in_string = 0;\n\tlet close_brackets_length_in_string_in_string_in_string_in_string = 0;\n\tlet brackets_length_in_string_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string_in_string_in_string = 0;\n\tlet open_brackets_length_in_string_in_string_in_string_in_string = 0;\n\tlet close_brackets_length_in_string_in_string_in_string_in_string = 0;\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpcsidm3mm.ts(76,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333965
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets = string.match(/\\[.*?\\]/g);\n    if (brackets) {\n        for (let i = 0; i < brackets.length; i++) {\n            if (brackets[i].match(/\\[.*?\\]/)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmphfa5iyhn.js:31:12)\n    at Object.<anonymous> (/tmp/tmphfa5iyhn.js:45:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333966
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_curly: number[] = [];\n\tlet close_curly: number[] = [];\n\tlet open_paren: number[] = [];\n\tlet close_paren: number[] = [];\n\tlet open_curly_or_paren: number[] = [];\n\tlet close_curly_or_paren: number[] = [];\n\tlet open_paren_or_curly: number[] = [];\n\tlet close_paren_or_curly: number[] = [];\n\tlet open_curly_or_paren_or_curly: number[] = [];\n\tlet close_curly_or_paren_or_curly: number[] = [];\n\tlet open_paren_or_curly_or_paren: number[] = [];\n\tlet close_paren_or_curly_or_paren: number[] = [];\n\tlet open_curly_or_paren_or_curly_or_paren: number[] = [];\n\tlet close_curly_or_paren_or_curly_or_paren: number[] = [];\n\tlet open_paren_or_curly_or_paren_or_curly: number[] = [];\n\tlet close_paren_or_curly_or_paren_or_curly: number[] = [];\n\tlet open_curly_or_paren_or_curly_or_paren_or_curly: number[] = [];\n\tlet close_paren_or_curly_or_paren_or_curly_or_paren: number[] = [];\n\tlet open_paren_or_curly_or_paren_or_curly_or_paren: number[] = [];\n\tlet close_paren_or_curly_or_paren_or_curly_or_paren_or_curly: number[] = [];\n\tlet open_curly_or_paren_or_curly_or_paren_or_curly_or_paren: number[] = [];\n\tlet close_paren_or_curly_or_paren_or_curly_or_paren_or_curly_or_paren: number[] = [];\n\tlet open_paren_or_curly_or_paren_or_curly_or_paren_or_curly_or_paren: number[] = [];\n\tlet close_paren_or_curly_or_paren_or_curly_or_paren_or_curly_or_paren_or_curly: number[] = [];\n\tlet open_curly_or_paren_or_curly_or_paren_or_curly_or_paren_or_curly_or_paren_or_curly: number[] = [];\n\tlet close_paren_or_curly_or_paren_or_curly_or_paren_or_curly_or_paren_or_curly_or_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpohhtmvyu.ts(68,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333965
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            stack.push(\"[\" + string[i]);\n        } else if (string[i] === \"]\") {\n            if (stack.length <= 0) {\n                return false;\n            }\n            stack.pop();\n        } else if (string[i] === \"[\") {\n            if (stack.length <= 0) {\n                return false;\n            }\n            stack.push(\"[\" + string[i]);\n        } else if (string[i] === \"]\") {\n            if (stack.length <= 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmplfz0_lzg.js:48:12)\n    at Object.<anonymous> (/tmp/tmplfz0_lzg.js:61:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333965
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_curly: number[] = [];\n\tlet close_curly: number[] = [];\n\tlet open_paren: number[] = [];\n\tlet close_paren: number[] = [];\n\tlet open_brackets_index: number[] = [];\n\tlet close_brackets_index: number[] = [];\n\tlet open_curly_index: number[] = [];\n\tlet close_curly_index: number[] = [];\n\tlet open_paren_index: number[] = [];\n\tlet close_paren_index: number[] = [];\n\tlet open_brackets_index_count: number[] = [];\n\tlet close_brackets_index_count: number[] = [];\n\tlet open_curly_index_count: number[] = [];\n\tlet close_curly_index_count: number[] = [];\n\tlet open_paren_index_count: number[] = [];\n\tlet close_paren_index_count: number[] = [];\n\tlet open_brackets_index_count_max: number[] = [];\n\tlet close_brackets_index_count_max: number[] = [];\n\tlet open_curly_index_count_max: number[] = [];\n\tlet close_curly_index_count_max: number[] = [];\n\tlet open_paren_index_count_max: number[] = [];\n\tlet close_paren_index_count_max: number[] = [];\n\tlet open_brackets_index_count_max_max: number[] = [];\n\tlet close_brackets_index_count_max_max: number[] = [];\n\tlet open_curly_index_count_max_max: number[] = [];\n\tlet close_curly_index_count_max_max: number[] = [];\n\tlet open_paren_index_count_max_max: number[] = [];\n\tlet close_paren_index_count_max_max: number[] = [];\n\tlet open_brackets_index_count_max_max_max: number[] = [];\n\tlet close_brackets_index_count_max_max_max: number[] = [];\n\tlet open_curly_index_count_max_max_max: number[] = [];\n\tlet close_curly_index_count_max_max_max: number[] = [];\n\tlet open_paren_index_count_max_max_max: number[] = [];\n\tlet close_paren_index_count_max_max_max: number[] = [];\n\tlet open_brackets_index_count_max_max_max_max: number[] = [];\n\tlet close_brackets_index_count_max_max_max_max: number[] = [];\n\tlet open_curly_index_count_max_max_max_max: number[] = [];\n\tlet close_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpys3e0i2b.ts(80,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333965
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            stack.push(\"[\" + string[i]);\n        } else if (string[i] === \"]\") {\n            if (stack.length > 0) {\n                let open = stack.pop();\n                if (open === \"[\") {\n                    stack.push(\"[\" + string[i]);\n                } else if (open === \"]\") {\n                    stack.push(\"]\");\n                }\n            }\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpz1zl258r.js:41:12)\n    at Object.<anonymous> (/tmp/tmpz1zl258r.js:54:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333965
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number = 0;\n\tlet close_brackets: number = 0;\n\tlet open_brackets_stack: string[] = [];\n\tlet close_brackets_stack: string[] = [];\n\tlet open_brackets_stack_string: string = \"\";\n\tlet close_brackets_stack_string: string = \"\";\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index2: number = 0;\n\tlet close_brackets_stack_string_index2: number = 0;\n\tlet open_brackets_stack_string_index3: number = 0;\n\tlet close_brackets_stack_string_index3: number = 0;\n\tlet open_brackets_stack_string_index4: number = 0;\n\tlet close_brackets_stack_string_index4: number = 0;\n\tlet open_brackets_stack_string_index5: number = 0;\n\tlet close_brackets_stack_string_index5: number = 0;\n\tlet open_brackets_stack_string_index6: number = 0;\n\tlet close_brackets_stack_string_index6: number = 0;\n\tlet open_brackets_stack_string_index7: number = 0;\n\tlet close_brackets_stack_string_index7: number = 0;\n\tlet open_brackets_stack_string_index8: number = 0;\n\tlet close_brackets_stack_string_index8: number = 0;\n\tlet open_brackets_stack_string_index9: number = 0;\n\tlet close_brackets_stack_string_index9: number = 0;\n\tlet open_brackets_stack_string_index10: number = 0;\n\tlet close_brackets_stack_string_index10: number = 0;\n\tlet open_brackets_stack_string_index11: number = 0;\n\tlet close_brackets_stack_string_index11: number = 0;\n\tlet open_brackets_stack_string_index12: number = 0;\n\tlet close_brackets_stack_string_index12: number = 0;\n\tlet open_brackets_stack_string_index13: number = 0;\n\tlet close_brackets_stack_string_index13: number = 0;\n\tlet open_brackets_stack_string_index14: number = 0;\n\tlet close_brackets_stack_string_index14: number = 0;\n\tlet open_brackets_stack_string_index15: number = 0;\n\tlet close_brackets_stack_string_index15: number = 0;\n\tlet open_b\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpa73zt2tq.ts(76,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333965
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] == '[') {\n            stack.push(string[i]);\n        } else if (string[i] == ']') {\n            if (stack.length == 0) {\n                return false;\n            }\n            let openBracket = stack.pop();\n            if (openBracket != string[i]) {\n                return false;\n            }\n        }\n    }\n    if (stack.length != 0) {\n        return false;\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmpcrk5qmr8.js:40:12)\n    at Object.<anonymous> (/tmp/tmpcrk5qmr8.js:55:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333966
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: number[] = [];\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    let open_brackets_stack: number[] = [];\n    let close_brackets_stack: number[] = [];\n    let bracket_stack: number[] = [];\n    let bracket_stack_length: number = 0;\n    let bracket_stack_index: number = 0;\n    let bracket_stack_last_index: number = 0;\n    let bracket_stack_last_index_length: number = 0;\n    let bracket_stack_last_index_length_index: number = 0;\n    let bracket_stack_last_index_length_index_stack: number[] = [];\n    let bracket_stack_last_index_length_index_stack_length: number = 0;\n    let bracket_stack_last_index_length_index_stack_length_index: number = 0;\n    let bracket_stack_last_index_length_index_stack_length_index_stack: number[] = [];\n    let bracket_stack_last_index_length_index_stack_length_index_stack_length: number = 0;\n    let bracket_stack_last_index_length_index_stack_length_index_stack_length_index: number = 0;\n    let bracket_stack_last_index_length_index_stack_length_index_stack_length_index_stack: number[] = [];\n    let bracket_stack_last_index_length_index_stack_length_index_stack_length_index_stack_length: number = 0;\n    let bracket_stack_last_index_length_index_stack_length_index_stack_length_index_stack_length_index: number = 0;\n    let bracket_stack_last_index_length_index_stack_length_index_stack_length_index_stack_length_index_stack: number[] = [];\n    let bracket_stack_last_index_length_index_stack_length_index_stack_length_index_stack_length_index_stack_length: number = 0;\n    let bracket_stack_last_index_length_index_stack_length_index_stack_length_index_stack_length_index_stack_length_index: number = 0;\n    let bracket_stack_last_index_length_index_stack_length_index_stack_length_index_stack_length_index_stack_length_index_stack: number[] = [];\n    let bracket_stack_last_index_length_index_stack_length_index_stack_length_index_stack_length_index_stack_length_index_stack_length: number = 0;\n    let bracket_stack_last_index_length_index_stack_length_index_stack_length_index_stack_length_index_stack_length_index_stack_length_index: number = 0;\n    let bracket_stack_last_index_length_index_stack_length_index_stack_length_index_stack_length_index_stack_length_index_stack_length_index_stack: number[] = [];\n    let bracket_stack_last_index_length_index_stack_length_index_stack_length_index_stack_length_index_stack_length_index_stack_length_index_stack_length: number = 0;\n    let bracket_stack_last_index_length_index_stack_length_index_stack_length_index_stack_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpr_ihxspc.ts(68,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333965
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    if (string.length <= 1) return false;\n    let brackets: string[] = string.split('');\n    let stack: string[] = [];\n    for (let i = 0; i < brackets.length; i++) {\n        let bracket = brackets[i];\n        if (bracket.match(/[\\[\\]]/)) {\n            if (stack.length <= 0) return false;\n            if (stack[stack.length - 1] != bracket) \n                return false;\n            stack.pop();\n        } else {\n            stack.push(bracket);\n        }\n    }\n    return stack.length <= 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmp9pxxwjle.js:39:12)\n    at Object.<anonymous> (/tmp/tmp9pxxwjle.js:54:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333966
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: string[] = string.split(/\\[|\\]/);\n\tlet nested: boolean = false;\n\tfor (let i = 0; i < brackets.length; i++) {\n\t\tif (brackets[i].includes(\"[\")) {\n\t\t\tnested = true;\n\t\t}\n\t}\n\treturn nested;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmp4uv99idp.js:29:12)\n    at Object.<anonymous> (/tmp/tmp4uv99idp.js:44:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333966
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let open_brackets: number[] = [];\n    let closed_brackets: number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] == \"[\") {\n            open_brackets.push(i);\n        } else if (string[i] == \"]\") {\n            closed_brackets.push(i);\n        }\n    }\n    if (open_brackets.length != closed_brackets.length) {\n        return false;\n    }\n    for (let i = 0; i < open_brackets.length; i++) {\n        let open_bracket = open_brackets[i];\n        let closed_bracket = closed_brackets[i];\n        for (let j = open_bracket; j < closed_bracket; j++) {\n            if (string[j] != string[j + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmpmp27mvsg.js:44:12)\n    at Object.<anonymous> (/tmp/tmpmp27mvsg.js:59:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333969
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet opening_brackets: number[] = [];\n\tlet closing_brackets: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\t\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpz154qdui.ts(91,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333968
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number = 0;\n\tlet close_brackets: number = 0;\n\tlet open_brackets_stack: string[] = [];\n\tlet close_brackets_stack: string[] = [];\n\tlet open_brackets_length: number = 0;\n\tlet close_brackets_length: number = 0;\n\tlet open_brackets_string: string = \"\";\n\tlet close_brackets_string: string = \"\";\n\tlet open_brackets_string_index: number = 0;\n\tlet close_brackets_string_index: number = 0;\n\tlet open_brackets_string_index2: number = 0;\n\tlet close_brackets_string_index2: number = 0;\n\tlet open_brackets_string_index3: number = 0;\n\tlet close_brackets_string_index3: number = 0;\n\tlet open_brackets_string_index4: number = 0;\n\tlet close_brackets_string_index4: number = 0;\n\tlet open_brackets_string_index5: number = 0;\n\tlet close_brackets_string_index5: number = 0;\n\tlet open_brackets_string_index6: number = 0;\n\tlet close_brackets_string_index6: number = 0;\n\tlet open_brackets_string_index7: number = 0;\n\tlet close_brackets_string_index7: number = 0;\n\tlet open_brackets_string_index8: number = 0;\n\tlet close_brackets_string_index8: number = 0;\n\tlet open_brackets_string_index9: number = 0;\n\tlet close_brackets_string_index9: number = 0;\n\tlet open_brackets_string_index10: number = 0;\n\tlet close_brackets_string_index10: number = 0;\n\tlet open_brackets_string_index11: number = 0;\n\tlet close_brackets_string_index11: number = 0;\n\tlet open_brackets_string_index12: number = 0;\n\tlet close_brackets_string_index12: number = 0;\n\tlet open_brackets_string_index13: number = 0;\n\tlet close_brackets_string_index13: number = 0;\n\tlet open_brackets_string_index14: number = 0;\n\tlet close_brackets_string_index14: number = 0;\n\tlet open_brackets_string_index15: number = 0;\n\tlet close_brackets_string_index15: number = 0;\n\tlet open_brackets_string_index16: number\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp294jpar5.ts(78,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333968
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number[] = [];\n\tlet closed_brackets: number[] = [];\n\tlet open_brackets_index = 0;\n\tlet closed_brackets_index = 0;\n\tlet open_brackets_length = 0;\n\tlet closed_brackets_length = 0;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_found = false;\n\tlet open_brackets_found = false;\n\tlet closed_brackets_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpkakyby0e.ts(93,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333969
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            stack.push(string[i]);\n        } else if (string[i] === \"]\") {\n            if (stack.length === 0) {\n                return false;\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpphmp2v9p.js:38:12)\n    at Object.<anonymous> (/tmp/tmpphmp2v9p.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333612
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_length: number[] = [];\n\tlet close_brackets_length: number[] = [];\n\tlet open_brackets_length_index: number[] = [];\n\tlet close_brackets_length_index: number[] = [];\n\tlet open_brackets_length_index_max: number[] = [];\n\tlet close_brackets_length_index_max: number[] = [];\n\tlet open_brackets_length_index_min: number[] = [];\n\tlet close_brackets_length_index_min: number[] = [];\n\tlet open_brackets_length_index_min_index: number[] = [];\n\tlet close_brackets_length_index_min_index: number[] = [];\n\tlet open_brackets_length_index_min_max: number[] = [];\n\tlet close_brackets_length_index_min_max: number[] = [];\n\tlet open_brackets_length_index_min_max_index: number[] = [];\n\tlet close_brackets_length_index_min_max_index: number[] = [];\n\tlet open_brackets_length_index_min_max_index_max: number[] = [];\n\tlet close_brackets_length_index_min_max_index_max: number[] = [];\n\tlet open_brackets_length_index_min_max_index_min: number[] = [];\n\tlet close_brackets_length_index_min_max_index_min: number[] = [];\n\tlet open_brackets_length_index_min_max_index_min_index: number[] = [];\n\tlet close_brackets_length_index_min_max_index_min_index: number[] = [];\n\tlet open_brackets_length_index_min_max_index_min_max: number[] = [];\n\tlet close_brackets_length_index_min_max_index_min_max: number[] = [];\n\tlet open_brackets_length_index_min_max_index_min_max_index: number[] = [];\n\tlet close_brackets_length_index_min_max_index_min_max_index: number[] = [];\n\tlet open_brackets_length_index_min_max_index_min_max_index_max: number[] = [];\n\tlet close_brackets_length_index_min_max_index_min_max_index_max: number[] = [];\n\tlet open_brackets_length_index_min_max_index_min_max_index_min: number[] = [];\n\tlet close_brackets_length_index_min_max_index_min_max_index_min: number[] = [];\n\tlet open\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpliuh180c.ts(71,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333969
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_stack: string[] = [];\n\tlet close_brackets_stack: string[] = [];\n\tlet open_brackets_stack_index: number[] = [];\n\tlet close_brackets_stack_index: number[] = [];\n\tlet open_brackets_stack_index2: number[] = [];\n\tlet close_brackets_stack_index2: number[] = [];\n\tlet open_brackets_stack_index3: number[] = [];\n\tlet close_brackets_stack_index3: number[] = [];\n\tlet open_brackets_stack_index4: number[] = [];\n\tlet close_brackets_stack_index4: number[] = [];\n\tlet open_brackets_stack_index5: number[] = [];\n\tlet close_brackets_stack_index5: number[] = [];\n\tlet open_brackets_stack_index6: number[] = [];\n\tlet close_brackets_stack_index6: number[] = [];\n\tlet open_brackets_stack_index7: number[] = [];\n\tlet close_brackets_stack_index7: number[] = [];\n\tlet open_brackets_stack_index8: number[] = [];\n\tlet close_brackets_stack_index8: number[] = [];\n\tlet open_brackets_stack_index9: number[] = [];\n\tlet close_brackets_stack_index9: number[] = [];\n\tlet open_brackets_stack_index10: number[] = [];\n\tlet close_brackets_stack_index10: number[] = [];\n\tlet open_brackets_stack_index11: number[] = [];\n\tlet close_brackets_stack_index11: number[] = [];\n\tlet open_brackets_stack_index12: number[] = [];\n\tlet close_brackets_stack_index12: number[] = [];\n\tlet open_brackets_stack_index13: number[] = [];\n\tlet close_brackets_stack_index13: number[] = [];\n\tlet open_brackets_stack_index14: number[] = [];\n\tlet close_brackets_stack_index14: number[] = [];\n\tlet open_brackets_stack_index15: number[] = [];\n\tlet close_brackets_stack_index15: number[] = [];\n\tlet open_brackets_stack_index16: number[] = [];\n\tlet close_b\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpl50lulap.ts(76,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333968
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_stack: string[] = [];\n\tlet close_brackets_stack: string[] = [];\n\tlet open_brackets_stack_index: number[] = [];\n\tlet close_brackets_stack_index: number[] = [];\n\tlet open_brackets_stack_string: string[] = [];\n\tlet close_brackets_stack_string: string[] = [];\n\tlet open_brackets_stack_string_index: number[] = [];\n\tlet close_brackets_stack_string_index: number[] = [];\n\tlet open_brackets_stack_string_string: string[] = [];\n\tlet close_brackets_stack_string_string: string[] = [];\n\tlet open_brackets_stack_string_string_index: number[] = [];\n\tlet close_brackets_stack_string_string_index: number[] = [];\n\tlet open_brackets_stack_string_string_string: string[] = [];\n\tlet close_brackets_stack_string_string_string: string[] = [];\n\tlet open_brackets_stack_string_string_string_index: number[] = [];\n\tlet close_brackets_stack_string_string_string_index: number[] = [];\n\tlet open_brackets_stack_string_string_string_string: string[] = [];\n\tlet close_brackets_stack_string_string_string: string[] = [];\n\tlet open_brackets_stack_string_string_string_index: number[] = [];\n\tlet close_brackets_stack_string_string_string_index: number[] = [];\n\tlet open_brackets_stack_string_string_string_string: string[] = [];\n\tlet close_brackets_stack_string_string_string: string[] = [];\n\tlet open_brackets_stack_string_string_string_string_index: number[] = [];\n\tlet close_brackets_stack_string_string_string_string_index: number[] = [];\n\tlet open_brackets_stack_string_string_string_string: string[] = [];\n\tlet close_brackets_stack_string_string_string: string[] = [];\n\tlet open_brackets_stack_string_string_string_string_index: number[] = [];\n\tlet close_brackets_stack_string_string_string_string_index: number[] = [];\n\tlet open_brackets_stack_string_string_string_string: string[] = [];\n\tlet close_brackets_stack_string_string_string: string[] = [];\n\tlet open_brackets_stack_string_string_string_string_index: number[] = [];\n\tlet close\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpjuw0epvl.ts(74,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333968
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number = 0;\n\tlet close_brackets: number = 0;\n\tlet open_curly: number = 0;\n\tlet close_curly: number = 0;\n\tlet open_square: number = 0;\n\tlet close_square: number = 0;\n\tlet open_brackets_stack: string[] = [];\n\tlet close_brackets_stack: string[] = [];\n\tlet open_curly_stack: string[] = [];\n\tlet close_curly_stack: string[] = [];\n\tlet open_squarel_stack: string[] = [];\n\tlet close_squarel_stack: string[] = [];\n\tlet open_brackets_stack_string: string = \"\";\n\tlet close_brackets_stack_string: string = \"\";\n\tlet open_curly_stack_string: string = \"\";\n\tlet close_curly_stack_string: string = \"\";\n\tlet open_squarel_stack_string: string = \"\";\n\tlet close_squarel_stack_string: string = \"\";\n\tlet open_brackets_stack_string2: string = \"\";\n\tlet close_brackets_stack_string2: string = \"\";\n\tlet open_curly_stack_string2: string = \"\";\n\tlet close_curly_stack_string2: string = \"\";\n\tlet open_squarel_stack_string2: string = \"\";\n\tlet close_squarel_stack_string2: string = \"\";\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlet char = string[i];\n\t\tif (char === \"[\") {\n\t\t\topen_brackets++;\n\t\t\topen_brackets_stack.push(string[i]);\n\t\t\topen_brackets_stack_string += string[i];\n\t\t} else if (char === \"]\") {\n\t\t\tclose_brackets++;\n\t\t\tclose_brackets_stack.push(string[i]);\n\t\t\tclose_brackets_stack_string += string[i];\n\t\t} else if (char === \"{\") {\n\t\t\topen_curly++;\n\t\t\topen_curly_stack.push(string[i]);\n\t\t\topen_curly_stack_string += string[i];\n\t\t} else if (char === \"}\") {\n\t\t\tclose_curly++;\n\t\t\tclose_curly_stack.push(string[i]);\n\t\t\tclose_curly_stack_string += string[i];\n\t\t} else if (char === \"[\") {\n\t\t\topen_square++;\n\t\t\topen_squarel_stack.push(string[i]);\n\t\t\topen_squarel_stack_string += string[i];\n\t\t} else if (char === \"]\") {\n\t\t\tclose_square++;\n\t\t\tclose_squarel_stack.push(string[i]);\n\t\t\tclose_squarel_stack_string += string[i];\n\t\t}\n\t}\n\tif (open_brackets === close_brackets && open_brackets === open_curly && open_brackets === close_cur\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpa6us32_g.ts(70,1): error TS1005: ')' expected.\n../../../../tmp/tmpa6us32_g.ts(92,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333968
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let bracketCount = 0;\n    let openBracketCount = 0;\n    let closeBracketCount = 0;\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            openBracketCount++;\n        } else if (string[i] === \"]\") {\n            closeBracketCount++;\n        } else if (string[i] === \"[\") {\n            bracketCount++;\n        } else if (string[i] === \"]\") {\n            bracketCount--;\n        }\n        if (bracketCount === 0 && openBracketCount === 0 && closeBracketCount === 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmpc561mroa.js:42:12)\n    at Object.<anonymous> (/tmp/tmpc561mroa.js:57:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333969
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    const stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\" || string[i] === \"(\") {\n            stack.push(string[i]);\n        } else if (string[i] === \"]\") {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpinqv63jv.js:36:12)\n    at Object.<anonymous> (/tmp/tmpinqv63jv.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333969
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_index = 0;\n\tlet close_brackets_index = 0;\n\tlet open_brackets_length = 0;\n\tlet close_brackets_length = 0;\n\tlet open_brackets_char: string;\n\tlet close_brackets_char: string;\n\tlet open_brackets_char_length: number;\n\tlet close_brackets_char_length: number;\n\tlet open_brackets_char_position: number;\n\tlet close_brackets_char_position: number;\n\tlet open_brackets_char_char_position: number;\n\tlet close_brackets_char_char_position: number;\n\tlet open_brackets_char_char_char_position: number;\n\tlet close_brackets_char_char_char_position: number;\n\tlet open_brackets_char_char_char_char_position: number;\n\tlet close_brackets_char_char_char_char_position: number;\n\tlet open_brackets_char_char_char_char_char_position: number;\n\tlet close_brackets_char_char_char_char_char_position: number;\n\tlet open_brackets_char_char_char_char_char_char_position: number;\n\tlet close_brackets_char_char_char_char_char_char_position: number;\n\tlet open_brackets_char_char_char_char_char_char_char_position: number;\n\tlet close_brackets_char_char_char_char_char_char_char_position: number;\n\tlet open_brackets_char_char_char_char_char_char_char_char_position: number;\n\tlet close_brackets_char_char_char_char_char_char_char_char_position: number;\n\tlet open_brackets_char_char_char_char_char_char_char_char_char_position: number;\n\tlet close_brackets_char_char_char_char_char_char_char_char_char_position: number;\n\tlet open_brackets_char_char_char_char_char_char_char_char_char_char_position: number;\n\tlet close_brackets_char_char_char_char_char_char_char_char_char_char_char_position: number;\n\tlet open_brackets_char_char_char_char_char_char_char_char_char_char_char_char_position: number;\n\tlet close_brackets_char_char_char_char_char_char_char_char_char_char_char_char_position: number;\n\tlet open_brackets_char_char_char_char_char_char_char_char_char_char_char_char_char_position: number;\n\tlet close_brackets_char_char_char_char_char_char_char_char_char_char_char_char_char_char_position: number;\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmphgj7ijzl.ts(74,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333969
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] == \"[\") {\n            stack.push(string[i]);\n        } else if (string[i] == \"]\") {\n            if (stack.length == 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length == 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpf6hh5s3s.js:36:12)\n    at Object.<anonymous> (/tmp/tmpf6hh5s3s.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333969
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        let char = string[i];\n        if (char === \"[\" || char === \"]\") {\n            if (stack.length < 1) {\n                return false;\n            }\n            let openBracket = stack[stack.length - 1];\n            if (char === openBracket) {\n                stack.pop();\n            } else {\n                return false;\n            }\n        } else {\n            stack.push(char);\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmp7ccqaqft.js:41:12)\n    at Object.<anonymous> (/tmp/tmp7ccqaqft.js:56:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333969
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_index = 0;\n\tlet close_brackets_index = 0;\n\tlet open_brackets_length = 0;\n\tlet close_brackets_length = 0;\n\tlet open_brackets_char: string;\n\tlet close_brackets_char: string;\n\tlet open_brackets_char_length: number;\n\tlet close_brackets_char_length: number;\n\tlet open_brackets_char_position: number;\n\tlet close_brackets_char_position: number;\n\tlet open_brackets_char_char_position: number;\n\tlet close_brackets_char_char_position: number;\n\tlet open_brackets_char_char_char_position: number;\n\tlet close_brackets_char_char_char_position: number;\n\tlet open_brackets_char_char_char_char_position: number;\n\tlet close_brackets_char_char_char_char_position: number;\n\tlet open_brackets_char_char_char_char_char_position: number;\n\tlet close_brackets_char_char_char_char_char_position: number;\n\tlet open_brackets_char_char_char_char_char_char_position: number;\n\tlet close_brackets_char_char_char_char_char_char_position: number;\n\tlet open_brackets_char_char_char_char_char_char_char_position: number;\n\tlet close_brackets_char_char_char_char_char_char_char_position: number;\n\tlet open_brackets_char_char_char_char_char_char_char_char_position: number;\n\tlet close_brackets_char_char_char_char_char_char_char_char_position: number;\n\tlet open_brackets_char_char_char_char_char_char_char_char_char_position: number;\n\tlet close_brackets_char_char_char_char_char_char_char_char_char_position: number;\n\tlet open_brackets_char_char_char_char_char_char_char_char_char_char_position: number;\n\tlet close_brackets_char_char_char_char_char_char_char_char_char_char_char_position: number;\n\tlet open_brackets_char_char_char_char_char_char_char_char_char_char_char_char_position: number;\n\tlet close_brackets_char_char_char_char_char_char_char_char_char_char_char_char_position: number;\n\tlet open_brackets_char_char_char_char_char_char_char_char_char_char_char_char_char_position: number;\n\tlet close_brackets_char_char_char_char_char_char_char_char_char_char_char_char_char_char_position: number;\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmphgj7ijzl.ts(74,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333969
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            stack.push(string[i]);\n        } else if (string[i] === \"]\") {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpzojs0i1x.js:36:12)\n    at Object.<anonymous> (/tmp/tmpzojs0i1x.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333962
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            brackets.push(i);\n        }\n        if (string[i] === \"]\") {\n            if (brackets.length === 0) {\n                return false;\n            }\n            brackets.pop();\n        }\n    }\n    return brackets.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpykkck7v7.js:36:12)\n    at Object.<anonymous> (/tmp/tmpykkck7v7.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333969
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            stack.push(string[i]);\n            open_brackets.push(i);\n        } else if (string[i] === \"]\") {\n            close_brackets.push(i);\n        }\n    }\n    if (stack.length !== open_brackets.length) return false;\n    for (let i = 0; i < open_brackets.length; i++) {\n        if (close_brackets[i] - open_brackets[i] > 1) return false;\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmp085pl9hp.js:40:12)\n    at Object.<anonymous> (/tmp/tmp085pl9hp.js:55:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333969
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_stack: string[] = [];\n\tlet close_brackets_stack: string[] = [];\n\tlet open_brackets_stack_index: number[] = [];\n\tlet close_brackets_stack_index: number[] = [];\n\tlet open_brackets_stack_string: string[] = [];\n\tlet close_brackets_stack_string: string[] = [];\n\tlet open_brackets_stack_string_index: number[] = [];\n\tlet close_brackets_stack_string_index: number[] = [];\n\tlet open_brackets_stack_string_string: string[] = [];\n\tlet close_brackets_stack_string_string: string[] = [];\n\tlet open_brackets_stack_string_string_index: number[] = [];\n\tlet close_brackets_stack_string_string_index: number[] = [];\n\tlet open_brackets_stack_string_string_string: string[] = [];\n\tlet close_brackets_stack_string_string_string: string[] = [];\n\tlet open_brackets_stack_string_string_string_index: number[] = [];\n\tlet close_brackets_stack_string_string_string_index: number[] = [];\n\tlet open_brackets_stack_string_string_string_string: string[] = [];\n\tlet close_brackets_stack_string_string_string: string[] = [];\n\tlet open_brackets_stack_string_string_string_index: number[] = [];\n\tlet close_brackets_stack_string_string_string_index: number[] = [];\n\tlet open_brackets_stack_string_string_string_string: string[] = [];\n\tlet close_brackets_stack_string_string_string: string[] = [];\n\tlet open_brackets_stack_string_string_string_string_index: number[] = [];\n\tlet close_brackets_stack_string_string_string_string_index: number[] = [];\n\tlet open_brackets_stack_string_string_string_string: string[] = [];\n\tlet close_brackets_stack_string_string_string: string[] = [];\n\tlet open_brackets_stack_string_string_string_string_index: number[] = [];\n\tlet close_brackets_stack_string_string_string_string_index: number[] = [];\n\tlet open_brackets_stack_string_string_string_string: string[] = [];\n\tlet close_brackets_stack_string_string_string: string[] = [];\n\tlet open_brackets_stack_string_string_string_string_index: number[] = [];\n\tlet close\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpjuw0epvl.ts(74,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333968
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    let open_brackets_stack: number[] = [];\n    let close_brackets_stack: number[] = [];\n    let open_brackets_stack_index: number[] = [];\n    let close_brackets_stack_index: number[] = [];\n    let open_brackets_stack_index2: number[] = [];\n    let close_brackets_stack_index2: number[] = [];\n    let open_brackets_stack_index3: number[] = [];\n    let close_brackets_stack_index3: number[] = [];\n    let open_brackets_stack_index4: number[] = [];\n    let close_brackets_stack_index4: number[] = [];\n    let open_brackets_stack_index5: number[] = [];\n    let close_brackets_stack_index5: number[] = [];\n    let open_brackets_stack_index6: number[] = [];\n    let close_brackets_stack_index6: number[] = [];\n    let open_brackets_stack_index7: number[] = [];\n    let close_brackets_stack_index7: number[] = [];\n    let open_brackets_stack_index8: number[] = [];\n    let close_brackets_stack_index8: number[] = [];\n    let open_brackets_stack_index9: number[] = [];\n    let close_brackets_stack_index9: number[] = [];\n    let open_brackets_stack_index10: number[] = [];\n    let close_brackets_stack_index10: number[] = [];\n    let open_brackets_stack_index11: number[] = [];\n    let close_brackets_stack_index11: number[] = [];\n    let open_brackets_stack_index12: number[] = [];\n    let close_brackets_stack_index12: number[] = [];\n    let open_brackets_stack_index13: number[] = [];\n    let close_brackets_stack_index13: number[] = [];\n    let open_brackets_stack_index14: number[] = [];\n    let close_brackets_stack_index14: number[] = [];\n    let open_brackets_stack_index15: number[] = [];\n    let close_brackets_stack_index15: number[] = [];\n    let open_brackets_stack_index16: number[] = [];\n    let close_brackets_stack_index16: number[] = [];\n    let open_brackets_stack_index17: number[] = [];\n    let close_brackets_stack_index17: \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpz625kilb.ts(56,9): error TS1005: ',' expected.\n../../../../tmp/tmpz625kilb.ts(78,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333969
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    if (string.length < 2) return false\n    if (string[0] != \"[\" || string[string.length - 1] != \"]\") return false\n    let stack: string[] = []\n    for (let i = 0; i < string.length - 1; i++) {\n        if (string[i] == \"[\" && string[i + 1] == \"[\") {\n            stack.push(\"[\")\n        } else if (string[i] == \"]\" && string[i + 1] == \"]\") {\n            stack.pop()\n        } else if (string[i] == \"[\" && string[i + 1] != \"]\") {\n            return false\n        } else if (string[i] == \"]\" && string[i + 1] != \"]\") {\n            return false\n        }\n    }\n    return stack.length == 0\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpeuevjeru.js:44:12)\n    at Object.<anonymous> (/tmp/tmpeuevjeru.js:56:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333969
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: number[] = [];\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            brackets.push(i);\n            open_brackets.push(i);\n        } else if (string[i] === \"]\") {\n            close_brackets.push(i);\n        } else if (string[i] === \"[\") {\n            open_brackets.push(i);\n        } else if (string[i] === \"]\") {\n            brackets.push(i);\n        }\n    }\n    if (brackets.length === 0) {\n        return false;\n    }\n    for (let i = 0; i < brackets.length; i++) {\n        let start = brackets[i];\n        let end = close_brackets[i];\n        if (open_brackets[i] === end) {\n            return false;\n        }\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpl3_z43wz.js:51:12)\n    at Object.<anonymous> (/tmp/tmpl3_z43wz.js:65:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333969
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_index = 0;\n\tlet close_brackets_index = 0;\n\tlet open_parenthesis_index = 0;\n\tlet close_parenthesis_index = 0;\n\tlet open_brackets_length = 0;\n\tlet close_brackets_length = 0;\n\tlet open_parenthesis_length = 0;\n\tlet close_parenthesis_length = 0;\n\tlet open_brackets_index_in_string = 0;\n\tlet close_brackets_index_in_string = 0;\n\tlet open_parenthesis_index_in_string = 0;\n\tlet close_parenthesis_index_in_string = 0;\n\tlet open_brackets_index_in_string2 = 0;\n\tlet close_brackets_index_in_string2 = 0;\n\tlet open_parenthesis_index_in_string2 = 0;\n\tlet close_parenthesis_index_in_string2 = 0;\n\tlet open_brackets_index_in_string3 = 0;\n\tlet close_brackets_index_in_string3 = 0;\n\tlet open_parenthesis_index_in_string3 = 0;\n\tlet close_parenthesis_index_in_string3 = 0;\n\tlet open_brackets_index_in_string4 = 0;\n\tlet close_brackets_index_in_string4 = 0;\n\tlet open_parenthesis_index_in_string4 = 0;\n\tlet close_parenthesis_index_in_string4 = 0;\n\tlet open_brackets_index_in_string5 = 0;\n\tlet close_brackets_index_in_string5 = 0;\n\tlet open_parenthesis_index_in_string5 = 0;\n\tlet close_parenthesis_index_in_string5 = 0;\n\tlet open_brackets_index_in_string6 = 0;\n\tlet close_brackets_index_in_string6 = 0;\n\tlet open_parenthesis_index_in_string6 = 0;\n\tlet close_parenthesis_index_in_string6 = 0;\n\tlet open_brackets_index_in_string7 = 0;\n\tlet close_brackets_index_in_string7 = 0;\n\tlet open_parenthesis_index_in_string7 = 0;\n\tlet close_parenthesis_index_in_string7 = 0;\n\tlet open_brackets_index_in_string8 = 0;\n\tlet close_brackets_index_in_string8 = 0;\n\tlet open_parenthesis_index_in_string8 = 0;\n\tlet close_parenthesis_index_in_string8 = 0;\n\tlet open_brackets_index_in_string9 = 0;\n\tlet close_brackets_index_in_string9 = 0;\n\t\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp1p86anei.ts(85,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333969
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    if (string.length < 2) return false\n    if (string[0] != \"[\" || string[string.length - 1] != \"]\") return false\n    let open = string.indexOf(\"[\")\n    let close = string.indexOf(\"]\")\n    if (open < 0 || close < 0) return false\n    let open2 = string.indexOf(\"[\", open + 1)\n    let close2 = string.indexOf(\"]\", close + 1)\n    if (open2 < 0 || close2 < 0) return false\n    if (open2 == close2) return false\n    return is_nested(string.substring(open + 1, close2))\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmp36i2s8yo.js:36:12)\n    at Object.<anonymous> (/tmp/tmp36i2s8yo.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333969
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_parens: number[] = [];\n\tlet close_parens: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_parens_stack: number[] = [];\n\tlet close_parens_stack: number[] = [];\n\tlet open_brackets_stack_index: number[] = [];\n\tlet close_brackets_stack_index: number[] = [];\n\tlet open_parens_stack_index: number[] = [];\n\tlet close_parens_stack_index: number[] = [];\n\tlet open_brackets_stack_index2: number[] = [];\n\tlet close_brackets_stack_index2: number[] = [];\n\tlet open_parens_stack_index2: number[] = [];\n\tlet close_parens_stack_index2: number[] = [];\n\tlet open_brackets_stack_index3: number[] = [];\n\tlet close_brackets_stack_index3: number[] = [];\n\tlet open_parens_stack_index3: number[] = [];\n\tlet close_parens_stack_index3: number[] = [];\n\tlet open_brackets_stack_index4: number[] = [];\n\tlet close_brackets_stack_index4: number[] = [];\n\tlet open_parens_stack_index4: number[] = [];\n\tlet close_parens_stack_index4: number[] = [];\n\tlet open_brackets_stack_index5: number[] = [];\n\tlet close_brackets_stack_index5: number[] = [];\n\tlet open_parens_stack_index5: number[] = [];\n\tlet close_parens_stack_index5: number[] = [];\n\tlet open_brackets_stack_index6: number[] = [];\n\tlet close_brackets_stack_index6: number[] = [];\n\tlet open_parens_stack_index6: number[] = [];\n\tlet close_parens_stack_index6: number[] = [];\n\tlet open_brackets_stack_index7: number[] = [];\n\tlet close_brackets_stack_index7: number[] = [];\n\tlet open_parens_stack_index7: number[] = [];\n\tlet close_parens_stack_index7: number[] = [];\n\tlet open_brackets_stack_index8: number[] = [];\n\tlet close_brackets_stack_index8: number[] = [];\n\tlet open_parens_stack_index8: number[] = [];\n\t\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp9px2bk3u.ts(80,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333969
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_brackets_stack_index: number = 0;\n\tlet close_brackets_stack_index: number = 0;\n\tlet open_brackets_stack_string: string = \"\";\n\tlet close_brackets_stack_string: string = \"\";\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_brackets_string: string = \"\";\n\tlet close_brackets_string: string = \"\";\n\tlet open_brackets_string_index: number = 0;\n\tlet close_brackets_string_index: number = 0;\n\tlet open_brackets_string_index2: number = 0;\n\tlet close_brackets_string_index2: number = 0;\n\tlet open_brackets_string_index3: number = 0;\n\tlet close_brackets_string_index3: number = 0;\n\tlet open_brackets_string_index4: number = 0;\n\tlet close_brackets_string_index4: number = 0;\n\tlet open_brackets_string_index5: number = 0;\n\tlet close_brackets_string_index5: number = 0;\n\tlet open_brackets_string_index6: number = 0;\n\tlet close_brackets_string_index6: number = 0;\n\tlet open_brackets_string_index7: number = 0;\n\tlet close_brackets_string_index7: number = 0;\n\tlet open_brackets_string_index8: number = 0;\n\tlet close_brackets_string_index8: number = 0;\n\tlet open_brackets_string_index9: number = 0;\n\tlet close_brackets_string_index9: number = 0;\n\tlet open_brackets_string_index10: number = 0;\n\tlet close_brackets_string_index10: number = 0;\n\tlet open_brackets_string_index11: number = 0;\n\tlet close_brackets_string_index11: number = 0;\n\tlet open_brackets_string_index12: number = 0;\n\tlet close_brackets_string_index12: number = 0;\n\tlet open_brackets_string_index13: number = 0;\n\tlet close_brackets_string_index13: number = 0;\n\tlet \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpx1f6xpus.ts(57,9): error TS1005: ',' expected.\n../../../../tmp/tmpx1f6xpus.ts(79,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333969
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        let char = string[i];\n        if (char === '[') {\n            stack.push(char);\n        } else if (char === ']') {\n            if (stack.length === 0) {\n                return false;\n            }\n            let openBracket = stack.pop();\n            if (openBracket !== '[') {\n                return false;\n            }\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmp3gnzgm8o.js:40:12)\n    at Object.<anonymous> (/tmp/tmp3gnzgm8o.js:53:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333969
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    let open_brackets: number[] = [];\n    let closed_brackets: number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        let char = string[i];\n        if (char === '[') {\n            stack.push(char);\n            open_brackets.push(i);\n        } else if (char === ']') {\n            if (stack.length === 0) {\n                return false;\n            }\n            let open_bracket = open_brackets.pop();\n            let closed_bracket = closed_brackets.pop();\n            if (closed_bracket < open_bracket) {\n                return false;\n            }\n            stack.splice(open_bracket, 1);\n            closed_brackets.push(open_bracket);\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpar9hfvft.js:47:12)\n    at Object.<anonymous> (/tmp/tmpar9hfvft.js:59:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333972
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet closed_brackets: number[] = [];\n\tlet open_brackets_size: number[] = [];\n\tlet closed_brackets_size: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet closed_brackets_position: number[] = [];\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpocn7vwpw.ts(85,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333971
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets = string.match(/\\[.*?\\]/g);\n    if (brackets) {\n        for (let i = 0; i < brackets.length; i++) {\n            let bracket = brackets[i];\n            if (bracket.match(/\\[.*?\\]/)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpnono9u6v.js:32:12)\n    at Object.<anonymous> (/tmp/tmpnono9u6v.js:46:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333972
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets = string.match(/\\[.*?\\]/g);\n\tlet nestedBrackets = string.match(/\\[.*?\\]/g);\n\tlet nestedBracketsCount = nestedBrackets.length;\n\tlet bracketsCount = brackets.length;\n\t\n\tif (bracketsCount === nestedBracketsCount) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmp0x5l25eo.js:32:12)\n    at Object.<anonymous> (/tmp/tmp0x5l25eo.js:46:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333972
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_parens: number[] = [];\n\tlet close_parens: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_parens_stack: number[] = [];\n\tlet close_parens_stack: number[] = [];\n\tlet open_brackets_size: number[] = [];\n\tlet close_brackets_size: number[] = [];\n\tlet open_parens_size: number[] = [];\n\tlet close_parens_size: number[] = [];\n\tlet open_brackets_index: number[] = [];\n\tlet close_brackets_index: number[] = [];\n\tlet open_parens_index: number[] = [];\n\tlet close_parens_index: number[] = [];\n\tlet open_brackets_index_stack: number[] = [];\n\tlet close_brackets_index_stack: number[] = [];\n\tlet open_parens_index_stack: number[] = [];\n\tlet close_parens_index_stack: number[] = [];\n\tlet open_brackets_index_size: number[] = [];\n\tlet close_brackets_index_size: number[] = [];\n\tlet open_parens_index_size: number[] = [];\n\tlet close_parens_index_size: number[] = [];\n\tlet open_brackets_index_index: number[] = [];\n\tlet close_brackets_index_index: number[] = [];\n\tlet open_parens_index_index: number[] = [];\n\tlet close_parens_index_index: number[] = [];\n\tlet open_brackets_index_index_stack: number[] = [];\n\tlet close_brackets_index_index_stack: number[] = [];\n\tlet open_parens_index_index_stack: number[] = [];\n\tlet close_parens_index_index_stack: number[] = [];\n\tlet open_brackets_index_index_size: number[] = [];\n\tlet close_brackets_index_index_size: number[] = [];\n\tlet open_parens_index_index_size: number[] = [];\n\tlet close_parens_index_index_size: number[] = [];\n\tlet open_brackets_index_index_index: number[] = [];\n\tlet close_brackets_index_index_index: number[] = [];\n\tlet open_parens_index_index_index: number[] = [];\n\tlet close_parens_index_index_index: number[] = [];\n\tlet open_brackets_index_index_index_stack: number[] = [];\n\tlet close_b\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpg1jv9sa5.ts(82,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333971
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: string[] = string.split(\"\").map(c => c.charCodeAt(0));\n    let stack: number[] = [];\n    for (let i = 0; i < brackets.length; i++) {\n        let bracket = brackets[i];\n        if (bracket === 91) {\n            stack.push(bracket);\n        } else if (bracket === 93) {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpmrvyecsu.ts(17,9): error TS2322: Type 'number[]' is not assignable to type 'string[]'.\n  Type 'number' is not assignable to type 'string'.\n../../../../tmp/tmpmrvyecsu.ts(21,13): error TS2367: This condition will always return 'false' since the types 'string' and 'number' have no overlap.\n../../../../tmp/tmpmrvyecsu.ts(23,20): error TS2367: This condition will always return 'false' since the types 'string' and 'number' have no overlap.\n",
      "timestamp": 1660333972
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_curly: number[] = [];\n\tlet close_curly: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_curly_stack: number[] = [];\n\tlet close_curly_stack: number[] = [];\n\tlet open_brackets_stack_length: number = 0;\n\tlet close_brackets_stack_length: number = 0;\n\tlet open_curly_stack_length: number = 0;\n\tlet close_curly_stack_length: number = 0;\n\tlet open_brackets_stack_string: string = \"\";\n\tlet close_brackets_stack_string: string = \"\";\n\tlet open_curly_stack_string: string = \"\";\n\tlet close_curly_stack_string: string = \"\";\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlet c = string.charAt(i);\n\t\tif (c == '[') {\n\t\t\topen_brackets_stack.push(i);\n\t\t\topen_brackets_stack_length++;\n\t\t} else if (c == ']') {\n\t\t\tclose_brackets_stack.push(i);\n\t\t\tclose_brackets_stack_length++;\n\t\t} else if (c == '{') {\n\t\t\topen_curly_stack.push(i);\n\t\t\topen_curly_stack_length++;\n\t\t} else if (c == '}') {\n\t\t\tclose_curly_stack.push(i);\n\t\t\tclose_curly_stack_length++;\n\t\t}\n\t\tif (open_brackets_stack.length > 0) {\n\t\t\topen_brackets_stack_string = open_brackets_stack_string.concat(c);\n\t\t} else if (open_brackets_stack_string.length > 0) {\n\t\t\tif (open_brackets_stack_length == open_brackets_stack_string.length) {\n\t\t\t\topen_brackets_stack_string = open_brackets_stack_string.concat(c);\n\t\t\t} else {\n\t\t\t\topen_brackets_stack_string = \"\";\n\t\t\t}\n\t\t}\n\t\tif (close_brackets_stack.length > 0) {\n\t\t\tclose_brackets_stack_string = close_brackets_stack_string.concat(c);\n\t\t} else if (close_brackets_stack_string.length > 0) {\n\t\t\tif (close_brackets_stack_length == close_brackets_stack_string.length) {\n\t\t\t\tclose_brackets_stack_string = close_brackets_stack_string.concat(c);\n\t\t\t} else {\n\t\t\t\tclose_brackets_stack_string = \"\";\n\t\t\t}\n\t\t}\n\t\tif (open_curly_stack.length > 0) {\n\t\t\topen_curly_stack_string = open_curly_stack_string.concat\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpxkmy01_x.ts(91,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333972
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number = 0;\n\tlet close_brackets: number = 0;\n\tlet open_brackets_stack: string[] = [];\n\tlet close_brackets_stack: string[] = [];\n\tlet open_brackets_stack_string: string = \"\";\n\tlet close_brackets_stack_string: string = \"\";\n\tlet open_brackets_string: string = \"\";\n\tlet close_brackets_string: string = \"\";\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlet char = string[i];\n\t\tif (char === \"[\") {\n\t\t\topen_brackets++;\n\t\t\topen_brackets_stack.push(string[i]);\n\t\t\topen_brackets_string += string[i];\n\t\t} else if (char === \"]\") {\n\t\t\tclose_brackets++;\n\t\t\tclose_brackets_stack.push(string[i]);\n\t\t\tclose_brackets_string += string[i];\n\t\t} else if (char === \"][]\") {\n\t\t\tclose_brackets++;\n\t\t\tclose_brackets_stack.push(string[i]);\n\t\t\tclose_brackets_string += string[i];\n\t\t} else if (char === \"[]\") {\n\t\t\topen_brackets++;\n\t\t\topen_brackets_stack.push(string[i]);\n\t\t\topen_brackets_string += string[i];\n\t\t} else if (char === \"[][]\") {\n\t\t\tclose_brackets++;\n\t\t\tclose_brackets_stack.push(string[i]);\n\t\t\tclose_brackets_string += string[i];\n\t\t} else if (char === \"[[]\") {\n\t\t\topen_brackets++;\n\t\t\topen_brackets_stack.push(string[i]);\n\t\t\topen_brackets_string += string[i];\n\t\t} else if (char === \"[]]\") {\n\t\t\tclose_brackets++;\n\t\t\tclose_brackets_stack.push(string[i]);\n\t\t\tclose_brackets_string += string[i];\n\t\t} else if (char === \"[[][]\") {\n\t\t\tclose_brackets++;\n\t\t\tclose_brackets_stack.push(string[i]);\n\t\t\tclose_brackets_string += string[i];\n\t\t} else if (char === \"[][]\") {\n\t\t\topen_brackets++;\n\t\t\topen_brackets_stack.push(string[i]);\n\t\t\topen_brackets_string += string[i];\n\t\t} else if (char === \"[]]\") {\n\t\t\tclose_brackets++;\n\t\t\tclose_brackets_stack.push(string[i]);\n\t\t\tclose_brackets_string += string[i];\n\t\t} else if (char === \"[[][]\") {\n\t\t\tclose_brackets++;\n\t\t\tclose_brackets_stack.push(string[i]);\n\t\t\tclose_brackets_string += string[i];\n\t\t} else if (char === \"\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpm820d9xr.ts(71,24): error TS1002: Unterminated string literal.\n../../../../tmp/tmpm820d9xr.ts(72,1): error TS1005: ')' expected.\n../../../../tmp/tmpm820d9xr.ts(94,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333972
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: number[] = [];\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    let open_brackets_stack: number[] = [];\n    let close_brackets_stack: number[] = [];\n    let bracket_counter: number = 0;\n    let bracket_counter2: number = 0;\n    let bracket_counter3: number = 0;\n    let bracket_counter4: number = 0;\n    let bracket_counter5: number = 0;\n    let bracket_counter6: number = 0;\n    let bracket_counter7: number = 0;\n    let bracket_counter8: number = 0;\n    let bracket_counter9: number = 0;\n    let bracket_counter10: number = 0;\n    let bracket_counter11: number = 0;\n    let bracket_counter12: number = 0;\n    let bracket_counter13: number = 0;\n    let bracket_counter14: number = 0;\n    let bracket_counter15: number = 0;\n    let bracket_counter16: number = 0;\n    let bracket_counter17: number = 0;\n    let bracket_counter18: number = 0;\n    let bracket_counter19: number = 0;\n    let bracket_counter20: number = 0;\n    let bracket_counter21: number = 0;\n    let bracket_counter22: number = 0;\n    let bracket_counter23: number = 0;\n    let bracket_counter24: number = 0;\n    let bracket_counter25: number = 0;\n    let bracket_counter26: number = 0;\n    let bracket_counter27: number = 0;\n    let bracket_counter28: number = 0;\n    let bracket_counter29: number = 0;\n    let bracket_counter30: number = 0;\n    let bracket_counter31: number = 0;\n    let bracket_counter32: number = 0;\n    let bracket_counter33: number = 0;\n    let bracket_counter34: number = 0;\n    let bracket_counter35: number = 0;\n    let bracket_counter36: number = 0;\n    let bracket_counter37: number = 0;\n    let bracket_counter38: number = 0;\n    let bracket_counter39: number = 0;\n    let bracket_counter40: number = 0;\n    let bracket_counter41: number = 0;\n    let bracket_counter42: number = 0;\n    let bracket_counter43: number = 0;\n    let bracket_counter44: number = 0;\n    let bracket_counter45: number = 0;\n    let bracket_counter46: number = 0;\n    let bracket_counter47\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp4frgy92w.ts(91,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333972
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet bracket_stack: number[] = [];\n\tlet bracket_stack_length: number = 0;\n\tlet bracket_stack_index: number = 0;\n\tlet bracket_stack_current: number = 0;\n\tlet bracket_stack_current_length: number = 0;\n\tlet bracket_stack_current_index: number = 0;\n\tlet bracket_stack_current_character: number = 0;\n\tlet bracket_stack_current_character_length: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet bracket_stack_current_character_position: number = 0;\n\tlet brack\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpzi_7e3td.ts(83,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333972
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        let char = string[i];\n        if (char === '[') {\n            stack.push(char);\n        } else if (char === ']') {\n            if (stack.length === 0) {\n                return false;\n            }\n            let top = stack.pop();\n            if (top !== char) {\n                return false;\n            }\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmps4vf_kgk.js:38:12)\n    at Object.<anonymous> (/tmp/tmps4vf_kgk.js:53:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333973
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_size: number[] = [];\n\tlet close_brackets_size: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_size: number[] = [];\n\tlet close_brackets_size: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_size: number[] = [];\n\tlet close_brackets_size: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_size: number[] = [];\n\tlet close_brackets_size: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_size: number[] = [];\n\tlet close_brackets_size: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_size: number[] = [];\n\tlet close_brackets_size: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_size: number[] = [];\n\tlet close_brackets_size: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_size: number[] = [];\n\tlet close_brackets_size: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_size: number[] = [];\n\tlet close_brackets_size: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open_brackets_size: number[] = [];\n\tlet close_brackets_size: number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position: number[] = [];\n\tlet open\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpjowyd4m7.ts(83,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333973
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_brackets_size: number = 0;\n\tlet close_brackets_size: number = 0;\n\tlet open_brackets_string: string = \"\";\n\tlet close_brackets_string: string = \"\";\n\tlet open_brackets_string_index: number = 0;\n\tlet close_brackets_string_index: number = 0;\n\tlet open_brackets_string_size: number = 0;\n\tlet close_brackets_string_size: number = 0;\n\tlet open_brackets_string_size_index: number = 0;\n\tlet close_brackets_string_size_index: number = 0;\n\tlet open_brackets_string_size_size: number = 0;\n\tlet close_brackets_string_size_size: number = 0;\n\tlet open_brackets_string_size_size_index: number = 0;\n\tlet close_brackets_string_size_size_index: number = 0;\n\tlet open_brackets_string_size_size_size: number = 0;\n\tlet close_brackets_string_size_size_size: number = 0;\n\tlet open_brackets_string_size_size_size_index: number = 0;\n\tlet close_brackets_string_size_size_size_index: number = 0;\n\tlet open_brackets_string_size_size_size_size: number = 0;\n\tlet close_brackets_string_size_size_size_size: number = 0;\n\tlet open_brackets_string_size_size_size_size_index: number = 0;\n\tlet close_brackets_string_size_size_size_size_index: number = 0;\n\tlet open_brackets_string_size_size_size_size_size: number = 0;\n\tlet close_brackets_string_size_size_size_size_size: number = 0;\n\tlet open_brackets_string_size_size_size_size_size_index: number = 0;\n\tlet close_brackets_string_size_size_size_size_size_index: number = 0;\n\tlet open_brackets_string_size_size_size_size_size_size: number = 0;\n\tlet close_brackets_string_size_size_size_size_size_size: number = 0;\n\tlet open_brackets_string_size_size_size_size_size_size_index: number = 0;\n\tlet close_brackets_string_size_size_size_size_size_size_size_index: number = 0;\n\tlet open_brackets_string_size\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpivl0vp4f.ts(74,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333973
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    const stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        const char = string[i];\n        if (char === '[') {\n            stack.push(char);\n        } else if (char === ']') {\n            if (stack.length === 0) {\n                return false;\n            }\n            const openBracket = stack.pop();\n            if (openBracket !== '[') {\n                return false;\n            }\n        }\n    }\n    if (stack.length === 0) {\n        return true;\n    }\n    return false;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpqdyhfi24.js:43:12)\n    at Object.<anonymous> (/tmp/tmpqdyhfi24.js:56:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333973
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: number[] = [];\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            brackets.push(i);\n        } else if (string[i] === \"]\") {\n            close_brackets.push(i);\n        } else if (string[i] === \"[\") {\n            open_brackets.push(i);\n        }\n    }\n    if (brackets.length !== close_brackets.length + open_brackets.length) {\n        return false;\n    }\n    for (let i = 0; i < brackets.length; i++) {\n        if (close_brackets[i] - open_brackets[i] > 1) {\n            return false;\n        }\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmps5rbz_qi.js:46:12)\n    at Object.<anonymous> (/tmp/tmps5rbz_qi.js:59:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333973
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_brackets_length = 0;\n\tlet close_brackets_length = 0;\n\tlet open_brackets_index = 0;\n\tlet close_brackets_index = 0;\n\tlet open_brackets_index_stack: number[] = [];\n\tlet close_brackets_index_stack: number[] = [];\n\tlet open_brackets_index_length = 0;\n\tlet close_brackets_index_length = 0;\n\tlet open_brackets_index_stack_index = 0;\n\tlet close_brackets_index_stack_index = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet close_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\n\tlet open_brackets_index_stack_index_length = 0;\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp473sdw4m.ts(80,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333973
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets = string.match(/\\[.*?\\]/g);\n    if (brackets) {\n        for (let i = 0; i < brackets.length; i++) {\n            let bracket = brackets[i];\n            let brackets = bracket.match(/\\[.*?\\]/g);\n            if (brackets) {\n                for (let j = 0; j < brackets.length; j++) {\n                    let bracket2 = brackets[j];\n                    if (bracket2.indexOf(bracket) !== -1) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp_6agr1ms.ts(20,27): error TS2448: Block-scoped variable 'brackets' used before its declaration.\n",
      "timestamp": 1660333973
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        let char = string[i];\n        if (char === '[') {\n            stack.push(char);\n        } else if (char === ']') {\n            if (stack.length === 0) {\n                return false;\n            }\n            let openBracket = stack.pop();\n            if (openBracket !== '[') {\n                return false;\n            }\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmp3gnzgm8o.js:40:12)\n    at Object.<anonymous> (/tmp/tmp3gnzgm8o.js:53:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333969
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_size: number = 0;\n\tlet close_brackets_size: number = 0;\n\tlet bracket_counter: number = 0;\n\tlet bracket_counter_size: number = 0;\n\tlet bracket_counter_size_max: number = 10;\n\tlet bracket_counter_size_min: number = 1;\n\tlet bracket_counter_size_step: number = 1;\n\tlet bracket_counter_size_max2: number = 10;\n\tlet bracket_counter_size_min2: number = 1;\n\tlet bracket_counter_size_step2: number = 1;\n\tlet bracket_counter_size_max3: number = 10;\n\tlet bracket_counter_size_min3: number = 1;\n\tlet bracket_counter_size_step3: number = 1;\n\tlet bracket_counter_size_max4: number = 10;\n\tlet bracket_counter_size_min4: number = 1;\n\tlet bracket_counter_size_step4: number = 1;\n\tlet bracket_counter_size_max5: number = 10;\n\tlet bracket_counter_size_min5: number = 1;\n\tlet bracket_counter_size_step5: number = 1;\n\tlet bracket_counter_size_max6: number = 10;\n\tlet bracket_counter_size_min6: number = 1;\n\tlet bracket_counter_size_step6: number = 1;\n\tlet bracket_counter_size_max7: number = 10;\n\tlet bracket_counter_size_min7: number = 1;\n\tlet bracket_counter_size_step7: number = 1;\n\tlet bracket_counter_size_max8: number = 10;\n\tlet bracket_counter_size_min8: number = 1;\n\tlet bracket_counter_size_step8: number = 1;\n\tlet bracket_counter_size_max9: number = 10;\n\tlet bracket_counter_size_min9: number = 1;\n\tlet bracket_counter_size_step9: number = 1;\n\tlet bracket_counter_size_max10: number = 10;\n\tlet bracket_counter_size_min10: number = 1;\n\tlet bracket_counter_size_step10: number = 1;\n\tlet bracket_counter_size_max11: number = 10;\n\tlet bracket_counter_size_min11: number = 1;\n\tlet bracket_counter_size_step11: number = 1;\n\tlet bracket_counter_size_max12: number = 10;\n\tlet bracket_counter_size_min12: number = 1;\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpx0kazo61.ts(82,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333973
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    if (string.length < 2) return false\n    if (string[0] != \"[\" || string[string.length - 1] != \"]\") return false\n    let stack = []\n    for (let i = 0; i < string.length - 1; i++) {\n        if (string[i] == \"[\" && string[i + 1] == \"]\") {\n            stack.push(i)\n        } else if (string[i] == \"[\" && string[i + 1] != \"]\") {\n            if (stack.length == 0) {\n                return false\n            }\n            let open = stack.pop()\n            if (string[open] == \"]\") {\n                stack.push(open)\n            }\n        }\n    }\n    return stack.length == 0\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmp0mdsl6cp.js:41:12)\n    at Object.<anonymous> (/tmp/tmp0mdsl6cp.js:56:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333973
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] == \"[\") {\n            stack.push(string[i]);\n        } else if (string[i] == \"]\") {\n            if (stack.length == 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    if (stack.length != 0) {\n        return false;\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpz3iq64q4.js:39:12)\n    at Object.<anonymous> (/tmp/tmpz3iq64q4.js:52:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333962
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        let char = string[i];\n        if (char === '[') {\n            stack.push(char);\n        } else if (char === ']') {\n            if (stack.length === 0) {\n                return false;\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpgjyq7xmf.js:39:12)\n    at Object.<anonymous> (/tmp/tmpgjyq7xmf.js:52:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333973
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number = 0;\n\tlet close_brackets: number = 0;\n\tlet open_brackets_stack: string[] = [];\n\tlet close_brackets_stack: string[] = [];\n\tlet open_brackets_stack_string: string = \"\";\n\tlet close_brackets_stack_string: string = \"\";\n\tlet open_brackets_string: string = \"\";\n\tlet close_brackets_string: string = \"\";\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlet char = string[i];\n\t\tif (char === \"[\") {\n\t\t\topen_brackets++;\n\t\t\topen_brackets_stack.push(char);\n\t\t\topen_brackets_string += char;\n\t\t} else if (char === \"]\") {\n\t\t\tclose_brackets++;\n\t\t\tclose_brackets_stack.push(char);\n\t\t\tclose_brackets_string += char;\n\t\t} else if (char === \"[[\") {\n\t\t\topen_brackets++;\n\t\t\topen_brackets_stack.push(char);\n\t\t\topen_brackets_string += char;\n\t\t} else if (char === \"]]\") {\n\t\t\tclose_brackets++;\n\t\t\tclose_brackets_stack.push(char);\n\t\t\tclose_brackets_string += char;\n\t\t} else if (char === \"[[[\") {\n\t\t\topen_brackets++;\n\t\t\topen_brackets_stack.push(char);\n\t\t\topen_brackets_string += char;\n\t\t} else if (char === \"]]\"]) {\n\t\t\tclose_brackets++;\n\t\t\tclose_brackets_stack.push(char);\n\t\t\tclose_brackets_string += char;\n\t\t} else if (char === \"[[[\") {\n\t\t\topen_brackets++;\n\t\t\topen_brackets_stack.push(char);\n\t\t\topen_brackets_string += char;\n\t\t} else if (char === \"]]\"]) {\n\t\t\tclose_brackets++;\n\t\t\tclose_brackets_stack.push(char);\n\t\t\tclose_brackets_string += char;\n\t\t} else if (char === \"[[[\") {\n\t\t\topen_brackets++;\n\t\t\topen_brackets_stack.push(char);\n\t\t\topen_brackets_string += char;\n\t\t} else if (char === \"]]\"]) {\n\t\t\tclose_brackets++;\n\t\t\tclose_brackets_stack.push(char);\n\t\t\tclose_brackets_string += char;\n\t\t} else if (char === \"[[[\") {\n\t\t\topen_brackets++;\n\t\t\topen_brackets_stack.push(char);\n\t\t\topen_brackets_string += char;\n\t\t} else if (char === \"]]\"]\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmppx5s3yc1.ts(47,27): error TS1005: ')' expected.\n../../../../tmp/tmppx5s3yc1.ts(47,28): error TS1128: Declaration or statement expected.\n../../../../tmp/tmppx5s3yc1.ts(51,5): error TS1128: Declaration or statement expected.\n../../../../tmp/tmppx5s3yc1.ts(55,27): error TS1005: ')' expected.\n../../../../tmp/tmppx5s3yc1.ts(55,28): error TS1128: Declaration or statement expected.\n../../../../tmp/tmppx5s3yc1.ts(59,5): error TS1128: Declaration or statement expected.\n../../../../tmp/tmppx5s3yc1.ts(63,27): error TS1005: ')' expected.\n../../../../tmp/tmppx5s3yc1.ts(63,28): error TS1128: Declaration or statement expected.\n../../../../tmp/tmppx5s3yc1.ts(67,5): error TS1128: Declaration or statement expected.\n../../../../tmp/tmppx5s3yc1.ts(71,27): error TS1005: ')' expected.\n../../../../tmp/tmppx5s3yc1.ts(94,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333973
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    if (string.length < 2) return false;\n    let open_brackets = 0;\n    let close_brackets = 0;\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] == \"[\") {\n            open_brackets++;\n        } else if (string[i] == \"]\") {\n            close_brackets++;\n        }\n        if (open_brackets < close_brackets) return false;\n    }\n    return open_brackets == close_brackets;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpdmox9dvb.js:38:12)\n    at Object.<anonymous> (/tmp/tmpdmox9dvb.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333973
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_brackets_length = 0;\n\tlet close_brackets_length = 0;\n\tlet open_stack: number[] = [];\n\tlet close_stack: number[] = [];\n\tlet open_stack_length = 0;\n\tlet close_stack_length = 0;\n\tlet open_brackets_index = 0;\n\tlet close_brackets_index = 0;\n\tlet open_brackets_index_in_string = 0;\n\tlet close_brackets_index_in_string = 0;\n\tlet open_brackets_index_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_stack = 0;\n\tlet close_brackets_index_in_string_in_stack = 0;\n\tlet open_brackets_index_in_stack = 0;\n\tlet close_brackets_index_in_stack = 0;\n\tlet open_brackets_index_in_stack_in_string = 0;\n\tlet close_brackets_index_in_stack_in_string = 0;\n\tlet open_brackets_index_in_stack_in_string_in_string = 0;\n\tlet close_brackets_index_in_stack_in_string_in_string = 0;\n\tlet open_brackets_index_in_stack_in_string_in_stack = 0;\n\tlet close_brackets_index_in_stack_in_string_in_stack = 0;\n\tlet open_brackets_index_in_stack_in_stack = 0;\n\tlet close_brackets_index_in_stack_in_stack = 0;\n\tlet open_brackets_index_in_stack_in_stack_in_string = 0;\n\tlet close_brackets_index_in_stack_in_stack_in_string = 0;\n\tlet open_brackets_index_in_stack_in_stack_in_string_in_string = 0;\n\tlet close_brackets_index_in_stack_in_stack_in_string_in_string = 0;\n\tlet open_brackets_index_in_stack_in_stack_in_string_in_stack = 0;\n\tlet close_brackets_index_in_stack_in_stack_in_stack = 0;\n\tlet open_brackets_index_in_stack_in_stack_in_stack_in_string = 0;\n\tlet close_brackets_index_in_stack_in_stack_in_stack_in_string = 0;\n\tlet open_brackets_index_in_stack_in_stack_in_stack_in_string_in_string = 0;\n\tlet \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpswcloo_6.ts(56,9): error TS1005: ',' expected.\n../../../../tmp/tmpswcloo_6.ts(78,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333973
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    if (string.length < 2) return false\n    if (string[0] != \"[\" || string[string.length - 1] != \"]\") return false\n    let open = string.indexOf(\"[\")\n    let close = string.indexOf(\"]\")\n    if (open < 0 || close < 0 || open >= close || close >= string.length - 1) return false\n    let nested = string.substring(open + 1, close)\n    let open2 = nested.indexOf(\"[\")\n    let close2 = nested.indexOf(\"]\")\n    if (open2 < 0 || close2 < 0 || open2 >= close2 || close2 >= nested.length - 1) return false\n    return true\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmpggeuooek.js:35:12)\n    at Object.<anonymous> (/tmp/tmpggeuooek.js:50:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333975
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number = 0;\n\tlet close_brackets: number = 0;\n\tlet open_brackets_stack: string[] = [];\n\tlet close_brackets_stack: string[] = [];\n\tlet open_brackets_stack_string: string = \"\";\n\tlet close_brackets_stack_string: string = \"\";\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index2: number = 0;\n\tlet close_brackets_stack_string_index2: number = 0;\n\tlet open_brackets_stack_string_index3: number = 0;\n\tlet close_brackets_stack_string_index3: number = 0;\n\tlet open_brackets_stack_string_index4: number = 0;\n\tlet close_brackets_stack_string_index4: number = 0;\n\tlet open_brackets_stack_string_index5: number = 0;\n\tlet close_brackets_stack_string_index5: number = 0;\n\tlet open_brackets_stack_string_index6: number = 0;\n\tlet close_brackets_stack_string_index6: number = 0;\n\tlet open_brackets_stack_string_index7: number = 0;\n\tlet close_brackets_stack_string_index7: number = 0;\n\tlet open_brackets_stack_string_index8: number = 0;\n\tlet close_brackets_stack_string_index8: number = 0;\n\tlet open_brackets_stack_string_index9: number = 0;\n\tlet close_brackets_stack_string_index9: number = 0;\n\tlet open_brackets_stack_string_index10: number = 0;\n\tlet close_brackets_stack_string_index10: number = 0;\n\tlet open_brackets_stack_string_index11: number = 0;\n\tlet close_brackets_stack_string_index11: number = 0;\n\tlet open_brackets_stack_string_index12: number = 0;\n\tlet close_brackets_stack_string_index12: number = 0;\n\tlet open_brackets_stack_string_index13: number = 0;\n\tlet close_brackets_stack_string_index13: number = 0;\n\tlet open_brackets_stack_string_index14: number = 0;\n\tlet close_brackets_stack_string_index14: number = 0;\n\tlet open_brackets_stack_string_index15: number = 0;\n\tlet close_brackets_stack_string_index15: number = 0;\n\tlet open_b\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpa73zt2tq.ts(76,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333965
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            stack.push(string[i]);\n        } else if (string[i] === \"]\") {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpzojs0i1x.js:36:12)\n    at Object.<anonymous> (/tmp/tmpzojs0i1x.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333962
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet bracketCount = 0;\n\tlet openBracketCount = 0;\n\tlet closeBracketCount = 0;\n\tlet openBracketCount2 = 0;\n\tlet closeBracketCount2 = 0;\n\tlet openBracketCount3 = 0;\n\tlet closeBracketCount3 = 0;\n\tlet openBracketCount4 = 0;\n\tlet closeBracketCount4 = 0;\n\tlet openBracketCount5 = 0;\n\tlet closeBracketCount5 = 0;\n\tlet openBracketCount6 = 0;\n\tlet closeBracketCount6 = 0;\n\tlet openBracketCount7 = 0;\n\tlet closeBracketCount7 = 0;\n\tlet openBracketCount8 = 0;\n\tlet closeBracketCount8 = 0;\n\tlet openBracketCount9 = 0;\n\tlet closeBracketCount9 = 0;\n\tlet openBracketCount10 = 0;\n\tlet closeBracketCount10 = 0;\n\tlet openBracketCount11 = 0;\n\tlet closeBracketCount11 = 0;\n\tlet openBracketCount12 = 0;\n\tlet closeBracketCount12 = 0;\n\tlet openBracketCount13 = 0;\n\tlet closeBracketCount13 = 0;\n\tlet openBracketCount14 = 0;\n\tlet closeBracketCount14 = 0;\n\tlet openBracketCount15 = 0;\n\tlet closeBracketCount15 = 0;\n\tlet openBracketCount16 = 0;\n\tlet closeBracketCount16 = 0;\n\tlet openBracketCount17 = 0;\n\tlet closeBracketCount17 = 0;\n\tlet openBracketCount18 = 0;\n\tlet closeBracketCount18 = 0;\n\tlet openBracketCount19 = 0;\n\tlet closeBracketCount19 = 0;\n\tlet openBracketCount20 = 0;\n\tlet closeBracketCount20 = 0;\n\tlet openBracketCount21 = 0;\n\tlet closeBracketCount21 = 0;\n\tlet openBracketCount22 = 0;\n\tlet closeBracketCount22 = 0;\n\tlet openBracketCount23 = 0;\n\tlet closeBracketCount23 = 0;\n\tlet openBracketCount24 = 0;\n\tlet closeBracketCount24 = 0;\n\tlet openBracketCount25 = 0;\n\tlet closeBracketCount25 = 0;\n\tlet openBracketCount26 = 0;\n\tlet closeBracketCount26 = 0;\n\tlet openBracketCount27 = 0;\n\tlet closeBracketCount27 = 0;\n\tlet openBracketCount28 = 0;\n\tlet closeBracketCount28 = 0;\n\tlet openBracketCount29 = 0;\n\tlet close\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpnh4y062h.ts(98,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333975
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: number[] = [];\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    let open_parens: number[] = [];\n    let close_parens: number[] = [];\n    let open_brackets_stack: number[] = [];\n    let close_brackets_stack: number[] = [];\n    let open_parens_stack: number[] = [];\n    let close_parens_stack: number[] = [];\n    let open_brackets_stack_index: number[] = [];\n    let close_brackets_stack_index: number[] = [];\n    let open_parens_stack_index: number[] = [];\n    let close_parens_stack_index: number[] = [];\n    let open_brackets_stack_index2: number[] = [];\n    let close_brackets_stack_index2: number[] = [];\n    let open_parens_stack_index2: number[] = [];\n    let close_parens_stack_index2: number[] = [];\n    let open_brackets_stack_index3: number[] = [];\n    let close_brackets_stack_index3: number[] = [];\n    let open_parens_stack_index3: number[] = [];\n    let close_parens_stack_index3: number[] = [];\n    let open_brackets_stack_index4: number[] = [];\n    let close_brackets_stack_index4: number[] = [];\n    let open_parens_stack_index4: number[] = [];\n    let close_parens_stack_index4: number[] = [];\n    let open_brackets_stack_index5: number[] = [];\n    let close_brackets_stack_index5: number[] = [];\n    let open_parens_stack_index5: number[] = [];\n    let close_parens_stack_index5: number[] = [];\n    let open_brackets_stack_index6: number[] = [];\n    let close_brackets_stack_index6: number[] = [];\n    let open_parens_stack_index6: number[] = [];\n    let close_parens_stack_index6: number[] = [];\n    let open_brackets_stack_index7: number[] = [];\n    let close_brackets_stack_index7: number[] = [];\n    let open_parens_stack_index7: number[] = [];\n    let close_parens_stack_index7: number[] = [];\n    let open_brackets_stack_index8: number[] = [];\n    let close_brackets_stack_index8: number[] = [];\n    let open_parens_stack_index8: number[] = [];\n    let close_parens_stack_index8: number[] = [];\n    let open_brackets_stack_index9: number[] = [];\n    let close_brackets_stack_index9: number[] = [];\n    let \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpcbhfwkee.ts(61,9): error TS1005: ',' expected.\n../../../../tmp/tmpcbhfwkee.ts(83,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333975
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets = string.match(/\\[.*?\\]/g);\n    if (brackets === null) {\n        return false;\n    }\n    let nesting = 0;\n    for (let i = 0; i < brackets.length; i++) {\n        if (brackets[i] === \"[\") {\n            nesting++;\n        } else if (brackets[i] === \"]\") {\n            nesting--;\n        }\n        if (nesting < 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpy_gaf1dr.js:39:12)\n    at Object.<anonymous> (/tmp/tmpy_gaf1dr.js:53:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333975
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: number[] = [];\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    let open_parens: number[] = [];\n    let close_parens: number[] = [];\n    let open_brackets_stack: number[] = [];\n    let close_brackets_stack: number[] = [];\n    let open_parens_stack: number[] = [];\n    let close_parens_stack: number[] = [];\n    let open_brackets_stack_index: number[] = [];\n    let close_brackets_stack_index: number[] = [];\n    let open_parens_stack_index: number[] = [];\n    let close_parens_stack_index: number[] = [];\n    let open_brackets_stack_index2: number[] = [];\n    let close_brackets_stack_index2: number[] = [];\n    let open_parens_stack_index2: number[] = [];\n    let close_parens_stack_index2: number[] = [];\n    let open_brackets_stack_index3: number[] = [];\n    let close_brackets_stack_index3: number[] = [];\n    let open_parens_stack_index3: number[] = [];\n    let close_parens_stack_index3: number[] = [];\n    let open_brackets_stack_index4: number[] = [];\n    let close_brackets_stack_index4: number[] = [];\n    let open_parens_stack_index4: number[] = [];\n    let close_parens_stack_index4: number[] = [];\n    let open_brackets_stack_index5: number[] = [];\n    let close_brackets_stack_index5: number[] = [];\n    let open_parens_stack_index5: number[] = [];\n    let close_parens_stack_index5: number[] = [];\n    let open_brackets_stack_index6: number[] = [];\n    let close_brackets_stack_index6: number[] = [];\n    let open_parens_stack_index6: number[] = [];\n    let close_parens_stack_index6: number[] = [];\n    let open_brackets_stack_index7: number[] = [];\n    let close_brackets_stack_index7: number[] = [];\n    let open_parens_stack_index7: number[] = [];\n    let close_parens_stack_index7: number[] = [];\n    let open_brackets_stack_index8: number[] = [];\n    let close_brackets_stack_index8: number[] = [];\n    let open_parens_stack_index8: number[] = [];\n    let close_parens_stack_index8: number[] = [];\n    let open_brackets_stack_index9: number[] = [];\n    let close_brackets_stack_index9: number[] = [];\n    let \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpcbhfwkee.ts(61,9): error TS1005: ',' expected.\n../../../../tmp/tmpcbhfwkee.ts(83,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333975
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number = 0;\n\tlet close_brackets: number = 0;\n\tlet open_brackets_stack: string[] = [];\n\tlet close_brackets_stack: string[] = [];\n\tlet open_brackets_stack_string: string = \"\";\n\tlet close_brackets_stack_string: string = \"\";\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index2: number = 0;\n\tlet close_brackets_stack_string_index2: number = 0;\n\tlet open_brackets_stack_string_index3: number = 0;\n\tlet close_brackets_stack_string_index3: number = 0;\n\tlet open_brackets_stack_string_index4: number = 0;\n\tlet close_brackets_stack_string_index4: number = 0;\n\tlet open_brackets_stack_string_index5: number = 0;\n\tlet close_brackets_stack_string_index5: number = 0;\n\tlet open_brackets_stack_string_index6: number = 0;\n\tlet close_brackets_stack_string_index6: number = 0;\n\tlet open_brackets_stack_string_index7: number = 0;\n\tlet close_brackets_stack_string_index7: number = 0;\n\tlet open_brackets_stack_string_index8: number = 0;\n\tlet close_brackets_stack_string_index8: number = 0;\n\tlet open_brackets_stack_string_index9: number = 0;\n\tlet close_brackets_stack_string_index9: number = 0;\n\tlet open_brackets_stack_string_index10: number = 0;\n\tlet close_brackets_stack_string_index10: number = 0;\n\tlet open_brackets_stack_string_index11: number = 0;\n\tlet close_brackets_stack_string_index11: number = 0;\n\tlet open_brackets_stack_string_index12: number = 0;\n\tlet close_brackets_stack_string_index12: number = 0;\n\tlet open_brackets_stack_string_index13: number = 0;\n\tlet close_brackets_stack_string_index13: number = 0;\n\tlet open_brackets_stack_string_index14: number = 0;\n\tlet close_brackets_stack_string_index14: number = 0;\n\tlet open_brackets_stack_string_index15: number = 0;\n\tlet close_brackets_stack_string_index15: \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp0jvnjyr4.ts(54,9): error TS1005: ',' expected.\n../../../../tmp/tmp0jvnjyr4.ts(76,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333975
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\" || string[i] === \"(\") {\n            stack.push(string[i]);\n        } else if (string[i] === \"]\") {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    if (stack.length === 0) {\n        return true;\n    }\n    return false;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpmz_3d391.js:39:12)\n    at Object.<anonymous> (/tmp/tmpmz_3d391.js:52:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333976
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let open_brackets: number[] = [];\n    let closed_brackets: number[] = [];\n    let open_brackets_length: number = 0;\n    let closed_brackets_length: number = 0;\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            open_brackets_length++;\n        } else if (string[i] === \"]\") {\n            closed_brackets_length++;\n        }\n        if (open_brackets_length >= closed_brackets_length) {\n            open_brackets.push(open_brackets_length);\n            closed_brackets.push(closed_brackets_length);\n        }\n    }\n    for (let i = 0; i < open_brackets.length; i++) {\n        if (open_brackets[i] === closed_brackets[i]) {\n            return true;\n        }\n    }\n    return false;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpfrdmug76.js:44:12)\n    at Object.<anonymous> (/tmp/tmpfrdmug76.js:58:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333976
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        let char = string[i];\n        if (char === \"[\") {\n            stack.push(char);\n        } else if (char === \"]\") {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpa2_w1wi6.js:37:12)\n    at Object.<anonymous> (/tmp/tmpa2_w1wi6.js:50:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333976
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    let opening_brackets: number[] = [];\n    let closing_brackets: number[] = [];\n    let opening_quotes: number[] = [];\n    let closing_quotes: number[] = [];\n    let opening_curly_brackets: number[] = [];\n    let closing_curly_brackets: number[] = [];\n    let opening_square_brackets: number[] = [];\n    let closing_square_brackets: number[] = [];\n    let opening_curly_quotes: number[] = [];\n    let closing_curly_quotes: number[] = [];\n    let opening_square_quotes: number[] = [];\n    let closing_square_quotes: number[] = [];\n    let opening_curly_braces: number[] = [];\n    let closing_curly_braces: number[] = [];\n    let opening_square_braces: number[] = [];\n    let closing_square_braces: number[] = [];\n    let opening_parenthesis: number[] = [];\n    let closing_parenthesis: number[] = [];\n    let opening_square_parenthesis: number[] = [];\n    let closing_square_parenthesis: number[] = [];\n    let opening_curly_braces: number[] = [];\n    let closing_curly_braces: number[] = [];\n    let opening_square_braces: number[] = [];\n    let closing_square_braces: number[] = [];\n    let opening_curly_quotes: number[] = [];\n    let closing_curly_quotes: number[] = [];\n    let opening_square_quotes: number[] = [];\n    let closing_square_quotes: number[] = [];\n    let opening_curly_braces: number[] = [];\n    let closing_curly_braces: number[] = [];\n    let opening_square_braces: number[] = [];\n    let closing_square_braces: number[] = [];\n    let opening_curly_brackets: number[] = [];\n    let closing_curly_brackets: number[] = [];\n    let opening_square_brackets: number[] = [];\n    let closing_square_brackets: number[] = [];\n    let opening_parenthesis: number[] = [];\n    let closing_parenthesis: number[] = [];\n    let opening_square_parenthesis: number[] = [];\n    let closing_square_parenthesis: number[] = [];\n    let opening_curly_brackets: number[] = [];\n    let closing_curly_brackets: number[] = [];\n    let opening_square_brackets: number[] = [];\n    let closing_square_brackets: number[] = [];\n    let opening_curly_quotes: number[] = [];\n    let closing_curly_quotes: number\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpd15ncj4e.ts(86,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333976
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_brackets_length: number = 0;\n\tlet close_brackets_length: number = 0;\n\tlet open_brackets_index = 0;\n\tlet close_brackets_index = 0;\n\tlet open_brackets_index_in_string = 0;\n\tlet close_brackets_index_in_string = 0;\n\tlet open_brackets_index_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string_in_string_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string_in_string_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string_in_string_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string_in_string_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string_in_string_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string_in_string_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string_in_string_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string_in_string_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string_in_string_in_string_in_string_in_string = 0;\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpuxmvrrb4.ts(69,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333975
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_parens: number[] = [];\n\tlet close_parens: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_parens_stack: number[] = [];\n\tlet close_parens_stack: number[] = [];\n\tlet open_brackets_stack_index: number[] = [];\n\tlet close_brackets_stack_index: number[] = [];\n\tlet open_parens_stack_index: number[] = [];\n\tlet close_parens_stack_index: number[] = [];\n\tlet open_brackets_stack_index2: number[] = [];\n\tlet close_brackets_stack_index2: number[] = [];\n\tlet open_parens_stack_index2: number[] = [];\n\tlet close_parens_stack_index2: number[] = [];\n\tlet open_brackets_stack_index3: number[] = [];\n\tlet close_brackets_stack_index3: number[] = [];\n\tlet open_parens_stack_index3: number[] = [];\n\tlet close_parens_stack_index3: number[] = [];\n\tlet open_brackets_stack_index4: number[] = [];\n\tlet close_brackets_stack_index4: number[] = [];\n\tlet open_parens_stack_index4: number[] = [];\n\tlet close_parens_stack_index4: number[] = [];\n\tlet open_brackets_stack_index5: number[] = [];\n\tlet close_brackets_stack_index5: number[] = [];\n\tlet open_parens_stack_index5: number[] = [];\n\tlet close_parens_stack_index5: number[] = [];\n\tlet open_brackets_stack_index6: number[] = [];\n\tlet close_brackets_stack_index6: number[] = [];\n\tlet open_parens_stack_index6: number[] = [];\n\tlet close_parens_stack_index6: number[] = [];\n\tlet open_brackets_stack_index7: number[] = [];\n\tlet close_brackets_stack_index7: number[] = [];\n\tlet open_parens_stack_index7: number[] = [];\n\tlet close_parens_stack_index7: number[] = [];\n\tlet open_brackets_stack_index8: number[] = [];\n\tlet close_brackets_stack_index8: number[] = [];\n\tlet open_parens_stack_index8: number[] = [];\n\t\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpymwg3hw3.ts(80,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333976
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] == \"[\") {\n            stack.push(string[i]);\n        } else if (string[i] == \"]\") {\n            if (stack.length == 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length == 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpf6hh5s3s.js:36:12)\n    at Object.<anonymous> (/tmp/tmpf6hh5s3s.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333969
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: string[] = string.split('');\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    let open_brackets_stack: number[] = [];\n    let close_brackets_stack: number[] = [];\n    let open_brackets_length: number = 0;\n    let close_brackets_length: number = 0;\n    let open_brackets_stack_index: number = 0;\n    let close_brackets_stack_index: number = 0;\n    let open_brackets_length_index: number = 0;\n    let close_brackets_length_index: number = 0;\n    let open_brackets_stack_index2: number = 0;\n    let close_brackets_stack_index2: number = 0;\n    let open_brackets_length_index2: number = 0;\n    let close_brackets_length_index2: number = 0;\n    let open_brackets_stack_index3: number = 0;\n    let close_brackets_stack_index3: number = 0;\n    let open_brackets_length_index3: number = 0;\n    let close_brackets_length_index3: number = 0;\n    let open_brackets_stack_index4: number = 0;\n    let close_brackets_stack_index4: number = 0;\n    let open_brackets_length_index4: number = 0;\n    let close_brackets_length_index4: number = 0;\n    let open_brackets_stack_index5: number = 0;\n    let close_brackets_stack_index5: number = 0;\n    let open_brackets_length_index5: number = 0;\n    let close_brackets_length_index5: number = 0;\n    let open_brackets_stack_index6: number = 0;\n    let close_brackets_stack_index6: number = 0;\n    let open_brackets_length_index6: number = 0;\n    let close_brackets_length_index6: number = 0;\n    let open_brackets_stack_index7: number = 0;\n    let close_brackets_stack_index7: number = 0;\n    let open_brackets_length_index7: number = 0;\n    let close_brackets_length_index7: number = 0;\n    let open_brackets_stack_index8: number = 0;\n    let close_brackets_stack_index8: number = 0;\n    let open_brackets_length_index8: number = 0;\n    let close_brackets_length_index8: number = 0;\n    let open_brackets_stack_index9: number = 0;\n    let close_brackets_stack_index9: number = 0;\n    let open_brackets_length_index9: number = 0;\n    let \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp4um0j57l.ts(60,9): error TS1005: ',' expected.\n../../../../tmp/tmp4um0j57l.ts(82,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333976
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    if (string.length < 2) return false;\n    let brackets = string.replace(/[\\[\\]]/g, '').split('');\n    let open_brackets = brackets.filter(x => x === '[');\n    let close_brackets = brackets.filter(x => x === ']');\n    if (open_brackets.length < 1 || close_brackets.length < 1) return false;\n    let open_brackets_count = open_brackets.filter(x => x === '[').length;\n    let close_brackets_count = close_brackets.filter(x => x === ']').length;\n    if (open_brackets_count === close_brackets_count && open_brackets_count === brackets.length - 1) return true;\n    return false;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmpskwjuvuu.js:33:12)\n    at Object.<anonymous> (/tmp/tmpskwjuvuu.js:48:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333976
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        let char = string[i];\n        if (char === '[') {\n            open_brackets.push(i);\n        } else if (char === ']') {\n            close_brackets.push(i);\n        }\n    }\n    if (open_brackets.length !== close_brackets.length) {\n        return false;\n    }\n    for (let i = 0; i < open_brackets.length; i++) {\n        let open_bracket = open_brackets[i];\n        let close_bracket = close_brackets[i];\n        if (open_bracket === close_bracket) {\n            continue;\n        }\n        if (open_bracket > close_bracket) {\n            return false;\n        }\n        let open_char = string.substring(open_bracket, open_bracket + 1);\n        let close_char = string.substring(close_bracket, close_bracket + 1);\n        if (open_char === '[' && close_char === ']') {\n            continue;\n        }\n        if (open_char === '[' && close_char === '[') {\n            continue;\n        }\n        if (open_char === ']' && close_char === ']') {\n            continue;\n        }\n        if (open_char === ']' && close_char === '[') {\n            continue;\n        }\n        if (open_char === '[' && close_char === ']') {\n            continue;\n        }\n        if (open_char === '[' && close_char === '[') {\n            continue;\n        }\n        if (open_char === ']' && close_char === '[') {\n            continue;\n        }\n        if (open_char === ']' && close_char === '[') {\n            continue;\n        }\n        if (open_char === '[' && close_char === ']') {\n            continue;\n        }\n        if (open_char === '[' && close_char === '[') {\n            continue;\n        }\n        if (open_char === ']' && close_char === '[') {\n            continue;\n        }\n        if (open_char === '[' && close_char === ']') {\n            continue;\n        }\n        if (open_char === '[' && close_char === '[') {\n            continue;\n        }\n        if (open_char === ']' && close_char === '[') {\n            continue;\n        }\n        if (open_char === '[' && close_char === '[') {\n            continue;\n        }\n        if (open_char === ']' && close_char === '[') {\n            continue;\n        }\n        if (open_char === '[' && close_char === '[') {\n            continue;\n        }\n        if (open_char === ']' && close_char === '[') {\n            continue;\n        }\n        if (open_char === '[' && close_char === '[') {\n            continue;\n        }\n        if (open_char === '[' && close_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp2m9tyq6x.ts(99,1): error TS1005: ')' expected.\n../../../../tmp/tmp2m9tyq6x.ts(121,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333976
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_parens: number[] = [];\n\tlet close_parens: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_parens_stack: number[] = [];\n\tlet close_parens_stack: number[] = [];\n\tlet open_brackets_stack_index: number[] = [];\n\tlet close_brackets_stack_index: number[] = [];\n\tlet open_parens_stack_index: number[] = [];\n\tlet close_parens_stack_index: number[] = [];\n\tlet open_brackets_stack_index2: number[] = [];\n\tlet close_brackets_stack_index2: number[] = [];\n\tlet open_parens_stack_index2: number[] = [];\n\tlet close_parens_stack_index2: number[] = [];\n\tlet open_brackets_stack_index3: number[] = [];\n\tlet close_brackets_stack_index3: number[] = [];\n\tlet open_parens_stack_index3: number[] = [];\n\tlet close_parens_stack_index3: number[] = [];\n\tlet open_brackets_stack_index4: number[] = [];\n\tlet close_brackets_stack_index4: number[] = [];\n\tlet open_parens_stack_index4: number[] = [];\n\tlet close_parens_stack_index4: number[] = [];\n\tlet open_brackets_stack_index5: number[] = [];\n\tlet close_brackets_stack_index5: number[] = [];\n\tlet open_parens_stack_index5: number[] = [];\n\tlet close_parens_stack_index5: number[] = [];\n\tlet open_brackets_stack_index6: number[] = [];\n\tlet close_brackets_stack_index6: number[] = [];\n\tlet open_parens_stack_index6: number[] = [];\n\tlet close_parens_stack_index6: number[] = [];\n\tlet open_brackets_stack_index7: number[] = [];\n\tlet close_brackets_stack_index7: number[] = [];\n\tlet open_parens_stack_index7: number[] = [];\n\tlet close_parens_stack_index7: number[] = [];\n\tlet open_brackets_stack_index8: number[] = [];\n\tlet close_brackets_stack_index8: number[] = [];\n\tlet open_parens_stack_index8: number[] = [];\n\t\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpymwg3hw3.ts(80,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333976
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_curly: number[] = [];\n\tlet close_curly: number[] = [];\n\tlet open_paren: number[] = [];\n\tlet close_paren: number[] = [];\n\tlet open_curly_brackets: number[] = [];\n\tlet close_curly_brackets: number[] = [];\n\tlet open_paren_brackets: number[] = [];\n\tlet close_paren_brackets: number[] = [];\n\tlet open_curly_brackets_brackets: number[] = [];\n\tlet close_curly_brackets_brackets: number[] = [];\n\tlet open_paren_brackets_brackets: number[] = [];\n\tlet close_paren_brackets_brackets: number[] = [];\n\tlet open_curly_brackets_brackets_brackets: number[] = [];\n\tlet close_curly_brackets_brackets_brackets: number[] = [];\n\tlet open_paren_brackets_brackets_brackets: number[] = [];\n\tlet close_paren_brackets_brackets_brackets: number[] = [];\n\tlet open_curly_brackets_brackets_brackets_brackets: number[] = [];\n\tlet close_curly_brackets_brackets_brackets_brackets: number[] = [];\n\tlet open_paren_brackets_brackets_brackets_brackets: number[] = [];\n\tlet close_paren_brackets_brackets_brackets_brackets: number[] = [];\n\tlet open_curly_brackets_brackets_brackets_brackets_brackets: number[] = [];\n\tlet close_curly_brackets_brackets_brackets_brackets_brackets: number[] = [];\n\tlet open_paren_brackets_brackets_brackets_brackets_brackets: number[] = [];\n\tlet close_paren_brackets_brackets_brackets_brackets_brackets: number[] = [];\n\tlet open_curly_brackets_brackets_brackets_brackets_brackets_brackets: number[] = [];\n\tlet close_curly_brackets_brackets_brackets_brackets_brackets_brackets: number[] = [];\n\tlet open_paren_brackets_brackets_brackets_brackets_brackets_brackets: number[] = [];\n\tlet close_paren_brackets_brackets_brackets_brackets_brackets_brackets: number[] = [];\n\tlet open_curly_brackets_brackets_brackets_brackets_brackets_brackets_brackets: number[] = [];\n\tlet close_curly_brackets_brackets_brackets_brackets_brackets_brackets_brackets: number[] = [];\n\tlet open_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpdw2_80ry.ts(73,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333976
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        let char = string[i];\n        if (char === '[') {\n            stack.push(char);\n        } else if (char === ']') {\n            if (stack.length === 0) {\n                return false;\n            }\n            let openBracket = stack.pop();\n            if (openBracket !== '[') {\n                return false;\n            }\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmp3gnzgm8o.js:40:12)\n    at Object.<anonymous> (/tmp/tmp3gnzgm8o.js:53:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333969
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet bracket_stack: number[] = [];\n\tlet bracket_stack_length: number = 0;\n\tlet bracket_stack_pointer: number = 0;\n\tlet bracket_stack_pointer_length: number = 0;\n\tlet bracket_stack_pointer_pointer: number = 0;\n\tlet bracket_stack_pointer_pointer_length: number = 0;\n\tlet bracket_stack_pointer_pointer_pointer: number = 0;\n\tlet bracket_stack_pointer_pointer_pointer_length: number = 0;\n\tlet bracket_stack_pointer_pointer_pointer_pointer: number = 0;\n\tlet bracket_stack_pointer_pointer_pointer_pointer_length: number = 0;\n\tlet bracket_stack_pointer_pointer_pointer_pointer_pointer_length: number = 0;\n\tlet bracket_stack_pointer_pointer_pointer_pointer_pointer_pointer_length: number = 0;\n\tlet bracket_stack_pointer_pointer_pointer_pointer_pointer_pointer_length: number = 0;\n\tlet bracket_stack_pointer_pointer_pointer_pointer_pointer_pointer_length: number = 0;\n\tlet bracket_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_length: number = 0;\n\tlet bracket_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_length: number = 0;\n\tlet bracket_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_length: number = 0;\n\tlet bracket_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_length: number = 0;\n\tlet bracket_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_length: number = 0;\n\tlet bracket_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_length: number = 0;\n\tlet bracket_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_length: number = 0;\n\tlet bracket_stack_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_pointer_length: number = 0;\n\tlet brack\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpf_97qg7m.ts(67,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333976
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: number[] = [];\n    let open_brackets: number[] = [];\n    let closed_brackets: number[] = [];\n    let open_parens: number[] = [];\n    let close_parens: number[] = [];\n    let open_brackets_stack: number[] = [];\n    let closed_brackets_stack: number[] = [];\n    let open_parens_stack: number[] = [];\n    let close_parens_stack: number[] = [];\n    let open_brackets_stack_index: number[] = [];\n    let closed_brackets_stack_index: number[] = [];\n    let open_parens_stack_index: number[] = [];\n    let close_parens_stack_index: number[] = [];\n    let open_brackets_stack_index2: number[] = [];\n    let closed_brackets_stack_index2: number[] = [];\n    let open_parens_stack_index2: number[] = [];\n    let close_parens_stack_index2: number[] = [];\n    let open_brackets_stack_index3: number[] = [];\n    let closed_brackets_stack_index3: number[] = [];\n    let open_parens_stack_index3: number[] = [];\n    let close_parens_stack_index3: number[] = [];\n    let open_brackets_stack_index4: number[] = [];\n    let closed_brackets_stack_index4: number[] = [];\n    let open_parens_stack_index4: number[] = [];\n    let close_parens_stack_index4: number[] = [];\n    let open_brackets_stack_index5: number[] = [];\n    let closed_brackets_stack_index5: number[] = [];\n    let open_parens_stack_index5: number[] = [];\n    let close_parens_stack_index5: number[] = [];\n    let open_brackets_stack_index6: number[] = [];\n    let closed_brackets_stack_index6: number[] = [];\n    let open_parens_stack_index6: number[] = [];\n    let close_parens_stack_index6: number[] = [];\n    let open_brackets_stack_index7: number[] = [];\n    let closed_brackets_stack_index7: number[] = [];\n    let open_parens_stack_index7: number[] = [];\n    let close_parens_stack_index7: number[] = [];\n    let open_brackets_stack_index8: number[] = [];\n    let closed_brackets_stack_index8: number[] = [];\n    let open_parens_stack_index8: number[] = [];\n    let close_parens_stack_index8: number[] = [];\n    let open_brackets_stack_index9: number[] = [];\n    let closed_brackets_stack_index9: number[] = [];\n    let open_parens_stack_index9: number[] = [];\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp0n8cpais.ts(84,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333976
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number = 0;\n\tlet close_brackets: number = 0;\n\tlet open_brackets_stack: string[] = [];\n\tlet close_brackets_stack: string[] = [];\n\tlet open_brackets_length: number = 0;\n\tlet close_brackets_length: number = 0;\n\tlet open_brackets_stack_index: number = 0;\n\tlet close_brackets_stack_index: number = 0;\n\tlet open_brackets_stack_string: string = \"\";\n\tlet close_brackets_stack_string: string = \"\";\n\tlet open_brackets_string: string = \"\";\n\tlet close_brackets_string: string = \"\";\n\tlet open_brackets_string_index: number = 0;\n\tlet close_brackets_string_index: number = 0;\n\tlet open_brackets_string_index2: number = 0;\n\tlet close_brackets_string_index2: number = 0;\n\tlet open_brackets_string_index3: number = 0;\n\tlet close_brackets_string_index3: number = 0;\n\tlet open_brackets_string_index4: number = 0;\n\tlet close_brackets_string_index4: number = 0;\n\tlet open_brackets_string_index5: number = 0;\n\tlet close_brackets_string_index5: number = 0;\n\tlet open_brackets_string_index6: number = 0;\n\tlet close_brackets_string_index6: number = 0;\n\tlet open_brackets_string_index7: number = 0;\n\tlet close_brackets_string_index7: number = 0;\n\tlet open_brackets_string_index8: number = 0;\n\tlet close_brackets_string_index8: number = 0;\n\tlet open_brackets_string_index9: number = 0;\n\tlet close_brackets_string_index9: number = 0;\n\tlet open_brackets_string_index10: number = 0;\n\tlet close_brackets_string_index10: number = 0;\n\tlet open_brackets_string_index11: number = 0;\n\tlet close_brackets_string_index11: number = 0;\n\tlet open_brackets_string_index12: number = 0;\n\tlet close_brackets_string_index12: number = 0;\n\tlet open_brackets_string_index13: number = 0;\n\tlet close_brackets_string_index13: number = 0;\n\tlet open_brackets_string_index14: number = 0;\n\tlet close_b\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpzudcl3se.ts(79,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333976
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        let char = string[i];\n        if (char === '[') {\n            open_brackets.push(i);\n        } else if (char === ']') {\n            close_brackets.push(i);\n        } else if (char === '[' || char === ']') {\n            if (open_brackets.length === 0) {\n                return false;\n            }\n            let open_bracket = open_brackets[open_brackets.length - 1];\n            let close_bracket = close_brackets[close_brackets.length - 1];\n            if (open_bracket === close_bracket) {\n                open_brackets.pop();\n                close_brackets.pop();\n            } else {\n                return false;\n            }\n        }\n        stack.push(char);\n    }\n    return open_brackets.length !== 0 || close_brackets.length !== 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpaeqho92l.js:50:12)\n    at Object.<anonymous> (/tmp/tmpaeqho92l.js:64:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333977
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        let char = string[i];\n        if (char === '[') {\n            stack.push(char);\n        } else if (char === ']') {\n            if (stack.length !== 1) {\n                return false;\n            }\n            stack.pop();\n        } else {\n            if (stack.length !== 0 && stack[stack.length - 1] !== '[') {\n                return false;\n            }\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmpfobagpbq.js:40:12)\n    at Object.<anonymous> (/tmp/tmpfobagpbq.js:55:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333977
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    const stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        const char = string[i];\n        if (char === '[') {\n            stack.push(char);\n        } else if (char === ']') {\n            if (stack.length === 0) {\n                return false;\n            }\n            const top = stack.pop();\n            if (top !== '[' || stack.length === 0) {\n                return false;\n            }\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmpzrq8ixyy.js:38:12)\n    at Object.<anonymous> (/tmp/tmpzrq8ixyy.js:53:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333977
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_parens: number[] = [];\n\tlet close_parens: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_parens_stack: number[] = [];\n\tlet close_parens_stack: number[] = [];\n\tlet open_brackets_stack_index: number = 0;\n\tlet close_brackets_stack_index: number = 0;\n\tlet open_parens_stack_index: number = 0;\n\tlet close_parens_stack_index: number = 0;\n\tlet open_brackets_stack_string: string = \"\";\n\tlet close_brackets_stack_string: string = \"\";\n\tlet open_parens_stack_string: string = \"\";\n\tlet close_parens_stack_string: string = \"\";\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_parens_stack_string_index: number = 0;\n\tlet close_parens_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index2: number = 0;\n\tlet close_brackets_stack_string_index2: number = 0;\n\tlet open_parens_stack_string_index2: number = 0;\n\tlet close_parens_stack_string_index2: number = 0;\n\tlet open_brackets_stack_string_index3: number = 0;\n\tlet close_brackets_stack_string_index3: number = 0;\n\tlet open_parens_stack_string_index3: number = 0;\n\tlet close_parens_stack_string_index3: number = 0;\n\tlet open_brackets_stack_string_index4: number = 0;\n\tlet close_brackets_stack_string_index4: number = 0;\n\tlet open_parens_stack_string_index4: number = 0;\n\tlet close_parens_stack_string_index4: number = 0;\n\tlet open_brackets_stack_string_index5: number = 0;\n\tlet close_brackets_stack_string_index5: number = 0;\n\tlet open_parens_stack_string_index5: number = 0;\n\tlet close_parens_stack_string_index5: number = 0;\n\tlet open_brackets_stack_string_index6: number = 0;\n\tlet close_brackets_stack_string_index6: number = 0;\n\tlet open_parens_stack_string_index6: number = 0;\n\tlet close_parens_stack_string_index6: number = 0;\n\tlet open_brackets_stack\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp6hjo4p7d.ts(81,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333977
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet closed_brackets: number[] = [];\n\tlet open_brackets_length: number[] = [];\n\tlet closed_brackets_length: number[] = [];\n\tlet open_chars: number[] = [];\n\tlet close_chars: number[] = [];\n\tlet open_chars_length: number[] = [];\n\tlet close_chars_length: number[] = [];\n\tlet open_char: string;\n\tlet close_char: string;\n\tlet open_bracket: string;\n\tlet close_bracket: string;\n\tlet open_brackets_length_string: string;\n\tlet closed_brackets_length_string: string;\n\tlet open_chars_length_string: string;\n\tlet close_chars_length_string: string;\n\tlet open_char_string: string;\n\tlet close_char_string: string;\n\tlet open_brackets_string: string;\n\tlet closed_brackets_string: string;\n\tlet open_chars_string: string;\n\tlet close_chars_string: string;\n\tlet open_char_string_string: string;\n\tlet close_char_string_string: string;\n\tlet open_brackets_string_string: string;\n\tlet closed_brackets_string_string: string;\n\tlet open_chars_string_string: string;\n\tlet close_chars_string_string: string;\n\tlet open_char_string_string_string: string;\n\tlet close_char_string_string: string;\n\tlet open_brackets_string_string: string;\n\tlet closed_brackets_string_string: string;\n\tlet open_chars_string_string: string;\n\tlet close_chars_string_string: string;\n\tlet open_char_string_string_string: string;\n\tlet close_char_string_string: string;\n\tlet open_brackets_string_string: string;\n\tlet closed_brackets_string_string: string;\n\tlet open_chars_string_string: string;\n\tlet close_chars_string_string: string;\n\tlet open_char_string_string_string: string;\n\tlet close_char_string_string: string;\n\tlet open_brackets_string_string: string;\n\tlet closed_brackets_string_string: string;\n\tlet open_chars_string_string: string;\n\tlet close_chars_string_string: string;\n\tlet open_char_string_string: string;\n\tlet close_char_string_string: string;\n\tlet open_brackets_string_string: string;\n\tlet closed_brackets_string_string: string;\n\tlet open_chars_string_string: string;\n\tlet close_chars_string_string: string;\n\tlet open_char_string_string: string;\n\tlet close_char_string_string: string;\n\tlet open_brackets_string_string: string;\n\tlet closed_brackets_string_string: string;\n\tlet open_chars_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpgl42uupw.ts(97,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333977
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] == \"[\") {\n            stack.push(string[i]);\n        } else if (string[i] == \"]\") {\n            if (stack.length == 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length == 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpf6hh5s3s.js:36:12)\n    at Object.<anonymous> (/tmp/tmpf6hh5s3s.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333969
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets = string.match(/\\[.*?\\]/g);\n\tlet nested = false;\n\t\n\tif (brackets) {\n\t\tbrackets.forEach((bracket: string) => {\n\t\t\tlet brackets = bracket.match(/\\[.*?\\]/g);\n\t\t\tif (brackets) {\n\t\t\t\tnested = true;\n\t\t\t}\n\t\t});\n\t}\n\t\n\treturn nested;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmp2ii9egha.js:33:12)\n    at Object.<anonymous> (/tmp/tmp2ii9egha.js:47:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333978
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: number[] = [];\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    let open_brackets_stack: number[] = [];\n    let close_brackets_stack: number[] = [];\n    let bracket_counter = 0;\n    let bracket_counter2 = 0;\n    let bracket_counter3 = 0;\n    let bracket_counter4 = 0;\n    let bracket_counter5 = 0;\n    let bracket_counter6 = 0;\n    let bracket_counter7 = 0;\n    let bracket_counter8 = 0;\n    let bracket_counter9 = 0;\n    let bracket_counter10 = 0;\n    let bracket_counter11 = 0;\n    let bracket_counter12 = 0;\n    let bracket_counter13 = 0;\n    let bracket_counter14 = 0;\n    let bracket_counter15 = 0;\n    let bracket_counter16 = 0;\n    let bracket_counter17 = 0;\n    let bracket_counter18 = 0;\n    let bracket_counter19 = 0;\n    let bracket_counter20 = 0;\n    let bracket_counter21 = 0;\n    let bracket_counter22 = 0;\n    let bracket_counter23 = 0;\n    let bracket_counter24 = 0;\n    let bracket_counter25 = 0;\n    let bracket_counter26 = 0;\n    let bracket_counter27 = 0;\n    let bracket_counter28 = 0;\n    let bracket_counter29 = 0;\n    let bracket_counter30 = 0;\n    let bracket_counter31 = 0;\n    let bracket_counter32 = 0;\n    let bracket_counter33 = 0;\n    let bracket_counter34 = 0;\n    let bracket_counter35 = 0;\n    let bracket_counter36 = 0;\n    let bracket_counter37 = 0;\n    let bracket_counter38 = 0;\n    let bracket_counter39 = 0;\n    let bracket_counter40 = 0;\n    let bracket_counter41 = 0;\n    let bracket_counter42 = 0;\n    let bracket_counter43 = 0;\n    let bracket_counter44 = 0;\n    let bracket_counter45 = 0;\n    let bracket_counter46 = 0;\n    let bracket_counter47 = 0;\n    let bracket_counter48 = 0;\n    let bracket_counter49 = 0;\n    let bracket_counter50 = 0;\n    let bracket_counter51 = 0;\n    let bracket_counter52 = 0;\n    let bracket_counter53 = 0;\n    let bracket_counter54 = 0;\n    let bracket_counter55 = 0;\n    let bracket_counter56 = 0;\n    let bracket_counter57 = 0;\n    let bracket_counter58 = 0;\n    let bra\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpb2ozev8m.ts(103,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333978
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    if (string === \"\") {\n        return false;\n    }\n    let brackets = 0;\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            brackets++;\n        } else if (string[i] === \"]\") {\n            brackets--;\n        }\n        if (brackets < 0) {\n            return false;\n        }\n    }\n    return brackets === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpsim9469q.js:39:12)\n    at Object.<anonymous> (/tmp/tmpsim9469q.js:52:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333979
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_parens: number[] = [];\n\tlet close_parens: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_parens_stack: number[] = [];\n\tlet close_parens_stack: number[] = [];\n\tlet open_brackets_stack_index: number[] = [];\n\tlet close_brackets_stack_index: number[] = [];\n\tlet open_parens_stack_index: number[] = [];\n\tlet close_parens_stack_index: number[] = [];\n\tlet open_brackets_stack_index2: number[] = [];\n\tlet close_brackets_stack_index2: number[] = [];\n\tlet open_parens_stack_index2: number[] = [];\n\tlet close_parens_stack_index2: number[] = [];\n\tlet open_brackets_stack_index3: number[] = [];\n\tlet close_brackets_stack_index3: number[] = [];\n\tlet open_parens_stack_index3: number[] = [];\n\tlet close_parens_stack_index3: number[] = [];\n\tlet open_brackets_stack_index4: number[] = [];\n\tlet close_brackets_stack_index4: number[] = [];\n\tlet open_parens_stack_index4: number[] = [];\n\tlet close_parens_stack_index4: number[] = [];\n\tlet open_brackets_stack_index5: number[] = [];\n\tlet close_brackets_stack_index5: number[] = [];\n\tlet open_parens_stack_index5: number[] = [];\n\tlet close_parens_stack_index5: number[] = [];\n\tlet open_brackets_stack_index6: number[] = [];\n\tlet close_brackets_stack_index6: number[] = [];\n\tlet open_parens_stack_index6: number[] = [];\n\tlet close_parens_stack_index6: number[] = [];\n\tlet open_brackets_stack_index7: number[] = [];\n\tlet close_brackets_stack_index7: number[] = [];\n\tlet open_parens_stack_index7: number[] = [];\n\tlet close_parens_stack_index7: number[] = [];\n\tlet open_brackets_stack_index8: number[] = [];\n\tlet close_brackets_stack_index8: number[] = [];\n\tlet open_parens_stack_index8: number[] = [];\n\t\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpymwg3hw3.ts(80,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333976
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: number[] = [];\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    let open_brackets_stack: number[] = [];\n    let close_brackets_stack: number[] = [];\n    let open_stack: number[] = [];\n    let close_stack: number[] = [];\n    let open_stack_index: number = 0;\n    let close_stack_index: number = 0;\n    let open_stack_string: string = \"\";\n    let close_stack_string: string = \"\";\n    for (let i = 0; i < string.length; i++) {\n        let char = string[i];\n        if (char === \"[\") {\n            open_brackets.push(open_stack_index);\n            open_brackets_stack.push(open_stack_string);\n            open_stack.push(open_stack_index);\n            open_stack_string = \"\";\n        } else if (char === \"]\") {\n            close_brackets.push(close_stack_index);\n            close_brackets_stack.push(close_stack_string);\n            close_stack.push(close_stack_index);\n            close_stack_string = \"\";\n        } else if (char === \"][]\") {\n            close_brackets.push(close_stack_index);\n            close_brackets_stack.push(close_stack_string);\n            close_stack.push(close_stack_index);\n            close_stack_string = \"\";\n        } else if (char === \"[]\") {\n            open_brackets.push(open_stack_index);\n            open_brackets_stack.push(open_stack_string);\n            open_stack.push(open_stack_index);\n            open_stack_string = \"\";\n        } else if (char === \"[][]\") {\n            open_brackets.push(open_stack_index);\n            open_brackets_stack.push(open_stack_string);\n            open_stack.push(open_stack_index);\n            open_stack_string = \"\";\n        } else if (char === \"[[]\") {\n            close_brackets.push(close_stack_index);\n            close_brackets_stack.push(close_stack_string);\n            close_stack.push(close_stack_index);\n            close_stack_string = \"\";\n        } else if (char === \"[[][]\") {\n            close_brackets.push(close_stack_index);\n            close_brackets_stack.push(close_stack_string);\n            close_stack.push(close_stack_index);\n            close_stack_string = \"\";\n        } else if (char === \"[[[]\") {\n            close_brackets.push(close_stack_index);\n            close_brackets_stack.push(close_stack_string);\n            close_stack.push(close_stack_index);\n            close_stack_string = \"\";\n        } else if (char === \"[[[][]\") {\n            close_brackets.push(close_stack_index);\n            close_brackets_stack.push(close_stack_string);\n            close_stack.push(close_stack\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp48kt56te.ts(74,1): error TS1005: ',' expected.\n../../../../tmp/tmp48kt56te.ts(74,9): error TS1005: ',' expected.\n../../../../tmp/tmp48kt56te.ts(96,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333979
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: string[] = string.split(\"\");\n    let open_brackets: number[] = [];\n    let closed_brackets: number[] = [];\n    let open_stack: number[] = [];\n    let close_stack: number[] = [];\n    let open_brackets_stack: number[] = [];\n    let closed_brackets_stack: number[] = [];\n    let open_brackets_stack_index: number = 0;\n    let closed_brackets_stack_index: number = 0;\n    let open_brackets_stack_string: string = \"\";\n    let closed_brackets_stack_string: string = \"\";\n    let open_brackets_stack_string_index: number = 0;\n    let closed_brackets_stack_string_index: number = 0;\n    let open_brackets_stack_string_string: string = \"\";\n    let closed_brackets_stack_string_string: string = \"\";\n    let open_brackets_stack_string_string_index: number = 0;\n    let closed_brackets_stack_string_string_index: number = 0;\n    let open_brackets_stack_string_string_string: string = \"\";\n    let closed_brackets_stack_string_string_string: number = 0;\n    let open_brackets_stack_string_string_string: string = \"\";\n    let closed_brackets_stack_string_string_string: string = \"\";\n    let open_brackets_stack_string_string_string_index: number = 0;\n    let closed_brackets_stack_string_string_string_index: number = 0;\n    let open_brackets_stack_string_string_string_string: string = \"\";\n    let closed_brackets_stack_string_string_string: string = \"\";\n    let open_brackets_stack_string_string_string_index: number = 0;\n    let closed_brackets_stack_string_string_string_index: number = 0;\n    let open_brackets_stack_string_string_string_string: string = \"\";\n    let closed_brackets_stack_string_string_string: string = \"\";\n    let open_brackets_stack_string_string_string_string_index: number = 0;\n    let closed_brackets_stack_string_string_string_string_index: number = 0;\n    let open_brackets_stack_string_string_string_string: string = \"\";\n    let closed_brackets_stack_string_string_string: string = \"\";\n    let open_brackets_stack_string_string_string_string_index: number = 0;\n    let closed_brackets_stack_string_string_string_string_index: number = 0;\n    let open_brackets_stack_string_string_string_string: string = \"\";\n    let closed_brackets_stack_string_string_string: string = \"\";\n    let open_brackets_stack_string_string_string_string_index: number = 0;\n    let closed_brackets_stack_string_string_string_string_index: number = 0;\n    let open_brackets_stack_string_string_string_string_string: string = \"\";\n    let closed_bracket\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp3u6541wh.ts(80,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333979
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    let open_brackets_stack: number[] = [];\n    let close_brackets_stack: number[] = [];\n    let open_brackets_length = 0;\n    let close_brackets_length = 0;\n    let open_quotes: number[] = [];\n    let close_quotes: number[] = [];\n    let open_quotes_stack: number[] = [];\n    let close_quotes_stack: number[] = [];\n    let open_quotes_length = 0;\n    let close_quotes_length = 0;\n    let open_quotes_index = 0;\n    let close_quotes_index = 0;\n    let open_quotes_string = \"\";\n    let close_quotes_string = \"\";\n    let open_quotes_string_index = 0;\n    let close_quotes_string_index = 0;\n    let open_quotes_index = 0;\n    let close_quotes_index = 0;\n    let open_quotes_string = \"\";\n    let close_quotes_string = \"\";\n    let open_quotes_string_index = 0;\n    let close_quotes_string_index = 0;\n    let open_quotes_index = 0;\n    let close_quotes_index = 0;\n    let open_quotes_string = \"\";\n    let close_quotes_string = \"\";\n    let open_quotes_string_index = 0;\n    let close_quotes_string_index = 0;\n    let open_quotes_index = 0;\n    let close_quotes_index = 0;\n    let open_quotes_string = \"\";\n    let close_quotes_string = \"\";\n    let open_quotes_string_index = 0;\n    let close_quotes_string_index = 0;\n    let open_quotes_index = 0;\n    let close_quotes_index = 0;\n    let open_quotes_string = \"\";\n    let close_quotes_string = \"\";\n    let open_quotes_string_index = 0;\n    let close_quotes_string_index = 0;\n    let open_quotes_index = 0;\n    let close_quotes_index = 0;\n    let open_quotes_string = \"\";\n    let close_quotes_string = \"\";\n    let open_quotes_string_index = 0;\n    let close_quotes_string_index = 0;\n    let open_quotes_index = 0;\n    let close_quotes_index = 0;\n    let open_quotes_string = \"\";\n    let close_quotes_string = \"\";\n    let open_quotes_string_index = 0;\n    let close_quotes_string_index = 0;\n    let open_quotes_index = 0;\n    let close_quotes_index = 0;\n    let open_quotes_string = \"\";\n    let close_quotes_string = \"\";\n    let open_quotes_string_index = 0;\n    let close_quotes_string_index = 0;\n    let open_quotes_index = 0;\n    let close_quotes_index = 0;\n    let open_quotes_string = \"\";\n    let close_quotes_string = \"\";\n    let open_quotes_string_index = 0;\n    let close_quotes_string_index = 0;\n    let open_quotes_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpwu267nvn.ts(106,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333979
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_parens: number[] = [];\n\tlet close_parens: number[] = [];\n\tlet open_brackets_size: number = 0;\n\tlet close_brackets_size: number = 0;\n\tlet open_parens_size: number = 0;\n\tlet close_parens_size: number = 0;\n\tlet open_brackets_index = 0;\n\tlet close_brackets_index = 0;\n\tlet open_parens_index = 0;\n\tlet close_parens_index = 0;\n\tlet open_brackets_index_in_string = 0;\n\tlet close_brackets_index_in_string = 0;\n\tlet open_parens_index_in_string = 0;\n\tlet close_parens_index_in_string = 0;\n\tlet open_brackets_index_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string = 0;\n\tlet open_parens_index_in_string_in_string = 0;\n\tlet close_parens_index_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string = 0;\n\tlet open_parens_index_in_string_in_string = 0;\n\tlet close_parens_index_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_parens_index_in_string_in_string_in_string = 0;\n\tlet close_parens_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_parens_index_in_string_in_string_in_string = 0;\n\tlet close_parens_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_parens_index_in_string_in_string_in_string = 0;\n\tlet close_parens_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_parens_index_in_string_in_string_in_string = 0;\n\tlet close_parens_index_in_string_in_string_in_string = 0;\n\t\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmph0jvrh0b.ts(81,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333979
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    if (string === \"\") {\n        return false;\n    }\n    let bracketCount = 0;\n    let openBracketCount = 0;\n    let closeBracketCount = 0;\n    let openBracketCount2 = 0;\n    let closeBracketCount2 = 0;\n    let openBracketCount3 = 0;\n    let closeBracketCount3 = 0;\n    let openBracketCount4 = 0;\n    let closeBracketCount4 = 0;\n    let openBracketCount5 = 0;\n    let closeBracketCount5 = 0;\n    let openBracketCount6 = 0;\n    let closeBracketCount6 = 0;\n    let openBracketCount7 = 0;\n    let closeBracketCount7 = 0;\n    let openBracketCount8 = 0;\n    let closeBracketCount8 = 0;\n    let openBracketCount9 = 0;\n    let closeBracketCount9 = 0;\n    let openBracketCount10 = 0;\n    let closeBracketCount10 = 0;\n    let openBracketCount11 = 0;\n    let closeBracketCount11 = 0;\n    let openBracketCount12 = 0;\n    let closeBracketCount12 = 0;\n    let openBracketCount13 = 0;\n    let closeBracketCount13 = 0;\n    let openBracketCount14 = 0;\n    let closeBracketCount14 = 0;\n    let openBracketCount15 = 0;\n    let closeBracketCount15 = 0;\n    let openBracketCount16 = 0;\n    let closeBracketCount16 = 0;\n    let openBracketCount17 = 0;\n    let closeBracketCount17 = 0;\n    let openBracketCount18 = 0;\n    let closeBracketCount18 = 0;\n    let openBracketCount19 = 0;\n    let closeBracketCount19 = 0;\n    let openBracketCount20 = 0;\n    let closeBracketCount20 = 0;\n    let openBracketCount21 = 0;\n    let closeBracketCount21 = 0;\n    let openBracketCount22 = 0;\n    let closeBracketCount22 = 0;\n    let openBracketCount23 = 0;\n    let closeBracketCount23 = 0;\n    let openBracketCount24 = 0;\n    let closeBracketCount24 = 0;\n    let openBracketCount25 = 0;\n    let closeBracketCount25 = 0;\n    let openBracketCount26 = 0;\n    let closeBracketCount26 = 0;\n    let openBracketCount27 = 0;\n    let closeBracketCount27 = 0;\n    let openBracketCount28 = 0;\n    let closeBracketCount28 = 0;\n    let openBracketCount29 = 0;\n    let closeBracketCount29 = 0;\n    let openBracketCount30 = 0;\n    let closeBracketCount30 = 0;\n    let openBracketCount31 = 0;\n    let closeBracketCount31 = 0;\n    let openBracketCount32 = 0;\n    let closeBra\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpvr4o8_4j.ts(107,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333979
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets = string.match(/\\[.*?\\]/g);\n    return brackets !== null;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmp62u6ysah.js:24:12)\n    at Object.<anonymous> (/tmp/tmp62u6ysah.js:38:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333980
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            stack.push(string[i]);\n        } else if (string[i] === \"]\") {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpzojs0i1x.js:36:12)\n    at Object.<anonymous> (/tmp/tmpzojs0i1x.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333962
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    let open_brackets_stack: number[] = [];\n    let close_brackets_stack: number[] = [];\n    let open_chars: number[] = [];\n    let close_chars: number[] = [];\n    let open_chars_stack: number[] = [];\n    let close_chars_stack: number[] = [];\n    let open_chars_stack_index: number = 0;\n    let close_chars_stack_index: number = 0;\n    let open_char: string = \"\";\n    let close_char: string = \"\";\n    let open_char_index: number = 0;\n    let close_char_index: number = 0;\n    let open_char_index2: number = 0;\n    let close_char_index2: number = 0;\n    let open_char_index3: number = 0;\n    let close_char_index3: number = 0;\n    let open_char_index4: number = 0;\n    let close_char_index4: number = 0;\n    let open_char_index5: number = 0;\n    let close_char_index5: number = 0;\n    let open_char_index6: number = 0;\n    let close_char_index6: number = 0;\n    let open_char_index7: number = 0;\n    let close_char_index7: number = 0;\n    let open_char_index8: number = 0;\n    let close_char_index8: number = 0;\n    let open_char_index9: number = 0;\n    let close_char_index9: number = 0;\n    let open_char_index10: number = 0;\n    let close_char_index10: number = 0;\n    let open_char_index11: number = 0;\n    let close_char_index11: number = 0;\n    let open_char_index12: number = 0;\n    let close_char_index12: number = 0;\n    let open_char_index13: number = 0;\n    let close_char_index13: number = 0;\n    let open_char_index14: number = 0;\n    let close_char_index14: number = 0;\n    let open_char_index15: number = 0;\n    let close_char_index15: number = 0;\n    let open_char_index16: number = 0;\n    let close_char_index16: number = 0;\n    let open_char_index17: number = 0;\n    let close_char_index17: number = 0;\n    let open_char_index18: number = 0;\n    let close_char_index18: number = 0;\n    let open_char_index19: number = 0;\n    let close_char_index19: number = 0;\n    let open_char_index20: number = 0;\n    let close_char_index20: number = 0;\n    let open_char_index21: number = 0;\n    let close_char_index21: number = 0;\n    let open_char_index22: number = 0;\n    let close_char_index22: number = 0;\n    let open_char_index23: number = 0;\n    let close_char_index23: number = 0;\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmppa1ftwrj.ts(98,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333979
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            brackets.push(i);\n        } else if (string[i] === \"]\") {\n            if (brackets.length === 0) {\n                return false;\n            }\n            brackets.pop();\n        }\n    }\n    return brackets.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmp8kw6olw7.js:36:12)\n    at Object.<anonymous> (/tmp/tmp8kw6olw7.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333980
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_curly: number[] = [];\n\tlet close_curly: number[] = [];\n\tlet open_square: number[] = [];\n\tlet close_square: number[] = [];\n\tlet open_paren: number[] = [];\n\tlet close_paren: number[] = [];\n\tlet open_square_curly: number[] = [];\n\tlet close_square_curly: number[] = [];\n\tlet open_curly_curly: number[] = [];\n\tlet close_curly_curly: number[] = [];\n\tlet open_paren_curly: number[] = [];\n\tlet close_paren_curly: number[] = [];\n\tlet open_square_paren: number[] = [];\n\tlet close_square_paren: number[] = [];\n\tlet open_curly_paren: number[] = [];\n\tlet close_curly_paren: number[] = [];\n\tlet open_paren_paren: number[] = [];\n\tlet close_paren_paren: number[] = [];\n\tlet open_square_curly_paren: number[] = [];\n\tlet close_square_curly_paren: number[] = [];\n\tlet open_curly_curly_paren: number[] = [];\n\tlet close_curly_curly_paren: number[] = [];\n\tlet open_paren_curly_paren: number[] = [];\n\tlet close_paren_curly_paren: number[] = [];\n\tlet open_square_paren_curly: number[] = [];\n\tlet close_square_paren_curly: number[] = [];\n\tlet open_curly_paren_curly: number[] = [];\n\tlet close_curly_paren_curly: number[] = [];\n\tlet open_paren_paren_curly: number[] = [];\n\tlet close_paren_paren_curly: number[] = [];\n\tlet open_square_curly_curly: number[] = [];\n\tlet close_square_curly_curly: number[] = [];\n\tlet open_curly_curly_curly: number[] = [];\n\tlet close_curly_curly_curly: number[] = [];\n\tlet open_paren_curly_curly: number[] = [];\n\tlet close_paren_curly_curly: number[] = [];\n\tlet open_square_paren_curly_curly: number[] = [];\n\tlet close_square_paren_curly_curly: number[] = [];\n\tlet open_curly_paren_curly_curly\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpi9su72y_.ts(81,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333979
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_parens: number[] = [];\n\tlet close_parens: number[] = [];\n\tlet open_parens_stack: number[] = [];\n\tlet close_parens_stack: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_parens_stack_index: number = 0;\n\tlet close_parens_stack_index: number = 0;\n\tlet open_brackets_stack_index: number = 0;\n\tlet close_brackets_stack_index: number = 0;\n\tlet open_parens_stack_string: string = \"\";\n\tlet close_parens_stack_string: string = \"\";\n\tlet open_brackets_stack_string: string = \"\";\n\tlet close_brackets_stack_string: string = \"\";\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp84fhtwml.ts(58,9): error TS1005: ',' expected.\n../../../../tmp/tmp84fhtwml.ts(80,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333980
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] == '[') {\n            stack.push(string[i]);\n        } else if (string[i] == ']') {\n            if (stack.length == 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    if (stack.length != 0) {\n        return false;\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmp40bc56jz.js:39:12)\n    at Object.<anonymous> (/tmp/tmp40bc56jz.js:52:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333980
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number = 0;\n\tlet closed_brackets: number = 0;\n\tlet open_brackets_stack: string[] = [];\n\tlet closed_brackets_stack: string[] = [];\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlet char = string[i];\n\t\tif (char === '[') {\n\t\t\topen_brackets++;\n\t\t\topen_brackets_stack.push(char);\n\t\t} else if (char === ']') {\n\t\t\tclosed_brackets++;\n\t\t\tclosed_brackets_stack.push(char);\n\t\t} else if (char === '[' && open_brackets > 0 && closed_brackets > 0) {\n\t\t\topen_brackets--;\n\t\t\tclosed_brackets--;\n\t\t\topen_brackets_stack.pop();\n\t\t\tclosed_brackets_stack.pop();\n\t\t} else if (char === ']' && open_brackets > 0 && closed_brackets > 0) {\n\t\t\topen_brackets--;\n\t\t\tclosed_brackets--;\n\t\t\topen_brackets_stack.pop();\n\t\t\tclosed_brackets_stack.pop();\n\t\t} else if (char === '[' && open_brackets == 0 && closed_brackets == 0) {\n\t\t\topen_brackets_stack.pop();\n\t\t\tclosed_brackets_stack.pop();\n\t\t}\n\t}\n\n\treturn open_brackets == 0 && closed_brackets == 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmpbm6u4mz8.js:53:12)\n    at Object.<anonymous> (/tmp/tmpbm6u4mz8.js:68:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333980
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    let open_brackets: number[] = [];\n    let closed_brackets: number[] = [];\n    let open_brackets_size: number[] = [];\n    let closed_brackets_size: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_brackets_position: number[] = [];\n    let closed_brackets_position: number[] = [];\n    let open_bra\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5twf0oxd.ts(89,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333980
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_idx: number[] = [];\n\tlet close_brackets_idx: number[] = [];\n\tlet open_brackets_idx2: number[] = [];\n\tlet close_brackets_idx2: number[] = [];\n\tlet open_brackets_idx3: number[] = [];\n\tlet close_brackets_idx3: number[] = [];\n\tlet open_brackets_idx4: number[] = [];\n\tlet close_brackets_idx4: number[] = [];\n\tlet open_brackets_idx5: number[] = [];\n\tlet close_brackets_idx5: number[] = [];\n\tlet open_brackets_idx6: number[] = [];\n\tlet close_brackets_idx6: number[] = [];\n\tlet open_brackets_idx7: number[] = [];\n\tlet close_brackets_idx7: number[] = [];\n\tlet open_brackets_idx8: number[] = [];\n\tlet close_brackets_idx8: number[] = [];\n\tlet open_brackets_idx9: number[] = [];\n\tlet close_brackets_idx9: number[] = [];\n\tlet open_brackets_idx10: number[] = [];\n\tlet close_brackets_idx10: number[] = [];\n\tlet open_brackets_idx11: number[] = [];\n\tlet close_brackets_idx11: number[] = [];\n\tlet open_brackets_idx12: number[] = [];\n\tlet close_brackets_idx12: number[] = [];\n\tlet open_brackets_idx13: number[] = [];\n\tlet close_brackets_idx13: number[] = [];\n\tlet open_brackets_idx14: number[] = [];\n\tlet close_brackets_idx14: number[] = [];\n\tlet open_brackets_idx15: number[] = [];\n\tlet close_brackets_idx15: number[] = [];\n\tlet open_brackets_idx16: number[] = [];\n\tlet close_brackets_idx16: number[] = [];\n\tlet open_brackets_idx17: number[] = [];\n\tlet close_brackets_idx17: number[] = [];\n\tlet open_brackets_idx18: number[] = [];\n\tlet close\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpku0uv21b.ts(78,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333980
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] == \"[\") {\n            stack.push(string[i]);\n        } else if (string[i] == \"]\") {\n            if (stack.length == 0) {\n                return false;\n            }\n            let openBracket = stack.pop();\n            if (openBracket != string[i]) {\n                return false;\n            }\n        }\n    }\n    return stack.length == 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmp6c6dznug.js:37:12)\n    at Object.<anonymous> (/tmp/tmp6c6dznug.js:52:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333980
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number = 0;\n\tlet close_brackets: number = 0;\n\tlet open_brackets_stack: string[] = [];\n\tlet close_brackets_stack: string[] = [];\n\tlet open_brackets_stack_string: string = \"\";\n\tlet close_brackets_stack_string: string = \"\";\n\tlet open_brackets_string: string = \"\";\n\tlet close_brackets_string: string = \"\";\n\tlet open_brackets_string_index: number = 0;\n\tlet close_brackets_string_index: number = 0;\n\tlet open_brackets_string_index2: number = 0;\n\tlet close_brackets_string_index2: number = 0;\n\tlet open_brackets_string_index3: number = 0;\n\tlet close_brackets_string_index3: number = 0;\n\tlet open_brackets_string_index4: number = 0;\n\tlet close_brackets_string_index4: number = 0;\n\tlet open_brackets_string_index5: number = 0;\n\tlet close_brackets_string_index5: number = 0;\n\tlet open_brackets_string_index6: number = 0;\n\tlet close_brackets_string_index6: number = 0;\n\tlet open_brackets_string_index7: number = 0;\n\tlet close_brackets_string_index7: number = 0;\n\tlet open_brackets_string_index8: number = 0;\n\tlet close_brackets_string_index8: number = 0;\n\tlet open_brackets_string_index9: number = 0;\n\tlet close_brackets_string_index9: number = 0;\n\tlet open_brackets_string_index10: number = 0;\n\tlet close_brackets_string_index10: number = 0;\n\tlet open_brackets_string_index11: number = 0;\n\tlet close_brackets_string_index11: number = 0;\n\tlet open_brackets_string_index12: number = 0;\n\tlet close_brackets_string_index12: number = 0;\n\tlet open_brackets_string_index13: number = 0;\n\tlet close_brackets_string_index13: number = 0;\n\tlet open_brackets_string_index14: number = 0;\n\tlet close_brackets_string_index14: number = 0;\n\tlet open_brackets_string_index15: number = 0;\n\tlet close_brackets_string_index15: number = 0;\n\tlet open_brackets_string_index16: number\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp894sujct.ts(78,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333980
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    if (string.length <= 1) {\n        return false;\n    }\n    let opening_brackets: number[] = [];\n    let closing_brackets: number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            opening_brackets.push(i);\n        } else if (string[i] === \"]\") {\n            closing_brackets.push(i);\n        }\n    }\n    if (opening_brackets.length <= 1) {\n        return false;\n    }\n    for (let i = 0; i < opening_brackets.length; i++) {\n        let opening_bracket = opening_brackets[i];\n        let closing_bracket = closing_brackets[i];\n        if (closing_bracket === opening_bracket) {\n            return false;\n        }\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmp_12z0d89.js:46:12)\n    at Object.<anonymous> (/tmp/tmp_12z0d89.js:60:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333980
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets = string.match(/\\[.*?\\]/g);\n\tlet nested = false;\n\t\n\tif(brackets) {\n\t\tbrackets.forEach(bracket => {\n\t\t\tlet brackets = bracket.match(/\\[.*?\\]/g);\n\t\t\t\n\t\t\tif(brackets) {\n\t\t\t\tbrackets.forEach(bracket => {\n\t\t\t\t\tif(bracket.match(/\\[.*?\\]/)) {\n\t\t\t\t\t\tnested = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\t\n\treturn nested;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmprn5l2doa.js:37:12)\n    at Object.<anonymous> (/tmp/tmprn5l2doa.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333980
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    if (string.length <= 1) {\n        return false;\n    }\n    let opening_brackets = 0;\n    let closing_brackets = 0;\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            opening_brackets++;\n        } else if (string[i] === \"]\") {\n            closing_brackets++;\n        }\n    }\n    return opening_brackets <= closing_brackets;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmp902s9gil.js:36:12)\n    at Object.<anonymous> (/tmp/tmp902s9gil.js:50:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333980
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_parens: number[] = [];\n\tlet close_parens: number[] = [];\n\tlet bracket_depth: number[] = [];\n\tlet paren_depth: number[] = [];\n\tlet open_brackets_depth: number[] = [];\n\tlet close_brackets_depth: number[] = [];\n\tlet open_parens_depth: number[] = [];\n\tlet close_parens_depth: number[] = [];\n\tlet bracket_depth_index: number[] = [];\n\tlet paren_depth_index: number[] = [];\n\tlet open_brackets_depth_index: number[] = [];\n\tlet close_brackets_depth_index: number[] = [];\n\tlet open_parens_depth_index: number[] = [];\n\tlet close_parens_depth_index: number[] = [];\n\tlet bracket_depth_index2: number[] = [];\n\tlet paren_depth_index2: number[] = [];\n\tlet open_brackets_depth_index2: number[] = [];\n\tlet close_brackets_depth_index2: number[] = [];\n\tlet open_parens_depth_index2: number[] = [];\n\tlet close_parens_depth_index2: number[] = [];\n\tlet bracket_depth_index3: number[] = [];\n\tlet paren_depth_index3: number[] = [];\n\tlet open_brackets_depth_index3: number[] = [];\n\tlet close_brackets_depth_index3: number[] = [];\n\tlet open_parens_depth_index3: number[] = [];\n\tlet close_parens_depth_index3: number[] = [];\n\tlet bracket_depth_index4: number[] = [];\n\tlet paren_depth_index4: number[] = [];\n\tlet open_brackets_depth_index4: number[] = [];\n\tlet close_brackets_depth_index4: number[] = [];\n\tlet open_parens_depth_index4: number[] = [];\n\tlet close_parens_depth_index4: number[] = [];\n\tlet bracket_depth_index5: number[] = [];\n\tlet paren_depth_index5: number[] = [];\n\tlet open_brackets_depth_index5: number[] = [];\n\tlet close_brackets_depth_index5: number[] = [];\n\tlet open_parens_depth_index5: number[] = [];\n\tlet close_parens_depth_index5: number[] = [];\n\tlet bracket_depth_index6: number[] = [];\n\tlet paren_depth_index6: number[] = [];\n\tlet open\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpf1ltrzho.ts(83,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333980
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            stack.push(string[i]);\n        } else if (string[i] === \"]\") {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpzojs0i1x.js:36:12)\n    at Object.<anonymous> (/tmp/tmpzojs0i1x.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333962
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    let open_brackets_stack: number[] = [];\n    let close_brackets_stack: number[] = [];\n    let open_brackets_length: number = 0;\n    let close_brackets_length: number = 0;\n    for (let i = 0; i < string.length; i++) {\n        let char = string[i];\n        if (char === '[') {\n            open_brackets_stack.push(open_brackets_length);\n            open_brackets.push(open_brackets_length);\n            open_brackets_length++;\n        } else if (char === ']') {\n            close_brackets_stack.push(close_brackets_length);\n            close_brackets.push(close_brackets_length);\n            close_brackets_length++;\n        } else if (char === '[') {\n            open_brackets_length--;\n        } else if (char === ']') {\n            close_brackets_length--;\n        }\n    }\n    if (open_brackets_stack.length !== close_brackets_stack.length) {\n        return false;\n    }\n    for (let i = 0; i < open_brackets_stack.length; i++) {\n        if (open_brackets_stack[i] !== close_brackets_stack[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmptf8kx4b7.js:57:12)\n    at Object.<anonymous> (/tmp/tmptf8kx4b7.js:70:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333982
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] == '[') {\n            stack.push('[');\n        } else if (string[i] == ']') {\n            if (stack.length == 0) {\n                return false;\n            }\n            stack.pop();\n        } else if (string[i] == '[' || string[i] == ']') {\n            if (stack.length == 0) {\n                return false;\n            }\n            stack.pop();\n            stack.push(string[i]);\n        }\n    }\n    if (stack.length != 0) {\n        return false;\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmp2pfdjpkr.js:46:12)\n    at Object.<anonymous> (/tmp/tmp2pfdjpkr.js:59:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333982
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_curly: number[] = [];\n\tlet close_curly: number[] = [];\n\tlet open_paren: number[] = [];\n\tlet close_paren: number[] = [];\n\tlet open_brackets_stack: string[] = [];\n\tlet close_brackets_stack: string[] = [];\n\tlet open_curly_stack: string[] = [];\n\tlet close_curly_stack: string[] = [];\n\tlet open_paren_stack: string[] = [];\n\tlet close_paren_stack: string[] = [];\n\tlet open_brackets_stack_string: string[] = [];\n\tlet close_brackets_stack_string: string[] = [];\n\tlet open_curly_stack_string: string[] = [];\n\tlet close_curly_stack_string: string[] = [];\n\tlet open_paren_stack_string: string[] = [];\n\tlet close_paren_stack_string: string[] = [];\n\tlet open_brackets_stack_string_string: string[] = [];\n\tlet close_brackets_stack_string_string: string[] = [];\n\tlet open_curly_stack_string_string: string[] = [];\n\tlet close_curly_stack_string_string: string[] = [];\n\tlet open_paren_stack_string_string: string[] = [];\n\tlet close_paren_stack_string_string: string[] = [];\n\tlet open_brackets_stack_string_string: string[] = [];\n\tlet close_brackets_stack_string_string: string[] = [];\n\tlet open_curly_stack_string_string: string[] = [];\n\tlet close_curly_stack_string_string: string[] = [];\n\tlet open_paren_stack_string_string: string[] = [];\n\tlet close_paren_stack_string_string: string[] = [];\n\tlet open_brackets_stack_string_string: string[] = [];\n\tlet close_brackets_stack_string_string: string[] = [];\n\tlet open_curly_stack_string_string: string[] = [];\n\tlet close_curly_stack_string_string: string[] = [];\n\tlet open_paren_stack_string_string: string[] = [];\n\tlet close_paren_stack_string_string: string[] = [];\n\tlet open_brackets_stack_string_string: string[] = [];\n\tlet close_brackets_stack_string_string: string[] = [];\n\tlet open_curly_stack_string_string: string[] = [];\n\tlet close_curly_stack_string_string: string[] = [];\n\tlet open_paren_stack_string_string: string[] = [];\n\tlet close_paren_stack_string_string: string[] = [];\n\tlet open_brackets_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpih0y3zof.ts(83,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333982
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets = string.match(/\\[.*?\\]/g);\n    if (brackets === null) {\n        return false;\n    }\n    let bracketsCount = brackets.length;\n    for (let i = 0; i < bracketsCount; i++) {\n        let bracket = brackets[i];\n        let bracketCount = bracket.match(/\\[.*?\\]/g).length;\n        if (bracketCount > 1) {\n            return false;\n        }\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpxe78svis.js:35:12)\n    at Object.<anonymous> (/tmp/tmpxe78svis.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333983
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] == \"[\") {\n            stack.push(string[i]);\n        } else if (string[i] == \"]\") {\n            if (stack.length == 0) {\n                return false;\n            }\n            let openBracket = stack.pop();\n            if (openBracket != string[i]) {\n                return false;\n            }\n        }\n    }\n    return stack.length == 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmp6c6dznug.js:37:12)\n    at Object.<anonymous> (/tmp/tmp6c6dznug.js:52:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333980
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: string[] = string.split(']').map(x => x.split('['));\n    let stack: string[] = [];\n    for (let i = 0; i < brackets.length; i++) {\n        let bracket = brackets[i];\n        if (bracket.length < 2) {\n            return false;\n        }\n        if (bracket[0] === bracket[bracket.length - 1]) {\n            stack.push(bracket[0]);\n        } else {\n            if (stack.length > 0) {\n                let open = stack.pop();\n                if (open !== bracket[0]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmppqn_0di1.ts(17,9): error TS2322: Type 'string[][]' is not assignable to type 'string[]'.\n  Type 'string[]' is not assignable to type 'string'.\n",
      "timestamp": 1660333982
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet opening_brackets: number[] = [];\n\tlet closing_brackets: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] = [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\tlet \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpdljn8rdd.ts(69,9): error TS1005: ',' expected.\n../../../../tmp/tmpdljn8rdd.ts(91,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333982
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] == \"[\" || string[i] == \"(\") {\n            stack.push(string[i]);\n        } else if (string[i] == \"]\") {\n            if (stack.length == 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length == 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmp_phq6wwk.js:36:12)\n    at Object.<anonymous> (/tmp/tmp_phq6wwk.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333983
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    let open_brackets_stack: number[] = [];\n    let close_brackets_stack: number[] = [];\n    let open_chars: number[] = [];\n    let close_chars: number[] = [];\n    let open_chars_stack: number[] = [];\n    let close_chars_stack: number[] = [];\n    let open_chars_stack_index: number = 0;\n    let close_chars_stack_index: number = 0;\n    let open_char_index: number = 0;\n    let close_char_index: number = 0;\n    let open_brackets_stack_index: number = 0;\n    let close_brackets_stack_index: number = 0;\n    let open_char_index: number = 0;\n    let close_char_index: number = 0;\n    for (let i = 0; i < string.length; i++) {\n        let char = string.charAt(i);\n        if (char === '[') {\n            open_brackets.push(open_brackets_stack[open_brackets_stack_index]);\n            close_brackets.push(close_brackets_stack[close_brackets_stack_index]);\n            open_chars.push(open_chars_stack[open_chars_stack_index]);\n            close_chars.push(close_chars_stack[close_chars_stack_index]);\n            open_chars_stack_index++;\n            close_chars_stack_index++;\n            open_char_index++;\n            close_char_index++;\n            open_brackets_stack_index++;\n            close_brackets_stack_index++;\n        } else if (char === ']') {\n            open_brackets_stack[open_brackets_stack_index] = open_brackets.pop();\n            close_brackets_stack[close_brackets_stack_index] = close_brackets.pop();\n            open_chars_stack[open_chars_stack_index] = open_chars.pop();\n            close_chars_stack[close_chars_stack_index] = close_chars.pop();\n            open_chars_stack_index--;\n            close_chars_stack_index--;\n            open_brackets_stack_index--;\n            close_brackets_stack_index--;\n        } else if (char === '{') {\n            open_brackets_stack.push(open_brackets_stack_index);\n            close_brackets_stack.push(close_brackets_stack_index);\n            open_chars_stack.push(open_char_index);\n            close_chars_stack.push(close_char_index);\n            open_brackets_stack_index++;\n            close_brackets_stack_index++;\n            open_char_index++;\n            close_char_index++;\n        } else if (char === '}') {\n            open_brackets_stack[open_b\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp29jx4p_d.ts(66,1): error TS1005: ']' expected.\n../../../../tmp/tmp29jx4p_d.ts(88,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333983
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\" || string[i] === \"(\") {\n            open_brackets.push(i);\n        } else if (string[i] === \"]\" || string[i] === \")\") {\n            close_brackets.push(i);\n        }\n    }\n    if (open_brackets.length !== close_brackets.length) {\n        return false;\n    }\n    for (let i = 0; i < open_brackets.length; i++) {\n        let open_bracket = open_brackets[i];\n        let close_bracket = close_brackets[i];\n        if (open_bracket === close_bracket) {\n            continue;\n        }\n        let open_char = string.substr(open_bracket, 1);\n        let close_char = string.substr(close_bracket, 1);\n        if (open_char === close_char) {\n            continue;\n        }\n        if (open_char === \"[\" && close_char === \"]\") {\n            continue;\n        }\n        if (open_char === \"(\" && close_char === \")\") {\n            continue;\n        }\n        return false;\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmp40cp610w.js:56:12)\n    at Object.<anonymous> (/tmp/tmp40cp610w.js:69:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333983
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets = string.match(/\\[.*?\\]/g);\n    if (brackets == null) {\n        return false;\n    }\n    for (let i = 0; i < brackets.length; i++) {\n        let bracket = brackets[i];\n        let brackets = bracket.match(/\\[.*?\\]/g);\n        if (brackets == null) {\n            return false;\n        }\n        for (let j = 0; j < brackets.length; j++) {\n            let bracket2 = brackets[j];\n            if (bracket2.indexOf(bracket) != bracket.indexOf(bracket2)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp2u3hi1eb.ts(22,23): error TS2448: Block-scoped variable 'brackets' used before its declaration.\n",
      "timestamp": 1660333983
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets = string.match(/\\[.*?\\]/g);\n\tlet nested = false;\n\t\n\tfor (let i = 0; i < brackets.length; i++) {\n\t\tlet bracket = brackets[i];\n\t\tlet open_brackets = bracket.match(/\\[.*?\\]/g);\n\t\tlet close_brackets = bracket.match(/\\[.*?\\]/g);\n\t\t\n\t\tif (open_brackets.length != close_brackets.length) {\n\t\t\tnested = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn nested;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmpgsqi9m25.js:33:12)\n    at Object.<anonymous> (/tmp/tmpgsqi9m25.js:48:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333983
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number = 0;\n\tlet close_brackets: number = 0;\n\tlet open_brackets_stack: string[] = [];\n\tlet close_brackets_stack: string[] = [];\n\tlet open_brackets_stack_string: string = \"\";\n\tlet close_brackets_stack_string: string = \"\";\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlet char = string[i];\n\t\tif (char === \"[\") {\n\t\t\topen_brackets++;\n\t\t\topen_brackets_stack.push(string[i]);\n\t\t\topen_brackets_stack_string += string[i];\n\t\t} else if (char === \"]\") {\n\t\t\tclose_brackets++;\n\t\t\tclose_brackets_stack.push(string[i]);\n\t\t\tclose_brackets_stack_string += string[i];\n\t\t} else if (char === \"]\" && open_brackets > 0 && close_brackets > 0) {\n\t\t\topen_brackets--;\n\t\t\tclose_brackets--;\n\t\t\tif (open_brackets === 0 && close_brackets === 0) {\n\t\t\t\topen_brackets_stack.pop();\n\t\t\t\tclose_brackets_stack.pop();\n\t\t\t\tif (open_brackets_stack.length === 0) {\n\t\t\t\t\topen_brackets_stack_string = open_brackets_stack_string.slice(0, open_brackets_stack_string.length - 1);\n\t\t\t\t}\n\t\t\t\tif (close_brackets_stack.length === 0) {\n\t\t\t\t\tclose_brackets_stack_string = close_brackets_stack_string.slice(0, close_brackets_stack_string.length - 1);\n\t\t\t\t}\n\t\t\t\tif (open_brackets_stack_string.length !== close_brackets_stack_string.length) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor (let j = 0; j < open_brackets_stack_string.length; j++) {\n\t\t\t\t\tlet open_bracket = open_brackets_stack_string[j];\n\t\t\t\t\tlet close_bracket = close_brackets_stack_string[j];\n\t\t\t\t\tif (open_bracket !== close_bracket) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmprvokicwf.js:66:12)\n    at Object.<anonymous> (/tmp/tmprvokicwf.js:81:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333983
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    if (string.length <= 1) {\n        return false;\n    }\n    let open_brackets = 0;\n    let close_brackets = 0;\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            open_brackets++;\n        } else if (string[i] === \"]\") {\n            close_brackets++;\n        }\n        if (open_brackets === close_brackets) {\n            return false;\n        }\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmpl_2n6_8a.js:38:12)\n    at Object.<anonymous> (/tmp/tmpl_2n6_8a.js:53:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333984
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number = 0;\n\tlet closed_brackets: number = 0;\n\tlet open_brackets_stack: string[] = [];\n\tlet closed_brackets_stack: string[] = [];\n\tlet open_brackets_stack_string: string = \"\";\n\tlet closed_brackets_stack_string: string = \"\";\n\tfor (let i = 0; i < string.length; i++) {\n\t\tif (string[i] === \"[\") {\n\t\t\topen_brackets++;\n\t\t\topen_brackets_stack.push(string[i]);\n\t\t\topen_brackets_stack_string += string[i];\n\t\t} else if (string[i] === \"]\") {\n\t\t\tclosed_brackets++;\n\t\t\tclosed_brackets_stack.push(string[i]);\n\t\t\tclosed_brackets_stack_string += string[i];\n\t\t} else if (string[i] === \"[\" && open_brackets > 0) {\n\t\t\topen_brackets--;\n\t\t\topen_brackets_stack.pop();\n\t\t\topen_brackets_stack_string += open_brackets_stack_string;\n\t\t} else if (string[i] === \"]\" && closed_brackets > 0) {\n\t\t\tclosed_brackets--;\n\t\t\tclosed_brackets_stack.pop();\n\t\t\tclosed_brackets_stack_string += closed_brackets_stack_string;\n\t\t}\n\t}\n\treturn (open_brackets === 0 && closed_brackets === 0);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmpo8m_nuea.js:50:12)\n    at Object.<anonymous> (/tmp/tmpo8m_nuea.js:65:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333984
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_parens: number[] = [];\n\tlet close_parens: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_parens_stack: number[] = [];\n\tlet close_parens_stack: number[] = [];\n\tlet open_brackets_stack_index: number[] = [];\n\tlet close_brackets_stack_index: number[] = [];\n\tlet open_parens_stack_index: number[] = [];\n\tlet close_parens_stack_index: number[] = [];\n\tlet open_brackets_stack_index2: number[] = [];\n\tlet close_brackets_stack_index2: number[] = [];\n\tlet open_parens_stack_index2: number[] = [];\n\tlet close_parens_stack_index2: number[] = [];\n\tlet open_brackets_stack_index3: number[] = [];\n\tlet close_brackets_stack_index3: number[] = [];\n\tlet open_parens_stack_index3: number[] = [];\n\tlet close_parens_stack_index3: number[] = [];\n\tlet open_brackets_stack_index4: number[] = [];\n\tlet close_brackets_stack_index4: number[] = [];\n\tlet open_parens_stack_index4: number[] = [];\n\tlet close_parens_stack_index4: number[] = [];\n\tlet open_brackets_stack_index5: number[] = [];\n\tlet close_brackets_stack_index5: number[] = [];\n\tlet open_parens_stack_index5: number[] = [];\n\tlet close_parens_stack_index5: number[] = [];\n\tlet open_brackets_stack_index6: number[] = [];\n\tlet close_brackets_stack_index6: number[] = [];\n\tlet open_parens_stack_index6: number[] = [];\n\tlet close_parens_stack_index6: number[] = [];\n\tlet open_brackets_stack_index7: number[] = [];\n\tlet close_brackets_stack_index7: number[] = [];\n\tlet open_parens_stack_index7: number[] = [];\n\tlet close_parens_stack_index7: number[] = [];\n\tlet open_brackets_stack_index8: number[] = [];\n\tlet close_brackets_stack_index8: number[] = [];\n\tlet open_parens_stack_index8: number[] = [];\n\t\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpymwg3hw3.ts(80,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333976
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: string[] = string.split(\"]\");\n\tlet open_brackets: string[] = string.split(\"[\");\n\tlet close_brackets: string[] = string.split(\"]\");\n\tlet open_count: number;\n\tlet close_count: number;\n\tlet open_brackets_index: number;\n\tlet close_brackets_index: number;\n\tlet open_brackets_length: number;\n\tlet close_brackets_length: number;\n\tlet open_brackets_index_in_string: number;\n\tlet close_brackets_index_in_string: number;\n\tlet open_brackets_index_in_string_index: number;\n\tlet close_brackets_index_in_string_index: number;\n\tlet open_brackets_index_in_string_index2: number;\n\tlet close_brackets_index_in_string_index2: number;\n\tlet open_brackets_index_in_string_index3: number;\n\tlet close_brackets_index_in_string_index3: number;\n\tlet open_brackets_index_in_string_index4: number;\n\tlet close_brackets_index_in_string_index4: number;\n\tlet open_brackets_index_in_string_index5: number;\n\tlet close_brackets_index_in_string_index5: number;\n\tlet open_brackets_index_in_string_index6: number;\n\tlet close_brackets_index_in_string_index6: number;\n\tlet open_brackets_index_in_string_index7: number;\n\tlet close_brackets_index_in_string_index7: number;\n\tlet open_brackets_index_in_string_index8: number;\n\tlet close_brackets_index_in_string_index8: number;\n\tlet open_brackets_index_in_string_index9: number;\n\tlet close_brackets_index_in_string_index9: number;\n\tlet open_brackets_index_in_string_index10: number;\n\tlet close_brackets_index_in_string_index10: number;\n\tlet open_brackets_index_in_string_index11: number;\n\tlet close_brackets_index_in_string_index11: number;\n\tlet open_brackets_index_in_string_index12: number;\n\tlet close_brackets_index_in_string_index12: number;\n\tlet open_brackets_index_in_string_index13: number;\n\tlet close_brackets_index_in_string_index13: number;\n\tlet open_brackets_index_in_string_index14: number;\n\tlet close_brackets_index_in_string_index14: number;\n\tlet open_b\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpg283555h.ts(79,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333983
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    const stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        const char = string[i];\n        if (char === '[') {\n            stack.push(char);\n        } else if (char === ']') {\n            if (stack.length !== 0) return false;\n            stack.pop();\n        } else {\n            if (stack.length !== 0) return false;\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmpayfcbsjm.js:38:12)\n    at Object.<anonymous> (/tmp/tmpayfcbsjm.js:53:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333983
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: number[] = [];\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    let open_brackets_stack: number[] = [];\n    let close_brackets_stack: number[] = [];\n    let open_stack: number[] = [];\n    let close_stack: number[] = [];\n    let open_stack_string: string = \"\";\n    let close_stack_string: string = \"\";\n    let open_stack_string_index: number = 0;\n    let close_stack_string_index: number = 0;\n    let open_stack_string_index2: number = 0;\n    let close_stack_string_index2: number = 0;\n    let open_stack_string_index3: number = 0;\n    let close_stack_string_index3: number = 0;\n    let open_stack_string_index4: number = 0;\n    let close_stack_string_index4: number = 0;\n    let open_stack_string_index5: number = 0;\n    let close_stack_string_index5: number = 0;\n    let open_stack_string_index6: number = 0;\n    let close_stack_string_index6: number = 0;\n    let open_stack_string_index7: number = 0;\n    let close_stack_string_index7: number = 0;\n    let open_stack_string_index8: number = 0;\n    let close_stack_string_index8: number = 0;\n    let open_stack_string_index9: number = 0;\n    let close_stack_string_index9: number = 0;\n    let open_stack_string_index10: number = 0;\n    let close_stack_string_index10: number = 0;\n    let open_stack_string_index11: number = 0;\n    let close_stack_string_index11: number = 0;\n    let open_stack_string_index12: number = 0;\n    let close_stack_string_index12: number = 0;\n    let open_stack_string_index13: number = 0;\n    let close_stack_string_index13: number = 0;\n    let open_stack_string_index14: number = 0;\n    let close_stack_string_index14: number = 0;\n    let open_stack_string_index15: number = 0;\n    let close_stack_string_index15: number = 0;\n    let open_stack_string_index16: number = 0;\n    let close_stack_string_index16: number = 0;\n    let open_stack_string_index17: number = 0;\n    let close_stack_string_index17: number = 0;\n    let open_stack_string_index18: number = 0;\n    let close_stack_string_index18: number = 0;\n    let open_stack_string_index19: number = 0;\n    let close_stack_string_index19: number = 0;\n    let open_stack_string_index20: number = 0;\n    let close_stack_string_index20: number = 0;\n    let open_stack_string_index21: number = 0;\n    let close_stack_string_index21: number = 0;\n    let open_stack_string_index22: number = 0;\n    let close_stack_string_index22: number = 0;\n    let \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpl1f2v7bf.ts(71,9): error TS1005: ',' expected.\n../../../../tmp/tmpl1f2v7bf.ts(93,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333983
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\" || string[i] === \"(\") {\n            stack.push(string[i]);\n        } else if (string[i] === \"]\") {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpjkbgyvge.js:36:12)\n    at Object.<anonymous> (/tmp/tmpjkbgyvge.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333984
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[] = [];\n\tlet open_brackets: number = 0;\n\tlet close_brackets: number = 0;\n\tlet open_curly: number = 0;\n\tlet close_curly: number = 0;\n\tlet open_parens: number = 0;\n\tlet close_parens: number = 0;\n\tlet open_brackets_stack: string[] = [];\n\tlet close_brackets_stack: string[] = [];\n\tlet open_curly_stack: string[] = [];\n\tlet close_curly_stack: string[] = [];\n\tlet open_parens_stack: string[] = [];\n\tlet close_parens_stack: string[] = [];\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlet char = string[i];\n\t\tif (char === '[') {\n\t\t\topen_brackets++;\n\t\t\topen_brackets_stack.push(char);\n\t\t} else if (char === ']') {\n\t\t\tclose_brackets++;\n\t\t\tclose_brackets_stack.push(char);\n\t\t} else if (char === '(') {\n\t\t\topen_parens++;\n\t\t\topen_parens_stack.push(char);\n\t\t} else if (char === ')') {\n\t\t\tclose_parens++;\n\t\t\tclose_parens_stack.push(char);\n\t\t} else if (char === '{') {\n\t\t\topen_curly++;\n\t\t\topen_curly_stack.push(char);\n\t\t} else if (char === '}') {\n\t\t\tclose_curly++;\n\t\t\tclose_curly_stack.push(char);\n\t\t}\n\t}\n\tif (open_brackets !== close_brackets || open_parens !== close_parens || open_curly !== close_curly) {\n\t\treturn false;\n\t}\n\twhile (open_brackets_stack.length > 0 && open_brackets_stack[open_brackets_stack.length - 1] === close_brackets_stack[close_brackets_stack.length - 1]) {\n\t\topen_brackets_stack.pop();\n\t\tclose_brackets_stack.pop();\n\t}\n\twhile (open_parens_stack.length > 0 && open_parens_stack[open_parens_stack.length - 1] === close_parens_stack[close_parens_stack.length - 1]) {\n\t\topen_parens_stack.pop();\n\t\tclose_parens_stack.pop();\n\t}\n\twhile (open_curly_stack.length > 0 && open_curly_stack[open_curly_stack.length - 1] === close_curly_stack[close_curly_stack.length - 1]) {\n\t\topen_curly_stack.pop();\n\t\tclose_curly_stack.pop();\n\t}\n\tif (open_brackets_stack.length > 0) {\n\t\treturn false;\n\t}\n\tif (open_parens_stack.length > 0) {\n\t\treturn false;\n\t}\n\tif (open_curly_stack.length > 0) {\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpr_egu5ea.ts(97,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333984
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_index = 0;\n\tlet close_brackets_index = 0;\n\tlet open_brackets_length = 0;\n\tlet close_brackets_length = 0;\n\tlet open_brackets_index_in_string = 0;\n\tlet close_brackets_index_in_string = 0;\n\tlet open_brackets_length_in_string = 0;\n\tlet close_brackets_length_in_string = 0;\n\tlet open_brackets_index_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string = 0;\n\tlet open_brackets_length_in_string_in_string = 0;\n\tlet close_brackets_length_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_length_in_string_in_string_in_string = 0;\n\tlet close_brackets_length_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_length_in_string_in_string_in_string = 0;\n\tlet close_brackets_length_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_length_in_string_in_string_in_string = 0;\n\tlet close_brackets_length_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_length_in_string_in_string_in_string = 0;\n\tlet close_brackets_length_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet close_brackets_index_in_string_in_string_in_string = 0;\n\tlet open_brackets_length_in_string_in_string_in_string = 0;\n\tlet close_brackets_length_in_string_in_string_in_string = 0;\n\tlet open_brackets_index_in_string_in_string_in_string = 0;\n\tlet \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpozs5lny9.ts(54,9): error TS1005: ',' expected.\n../../../../tmp/tmpozs5lny9.ts(76,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333984
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: number[] = [];\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    let open_brackets_stack: number[] = [];\n    let close_brackets_stack: number[] = [];\n    let open_stack: number[] = [];\n    let close_stack: number[] = [];\n    let open_stack_index: number = 0;\n    let close_stack_index: number = 0;\n    let open_stack_string: string = \"\";\n    let close_stack_string: string = \"\";\n    let open_stack_string_index: number = 0;\n    let close_stack_string_index: number = 0;\n    let open_stack_string_index2: number = 0;\n    let close_stack_string_index2: number = 0;\n    let open_stack_string_index3: number = 0;\n    let close_stack_string_index3: number = 0;\n    let open_stack_string_index4: number = 0;\n    let close_stack_string_index4: number = 0;\n    let open_stack_string_index5: number = 0;\n    let close_stack_string_index5: number = 0;\n    let open_stack_string_index6: number = 0;\n    let close_stack_string_index6: number = 0;\n    let open_stack_string_index7: number = 0;\n    let close_stack_string_index7: number = 0;\n    let open_stack_string_index8: number = 0;\n    let close_stack_string_index8: number = 0;\n    let open_stack_string_index9: number = 0;\n    let close_stack_string_index9: number = 0;\n    let open_stack_string_index10: number = 0;\n    let close_stack_string_index10: number = 0;\n    let open_stack_string_index11: number = 0;\n    let close_stack_string_index11: number = 0;\n    let open_stack_string_index12: number = 0;\n    let close_stack_string_index12: number = 0;\n    let open_stack_string_index13: number = 0;\n    let close_stack_string_index13: number = 0;\n    let open_stack_string_index14: number = 0;\n    let close_stack_string_index14: number = 0;\n    let open_stack_string_index15: number = 0;\n    let close_stack_string_index15: number = 0;\n    let open_stack_string_index16: number = 0;\n    let close_stack_string_index16: number = 0;\n    let open_stack_string_index17: number = 0;\n    let close_stack_string_index17: number = 0;\n    let open_stack_string_index18: number = 0;\n    let close_stack_string_index18: number = 0;\n    let open_stack_string_index19: number = 0;\n    let close_stack_string_index19: number = 0;\n    let open_stack_string_index20: number = 0;\n    let close_stack_string_index20: number = 0;\n    let open_stack_string_index21: number = 0;\n    let close_stack_string_index21: number = 0;\n    let open_stack_string_index\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpe9_v6mv2.ts(93,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333983
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_parens: number[] = [];\n\tlet close_parens: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_parens_stack: number[] = [];\n\tlet close_parens_stack: number[] = [];\n\tlet open_brackets_size: number = 0;\n\tlet close_brackets_size: number = 0;\n\tlet open_parens_size: number = 0;\n\tlet close_parens_size: number = 0;\n\tlet open_brackets_string: string = \"\";\n\tlet close_brackets_string: string = \"\";\n\tlet open_parens_string: string = \"\";\n\tlet close_parens_string: string = \"\";\n\tlet open_brackets_string_size: number = 0;\n\tlet close_brackets_string_size: number = 0;\n\tlet open_parens_string_size: number = 0;\n\tlet close_parens_string_size: number = 0;\n\tlet open_brackets_string_size2: number = 0;\n\tlet close_brackets_string_size2: number = 0;\n\tlet open_parens_string_size2: number = 0;\n\tlet close_parens_string_size2: number = 0;\n\tlet open_brackets_string_size3: number = 0;\n\tlet close_brackets_string_size3: number = 0;\n\tlet open_parens_string_size3: number = 0;\n\tlet close_parens_string_size3: number = 0;\n\tlet open_brackets_string_size4: number = 0;\n\tlet close_brackets_string_size4: number = 0;\n\tlet open_parens_string_size4: number = 0;\n\tlet close_parens_string_size4: number = 0;\n\tlet open_brackets_string_size5: number = 0;\n\tlet close_brackets_string_size5: number = 0;\n\tlet open_parens_string_size5: number = 0;\n\tlet close_parens_string_size5: number = 0;\n\tlet open_brackets_string_size6: number = 0;\n\tlet close_brackets_string_size6: number = 0;\n\tlet open_parens_string_size6: number = 0;\n\tlet close_parens_string_size6: number = 0;\n\tlet open_brackets_string_size7: number = 0;\n\tlet close_brackets_string_size7: number = 0;\n\tlet open_parens_string_size7: number = 0;\n\tlet close_parens_string_size7: number = 0;\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpjbmdsn_3.ts(84,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333984
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number = 0;\n\tlet close_brackets: number = 0;\n\tlet open_brackets_stack: string[] = [];\n\tlet close_brackets_stack: string[] = [];\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlet char = string[i];\n\t\tif (char === \"[\") {\n\t\t\topen_brackets++;\n\t\t\topen_brackets_stack.push(string[i]);\n\t\t} else if (char === \"]\") {\n\t\t\tclose_brackets++;\n\t\t\tclose_brackets_stack.push(string[i]);\n\t\t} else if (char === \"]\" && open_brackets > 0 && close_brackets > 0) {\n\t\t\topen_brackets--;\n\t\t\tclose_brackets--;\n\t\t\topen_brackets_stack.pop();\n\t\t\tclose_brackets_stack.pop();\n\t\t} else if (char === \"[\" && open_brackets > 0 && close_brackets === 0) {\n\t\t\topen_brackets--;\n\t\t\topen_brackets_stack.pop();\n\t\t} else if (char === \"]\" && open_brackets === 0 && close_brackets > 0) {\n\t\t\tclose_brackets--;\n\t\t\tclose_brackets_stack.pop();\n\t\t}\n\t}\n\n\treturn open_brackets === 0 && close_brackets === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmp2rhddxde.js:51:12)\n    at Object.<anonymous> (/tmp/tmp2rhddxde.js:66:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333984
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets = string.match(/\\[.*?\\]/g);\n\tlet nested = false;\n\tfor (let i = 0; i < brackets.length; i++) {\n\t\tlet bracket = brackets[i];\n\t\tlet open_brackets = bracket.match(/\\[/g);\n\t\tlet close_brackets = bracket.match(/\\]/g);\n\t\tif (open_brackets && close_brackets) {\n\t\t\tnested = true;\n\t\t}\n\t}\n\treturn nested;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpk_t69ws2.js:33:12)\n    at Object.<anonymous> (/tmp/tmpk_t69ws2.js:47:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333985
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_parens: number[] = [];\n\tlet close_parens: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_parens_stack: number[] = [];\n\tlet close_parens_stack: number[] = [];\n\tlet open_brackets_stack_index: number = 0;\n\tlet close_brackets_stack_index: number = 0;\n\tlet open_parens_stack_index: number = 0;\n\tlet close_parens_stack_index: number = 0;\n\tlet open_brackets_stack_string: string = \"\";\n\tlet close_brackets_stack_string: string = \"\";\n\tlet open_parens_stack_string: string = \"\";\n\tlet close_parens_stack_string: string = \"\";\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlet char = string[i];\n\t\tif (char === \"[\") {\n\t\t\tbrackets.push(open_brackets_stack[open_brackets_stack_index]);\n\t\t\topen_brackets_stack_string = open_brackets_stack_string.concat(\"[\");\n\t\t\topen_brackets_stack_index++;\n\t\t} else if (char === \"]\") {\n\t\t\tclose_brackets_stack_string = close_brackets_stack_string.concat(\"]\");\n\t\t\tclose_brackets_stack_index++;\n\t\t\tclose_brackets_stack.push(close_brackets_stack_index);\n\t\t} else if (char === \"(\") {\n\t\t\topen_parens_stack_string = open_parens_stack_string.concat(\"(\");\n\t\t\topen_parens_stack.push(open_parens_stack_index);\n\t\t\topen_parens_stack_index++;\n\t\t} else if (char === \")\") {\n\t\t\tclose_parens_stack_string = close_parens_stack_string.concat(\")\");\n\t\t\tclose_parens_stack.push(close_parens_stack_index);\n\t\t\tclose_parens_stack_index++;\n\t\t\tclose_parens_stack.push(close_parens_stack_index);\n\t\t} else if (char === \"[\") {\n\t\t\topen_brackets_stack_string = open_brackets_stack_string.concat(\"[\");\n\t\t\topen_brackets_stack_index++;\n\t\t} else if (char === \"]\") {\n\t\t\tclose_brackets_stack_string = close_brackets_stack_string.concat(\"]\");\n\t\t\tclose_brackets_stack_index++;\n\t\t\tclose_brackets_stack.push(close_brackets_stack_index);\n\t\t} else if (char === \"\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpckyy5vy1.ts(60,24): error TS1002: Unterminated string literal.\n../../../../tmp/tmpckyy5vy1.ts(61,1): error TS1005: ')' expected.\n../../../../tmp/tmpckyy5vy1.ts(83,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333985
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets: string[] = string.split(\"\").filter(x => x === \"[\" || x === \"]\");\n    let nested: boolean = false;\n    for (let i = 0; i < brackets.length; i++) {\n        if (brackets[i + 1] === \"[\" && brackets[i + 2] === \"[\" && brackets[i + 3] === \"[\" && brackets[i + 4] === \"[\" && brackets[i + 5] === \"[\" && brackets[i + 6] === \"[\" && brackets[i + 7] === \"[\" && brackets[i + 8] === \"[\" && brackets[i + 9] === \"[\" && brackets[i + 10] === \"[\" && brackets[i + 11] === \"[\" && brackets[i + 12] === \"[\" && brackets[i + 13] === \"[\" && brackets[i + 14] === \"[\" && brackets[i + 15] === \"[\" && brackets[i + 16] === \"[\" && brackets[i + 17] === \"[\" && brackets[i + 18] === \"[\" && brackets[i + 19] === \"[\" && brackets[i + 20] === \"[\" && brackets[i + 21] === \"[\" && brackets[i + 22] === \"[\" && brackets[i + 23] === \"[\" && brackets[i + 24] === \"[\" && brackets[i + 25] === \"[\" && brackets[i + 26] === \"[\" && brackets[i + 27] === \"[\" && brackets[i + 28] === \"[\" && brackets[i + 29] === \"[\" && brackets[i + 30] === \"[\" && brackets[i + 31] === \"[\" && brackets[i + 32] === \"[\" && brackets[i + 33] === \"[\" && brackets[i + 34] === \"[\" && brackets[i + 35] === \"[\" && brackets[i + 36] === \"[\" && brackets[i + 37] === \"[\" && brackets[i + 38] === \"[\" && brackets[i + 39] === \"[\" && brackets[i + 40] === \"[\" && brackets[i + 41] === \"[\" && brackets[i + 42] === \"[\" && brackets[i + 43] === \"[\" && brackets[i + 44] === \"[\" && brackets[i + 45] === \"[\" && brackets[i + 46] === \"[\" && brackets[i + 47] === \"[\" && brackets[i + 48] === \"[\" && brackets[i + 49] === \"[\" && brackets[i + 50] === \"[\" && brackets[i + 51] === \"[\" && brackets[i + 52] === \"[\" && brackets[i + 53] === \"[\" && brackets[i + 54] === \"[\" && brackets[i + 55] === \"[\" && brackets[i + 56] === \"[\" && brackets[i + 57] === \"[\" && brackets[i + 58] === \"[\" && brackets[i + 59] === \"[\" && brackets[i + 60] === \"[\" && brackets[i\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpim3bbzgi.ts(21,1): error TS1005: ']' expected.\n../../../../tmp/tmpim3bbzgi.ts(43,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333985
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    let open_curly: number[] = [];\n    let close_curly: number[] = [];\n    let open_square: number[] = [];\n    let close_square: number[] = [];\n    let open_paren: number[] = [];\n    let close_paren: number[] = [];\n    let open_angle: number[] = [];\n    let close_angle: number[] = [];\n    let open_paren_curly: number[] = [];\n    let close_paren_curly: number[] = [];\n    let open_paren_square: number[] = [];\n    let close_paren_square: number[] = [];\n    let open_angle_square: number[] = [];\n    let close_angle_square: number[] = [];\n    let open_angle_paren: number[] = [];\n    let close_angle_paren: number[] = [];\n    let open_angle_curly: number[] = [];\n    let close_angle_curly: number[] = [];\n    let open_angle_paren_curly: number[] = [];\n    let close_angle_paren_curly: number[] = [];\n    let open_angle_paren_square: number[] = [];\n    let close_angle_paren_square: number[] = [];\n    let open_angle_angle: number[] = [];\n    let close_angle_angle: number[] = [];\n    let open_angle_angle_paren: number[] = [];\n    let close_angle_angle_paren: number[] = [];\n    let open_angle_angle_curly: number[] = [];\n    let close_angle_angle_curly: number[] = [];\n    let open_angle_angle_paren_curly: number[] = [];\n    let close_angle_angle_paren_curly: number[] = [];\n    let open_angle_angle_paren_square: number[] = [];\n    let close_angle_angle_paren_square: number[] = [];\n    let open_angle_angle_angle: number[] = [];\n    let close_angle_angle_angle: number[] = [];\n    let open_angle_angle_angle_paren: number[] = [];\n    let close_angle_angle_angle_paren: number[] = [];\n    let open_angle_angle_angle_curly: number[] = [];\n    let close_angle_angle_angle_curly: number[] = [];\n    let open_angle_angle_angle_paren_curly: number[] = [];\n    let close_angle_angle_angle_paren_curly: number[] = [];\n    let open_angle_angle_angle_paren_square: number[] = [];\n    let close_angle_angle_angle_paren_square: number[] = [];\n    let open_angle_angle_angle_angle: number[] = [];\n    let close_angle_angle_angle_angle: number[] = [];\n    let open_angle_angle_angle_angle_paren: number[] = [];\n    let close_angle_angle_angle_angle_paren: number[] = [];\n    let open_angle_angle_angle_angle_curly\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp3zivhkch.ts(89,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333986
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: string[] = string.split(\"\");\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet i: number;\n\tlet j: number;\n\tlet open_brackets_length: number;\n\tlet close_brackets_length: number;\n\tlet open_brackets_length_index: number;\n\tlet close_brackets_length_index: number;\n\tlet open_brackets_length_index_previous: number;\n\tlet close_brackets_length_index_previous: number;\n\tlet open_brackets_length_index_next: number;\n\tlet close_brackets_length_index_next: number;\n\tlet open_brackets_length_index_current: number;\n\tlet close_brackets_length_index_current: number;\n\tlet open_brackets_length_index_next: number;\n\tlet close_brackets_length_index_next: number;\n\tlet open_brackets_length_index_previous: number;\n\tlet close_brackets_length_index_previous: number;\n\tlet open_brackets_length_index_current: number;\n\tlet close_brackets_length_index_current: number;\n\tlet open_brackets_length_index_next: number;\n\tlet close_brackets_length_index_next: number;\n\tlet open_brackets_length_index_previous: number;\n\tlet close_brackets_length_index_previous: number;\n\tlet open_brackets_length_index_current: number;\n\tlet close_brackets_length_index_current: number;\n\tlet open_brackets_length_index_next: number;\n\tlet close_brackets_length_index_next: number;\n\tlet open_brackets_length_index_previous: number;\n\tlet close_brackets_length_index_previous: number;\n\tlet open_brackets_length_index_current: number;\n\tlet close_brackets_length_index_current: number;\n\tlet open_brackets_length_index_next: number;\n\tlet close_brackets_length_index_next: number;\n\tlet open_brackets_length_index_previous: number;\n\tlet close_brackets_length_index_previous: number;\n\tlet open_brackets_length_index_current: number;\n\tlet close_brackets_length_index_current: number;\n\tlet open_brackets_length_index_next: number;\n\tlet close_brackets_length_index_next: number;\n\tlet open_brackets_length_index_previous: number;\n\tlet close_brackets_length_index_previous: number;\n\tlet open_brackets_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmplzzyx9jk.ts(83,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333985
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let open_brackets: number[] = [];\n    let closed_brackets: number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            open_brackets.push(i);\n        } else if (string[i] === \"]\") {\n            closed_brackets.push(i);\n        }\n    }\n    if (open_brackets.length !== closed_brackets.length) {\n        return false;\n    }\n    for (let i = 0; i < open_brackets.length; i++) {\n        let open_bracket = open_brackets[i];\n        let closed_bracket = closed_brackets[i];\n        if (open_bracket === closed_bracket) {\n            continue;\n        }\n        if (open_bracket > closed_bracket) {\n            return false;\n        }\n        let open_length = open_bracket - 1;\n        let close_length = closed_bracket - 1;\n        let open_brackets_length = open_brackets.length - 1;\n        let closed_brackets_length = closed_brackets.length - 1;\n        for (let j = 0; j < open_brackets_length; j++) {\n            if (open_brackets[j + 1] === closed_bracket) {\n                open_length--;\n                closed_brackets_length--;\n            }\n        }\n        for (let j = 0; j < closed_brackets_length; j++) {\n            if (closed_brackets[j + 1] === open_bracket) {\n                open_brackets_length--;\n                open_length--;\n            }\n        }\n        if (open_length !== 0 || closed_brackets_length !== 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmp_9h5qql4.js:64:12)\n    at Object.<anonymous> (/tmp/tmp_9h5qql4.js:79:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333986
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            stack.push(\"[\");\n        } else if (string[i] === \"]\") {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.pop();\n        } else if (string[i] === \"[\") {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.push(\"[\");\n        } else if (string[i] === \"]\") {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpce2q6npf.js:48:12)\n    at Object.<anonymous> (/tmp/tmpce2q6npf.js:61:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333986
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets = string.match(/\\[.*?\\]/g);\n\treturn brackets !== null;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmp_6oc3v4q.js:24:12)\n    at Object.<anonymous> (/tmp/tmp_6oc3v4q.js:38:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333986
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let brackets = string.match(/\\[.*?\\]/g);\n    if (brackets == null) {\n        return false;\n    }\n    for (let i = 0; i < brackets.length; i++) {\n        let bracket = brackets[i];\n        let open = bracket.match(/\\[/);\n        let close = bracket.match(/\\]/);\n        if (open != null && close != null) {\n            if (open[0].length != close[0].length) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpdgnmzg4i.js:37:12)\n    at Object.<anonymous> (/tmp/tmpdgnmzg4i.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333986
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        let char = string[i];\n        if (char == \"[\") {\n            stack.push(\"[\" + char);\n        } else if (char == \"]\") {\n            if (stack.length == 0) {\n                return false;\n            }\n            let bracket = stack.pop();\n            if (bracket != \"[\") {\n                return false;\n            }\n        } else if (char == \"[\") {\n            if (stack.length == 0) {\n                return false;\n            }\n            let bracket = stack.pop();\n            if (bracket != \"[\") {\n                return false;\n            }\n        } else if (char == \"]\") {\n            if (stack.length == 0) {\n                return false;\n            }\n            let bracket = stack.pop();\n            if (bracket != \"[\") {\n                return false;\n            }\n        } else {\n            if (stack.length == 0) {\n                return false;\n            }\n            let bracket = stack.pop();\n            if (bracket != \"[\") {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmpv8zxd_qm.js:65:12)\n    at Object.<anonymous> (/tmp/tmpv8zxd_qm.js:80:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333986
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    if (string.length <= 1) {\n        return false;\n    }\n    let opening_brackets: number[] = [];\n    let closing_brackets: number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            opening_brackets.push(i);\n        } else if (string[i] === \"]\") {\n            closing_brackets.push(i);\n        }\n    }\n    if (opening_brackets.length !== closing_brackets.length) {\n        return false;\n    }\n    for (let i = 0; i < opening_brackets.length; i++) {\n        let opening_bracket = opening_brackets[i];\n        let closing_bracket = closing_brackets[i];\n        if (opening_bracket === closing_bracket) {\n            continue;\n        }\n        if (opening_bracket > closing_bracket) {\n            return false;\n        }\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpljfzt6hb.js:50:12)\n    at Object.<anonymous> (/tmp/tmpljfzt6hb.js:63:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333986
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_parens: number[] = [];\n\tlet close_parens: number[] = [];\n\tlet open_parens_stack: number[] = [];\n\tlet close_parens_stack: number[] = [];\n\tlet open_parens_stack_index: number = 0;\n\tlet close_parens_stack_index: number = 0;\n\tlet open_parens_stack_string: string = \"\";\n\tlet close_parens_stack_string: string = \"\";\n\tlet open_parens_stack_string_index: number = 0;\n\tlet close_parens_stack_string_index: number = 0;\n\tlet open_parens_stack_string_index2: number = 0;\n\tlet close_parens_stack_string_index2: number = 0;\n\tlet open_parens_stack_string_index3: number = 0;\n\tlet close_parens_stack_string_index3: number = 0;\n\tlet open_parens_stack_string_index4: number = 0;\n\tlet close_parens_stack_string_index4: number = 0;\n\tlet open_parens_stack_string_index5: number = 0;\n\tlet close_parens_stack_string_index5: number = 0;\n\tlet open_parens_stack_string_index6: number = 0;\n\tlet close_parens_stack_string_index6: number = 0;\n\tlet open_parens_stack_string_index7: number = 0;\n\tlet close_parens_stack_string_index7: number = 0;\n\tlet open_parens_stack_string_index8: number = 0;\n\tlet close_parens_stack_string_index8: number = 0;\n\tlet open_parens_stack_string_index9: number = 0;\n\tlet close_parens_stack_string_index9: number = 0;\n\tlet open_parens_stack_string_index10: number = 0;\n\tlet close_parens_stack_string_index10: number = 0;\n\tlet open_parens_stack_string_index11: number = 0;\n\tlet close_parens_stack_string_index11: number = 0;\n\tlet open_parens_stack_string_index12: number = 0;\n\tlet close_parens_stack_string_index12: number = 0;\n\tlet open_parens_stack_string_index13: number = 0;\n\tlet close_parens_stack_string_index13: number = 0;\n\tlet open_parens_stack_string_index14: number = 0;\n\tlet close_parens_stack_string_index14: number = 0;\n\tlet open_parens_stack_string_index15: number = 0;\n\tlet close_parens_stack_string_index15: number = 0;\n\tlet open_parens_stack_string_index16: number = 0;\n\tlet close_parens_stack_string\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp00l9ni4x.ts(82,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333986
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            stack.push(\"[\");\n        } else if (string[i] === \"]\") {\n            if (stack.length === 0) {\n                return false;\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmphjygp2ng.js:38:12)\n    at Object.<anonymous> (/tmp/tmphjygp2ng.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333986
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let open_brackets: number[] = [];\n    let close_brackets: number[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            open_brackets.push(i);\n        } else if (string[i] === \"]\") {\n            close_brackets.push(i);\n        }\n    }\n    if (open_brackets.length !== close_brackets.length) {\n        return false;\n    }\n    for (let i = 0; i < open_brackets.length; i++) {\n        if (open_brackets[i + 1] - open_brackets[i] <= 1) {\n            return false;\n        }\n    }\n    return true;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould loosely deep-equal\n\ntrue\n    at test (/tmp/tmp6h4cort0.js:40:12)\n    at Object.<anonymous> (/tmp/tmp6h4cort0.js:55:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n  expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333987
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number = 0;\n\tlet close_brackets: number = 0;\n\tlet open_curly: number = 0;\n\tlet close_curly: number = 0;\n\tlet open_paren: number = 0;\n\tlet close_paren: number = 0;\n\tlet open_curly_brackets: number = 0;\n\tlet close_curly_brackets: number = 0;\n\tlet open_paren_brackets: number = 0;\n\tlet close_paren_brackets: number = 0;\n\tlet open_brackets_brackets: number = 0;\n\tlet close_brackets_brackets: number = 0;\n\tlet open_curly_brackets_brackets: number = 0;\n\tlet close_curly_brackets_brackets: number = 0;\n\tlet open_paren_brackets_brackets: number = 0;\n\tlet close_paren_brackets_brackets: number = 0;\n\tlet open_brackets_brackets_brackets: number = 0;\n\tlet close_brackets_brackets_brackets: number = 0;\n\tlet open_curly_brackets_brackets_brackets: number = 0;\n\tlet close_curly_brackets_brackets_brackets: number = 0;\n\tlet open_paren_brackets_brackets_brackets: number = 0;\n\tlet close_paren_brackets_brackets_brackets: number = 0;\n\tlet open_brackets_brackets_brackets_brackets: number = 0;\n\tlet close_brackets_brackets_brackets_brackets: number = 0;\n\tlet open_curly_brackets_brackets_brackets_brackets: number = 0;\n\tlet close_curly_brackets_brackets_brackets_brackets: number = 0;\n\tlet open_paren_brackets_brackets_brackets_brackets: number = 0;\n\tlet close_paren_brackets_brackets_brackets_brackets: number = 0;\n\tlet open_brackets_brackets_brackets_brackets_brackets: number = 0;\n\tlet close_brackets_brackets_brackets_brackets_brackets: number = 0;\n\tlet open_curly_brackets_brackets_brackets_brackets_brackets: number = 0;\n\tlet close_curly_brackets_brackets_brackets_brackets_brackets: number = 0;\n\tlet open_paren_brackets_brackets_brackets_brackets_brackets: number = 0;\n\tlet close_paren_brackets_brackets_brackets_brackets_brackets: number = 0;\n\tlet open_brackets_brackets_brackets_brackets_brackets_brackets: number = 0;\n\tlet close_brackets_brackets_brackets_brackets_brackets_brackets: number = 0;\n\tlet open_curly_brackets_bracket\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp7ls2m5y8.ts(76,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333986
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    // Write your code here.\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] == \"[\") {\n            stack.push(string[i]);\n        } else if (string[i] == \"]\") {\n            if (stack.length == 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length == 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmps2a3dta9.js:37:12)\n    at Object.<anonymous> (/tmp/tmps2a3dta9.js:50:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333987
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number = 0;\n\tlet close_brackets: number = 0;\n\tlet open_brackets_stack: string[] = [];\n\tlet close_brackets_stack: string[] = [];\n\tlet open_chars: number = 0;\n\tlet close_chars: number = 0;\n\tlet open_chars_stack: string[] = [];\n\tlet close_chars_stack: string[] = [];\n\tlet open_chars_stack_string: string = \"\";\n\tlet close_chars_stack_string: string = \"\";\n\tlet open_chars_stack_string_index: number = 0;\n\tlet close_chars_stack_string_index: number = 0;\n\tlet open_chars_stack_string_index2: number = 0;\n\tlet close_chars_stack_string_index2: number = 0;\n\tlet open_chars_stack_string_index3: number = 0;\n\tlet close_chars_stack_string_index3: number = 0;\n\tlet open_chars_stack_string_index4: number = 0;\n\tlet close_chars_stack_string_index4: number = 0;\n\tlet open_chars_stack_string_index5: number = 0;\n\tlet close_chars_stack_string_index5: number = 0;\n\tlet open_chars_stack_string_index6: number = 0;\n\tlet close_chars_stack_string_index6: number = 0;\n\tlet open_chars_stack_string_index7: number = 0;\n\tlet close_chars_stack_string_index7: number = 0;\n\tlet open_chars_stack_string_index8: number = 0;\n\tlet close_chars_stack_string_index8: number = 0;\n\tlet open_chars_stack_string_index9: number = 0;\n\tlet close_chars_stack_string_index9: number = 0;\n\tlet open_chars_stack_string_index10: number = 0;\n\tlet close_chars_stack_string_index10: number = 0;\n\tlet open_chars_stack_string_index11: number = 0;\n\tlet close_chars_stack_string_index11: number = 0;\n\tlet open_chars_stack_string_index12: number = 0;\n\tlet close_chars_stack_string_index12: number = 0;\n\tlet open_chars_stack_string_index13: number = 0;\n\tlet close_chars_stack_string_index13: number = 0;\n\tlet open_chars_stack_string_index14: number = 0;\n\tlet close_chars_stack_string_index14: number = 0;\n\tlet open_chars_stack_string_index15: number = 0;\n\tlet close_chars_stack_string_index15: number = 0;\n\tlet open_chars_stack_string_index16: number = 0;\n\tlet close_chars_stack_string_index16: number = 0;\n\tlet open_chars_stack_string_index17: number = 0;\n\tlet close_chars_stack_string_index17: number = 0;\n\tlet open_chars_stack_string_index18: number = 0;\n\tlet close_chars_stack_string\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpnz13wu6d.ts(85,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333986
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[] = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet bracket_level: number = 0;\n\tlet bracket_level_count: number = 0;\n\tlet bracket_level_count_max: number = 10;\n\tlet bracket_level_count_current: number = 0;\n\tlet bracket_level_count_current_max: number = 10;\n\tlet bracket_level_count_current_min: number = 1;\n\tlet bracket_level_count_current_max: number = 10;\n\tlet bracket_level_count_current_min: number = 1;\n\tlet bracket_level_count_current_max: number = 10;\n\tlet bracket_level_count_current_min: number = 1;\n\tlet bracket_level_count_current_max: number = 10;\n\tlet bracket_level_count_current_min: number = 1;\n\tlet bracket_level_count_current_max: number = 10;\n\tlet bracket_level_count_current_min: number = 1;\n\tlet bracket_level_count_current_max: number = 10;\n\tlet bracket_level_count_current_min: number = 1;\n\tlet bracket_level_count_current_max: number = 10;\n\tlet bracket_level_count_current_min: number = 1;\n\tlet bracket_level_count_current_max: number = 10;\n\tlet bracket_level_count_current_min: number = 1;\n\tlet bracket_level_count_current_max: number = 10;\n\tlet bracket_level_count_current_min: number = 1;\n\tlet bracket_level_count_current_max: number = 10;\n\tlet bracket_level_count_current_min: number = 1;\n\tlet bracket_level_count_current_max: number = 10;\n\tlet bracket_level_count_current_min: number = 1;\n\tlet bracket_level_count_current_max: number = 10;\n\tlet bracket_level_count_current_min: number = 1;\n\tlet bracket_level_count_current_max: number = 10;\n\tlet bracket_level_count_current_min: number = 1;\n\tlet bracket_level_count_current_max: number = 10;\n\tlet bracket_level_count_current_min: number = 1;\n\tlet bracket_level_count_current_max: number = 10;\n\tlet bracket_level_count_current_min: number = 1;\n\tlet bracket_level_count_current_max: number = 10;\n\tlet bracket_level_count_current_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpc1a_xxy5.ts(80,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333986
    },
    {
      "exit_code": 2,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let open_brackets: number[] = [];\n    let closed_brackets: number[] = [];\n    let open_brackets_stack: number[] = [];\n    let closed_brackets_stack: number[] = [];\n    let open_brackets_length: number = 0;\n    let closed_brackets_length: number = 0;\n    let open_brackets_stack_index: number = 0;\n    let closed_brackets_stack_index: number = 0;\n    let open_brackets_stack_string: string = \"\";\n    let closed_brackets_stack_string: string = \"\";\n    let open_brackets_string: string = \"\";\n    let closed_brackets_string: string = \"\";\n    let open_brackets_string_index: number = 0;\n    let closed_brackets_string_index: number = 0;\n    let open_brackets_string_index2: number = 0;\n    let closed_brackets_string_index2: number = 0;\n    let open_brackets_string_index3: number = 0;\n    let closed_brackets_string_index3: number = 0;\n    let open_brackets_string_index4: number = 0;\n    let closed_brackets_string_index4: number = 0;\n    let open_brackets_string_index5: number = 0;\n    let closed_brackets_string_index5: number = 0;\n    let open_brackets_string_index6: number = 0;\n    let closed_brackets_string_index6: number = 0;\n    let open_brackets_string_index7: number = 0;\n    let closed_brackets_string_index7: number = 0;\n    let open_brackets_string_index8: number = 0;\n    let closed_brackets_string_index8: number = 0;\n    let open_brackets_string_index9: number = 0;\n    let closed_brackets_string_index9: number = 0;\n    let open_brackets_string_index10: number = 0;\n    let closed_brackets_string_index10: number = 0;\n    let open_brackets_string_index11: number = 0;\n    let closed_brackets_string_index11: number = 0;\n    let open_brackets_string_index12: number = 0;\n    let closed_brackets_string_index12: number = 0;\n    let open_brackets_string_index13: number = 0;\n    let closed_brackets_string_index13: number = 0;\n    let open_brackets_string_index14: number = 0;\n    let closed_brackets_string_index14: number = 0;\n    let open_brackets_string_index15: number = 0;\n    let closed_brackets_string_index15: number = 0;\n    let open_brackets_string_index16: number = 0;\n    let closed_brackets_string_index16\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp63mn3ua6.ts(83,8): error TS1005: '}' expected.\n",
      "timestamp": 1660333986
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    const stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        const char = string[i];\n        if (char === '[') {\n            stack.push(char);\n        } else if (char === ']') {\n            if (stack.length === 0) {\n                return false;\n            }\n            const openBracket = stack.pop();\n            if (openBracket !== '[') {\n                return false;\n            }\n        } else {\n            if (stack.length > 0) {\n                return false;\n            }\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmprax39f5m.js:45:12)\n    at Object.<anonymous> (/tmp/tmprax39f5m.js:58:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333987
    },
    {
      "exit_code": 1,
      "program": "//Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets \n// where at least one bracket in the subsequence is nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\")\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n// false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n// true\nfunction is_nested(string: string): boolean {\n    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === \"[\") {\n            stack.push(string[i]);\n        } else if (string[i] === \"]\") {\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould loosely deep-equal\n\nfalse\n    at test (/tmp/tmpzojs0i1x.js:36:12)\n    at Object.<anonymous> (/tmp/tmpzojs0i1x.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected: false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660333962
    }
  ]
}