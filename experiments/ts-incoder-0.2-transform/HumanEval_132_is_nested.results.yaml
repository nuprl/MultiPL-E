language: ts
name: HumanEval_132_is_nested
results:
- exit_code: 1
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n    let stack: string[]\
    \ = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i]\
    \ == \"[\") {\n            stack.push(string[i]);\n        } else if (string[i]\
    \ == \"]\") {\n            if (stack.length == 0) {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    if (stack.length\
    \ != 0) {\n        return false;\n    }\n    return true;\n}\n\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"\
    []]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"\
    []\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"\
    []]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"\
    [[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"\
    [[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\
    \"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"\
    ]]]]]]]]\"),false);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould\
    \ loosely deep-equal\n\nfalse\n    at test (/tmp/tmpmfzlf5dr.js:39:12)\n    at\
    \ Object.<anonymous> (/tmp/tmpmfzlf5dr.js:52:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected:\
    \ false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1659738833
- exit_code: 2
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[]\
    \ = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] =\
    \ [];\n\tlet open_parens: number[] = [];\n\tlet close_parens: number[] = [];\n\
    \tlet open_parens_stack: number[] = [];\n\tlet close_parens_stack: number[] =\
    \ [];\n\tlet open_brackets_stack: number[] = [];\n\tlet close_brackets_stack:\
    \ number[] = [];\n\tlet open_parens_stack_string: string = \"\";\n\tlet close_parens_stack_string:\
    \ string = \"\";\n\tlet open_brackets_stack_string: string = \"\";\n\tlet close_brackets_stack_string:\
    \ string = \"\";\n\tlet open_parens_stack_string_index: number = 0;\n\tlet close_parens_stack_string_index:\
    \ number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index:\
    \ number = 0;\n\tlet open_parens_stack_string_index: number = 0;\n\tlet close_parens_stack_string_index:\
    \ number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index:\
    \ number = 0;\n\tlet open_parens_stack_string_index: number = 0;\n\tlet close_parens_stack_string_index:\
    \ number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index:\
    \ number = 0;\n\tlet open_parens_stack_string_index: number = 0;\n\tlet close_parens_stack_string_index:\
    \ number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index:\
    \ number = 0;\n\tlet open_parens_stack_string_index: number = 0;\n\tlet close_parens_stack_string_index:\
    \ number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index:\
    \ number = 0;\n\tlet open_parens_stack_string_index: number = 0;\n\tlet close_parens_stack_string_index:\
    \ number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index:\
    \ number = 0;\n\tlet open_parens_stack_string_index: number = 0;\n\tlet close_parens_stack_string_index:\
    \ number = 0;\n\tlet open_brackets_stack_string_index: number = 0;\n\tlet close_brackets_stack_string_index:\
    \ number = 0;\n\tlet open_parens_stack_string_index\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"\
    []]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"\
    []\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"\
    []]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"\
    [[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"\
    [[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\
    \"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"\
    ]]]]]]]]\"),false);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp1tc4vjac.ts(81,8): error TS1005: ''}'' expected.

    '
  timestamp: 1659738833
- exit_code: 2
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[]\
    \ = [];\n\tlet opening_brackets: number[] = [];\n\tlet closing_brackets: number[]\
    \ = [];\n\tlet opening_chars: number[] = [];\n\tlet closing_chars: number[] =\
    \ [];\n\tlet opening_char: number[] = [];\n\tlet closing_char: number[] = [];\n\
    \tlet opening_char_index: number[] = [];\n\tlet closing_char_index: number[] =\
    \ [];\n\tlet opening_char_index2: number[] = [];\n\tlet closing_char_index2: number[]\
    \ = [];\n\tlet opening_char_index3: number[] = [];\n\tlet closing_char_index3:\
    \ number[] = [];\n\tlet opening_char_index4: number[] = [];\n\tlet closing_char_index4:\
    \ number[] = [];\n\tlet opening_char_index5: number[] = [];\n\tlet closing_char_index5:\
    \ number[] = [];\n\tlet opening_char_index6: number[] = [];\n\tlet closing_char_index6:\
    \ number[] = [];\n\tlet opening_char_index7: number[] = [];\n\tlet closing_char_index7:\
    \ number[] = [];\n\tlet opening_char_index8: number[] = [];\n\tlet closing_char_index8:\
    \ number[] = [];\n\tlet opening_char_index9: number[] = [];\n\tlet closing_char_index9:\
    \ number[] = [];\n\tlet opening_char_index10: number[] = [];\n\tlet closing_char_index10:\
    \ number[] = [];\n\tlet opening_char_index11: number[] = [];\n\tlet closing_char_index11:\
    \ number[] = [];\n\tlet opening_char_index12: number[] = [];\n\tlet closing_char_index12:\
    \ number[] = [];\n\tlet opening_char_index13: number[] = [];\n\tlet closing_char_index13:\
    \ number[] = [];\n\tlet opening_char_index14: number[] = [];\n\tlet closing_char_index14:\
    \ number[] = [];\n\tlet opening_char_index15: number[] = [];\n\tlet closing_char_index15:\
    \ number[] = [];\n\tlet opening_char_index16: number[] = [];\n\tlet closing_char_index16:\
    \ number[] = [];\n\tlet opening_char_index17: number[] = [];\n\tlet closing_char_index17:\
    \ number[] = [];\n\tlet opening_char_index18: number[] = [];\n\tlet closing_char_index18:\
    \ number[] = [];\n\tlet opening_char_index19: number[] = [];\n\tlet closing_char_index19:\
    \ \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
    \ test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"\
    ),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"\
    [][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"\
    [][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"\
    []]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"\
    [[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\n\
    test();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmptgsqsfy5.ts(62,9): error TS1005: '','' expected.

    ../../../../../tmp/tmptgsqsfy5.ts(84,8): error TS1005: ''}'' expected.

    '
  timestamp: 1659738833
- exit_code: 2
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n    let open_brackets:\
    \ number[] = [];\n    let closed_brackets: number[] = [];\n    for (let i = 0;\
    \ i < string.length; i++) {\n        let char = string[i];\n        if (char ===\
    \ '[') {\n            open_brackets.push(i);\n        } else if (char === ']')\
    \ {\n            closed_brackets.push(i);\n        }\n    }\n    if (open_brackets.length\
    \ !== closed_brackets.length) {\n        return false;\n    }\n    for (let i\
    \ = 0; i < open_brackets.length; i++) {\n        let open_bracket = open_brackets[i];\n\
    \        let closed_bracket = closed_brackets[i];\n        if (open_bracket ===\
    \ closed_bracket) {\n            continue;\n        }\n        let open_brackets_count\
    \ = open_brackets.length;\n        let closed_brackets_count = closed_brackets.length;\n\
    \        let open_brackets_index = open_bracket;\n        let closed_brackets_index\
    \ = closed_bracket;\n        while (open_brackets_count > 0) {\n            let\
    \ open_brackets_index = open_brackets[open_brackets_index - 1];\n            let\
    \ closed_brackets_index = closed_brackets[closed_brackets_index - 1];\n      \
    \      if (open_brackets_index === closed_brackets_index) {\n                open_brackets_count--;\n\
    \                closed_brackets_count--;\n            } else {\n            \
    \    break;\n            }\n        }\n        if (open_brackets_count === 0 &&\
    \ closed_brackets_count === 0) {\n            return true;\n        }\n    }\n\
    \    return false;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"\
    [[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"\
    [][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"\
    [][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"\
    []]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"\
    [[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\n\
    test();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpyo4q6u4h.ts(41,53): error TS2448: Block-scoped variable
    ''open_brackets_index'' used before its declaration.

    ../../../../../tmp/tmpyo4q6u4h.ts(42,57): error TS2448: Block-scoped variable
    ''closed_brackets_index'' used before its declaration.

    '
  timestamp: 1659738833
- exit_code: 2
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n    let brackets: number[]\
    \ = [];\n    let open_brackets: number[] = [];\n    let close_brackets: number[]\
    \ = [];\n    for (let i = 0; i < string.length; i++) {\n        let c = string[i];\n\
    \        if (c === \"[\") {\n            brackets.push(i);\n            open_brackets.push(i);\n\
    \        } else if (c === \"]\") {\n            close_brackets.push(i);\n    \
    \    } else if (c === \"[\") {\n            open_brackets.push(i);\n        }\
    \ else if (c === \"]\") {\n            brackets.push(i);\n        }\n    }\n \
    \   if (brackets.length === 0) {\n        return false;\n    }\n    for (let i\
    \ = 0; i < brackets.length; i++) {\n        let start = brackets[i];\n       \
    \ let end = close_brackets[i];\n        if (start === end) {\n            continue;\n\
    \        }\n        let open = open_brackets[i];\n        let close = close_brackets[i];\n\
    \        if (open === end) {\n            return false;\n        }\n        if\
    \ (open < end) {\n            let left_bracket = string.substring(open, start);\n\
    \            let right_bracket = string.substring(end, close);\n            if\
    \ (left_bracket.includes(\"[\")) {\n                return false;\n          \
    \  }\n            if (right_bracket.includes(\"[\")) {\n                return\
    \ false;\n            }\n        }\n    }\n    return true;\n}\n\ndeclare var\
    \ require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n\
    \  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n\
    \  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"\
    [][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"\
    [][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"\
    []]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"\
    [[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\n\
    test();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpjdoak_1b.ts(50,30): error TS2339: Property ''includes''
    does not exist on type ''string''.

    ../../../../../tmp/tmpjdoak_1b.ts(53,31): error TS2339: Property ''includes''
    does not exist on type ''string''.

    '
  timestamp: 1659738833
- exit_code: 1
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n    let stack: string[]\
    \ = [];\n    for (let i = 0; i < string.length; i++) {\n        if (string[i]\
    \ === \"[\") {\n            stack.push(string[i]);\n        } else if (string[i]\
    \ === \"]\") {\n            if (stack.length === 0) {\n                return\
    \ false;\n            }\n            stack.pop();\n        }\n    }\n    return\
    \ stack.length === 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"\
    [[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"\
    [][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"\
    [][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"\
    []]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"\
    [[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\n\
    test();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould\
    \ loosely deep-equal\n\nfalse\n    at test (/tmp/tmp6g01ux0_.js:36:12)\n    at\
    \ Object.<anonymous> (/tmp/tmp6g01ux0_.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected:\
    \ false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1659738833
- exit_code: 1
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n    let bracketCount =\
    \ 0;\n    let openingBracketCount = 0;\n    let closingBracketCount = 0;\n   \
    \ let openingBrackets: number[] = [];\n    let closingBrackets: number[] = [];\n\
    \    for (let i = 0; i < string.length; i++) {\n        const char = string[i];\n\
    \        if (char === '[') {\n            openingBracketCount++;\n           \
    \ openingBrackets.push(openingBracketCount);\n        } else if (char === ']')\
    \ {\n            closingBracketCount++;\n            closingBrackets.push(closingBracketCount);\n\
    \        } else if (char === '[' && openingBracketCount > closingBracketCount)\
    \ {\n            openingBracketCount--;\n            openingBrackets.push(openingBracketCount);\n\
    \        } else if (char === ']' && openingBracketCount < closingBracketCount)\
    \ {\n            closingBracketCount--;\n            closingBrackets.push(closingBracketCount);\n\
    \        }\n    }\n    for (let i = 0; i < openingBrackets.length; i++) {\n  \
    \      if (closingBrackets[i] === openingBrackets[i] - 1) {\n            return\
    \ true;\n        }\n    }\n    return false;\n}\n\ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"\
    []]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"\
    []\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"\
    []]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"\
    [[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"\
    [[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\
    \"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"\
    ]]]]]]]]\"),false);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould\
    \ loosely deep-equal\n\ntrue\n    at test (/tmp/tmp9u76bf67.js:51:12)\n    at\
    \ Object.<anonymous> (/tmp/tmp9u76bf67.js:66:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n \
    \ expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1659738833
- exit_code: 2
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[]\
    \ = [];\n\tlet opening_brackets: number[] = [];\n\tlet closing_brackets: number[]\
    \ = [];\n\tlet opening_square_brackets: number[] = [];\n\tlet closing_square_brackets:\
    \ number[] = [];\n\tlet opening_curly_brackets: number[] = [];\n\tlet closing_curly_brackets:\
    \ number[] = [];\n\tlet opening_angle_brackets: number[] = [];\n\tlet closing_angle_brackets:\
    \ number[] = [];\n\tlet opening_parenthesis: number[] = [];\n\tlet closing_parenthesis:\
    \ number[] = [];\n\tlet opening_square_parenthesis: number[] = [];\n\tlet closing_square_parenthesis:\
    \ number[] = [];\n\tlet opening_curly_parenthesis: number[] = [];\n\tlet closing_curly_parenthesis:\
    \ number[] = [];\n\tlet opening_angled_brackets: number[] = [];\n\tlet closing_angled_brackets:\
    \ number[] = [];\n\tlet opening_parenthesis_brackets: number[] = [];\n\tlet closing_parenthesis_brackets:\
    \ number[] = [];\n\tlet opening_square_parenthesis_brackets: number[] = [];\n\t\
    let closing_square_parenthesis_brackets: number[] = [];\n\tlet opening_curly_parenthesis_brackets:\
    \ number[] = [];\n\tlet closing_curly_parenthesis_brackets: number[] = [];\n\t\
    let opening_angled_brackets_brackets: number[] = [];\n\tlet closing_angled_brackets_brackets:\
    \ number[] = [];\n\tlet opening_parenthesis_brackets_brackets: number[] = [];\n\
    \tlet closing_parenthesis_brackets_brackets: number[] = [];\n\tlet opening_square_parenthesis_brackets_brackets:\
    \ number[] = [];\n\tlet closing_square_parenthesis_brackets_brackets: number[]\
    \ = [];\n\tlet opening_curly_parenthesis_brackets_brackets: number[] = [];\n\t\
    let closing_curly_parenthesis_brackets_brackets: number[] = [];\n\tlet opening_angled_brackets_brackets_brackets:\
    \ number[] = [];\n\tlet closing_angled_brackets_brackets_brackets: number[] =\
    \ [];\n\tlet opening_parenthesis_brackets_brackets_brackets: number[] = [];\n\t\
    let closing_parenthesis_brackets_brackets_brackets: number[] = [];\n\tlet opening_square_parenthesis_brackets_brackets_brackets:\
    \ number[] = [];\n\tlet closing_square_parenthesis_brackets_brackets_brackets:\
    \ number\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\
    \nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"\
    [[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"\
    [][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"\
    [][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"\
    []]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"\
    [[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\n\
    test();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp1cca5uq_.ts(76,8): error TS1005: ''}'' expected.

    '
  timestamp: 1659738833
- exit_code: 2
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number[]\
    \ = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_stack: number[]\
    \ = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_brackets_size:\
    \ number = 0;\n\tlet close_brackets_size: number = 0;\n\tlet open_brackets_index\
    \ = 0;\n\tlet close_brackets_index = 0;\n\tlet open_brackets_index_in_string =\
    \ 0;\n\tlet close_brackets_index_in_string = 0;\n\tlet open_brackets_index_in_string2\
    \ = 0;\n\tlet close_brackets_index_in_string2 = 0;\n\tlet open_brackets_index_in_string3\
    \ = 0;\n\tlet close_brackets_index_in_string3 = 0;\n\tlet open_brackets_index_in_string4\
    \ = 0;\n\tlet close_brackets_index_in_string4 = 0;\n\tlet open_brackets_index_in_string5\
    \ = 0;\n\tlet close_brackets_index_in_string5 = 0;\n\tlet open_brackets_index_in_string6\
    \ = 0;\n\tlet close_brackets_index_in_string6 = 0;\n\tlet open_brackets_index_in_string7\
    \ = 0;\n\tlet close_brackets_index_in_string7 = 0;\n\tlet open_brackets_index_in_string8\
    \ = 0;\n\tlet close_brackets_index_in_string8 = 0;\n\tlet open_brackets_index_in_string9\
    \ = 0;\n\tlet close_brackets_index_in_string9 = 0;\n\tlet open_brackets_index_in_string10\
    \ = 0;\n\tlet close_brackets_index_in_string10 = 0;\n\tlet open_brackets_index_in_string11\
    \ = 0;\n\tlet close_brackets_index_in_string11 = 0;\n\tlet open_brackets_index_in_string12\
    \ = 0;\n\tlet close_brackets_index_in_string12 = 0;\n\tlet open_brackets_index_in_string13\
    \ = 0;\n\tlet close_brackets_index_in_string13 = 0;\n\tlet open_brackets_index_in_string14\
    \ = 0;\n\tlet close_brackets_index_in_string14 = 0;\n\tlet open_brackets_index_in_string15\
    \ = 0;\n\tlet close_brackets_index_in_string15 = 0;\n\tlet open_brackets_index_in_string16\
    \ = 0;\n\tlet close_brackets_index_in_string16 = 0;\n\tlet open_brackets_index_in_string17\
    \ = 0;\n\tlet close\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"\
    [[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"\
    [][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"\
    [][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"\
    []]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"\
    [[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\n\
    test();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpc5ov9b8w.ts(81,8): error TS1005: ''}'' expected.

    '
  timestamp: 1659738833
- exit_code: 1
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n    if (string === \"\"\
    ) {\n        return false;\n    }\n    let brackets = 0;\n    for (let i = 0;\
    \ i < string.length; i++) {\n        if (string[i] === \"[\") {\n            brackets++;\n\
    \        }\n        if (string[i] === \"]\") {\n            brackets--;\n    \
    \    }\n    }\n    return brackets === 0;\n}\n\ndeclare var require: any;\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n\
    \  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"\
    []]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"\
    []\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"\
    []]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"\
    [[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"\
    [[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\
    \"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"\
    ]]]]]]]]\"),false);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould\
    \ loosely deep-equal\n\nfalse\n    at test (/tmp/tmpme7_03lj.js:36:12)\n    at\
    \ Object.<anonymous> (/tmp/tmpme7_03lj.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected:\
    \ false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1659738833
- exit_code: 2
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[]\
    \ = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] =\
    \ [];\n\tlet open_brackets_size: number[] = [];\n\tlet close_brackets_size: number[]\
    \ = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet open_brackets_position: number[] = [];\n\tlet close_brackets_position:\
    \ number[] = [];\n\tlet \ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"\
    [[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"\
    [][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"\
    [][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"\
    []]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"\
    [[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\n\
    test();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp154m2n1e.ts(61,9): error TS1005: '','' expected.

    ../../../../../tmp/tmp154m2n1e.ts(83,8): error TS1005: ''}'' expected.

    '
  timestamp: 1659738833
- exit_code: 2
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n\tlet brackets: number[]\
    \ = [];\n\tlet open_brackets: number[] = [];\n\tlet closed_brackets: number[]\
    \ = [];\n\tlet open_chars: number[] = [];\n\tlet close_chars: number[] = [];\n\
    \tlet open_char_index: number[] = [];\n\tlet close_char_index: number[] = [];\n\
    \tlet open_brackets_index: number[] = [];\n\tlet closed_brackets_index: number[]\
    \ = [];\n\tlet open_char_indexes: number[] = [];\n\tlet close_char_indexes: number[]\
    \ = [];\n\tlet open_brackets_indexes: number[] = [];\n\tlet closed_brackets_indexes:\
    \ number[] = [];\n\tlet open_char_indexes_count: number[] = [];\n\tlet close_char_indexes_count:\
    \ number[] = [];\n\tlet open_brackets_indexes_count: number[] = [];\n\tlet closed_brackets_indexes_count:\
    \ number[] = [];\n\tlet open_char_indexes_count: number[] = [];\n\tlet close_char_indexes_count:\
    \ number[] = [];\n\tlet open_brackets_indexes_count: number[] = [];\n\tlet closed_brackets_indexes_count:\
    \ number[] = [];\n\tlet open_char_indexes_count: number[] = [];\n\tlet close_char_indexes_count:\
    \ number[] = [];\n\tlet open_brackets_indexes_count: number[] = [];\n\tlet closed_brackets_indexes_count:\
    \ number[] = [];\n\tlet open_char_indexes_count: number[] = [];\n\tlet close_char_indexes_count:\
    \ number[] = [];\n\tlet open_brackets_indexes_count: number[] = [];\n\tlet closed_brackets_indexes_count:\
    \ number[] = [];\n\tlet open_char_indexes_count: number[] = [];\n\tlet close_char_indexes_count:\
    \ number[] = [];\n\tlet open_brackets_indexes_count: number[] = [];\n\tlet closed_brackets_indexes_count:\
    \ number[] = [];\n\tlet open_char_indexes_count: number[] = [];\n\tlet close_char_indexes_count:\
    \ number[] = [];\n\tlet open_brackets_indexes_count: number[] = [];\n\tlet closed_brackets_indexes_count:\
    \ number[] = [];\n\tlet open_char_indexes_count: number[] = [];\n\tlet close_char_indexes_count:\
    \ number[] = [];\n\tlet open_brackets_indexes_count: number[] = [];\n\tlet closed_brackets_indexes_count:\
    \ number[] = [];\n\tlet open_char_indexes_count: number[] = [];\n\tlet close_char_indexes_count:\
    \ number[] = [];\n\tlet open_brackets_indexes_count: \ndeclare var require: any;\n\
    const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"\
    []]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"\
    []\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"\
    []]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"\
    [[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"\
    [[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\
    \"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"\
    ]]]]]]]]\"),false);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpjzfuxv9k.ts(61,9): error TS1005: '','' expected.

    ../../../../../tmp/tmpjzfuxv9k.ts(83,8): error TS1005: ''}'' expected.

    '
  timestamp: 1659738833
- exit_code: 2
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number\
    \ = 0;\n\tlet close_brackets: number = 0;\n\tlet open_brackets_stack: string[]\
    \ = [];\n\tlet close_brackets_stack: string[] = [];\n\tlet open_brackets_length:\
    \ number = 0;\n\tlet close_brackets_length: number = 0;\n\tlet open_brackets_stack_index:\
    \ number = 0;\n\tlet close_brackets_stack_index: number = 0;\n\tlet open_brackets_length_index:\
    \ number = 0;\n\tlet close_brackets_length_index: number = 0;\n\tlet open_brackets_stack_string:\
    \ string = \"\";\n\tlet close_brackets_stack_string: string = \"\";\n\tlet open_brackets_length_string:\
    \ string = \"\";\n\tlet close_brackets_length_string: string = \"\";\n\tlet open_brackets_stack_string_index:\
    \ number = 0;\n\tlet close_brackets_stack_string_index: number = 0;\n\tlet open_brackets_length_string_index:\
    \ number = 0;\n\tlet close_brackets_length_string_index: number = 0;\n\tlet open_brackets_stack_indexed_string:\
    \ string = \"\";\n\tlet close_brackets_stack_indexed_string: string = \"\";\n\t\
    let open_brackets_length_indexed_string: string = \"\";\n\tlet close_brackets_length_indexed_string:\
    \ string = \"\";\n\tlet open_brackets_stack_indexed_string_index: number = 0;\n\
    \tlet close_brackets_stack_indexed_string_index: number = 0;\n\tlet open_brackets_length_indexed_string_index:\
    \ number = 0;\n\tlet close_brackets_length_indexed_string_index: number = 0;\n\
    \tlet open_brackets_stack_indexed_string_indexed_string: string = \"\";\n\tlet\
    \ close_brackets_stack_indexed_string_indexed_string: string = \"\";\n\tlet open_brackets_length_indexed_string_indexed_string:\
    \ string = \"\";\n\tlet close_brackets_length_indexed_string_indexed_string: string\
    \ = \"\";\n\tlet open_brackets_stack_indexed_string_indexed_string_index: number\
    \ = 0;\n\tlet close_brackets_stack_indexed_string_indexed_string_index: number\
    \ = 0;\n\tlet open_brackets_length_indexed_string_indexed_string_index: number\
    \ = 0;\n\tlet close_brackets_length_indexed_string_indexed_string_index: number\
    \ = 0;\n\tlet open_brackets_stack_indexed_string_indexed_string_indexed_string:\
    \ string = \"\";\n\tlet close_b\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"\
    [[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"\
    [][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"\
    [][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"\
    []]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"\
    [[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\n\
    test();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpnvwpzwny.ts(75,8): error TS1005: ''}'' expected.

    '
  timestamp: 1659738833
- exit_code: 2
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n\tlet stack: string[]\
    \ = [];\n\tlet open_brackets: number[] = [];\n\tlet close_brackets: number[] =\
    \ [];\n\tlet open_parens: number[] = [];\n\tlet close_parens: number[] = [];\n\
    \tlet bracket_count: string[] = [];\n\tlet paren_count: string[] = [];\n\tlet\
    \ bracket_stack: string[] = [];\n\tlet paren_stack: string[] = [];\n\tlet bracket_open:\
    \ string[] = [];\n\tlet paren_open: string[] = [];\n\tlet bracket_close: string[]\
    \ = [];\n\tlet paren_close: string[] = [];\n\tlet bracket_open_index: number[]\
    \ = [];\n\tlet paren_open_index: number[] = [];\n\tlet bracket_close_index: number[]\
    \ = [];\n\tlet paren_close_index: number[] = [];\n\tlet bracket_open_count: string[]\
    \ = [];\n\tlet paren_open_count: string[] = [];\n\tlet bracket_close_count: string[]\
    \ = [];\n\tlet paren_close_count: string[] = [];\n\tlet bracket_open_index: number[]\
    \ = [];\n\tlet paren_open_index: number[] = [];\n\tlet bracket_close_index: number[]\
    \ = [];\n\tlet paren_close_index: number[] = [];\n\tlet bracket_open_count: string[]\
    \ = [];\n\tlet paren_open_count: string[] = [];\n\tlet bracket_close_count: string[]\
    \ = [];\n\tlet paren_close_count: string[] = [];\n\tlet bracket_open_index: number[]\
    \ = [];\n\tlet paren_open_index: number[] = [];\n\tlet bracket_close_index: number[]\
    \ = [];\n\tlet paren_close_index: number[] = [];\n\tlet bracket_open_count: string[]\
    \ = [];\n\tlet paren_open_count: string[] = [];\n\tlet bracket_close_count: string[]\
    \ = [];\n\tlet paren_close_count: string[] = [];\n\tlet bracket_open_index: number[]\
    \ = [];\n\tlet paren_open_index: number[] = [];\n\tlet bracket_close_index: number[]\
    \ = [];\n\tlet paren_close_index: number[] = [];\n\tlet bracket_open_count: string[]\
    \ = [];\n\tlet paren_open_count: string[] = [];\n\tlet bracket_close_count: string[]\
    \ = [];\n\tlet paren_close_count: string[] = [];\n\tlet bracket_open_index: number[]\
    \ = [];\n\tlet paren_open_index: number[] = [];\n\tlet bracket_close_index: number[]\
    \ = [];\n\tlet paren\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"\
    [[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"\
    [][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"\
    [][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"\
    []]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"\
    [[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\n\
    test();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmp82rbndgx.ts(88,8): error TS1005: ''}'' expected.

    '
  timestamp: 1659738833
- exit_code: 1
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n    let brackets: string[]\
    \ = string.split(\"\");\n    let stack: string[] = [];\n    for (let i = 0; i\
    \ < brackets.length; i++) {\n        if (brackets[i] == \"[\" || brackets[i] ==\
    \ \"(\") {\n            stack.push(brackets[i]);\n        } else if (brackets[i]\
    \ == \"]\") {\n            if (stack.length == 0) {\n                return false;\n\
    \            }\n            stack.pop();\n        } else if (brackets[i] == \"\
    )\") {\n            if (stack.length == 0) {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if (stack.length\
    \ != 0) {\n                return false;\n            }\n        }\n    }\n  \
    \  return stack.length == 0;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"\
    [[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"\
    [][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"\
    [][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"\
    []]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"\
    [[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\n\
    test();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould\
    \ loosely deep-equal\n\nfalse\n    at test (/tmp/tmph1c9fbpr.js:48:12)\n    at\
    \ Object.<anonymous> (/tmp/tmph1c9fbpr.js:61:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected:\
    \ false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1659738833
- exit_code: 2
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n\tlet open_brackets: number[]\
    \ = [];\n\tlet close_brackets: number[] = [];\n\tlet open_brackets_stack: number[]\
    \ = [];\n\tlet close_brackets_stack: number[] = [];\n\tlet open_stack: number[]\
    \ = [];\n\tlet close_stack: number[] = [];\n\tlet open_stack_index: number = 0;\n\
    \tlet close_stack_index: number = 0;\n\tlet open_stack_string: string = \"\";\n\
    \tlet close_stack_string: string = \"\";\n\tlet open_stack_string_index: number\
    \ = 0;\n\tlet close_stack_string_index: number = 0;\n\tlet open_stack_string_len:\
    \ number = 0;\n\tlet close_stack_string_len: number = 0;\n\tlet open_stack_string_len_index:\
    \ number = 0;\n\tlet close_stack_string_len_index: number = 0;\n\tlet open_stack_string_len_len:\
    \ number = 0;\n\tlet close_stack_string_len_len: number = 0;\n\tlet open_stack_string_len_index:\
    \ number = 0;\n\tlet close_stack_string_len_index: number = 0;\n\tlet open_stack_string_len_len:\
    \ number = 0;\n\tlet close_stack_string_len_len: number = 0;\n\tlet open_stack_string_len_index:\
    \ number = 0;\n\tlet close_stack_string_len_index: number = 0;\n\tlet open_stack_string_len_len:\
    \ number = 0;\n\tlet close_stack_string_len_len: number = 0;\n\tlet open_stack_string_len_index:\
    \ number = 0;\n\tlet close_stack_string_len_index: number = 0;\n\tlet open_stack_string_len_len:\
    \ number = 0;\n\tlet close_stack_string_len_len: number = 0;\n\tlet open_stack_string_len_index:\
    \ number = 0;\n\tlet close_stack_string_len_index: number = 0;\n\tlet open_stack_string_len_len:\
    \ number = 0;\n\tlet close_stack_string_len_len: number = 0;\n\tlet open_stack_string_len_index:\
    \ number = 0;\n\tlet close_stack_string_len_index: number = 0;\n\tlet open_stack_string_len_len:\
    \ number = 0;\n\tlet close_stack_string_len_len: number = 0;\n\tlet open_stack_string_len_index:\
    \ number = 0;\n\tlet close_stack_string_len_index: number = 0;\n\tlet open_stack_string_len_len:\
    \ number = 0;\n\tlet close_stack_string_len_len: number = 0;\n\tlet open_stack_string_len_index:\
    \ number = 0;\n\tlet close_stack_string_len_index: number = 0;\n\tlet open_stack_string_len_len:\
    \ number = 0;\n\tlet close_stack_string_len: number = 0;\n\tlet open_stack_string_len_index:\
    \ number = 0;\n\tlet close_stack_string_len_index: number = 0;\ndeclare var require:\
    \ any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
    \ = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"\
    []]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"\
    []\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"\
    []]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"\
    [[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"\
    [[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\
    \"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"\
    ]]]]]]]]\"),false);\n}\n\ntest();"
  status: CompileError
  stderr: ''
  stdout: '../../../../../tmp/tmpyuq1_gb1.ts(87,8): error TS1005: ''}'' expected.

    '
  timestamp: 1659738833
- exit_code: 1
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n    if (string.length\
    \ <= 1) {\n        return false;\n    }\n    let opening_brackets: number[] =\
    \ [];\n    let closing_brackets: number[] = [];\n    for (let i = 0; i < string.length;\
    \ i++) {\n        if (string[i] === \"[\") {\n            opening_brackets.push(i);\n\
    \        } else if (string[i] === \"]\") {\n            closing_brackets.push(i);\n\
    \        }\n    }\n    if (opening_brackets.length < closing_brackets.length)\
    \ {\n        return false;\n    }\n    for (let i = 0; i < opening_brackets.length;\
    \ i++) {\n        let opening_bracket = opening_brackets[i];\n        let closing_bracket\
    \ = closing_brackets[i];\n        for (let j = opening_bracket; j < closing_bracket;\
    \ j++) {\n            if (string[j] === \"[\") {\n                if (is_nested(string[j\
    \ + 1])\n                    || is_nested(string[j + 2])) {\n                \
    \    return true;\n                }\n            } else if (string[j] === \"\
    ]\") {\n                if (is_nested(string[j + 1])\n                    || is_nested(string[j\
    \ + 2])) {\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    return false;\n}\n\ndeclare var require: any;\nconst assert\
    \ = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n\
    \  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"\
    []]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"\
    []\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"\
    []]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"\
    [[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"\
    [[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\
    \"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"\
    ]]]]]]]]\"),false);\n}\n\ntest();"
  status: Exception
  stderr: "/tmp/tmpntc0mf3l.js:17\n    if (string.length <= 1) {\n               ^\n\
    \nTypeError: Cannot read properties of undefined (reading 'length')\n    at is_nested\
    \ (/tmp/tmpntc0mf3l.js:17:16)\n    at is_nested (/tmp/tmpntc0mf3l.js:45:24)\n\
    \    at test (/tmp/tmpntc0mf3l.js:56:22)\n    at Object.<anonymous> (/tmp/tmpntc0mf3l.js:71:1)\n\
    \    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js\
    \ (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n\
    \    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\
    \nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1659738833
- exit_code: 1
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n    if (string.length\
    \ <= 1) {\n        return false;\n    }\n    let open_brackets = 0;\n    let closed_brackets\
    \ = 0;\n    for (let i = 0; i < string.length; i++) {\n        if (string[i] ===\
    \ \"[\") {\n            open_brackets++;\n        } else if (string[i] === \"\
    ]\") {\n            closed_brackets++;\n        }\n    }\n    return open_brackets\
    \ <= closed_brackets;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"\
    [[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"\
    [][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"\
    [][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"\
    []]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"\
    [[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\n\
    test();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\ntrue\n\nshould\
    \ loosely deep-equal\n\nfalse\n    at test (/tmp/tmphodds4jh.js:36:12)\n    at\
    \ Object.<anonymous> (/tmp/tmphodds4jh.js:50:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: true,\n  expected:\
    \ false,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1659738833
- exit_code: 1
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n    // Create a stack\
    \ to keep track of brackets\n    let stack: string[] = [];\n\n    // Iterate through\
    \ each character in the string\n    for (let i = 0; i < string.length; i++) {\n\
    \        // If the current character is a bracket then push it to the stack\n\
    \        if (string[i] === \"[\") {\n            stack.push(string[i]);\n    \
    \    }\n        // If the current character is a closing bracket then pop brackets\
    \ from the stack\n        else if (string[i] === \"]\") {\n            if (stack.length\
    \ === 0) {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n\n    // If there are any brackets left in the stack then there\
    \ must be a nested bracket\n    if (stack.length > 0) {\n        return true;\n\
    \    }\n\n    // Otherwise there must be a valid subsequence of brackets\n   \
    \ return false;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\
    \n\nfunction test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"\
    [[]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"\
    [][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"\
    [][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"\
    []]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"\
    [[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"\
    [[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\n\
    test();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould\
    \ loosely deep-equal\n\ntrue\n    at test (/tmp/tmp5ucr1d5q.js:43:12)\n    at\
    \ Object.<anonymous> (/tmp/tmp5ucr1d5q.js:58:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n \
    \ expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1659738833
- exit_code: 1
  program: "//Create a function that takes a string as input which contains only square\
    \ brackets.\n// The function should return True if and only if there is a valid\
    \ subsequence of brackets \n// where at least one bracket in the subsequence is\
    \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
    )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n\
    // false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n\
    // true\nfunction is_nested(string: string): boolean {\n    let brackets: string[]\
    \ = string.split(/\\[|\\]/);\n    let nestings: boolean[] = [];\n    for (let\
    \ i = 0; i < brackets.length; i++) {\n        let bracket: string = brackets[i];\n\
    \        let opening: boolean = bracket.search(/\\[/) >= 0;\n        let closing:\
    \ boolean = bracket.search(/\\]/) >= 0;\n        if (opening && closing) {\n \
    \           nestings.push(true);\n        } else if (opening) {\n            nestings.push(false);\n\
    \        } else if (closing) {\n            nestings.pop();\n        }\n    }\n\
    \    return nestings.indexOf(true) >= 0;\n}\n\ndeclare var require: any;\nconst\
    \ assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = is_nested;\n\
    \  assert.deepEqual(candidate(\"[[]]\"),true);\n  assert.deepEqual(candidate(\"\
    []]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"[][]\"),false);\n  assert.deepEqual(candidate(\"\
    []\"),false);\n  assert.deepEqual(candidate(\"[[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"\
    []]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"[][][[]]\"),true);\n  assert.deepEqual(candidate(\"\
    [[]\"),false);\n  assert.deepEqual(candidate(\"[]]\"),false);\n  assert.deepEqual(candidate(\"\
    [[]][[\"),true);\n  assert.deepEqual(candidate(\"[[][]]\"),true);\n  assert.deepEqual(candidate(\"\
    \"),false);\n  assert.deepEqual(candidate(\"[[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"\
    ]]]]]]]]\"),false);\n}\n\ntest();"
  status: AssertionError
  stderr: "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError\
    \ [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\nfalse\n\nshould\
    \ loosely deep-equal\n\ntrue\n    at test (/tmp/tmpidu3313j.js:38:12)\n    at\
    \ Object.<anonymous> (/tmp/tmpidu3313j.js:53:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n\
    \    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n  \
    \  at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load\
    \ (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint\
    \ [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\
    \ {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: false,\n \
    \ expected: true,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n"
  stdout: ''
  timestamp: 1659738833
