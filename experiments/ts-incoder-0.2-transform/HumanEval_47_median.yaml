name: HumanEval_47_median
language: ts
prompt: "//Return median of elements in the list l.\n// >>> median([3, 1, 2, 4, 5])\n\
  // 3\n// >>> median([-10, 4, 6, 1000, 10, 20])\n// 15.0\nfunction median(l: number[]):\
  \ number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = median;\n  assert.deepEqual(candidate([3, 1, 2, 4,\
  \ 5]),3);\n  assert.deepEqual(candidate([-10, 4, 6, 1000, 10, 20]),8.0);\n  assert.deepEqual(candidate([5]),5);\n\
  \  assert.deepEqual(candidate([6, 5]),5.5);\n  assert.deepEqual(candidate([8, 1,\
  \ 3, 9, 9, 2, 7]),7);\n}\n\ntest();"
completions: ["  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median\
    \ of an empty list\");\n  }\n  const sortedList = l.slice().sort((a, b) => a -\
    \ b);\n  const middle = Math.floor(sortedList.length / 2);\n  if (sortedList.length\
    \ % 2) {\n    return sortedList[middle];\n  }\n  const leftMedian = sortedList[middle\
    \ - 1];\n  const rightMedian = sortedList[middle];\n  return leftMedian + rightMedian\
    \ / 2;\n}\n", "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n\
    \  }\n  const middle = l.length / 2;\n  const left = l.slice(0, middle);\n  const\
    \ right = l.slice(middle);\n  return median(left) + median(right);\n}\n", "  if\
    \ (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
    \ list\");\n  }\n  const mid = l.length / 2;\n  if (mid === 0) {\n    return l[0];\n\
    \  }\n  if (mid === 1) {\n    return l[mid - 1];\n  }\n  const medianValue = median(l);\n\
    \  const leftMedian = median(l.slice(0, mid));\n  const rightMedian = median(l.slice(mid));\n\
    \  return medianValue + leftMedian + rightMedian;\n}\n", "  if (l.length === 0)\
    \ {\n    throw new Error(\"Cannot calculate median of an empty list\");\n  }\n\
    \  const middle = Math.floor(l.length / 2);\n  if (middle === 0) {\n    return\
    \ l[0];\n  }\n  if (middle === 1) {\n    return l[l.length - 1];\n  }\n  const\
    \ leftMedian = median(l.slice(0, middle));\n  const rightMedian = median(l.slice(middle\
    \ + 1));\n  return ((leftMedian + rightMedian) / 2);\n}\n", "  const n = l.length;\n\
    \  if (n < 1) {\n    throw new Error(\"List must contain at least one element\"\
    );\n  }\n  if (n === 1) {\n    return l[0];\n  }\n  const mid = Math.floor(n /\
    \ 2);\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
    \  return ((left + right) / 2) | 0;\n}\n", "  if (l.length <= 1) {\n    return\
    \ l[0];\n  }\n  const middle = l.length / 2;\n  const left = l.slice(0, middle);\n\
    \  const right = l.slice(middle);\n  return median(left) + median(right);\n}\n",
  "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const mid\
    \ = l.length / 2;\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
    \  return ((left > right) ? left : right);\n}\n", "  if (l.length === 0) {\n \
    \   return NaN;\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  const\
    \ len = sorted.length;\n  if (len % 2 === 0) {\n    return sorted[len / 2 - 1];\n\
    \  }\n  const middle = Math.floor(len / 2);\n  const median1 = sorted[middle];\n\
    \  const median2 = sorted[middle + 1];\n  return (median1 + median2) / 2.0;\n\
    }\n", "  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a,\
    \ b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return\
    \ sorted[len / 2 - 1];\n  }\n  const middle = Math.floor(len / 2);\n  const median1\
    \ = sorted[middle];\n  const median2 = sorted[middle + 1];\n  return (median1\
    \ + median2) / 2.0;\n}\n", "  if (l.length === 0) {\n    throw new Error(\"Cannot\
    \ compute median of an empty list\");\n  }\n  l.sort((a, b) => a - b);\n  const\
    \ mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return l[mid];\n  }\n\
    \  return (l[mid] + l[mid-1]) / 2;\n}\n", "  if (l.length === 0) {\n    return\
    \ NaN;\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n    return\
    \ l[mid];\n  }\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
    \  return ((left + right) / 2) | 0;\n}\n", "  if (l.length === 0) {\n    throw\
    \ new Error(\"Cannot calculate median of an empty list\");\n  }\n  const mid =\
    \ Math.floor(l.length / 2);\n  if (l.length % 2) {\n    return l[mid];\n  }\n\
    \  return median(l[mid], l[mid-1]);\n}\n", "  if (l.length % 2 === 0) {\n    return\
    \ l[Math.floor(l.length / 2)];\n  }\n  const mid = l.length / 2;\n  const left\
    \ = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n  return\
    \ left + Math.abs(right - left);\n}\n", "  if (l.length === 0) {\n    throw new\
    \ Error(\"Cannot calculate median of an empty list.\");\n  }\n  const n = l.length;\n\
    \  if (n === 1) {\n    return l[0];\n  }\n  const mid = Math.floor(n / 2);\n \
    \ const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
    \  return ((left + right) / 2) | 0;\n}\n", "  if (l.length === 0) {\n    throw\
    \ new Error(\"Cannot calculate median of an empty list\");\n  }\n  const mid =\
    \ l.length / 2;\n  if (mid % 1 !== 0) {\n    throw new Error(\"Cannot calculate\
    \ median of an even length list\");\n  }\n  if (l.length % 2 === 0) {\n    return\
    \ l[mid];\n  }\n  const medianOfLeftHalf = median(l.slice(0, mid));\n  const medianOfRightHalf\
    \ = median(l.slice(mid));\n  return medianOfLeftHalf + medianOfRightHalf;\n}\n",
  "  if (l.length === 0) {\n    throw new Error(\"Cannot calculate median of an empty\
    \ list\");\n  }\n  const n = l.length;\n  if (n === 1) {\n    return l[0];\n \
    \ }\n  const half = Math.floor(n / 2);\n  if (n % 2) {\n    return median(l[half])\
    \ < median(l[half - 1]) ? l[half] : l[half - 1];\n  }\n  return median(l[half])\
    \ < median(l[half - 1]) ? l[half] : l[half - 1];\n}\n", "  if (l.length === 0)\
    \ {\n    throw new Error(\"Cannot calculate median of an empty list\");\n  }\n\
    \  l.sort((a, b) => a - b);\n  const mid = l.length / 2;\n  if (l.length % 2 ===\
    \ 0) {\n    return l[mid];\n  }\n  return (l[mid] + l[mid-1]) / 2;\n}\n", "  if\
    \ (l.length === 0) {\n    throw new Error(\"Cannot compute median of an empty\
    \ list\");\n  }\n  const mid = l.length / 2;\n  if (l.length % 2 === 0) {\n  \
    \  return l[mid];\n  }\n  const leftMedian = median(l.slice(0, mid));\n  const\
    \ rightMedian = median(l.slice(mid));\n  return leftMedian + rightMedian / 2;\n\
    }\n", "  if (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n \
    \ const mid = l.length / 2;\n  const left = median(l.slice(0, mid));\n  const\
    \ right = median(l.slice(mid));\n  return Math.max(left, right);\n}\n", "  if\
    \ (l.length % 2 === 0) {\n    return l[(l.length / 2) - 1];\n  }\n  const mid\
    \ = l.length / 2;\n  const left = median(l.slice(0, mid));\n  const right = median(l.slice(mid));\n\
    \  return left + right;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
