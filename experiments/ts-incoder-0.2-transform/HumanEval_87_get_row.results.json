{
  "language": "ts",
  "name": "HumanEval_87_get_row",
  "results": [
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const rows = [row];\n  const columns = [lst[0]];\n  for (let i = 1; i < lst.length; i++) {\n    const column = lst[i];\n    for (let j = 0; j < column.length; j++) {\n      rows.push(column);\n      columns.push(column);\n    }\n  }\n  rows.sort((a, b) => a[0] - b[0]);\n  columns.sort((a, b) => b[1] - a[1]);\n  return rows.map(row => row.map(i => [i, columns[i - 1]]));\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp7_u0eohx.ts(32,3): error TS2322: Type '(number | number[])[][][]' is not assignable to type '[number, number][]'.\n  Type '(number | number[])[][]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n\n  const [rows, cols] = lst;\n  const [row, col] = get_row_col(rows, cols);\n  const [x, y] = get_row_col(row, col);\n\n  if (x === x) {\n    return [];\n  }\n\n  const [y1, y2] = get_row_col(row, col + 1);\n  const [x1, x2] = get_row_col(row, col - 1);\n\n  if (x === x1) {\n    return [\n      [x, y1],\n      [x, y2],\n    ];\n  }\n\n  if (x === x2) {\n    return [\n      [x, y1],\n      [y, y2],\n    ];\n  }\n\n  return [];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpcqbu35xn.ts(16,35): error TS2300: Duplicate identifier 'x'.\n../../../../tmp/tmpcqbu35xn.ts(22,22): error TS2304: Cannot find name 'get_row_col'.\n../../../../tmp/tmpcqbu35xn.ts(23,10): error TS2300: Duplicate identifier 'x'.\n../../../../tmp/tmpcqbu35xn.ts(23,18): error TS2304: Cannot find name 'get_row_col'.\n../../../../tmp/tmpcqbu35xn.ts(29,20): error TS2304: Cannot find name 'get_row_col'.\n../../../../tmp/tmpcqbu35xn.ts(30,20): error TS2304: Cannot find name 'get_row_col'.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [row, col] = lst[0].length;\n  const rows = [...Array(row)].map(() => []);\n  for (let i = 0; i < row; i++) {\n    rows[i].push(0);\n  }\n  for (let i = 0; i < lst.length; i++) {\n    const [row, col] = lst[i].length;\n    for (let j = 0; j < col; j++) {\n      if (lst[i][j] === x) {\n        rows[row].push([i, j]);\n      }\n    }\n  }\n  rows.sort((a, b) => a[0] - b[0]);\n  rows.sort((a, b) => b[1] - a[1]);\n  return rows;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpoym3tb7l.ts(20,9): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmpoym3tb7l.ts(26,11): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmpoym3tb7l.ts(35,3): error TS2322: Type 'any[][]' is not assignable to type '[number, number][]'.\n  Type 'any[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [row, col] = lst[0].length;\n  const rows = [...Array(row)].map(() => []);\n  for (let i = 0; i < row; i++) {\n    rows[i].push(0);\n  }\n  for (let i = 0; i < lst.length; i++) {\n    const [row, col] = lst[i].length;\n    for (let j = 0; j < col; j++) {\n      rows[row][col] = lst[i][j];\n    }\n  }\n  rows.sort((a, b) => a[0] - b[0]);\n  rows.sort((a, b) => b[1] - a[1]);\n  return rows.map(row => row.map(col => [col, row]));\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpr9dc9_e8.ts(20,9): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmpr9dc9_e8.ts(26,11): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmpr9dc9_e8.ts(33,3): error TS2322: Type 'any[][][]' is not assignable to type '[number, number][]'.\n  Type 'any[][]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [minRow, minCol] = rows.reduce(([minRow, minCol], row) => {\n    const [minRowVal, minColVal] = row.reduce(([minRowVal, minColVal], val) => {\n      if (val === x) {\n        return [minRowVal, minColVal];\n      }\n      if (val < minRowVal) {\n        return [val, val];\n      }\n      return [minRowVal, val];\n    }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n    return [Math.min(minRow, minRowVal), Math.min(minCol, minColVal)];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRow, maxCol] = rows.reduce(([maxRow, maxCol], row) => {\n    const [maxRowVal, maxColVal] = row.reduce(([maxRowVal, maxColVal], val) => {\n      if (val === x) {\n        return [maxRowVal, maxColVal];\n      }\n      if (val > maxRowVal) {\n        return [val, val];\n      }\n      return [maxRowVal, val];\n    }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n    return [Math.max(maxRow, maxRowVal), Math.max(maxCol, maxColVal)];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const rows: number[][] = [];\n  for (let row = minRow; row <= maxRow; row++) {\n    const rowCoords: number[] = [];\n    for (let col = minCol; col <= maxCol; col++) {\n      rowCoords.push([row, col]);\n    }\n    rows.push(rowCoords);\n  }\n  rows.sort((row1, row2) => row1[0] - row2[0]);\n  rows.sort((row1, row2) => row1[1] - row2[1]);\n  return rows;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpedsx0dvx.ts(20,10): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpedsx0dvx.ts(22,40): error TS2339: Property 'reduce' does not exist on type 'number'.\n../../../../tmp/tmpedsx0dvx.ts(34,40): error TS2339: Property 'reduce' does not exist on type 'number'.\n../../../../tmp/tmpedsx0dvx.ts(45,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpedsx0dvx.ts(49,22): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmpedsx0dvx.ts(51,15): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmpedsx0dvx.ts(55,3): error TS2322: Type 'number[]' is not assignable to type '[number, number][]'.\n  Type 'number' is not assignable to type '[number, number]'.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, columns] = lst;\n  const rowIndex = rows.findIndex((row) => row === x);\n  const columnIndex = columns.findIndex((column) => column === x);\n  if (rowIndex === -1) {\n    return [];\n  }\n  const [row, column] = [rowIndex, columnIndex];\n  const sortedRows = rows.sort((a, b) => a - b);\n  const sortedColumns = columns.sort((a, b) => b - a);\n  const coordinates = [\n    [row, sortedColumns[rowIndex]],\n    [row, sortedColumns[rowIndex + 1]],\n  ];\n  return coordinates.sort((a, b) => b[0] - a[0]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmppb6pv5vq.ts(33,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    if (row.includes(x)) {\n      result.push([i, row.indexOf(x)]);\n    }\n  }\n  result.sort((a, b) => {\n    if (a[1] < b[1]) return -1;\n    if (a[1] > b[1]) return 1;\n    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[0] < b[0]) return -1;\n    if (a[0] > b[0]) return 1;\n    return 0;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpg10p0gwz.ts(34,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n\n  const row = [x];\n  const columns = [lst[0].length - 1];\n  const coordinates = [row];\n\n  for (let i = 1; i < lst.length; i++) {\n    const column = lst[i].length - 1;\n    const coordinate = [row, column];\n\n    if (column > columns[columns.length - 1]) {\n      columns.push(column);\n      coordinates.push(coordinate);\n    }\n\n    row.push(lst[i][column]);\n  }\n\n  coordinates.sort((a, b) => a[0] - b[0]);\n  coordinates.sort((a, b) => b[1] - a[1]);\n\n  return coordinates;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp6m4lm3my.ts(31,24): error TS2345: Argument of type '(number | number[])[]' is not assignable to parameter of type 'number[]'.\n  Type 'number | number[]' is not assignable to type 'number'.\n    Type 'number[]' is not assignable to type 'number'.\n../../../../tmp/tmp6m4lm3my.ts(40,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [row, col] = lst[0];\n  const [row_sorted, col_sorted] = sort_2d(row, col);\n  const [row_sorted_reversed, col_sorted_reversed] = sort_2d(row_sorted, col_sorted);\n  const [row_sorted_reversed_reversed, col_sorted_reversed_reversed] = sort_2d(row_sorted_reversed, col_sorted_reversed);\n  const [row_sorted_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed] = sort_2d(row_sorted_reversed_reversed, col_sorted_reversed_reversed);\n  const [row_sorted_reversed_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed_reversed] = sort_2d(row_sorted_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed);\n  const [row_sorted_reversed_reversed_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed_reversed_reversed] = sort_2d(row_sorted_reversed_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed_reversed);\n  const [row_sorted_reversed_reversed_reversed_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed_reversed_reversed_reversed] = sort_2d(row_sorted_reversed_reversed_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed_reversed_reversed);\n  const [row_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed] = sort_2d(row_sorted_reversed_reversed_reversed_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed);\n  const [row_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed] = sort_2d(row_sorted_reversed_reversed_reversed_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed);\n  const [row_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed] = sort_2d(row_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed);\n  const [row_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed, col_sorted_reversed_reversed_reverse\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpgzg5lir1.ts(32,1): error TS1005: ',' expected.\n../../../../tmp/tmpgzg5lir1.ts(32,9): error TS1005: ',' expected.\n../../../../tmp/tmpgzg5lir1.ts(46,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [minRow, minCol] = rows.reduce(([minRow, minCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.min(row, minRow),\n      Math.min(col, minCol),\n    ];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRow, maxCol] = rows.reduce(([maxRow, maxCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.max(row, maxRow),\n      Math.max(col, maxCol),\n    ];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const [x, y] = x;\n  const [minRow, minCol] = rows.reduce(([minRow, minCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.min(row, minRow),\n      Math.min(col, minCol),\n    ];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRow, maxCol] = rows.reduce(([maxRow, maxCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.max(row, maxRow),\n      Math.max(col, maxCol),\n    ];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const [minX, minY] = minCol === x ? [minRow, x] : [x, minCol];\n  const [maxX, maxY] = maxCol === x ? [maxRow, x] : [x, maxCol];\n  const [minRow, minCol] = rows.reduce(([minRow, minCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.min(row, minRow),\n      Math.min(col, minCol),\n    ];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRow, maxCol] = rows.reduce(([maxRow, maxCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.max(row, maxRow),\n      Math.max(col, maxCol),\n    ];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const [minX, minY] = minCol === x ? [minRow, x] : [x, minCol];\n  const [maxX, maxY] = maxCol === x ? [maxRow, x] : [x, max\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpa4rvq9fa.ts(68,1): error TS1005: ',' expected.\n../../../../tmp/tmpa4rvq9fa.ts(68,9): error TS1005: ',' expected.\n../../../../tmp/tmpa4rvq9fa.ts(82,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n\n  const row = [x];\n  const columns = [lst[0].length - 1];\n\n  for (let i = 1; i < lst.length; i++) {\n    const curr = lst[i];\n    const [row, column] = [row, curr[row - 1] + columns];\n    columns.push(curr[column]);\n  }\n\n  row.sort((a, b) => a - b);\n  columns.sort((a, b) => b - a);\n\n  return row.map((r) => [r, columns[r - 1]]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpg90ahuv5.ts(26,28): error TS2448: Block-scoped variable 'row' used before its declaration.\n../../../../tmp/tmpg90ahuv5.ts(26,33): error TS2365: Operator '+' cannot be applied to types 'number' and 'number[]'.\n../../../../tmp/tmpg90ahuv5.ts(26,38): error TS2448: Block-scoped variable 'row' used before its declaration.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [row, col] = get_row_and_col(rows, cols, x);\n  return [\n    ...row.map(([x, y]) => [x, y + 1]),\n    ...col.map(([x, y]) => [x + 1, y])\n  ];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp_y28xmx9.ts(21,22): error TS2304: Cannot find name 'get_row_and_col'.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const coords: number[][] = [];\n  for (let row = 0; row < rows; row++) {\n    const row_coords: number[] = [];\n    for (let col = 0; col < cols; col++) {\n      if (lst[row][col] === x) {\n        row_coords.push([row, col]);\n      }\n    }\n    coords.push(row_coords);\n  }\n  coords.sort((a, b) => a[0] - b[0]);\n  coords.sort((a, b) => b[1] - a[1]);\n  return coords;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpjx4bosdy.ts(27,25): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmpjx4bosdy.ts(34,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const rowMap = new Map<number, number>();\n  const colMap = new Map<number, number>();\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowKey = rowMap.get(row) || 0;\n    rowMap.set(row, rowKey + 1);\n    for (let j = 0; j < cols; j++) {\n      const col = lst[i][j];\n      const colKey = colMap.get(col) || 0;\n      colMap.set(col, colKey + 1);\n      if (col === x) {\n        result.push([rowKey + 1, colKey + 1]);\n      }\n    }\n  }\n  return result.sort((a, b) => b[0] - a[0]).sort((a, b) => b[1] - a[1]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpeqzksfqp.ts(24,31): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmpeqzksfqp.ts(25,16): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmpeqzksfqp.ts(35,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const result = [row];\n  for (let i = 0; i < lst.length; i++) {\n    const lstRow = lst[i];\n    const lstRowLen = lstRow.length;\n    for (let j = 0; j < lstRowLen; j++) {\n      if (lstRow[j] === x) {\n        result.push([i, j]);\n      }\n    }\n  }\n  result.sort((a, b) => {\n    if (a[0] > b[0]) {\n      return 1;\n    }\n    if (a[0] < b[0]) {\n      return -1;\n    }\n    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[1] > b[1]) {\n      return 1;\n    }\n    if (a[1] < b[1]) {\n      return -1;\n    }\n    return 0;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpll3gyexe.ts(49,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    if (row.indexOf(x) !== -1) {\n      result.push([i, row.indexOf(x)]);\n    }\n  }\n  result.sort((a, b) => a[1] - b[1]);\n  result.sort((a, b) => b[0] - a[0]);\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp6c7twgul.ts(26,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const rows = [row];\n  const columns = [lst[0]];\n  for (let i = 1; i < lst.length; i++) {\n    const column = lst[i];\n    for (let j = 0; j < column.length; j++) {\n      row.push(column[j]);\n      columns.push(column);\n    }\n    rows.push(row);\n    row = [column];\n  }\n  rows.sort((a, b) => a[0] - b[0]);\n  columns.sort((a, b) => b.length - a[0]);\n  return rows.map(row => row.map(col => [col, col.length]));\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmplj0oyaa0.ts(30,5): error TS2588: Cannot assign to 'row' because it is a constant.\n../../../../tmp/tmplj0oyaa0.ts(34,3): error TS2322: Type 'any[][][]' is not assignable to type '[number, number][]'.\n  Type 'any[][]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n../../../../tmp/tmplj0oyaa0.ts(34,51): error TS2339: Property 'length' does not exist on type 'number'.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [row, col] = lst[0];\n  const rowLen = row.length;\n  const colLen = col.length;\n  const result = [];\n  for (let i = 0; i < rowLen; i++) {\n    const rowItem = row[i];\n    const colItem = col[i];\n    if (rowItem === x) {\n      result.push([i, colItem]);\n    }\n  }\n  return result.sort((a, b) => b[1] - a[1]).sort((a, b) => b[0] - a[0]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp1km3ulbo.ts(21,22): error TS2339: Property 'length' does not exist on type 'number'.\n../../../../tmp/tmp1km3ulbo.ts(22,22): error TS2339: Property 'length' does not exist on type 'number'.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const columns = [lst[0]];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i].indexOf(row[0]) === -1) {\n      row.push(lst[i][0]);\n      columns.push(lst[i]);\n    }\n  }\n  columns.sort((a, b) => b[0] - a[0]);\n  columns.sort((a, b) => b.length - a[1]);\n  return columns.map(col => [row, col]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5a0ll31f.ts(30,3): error TS2322: Type '[number[], number[]][]' is not assignable to type '[number, number][]'.\n  Type '[number[], number[]]' is not assignable to type '[number, number]'.\n    Type at position 0 in source is not compatible with type at position 0 in target.\n      Type 'number[]' is not assignable to type 'number'.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < cols; j++) {\n      const element = row[j];\n      if (element === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    if (a[0] < b[0]) {\n      return -1;\n    }\n    if (a[0] > b[0]) {\n      return 1;\n    }\n    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[1] < b[1]) {\n      return -1;\n    }\n    if (a[1] > b[1]) {\n      return 1;\n    }\n    return 0;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    [\n      0,\n      0\n    ]\n  ],\n  [\n    [\n      1,\n      0\n    ],\n    [\n      1,\n      4\n    ]\n  ],\n  [\n    [\n      2,\n      0\n    ],\n    [\n      2,\n      5\n    ]\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmpk15jjmxa.js:54:12)\n    at Object.<anonymous> (/tmp/tmpk15jjmxa.js:61:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ [ 0, 0 ] ], [ [ 1",
      "stdout": "",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const row: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row1 = lst[i];\n    const row2 = row1.slice();\n    row2.sort((a, b) => b - a);\n    row2.sort((a, b) => b - a);\n    for (let j = 0; j < row2.length; j++) {\n      if (row2[j] === x) {\n        row.push([i, j]);\n      }\n    }\n  }\n  return row;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpiack427y.ts(29,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const row = rows.findIndex(row => row === x);\n  const colIndex = cols.findIndex(col => col === x);\n  if (row === -1) {\n    return [];\n  }\n  const rowCoords = rows.map(row => [row, cols.indexOf(col)]);\n  const colCoords = cols.map(col => [row, cols.indexOf(col)]);\n  const sortedRowCoords = rowCoords.sort((a, b) => a[0] - b[0]);\n  const sortedColCoords = colCoords.sort((a, b) => a[1] - b[1]);\n  return sortedRowCoords.concat(sortedColCoords);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp0xawqujb.ts(26,56): error TS2552: Cannot find name 'col'. Did you mean 'cols'?\n../../../../tmp/tmp0xawqujb.ts(30,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [row, col] = get_row_and_col(rows, cols, x);\n  return [\n    [0, row],\n    [col, cols - 1],\n  ].sort((a, b) => a[0] - b[0]).sort((a, b) => a[1] - b[1]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpvun611qv.ts(21,22): error TS2304: Cannot find name 'get_row_and_col'.\n../../../../tmp/tmpvun611qv.ts(22,3): error TS2322: Type 'any[][]' is not assignable to type '[number, number][]'.\n  Type 'any[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n../../../../tmp/tmpvun611qv.ts(24,11): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows: number[][] = [];\n  const columns: number[] = [];\n  const row: number[] = [];\n  let row_index = 0;\n  let column_index = 0;\n  let row_indexes: number[] = [];\n  let column_indexes: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].indexOf(x) !== -1) {\n      row_indexes.push(row_index);\n      column_indexes.push(column_index);\n      row.push(lst[i][lst[i].indexOf(x)]);\n      row_index++;\n      column_index++;\n    } else {\n      row_indexes.push(row_index);\n      column_indexes.push(column_index);\n      row.push(0);\n      row_index++;\n      column_index++;\n    }\n  }\n  row_indexes.sort((a, b) => a - b);\n  column_indexes.sort((a, b) => b - a);\n  for (let i = 0; i < row_indexes.length; i++) {\n    rows.push(row.slice());\n    for (let j = 0; j < column_indexes.length; j++) {\n      rows[i][j] = rows[i][j] + (row_indexes[i] - row_indexes[j]) * column_indexes[j];\n    }\n  }\n  return rows;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp_0f1ru18.ts(47,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334486
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const rows = [row];\n  const columns = [lst[0]];\n  for (let i = 1; i < lst.length; i++) {\n    const column = lst[i];\n    const columnIndex = columns.indexOf(column);\n    if (columnIndex === -1) {\n      columns.push(column);\n      rows.push(column);\n    } else {\n      rows[columnIndex].push(column);\n    }\n  }\n  rows.sort((a, b) => a[0] - b[0]);\n  columns.sort((a, b) => b[1] - a[1]);\n  return rows.map(row => row.map(column => [column, columns[columns.indexOf(column) - 1]]));\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp0dvmkyte.ts(30,30): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmp0dvmkyte.ts(35,3): error TS2322: Type '(number | number[])[][][]' is not assignable to type '[number, number][]'.\n  Type '(number | number[])[][]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n../../../../tmp/tmp0dvmkyte.ts(35,77): error TS2345: Argument of type 'number' is not assignable to parameter of type 'number[]'.\n",
      "timestamp": 1660334486
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [minRow, minCol] = rows.reduce(([minRow, minCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.min(minRow, row),\n      Math.min(minCol, col),\n    ];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRow, maxCol] = rows.reduce(([maxRow, maxCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.max(maxRow, row),\n      Math.max(maxCol, col),\n    ];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const [minRowInd, minColInd] = rows.reduce(([minRowInd, minColInd], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.min(minRowInd, i),\n      Math.min(minColInd, col),\n    ];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRowInd, maxColInd] = rows.reduce(([maxRowInd, maxColInd], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.max(maxRowInd, i),\n      Math.max(maxColInd, col),\n    ];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const rowInd = minRowInd + (maxRowInd - minRowInd) * (x - minColInd) / (maxColInd - minColInd);\n  const colInd = minColInd + (maxColInd - minColInd) * (x - minRowInd) / (maxRowInd - minRowInd);\n  return rows.reduce(([x, y], row, i) => {\n    const [row, col] = row;\n    return [\n      x + rowInd,\n      y + colInd,\n    ];\n  }, [0, 0]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp0v0628zt.ts(21,59): error TS2300: Duplicate identifier 'row'.\n../../../../tmp/tmp0v0628zt.ts(22,11): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmp0v0628zt.ts(22,12): error TS2300: Duplicate identifier 'row'.\n../../../../tmp/tmp0v0628zt.ts(28,59): error TS2300: Duplicate identifier 'row'.\n../../../../tmp/tmp0v0628zt.ts(29,11): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmp0v0628zt.ts(29,12): error TS2300: Duplicate identifier 'row'.\n../../../../tmp/tmp0v0628zt.ts(35,71): error TS2300: Duplicate identifier 'row'.\n../../../../tmp/tmp0v0628zt.ts(36,11): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmp0v0628zt.ts(36,12): error TS2300: Duplicate identifier 'row'.\n../../../../tmp/tmp0v0628zt.ts(42,71): error TS2300: Duplicate identifier 'row'.\n../../../../tmp/tmp0v0628zt.ts(43,11): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmp0v0628zt.ts(43,12): error TS2300: Duplicate identifier 'row'.\n../../../../tmp/tmp0v0628zt.ts(51,3): error TS2322: Type 'number[]' is not assignable to type '[number, number][]'.\n  Type 'number' is not assignable to type '[number, number]'.\n../../../../tmp/tmp0v0628zt.ts(51,31): error TS2300: Duplicate identifier 'row'.\n../../../../tmp/tmp0v0628zt.ts(52,11): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmp0v0628zt.ts(52,12): error TS2300: Duplicate identifier 'row'.\n",
      "timestamp": 1660334486
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, columns] = lst;\n  const rowIndex = rows.findIndex(row => row === x);\n  if (rowIndex === -1) {\n    return [];\n  }\n  const columnIndex = columns.findIndex(column => column === x);\n  if (columnIndex === -1) {\n    return [];\n  }\n  const coordinates = [rowIndex, columnIndex];\n  coordinates.sort((a, b) => b - a);\n  coordinates.sort((a, b) => b - a);\n  return coordinates.map(coordinate => [coordinate, lst[coordinate]]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpoqqv94dd.ts(32,3): error TS2322: Type '[number, number[]][]' is not assignable to type '[number, number][]'.\n  Type '[number, number[]]' is not assignable to type '[number, number]'.\n    Type at position 1 in source is not compatible with type at position 1 in target.\n      Type 'number[]' is not assignable to type 'number'.\n",
      "timestamp": 1660334486
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [row, col] = get_row_and_col(rows, cols);\n  const [x, y] = get_row_and_col(row, col);\n  if (x === x) {\n    return [\n      [row, col],\n      [x + 1, y],\n      [x + 1, y + 1],\n      [x, y + 1],\n      [x, y + 2],\n      [x + 1, y + 2],\n      [x + 2, y],\n      [x + 2, y + 1],\n      [x + 2, y + 2],\n      [x, y + 2],\n    ];\n  }\n  return [];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpctiezw15.ts(16,35): error TS2300: Duplicate identifier 'x'.\n../../../../tmp/tmpctiezw15.ts(21,22): error TS2304: Cannot find name 'get_row_and_col'.\n../../../../tmp/tmpctiezw15.ts(22,10): error TS2300: Duplicate identifier 'x'.\n../../../../tmp/tmpctiezw15.ts(22,18): error TS2304: Cannot find name 'get_row_and_col'.\n",
      "timestamp": 1660334486
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const columns = [lst[0].length - 1];\n  for (let i = 1; i < lst.length; i++) {\n    const [y, c] = lst[i];\n    if (y === row[0]) {\n      row.push(c);\n      columns.push(y);\n    } else {\n      row.push(y);\n      columns.push(c);\n    }\n  }\n  row.sort((a, b) => a - b);\n  columns.sort((a, b) => b - a);\n  return [row, columns];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpvav1vg92.ts(34,11): error TS2322: Type 'number[]' is not assignable to type '[number, number]'.\n  Target requires 2 element(s) but source may have fewer.\n../../../../tmp/tmpvav1vg92.ts(34,16): error TS2322: Type 'number[]' is not assignable to type '[number, number]'.\n",
      "timestamp": 1660334486
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const result = [row];\n  for (let i = 0; i < lst.length; i++) {\n    const lstRow = lst[i];\n    for (let j = 0; j < lstRow.length; j++) {\n      if (lstRow[j] === x) {\n        result.push([i, j]);\n      }\n    }\n  }\n  return result.sort((a, b) => a[0] - b[0]).sort((a, b) => b[1] - a[1]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpl_cmuk0v.ts(30,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334487
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const columns = [lst[0]];\n  for (let i = 1; i < lst.length; i++) {\n    const column = lst[i];\n    for (let j = 0; j < column.length; j++) {\n      if (column[j] === x) {\n        row.push(j);\n        columns.unshift(column);\n        break;\n      }\n    }\n  }\n  row.sort((a, b) => a - b);\n  columns.sort((a, b) => b - a);\n  return [row, columns];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp99xuh4_0.ts(33,26): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmp99xuh4_0.ts(33,30): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmp99xuh4_0.ts(34,11): error TS2322: Type 'number[]' is not assignable to type '[number, number]'.\n  Target requires 2 element(s) but source may have fewer.\n../../../../tmp/tmp99xuh4_0.ts(34,16): error TS2322: Type 'number[][]' is not assignable to type '[number, number]'.\n  Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334486
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    const rowLength = row.length;\n    if (rowLength > x) {\n      result.push(row.slice(0, x));\n    } else {\n      result.push(row);\n    }\n  }\n  result.sort((a, b) => {\n    if (a[0] < b[0]) return -1;\n    if (a[0] > b[0]) return 1;\n    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[1] < b[1]) return -1;\n    if (a[1] > b[1]) return 1;\n    return 0;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpz8ebdc51.ts(37,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334487
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    if (row.includes(x)) {\n      rows.push([i, row.indexOf(x)]);\n    }\n  }\n  rows.sort((a, b) => {\n    if (a[1] < b[1]) return -1;\n    if (a[1] > b[1]) return 1;\n    return 0;\n  });\n  const result: number[][] = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    const rowResult = get_row(row.slice(0, row.indexOf(row[1])), row[1]);\n    for (let j = 0; j < rowResult.length; j++) {\n      result.push([row[0], rowResult[j]]);\n    }\n  }\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpth876ks8.ts(32,31): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number[][]'.\n  Type 'number' is not assignable to type 'number[]'.\n../../../../tmp/tmpth876ks8.ts(34,28): error TS2322: Type '[number, number]' is not assignable to type 'number'.\n../../../../tmp/tmpth876ks8.ts(37,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334487
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const coords: number[][] = [];\n  for (let row = 0; row < rows; row++) {\n    const row_coords: number[] = [];\n    for (let col = 0; col < cols; col++) {\n      if (lst[row][col] === x) {\n        row_coords.push([row, col]);\n      }\n    }\n    coords.push(row_coords);\n  }\n  coords.sort((a, b) => a[0] - b[0]);\n  coords.sort((a, b) => b[1] - a[1]);\n  return coords;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpjx4bosdy.ts(27,25): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmpjx4bosdy.ts(34,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, columns] = lst;\n  const [row, col] = get_row_and_col(rows, x);\n  return [\n    [row, col],\n    ...get_row(rows.slice(0, row), x),\n    ...get_row(rows.slice(row), x),\n  ];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpkeorsbi2.ts(21,22): error TS2304: Cannot find name 'get_row_and_col'.\n../../../../tmp/tmpkeorsbi2.ts(24,16): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number[][]'.\n  Type 'number' is not assignable to type 'number[]'.\n../../../../tmp/tmpkeorsbi2.ts(25,16): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number[][]'.\n",
      "timestamp": 1660334486
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [row, col] = get_row_and_col(rows, cols, x);\n  return [\n    [0, 0],\n    [row, col],\n  ];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmptzfxmqy0.ts(21,22): error TS2304: Cannot find name 'get_row_and_col'.\n",
      "timestamp": 1660334486
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const coords: number[][] = [];\n  for (let i = 0; i < rows; i++) {\n    coords[i] = [];\n    for (let j = 0; j < cols; j++) {\n      coords[i][j] = lst[i][j];\n    }\n  }\n  coords.sort((a, b) => {\n    if (a[0] < b[0]) {\n      return -1;\n    }\n    if (a[0] > b[0]) {\n      return 1;\n    }\n    return 0;\n  });\n  const rowCoords = coords.map(coord => coord[0]);\n  coords.sort((a, b) => {\n    if (a[1] < b[1]) {\n      return -1;\n    }\n    if (a[1] > b[1]) {\n      return 1;\n    }\n    return 0;\n  });\n  const colCoords = coords.map(coord => coord[1]);\n  const result: number[][] = [];\n  for (let i = 0; i < rowCoords.length; i++) {\n    const row = [rowCoords[i], colCoords[i]];\n    result.push(row);\n  }\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp7rmmqkam.ts(54,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334486
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [minRow, minCol] = rows.reduce(([minRow, minCol], row) => {\n    const [minRowVal, minColVal] = row.reduce(([minRowVal, minColVal], item) => {\n      if (item < minRowVal) {\n        return [item, item];\n      } else if (item > minRowVal) {\n        return [minRowVal, item];\n      }\n      return [minRowVal, minColVal];\n    }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n    return [Math.min(minRow, minRowVal), Math.min(minCol, minColVal)];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const maxRow = rows.length - 1;\n  const maxCol = cols.length - 1;\n  const [maxRowVal, maxColVal] = rows[maxRow].reduce(([maxRowVal, maxColVal], item) => {\n    if (item < maxRowVal) {\n      return [item, item];\n    } else if (item > maxRowVal) {\n      return [maxRowVal, item];\n    }\n    return [maxRowVal, maxColVal];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const [minRowVal, minColVal] = cols.reduce(([minRowVal, minColVal], item) => {\n    if (item < minColVal) {\n      return [item, item];\n    } else if (item > minColVal) {\n      return [minColVal, item];\n    }\n    return [minColVal, minRowVal];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  if (minRowVal === maxRowVal && minColVal === maxColVal) {\n    return [];\n  }\n  if (minRowVal === minColVal) {\n    return [[minRow, minCol]];\n  }\n  if (minRowVal === maxRowVal) {\n    return [[minRow, maxCol]];\n  }\n  if (minColVal === maxColVal) {\n    return [[minRow, minCol], [maxRow, minCol]];\n  }\n  return [[minRow, minCol], [maxRow, minCol], [maxRow, maxCol]];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpsu4cjsvt.ts(22,40): error TS2339: Property 'reduce' does not exist on type 'number'.\n../../../../tmp/tmpsu4cjsvt.ts(34,47): error TS2339: Property 'reduce' does not exist on type 'number'.\n",
      "timestamp": 1660334487
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.map(row => row.filter(x => x === x));\n  const sortedRows = rows.sort((a, b) => b[1] - a[1]);\n  const sortedRowsReverse = sortedRows.reverse();\n  const sortedRowsReverseRows = sortedRowsReverse.map(row => row.map(col => col[0]));\n  const sortedRowsReverseColumns = sortedRowsReverse.map(row => row.map(col => col[1]));\n  const sortedRowsReverseRowsColumns = sortedRowsReverseRows.map(row => row.map(col => col));\n  const sortedRowsReverseRowsColumnsReverse = sortedRowsReverseRowsColumns.map(row => row.reverse());\n  const sortedRowsReverseRowsColumnsReverseRows = sortedRowsReverseRowsColumnsReverse.map(row => row.map(col => col[0]));\n  const sortedRowsReverseRowsColumnsReverseRowsColumns = sortedRowsReverseRowsColumnsReverse.map(row => row.map(col => col[1]));\n  const sortedRowsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverseRowsColumnsReverse\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp2p0c3mkl.ts(41,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334486
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const row: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    if (row.indexOf(x) !== -1) {\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => b - a);\n      row.sort((a, b) => b - a);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => a - \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5p_ocyqa.ts(75,9): error TS1005: ',' expected.\n../../../../tmp/tmp5p_ocyqa.ts(89,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334487
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n\n  const row = [x];\n  const columns = [lst[0].length - 1];\n\n  for (let i = 1; i < lst.length; i++) {\n    const curr = lst[i];\n    const [row, column] = [row, curr[row - 1]];\n    columns.push(curr[column - 1]);\n  }\n\n  columns.sort((a, b) => b - a);\n  row.sort((a, b) => b - a);\n\n  return row.map((r) => [r, columns.indexOf(r)]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp6kgwnkhd.ts(26,28): error TS2448: Block-scoped variable 'row' used before its declaration.\n../../../../tmp/tmp6kgwnkhd.ts(26,38): error TS2448: Block-scoped variable 'row' used before its declaration.\n",
      "timestamp": 1660334486
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.map(row => row.filter((_, i) => i === x));\n  const rows = rows.reduce((acc, row) => acc.concat(row), []);\n  const rows = rows.sort((a, b) => a[0] - b[0]);\n  const cols = rows.map(row => row.slice(1).sort((a, b) => b[0] - a[0]));\n  return rows.map(row => row.map(col => col[0]));\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmppwg7q2l0.ts(17,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmppwg7q2l0.ts(18,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmppwg7q2l0.ts(19,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmppwg7q2l0.ts(21,3): error TS2322: Type 'any[][]' is not assignable to type '[number, number][]'.\n  Type 'any[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334487
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  const rows = lst.length;\n  const cols = lst[0].length;\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < cols; j++) {\n      if (row[j] === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    if (a[0] > b[0]) {\n      return 1;\n    }\n    if (a[0] < b[0]) {\n      return -1;\n    }\n    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[1] > b[1]) {\n      return 1;\n    }\n    if (a[1] < b[1]) {\n      return -1;\n    }\n    return 0;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpy0j20wx6.ts(48,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334487
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [row, col] = lst[0].length;\n  const rows = [...new Array(row)].map(() => []);\n  for (let i = 0; i < row; i++) {\n    rows[i].push(0);\n  }\n  for (let i = 0; i < lst.length; i++) {\n    const [row, col] = lst[i].length;\n    for (let j = 0; j < col; j++) {\n      if (lst[i][j] === x) {\n        rows[row].push([i, j]);\n      }\n    }\n  }\n  rows.sort((a, b) => a[0] - b[0]);\n  rows.sort((a, b) => b[1] - a[1]);\n  return rows;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp0h94985b.ts(20,9): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmp0h94985b.ts(26,11): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmp0h94985b.ts(35,3): error TS2322: Type 'any[][]' is not assignable to type '[number, number][]'.\n  Type 'any[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334486
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [row, col] = lst[0].length;\n  const rows = [...Array(row)].map(() => []);\n  for (let i = 0; i < row; i++) {\n    const row1 = lst[0].slice(i, i + 1);\n    const row2 = lst[1].slice(i, i + 1);\n    const row3 = lst[2].slice(i, i + 1);\n    rows[i].push([row1[x], row2[x - row1[x]]]);\n    rows[i].push([row3[x - row1[x]], row2[x - row1[x - row1[x]]]]);\n  }\n  rows[0].sort((a, b) => a[0] - b[0]);\n  rows[1].sort((a, b) => b[1] - a[1]);\n  rows[2].sort((a, b) => b[0] - a[0]);\n  return rows;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpuhpi1uvw.ts(20,9): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmpuhpi1uvw.ts(32,3): error TS2322: Type 'any[][]' is not assignable to type '[number, number][]'.\n  Type 'any[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334487
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  const rows = lst.length;\n  const cols = lst[0].length;\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const row_x = row[x];\n    const row_y = row[x - 1];\n    if (row_x === row_y) {\n      result.push([i, x]);\n    } else {\n      result.push([i, x - 1]);\n    }\n  }\n  result.sort((a, b) => {\n    const a_x = a[a[0]];\n    const b_x = b[b[0]];\n    if (a_x < b_x) {\n      return -1;\n    }\n    if (a_x > b_x) {\n      return 1;\n    }\n    return 0;\n  });\n  result.sort((a, b) => {\n    const a_y = a[a[1]];\n    const b_y = b[b[1]];\n    if (a_y < b_y) {\n      return -1;\n    }\n    if (a_y > b_y) {\n      return 1;\n    }\n    return 0;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpcc568gci.ts(52,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334487
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows: number[][] = [];\n  const cols: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    rows.push(lst[i]);\n    cols.push(lst[i].slice());\n  }\n  rows.sort((a, b) => a[0] - b[0]);\n  cols.sort((a, b) => b[1] - a[1]);\n  const result: number[][] = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    const col = cols[i];\n    for (let j = 0; j < col.length; j++) {\n      if (col[j] === x) {\n        result.push([i, j]);\n      }\n    }\n  }\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpu36galzy.ts(21,15): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmpu36galzy.ts(29,29): error TS2339: Property 'length' does not exist on type 'number'.\n../../../../tmp/tmpu36galzy.ts(35,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334487
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const columns = [lst[0].length - 1];\n  for (let i = 1; i < lst.length; i++) {\n    const curr = lst[i];\n    for (let j = 0; j < curr[0].length; j++) {\n      if (curr[0][j] === x) {\n        row.push(j);\n        columns.unshift(j);\n      }\n    }\n  }\n  row.sort((a, b) => a - b);\n  columns.sort((a, b) => b - a);\n  return [row, columns];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpdu599j0m.ts(24,33): error TS2339: Property 'length' does not exist on type 'number'.\n../../../../tmp/tmpdu599j0m.ts(33,11): error TS2322: Type 'number[]' is not assignable to type '[number, number]'.\n  Target requires 2 element(s) but source may have fewer.\n../../../../tmp/tmpdu599j0m.ts(33,16): error TS2322: Type 'number[]' is not assignable to type '[number, number]'.\n",
      "timestamp": 1660334489
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const rows = [row];\n  for (let i = 0; i < lst.length; i++) {\n    const lst2 = lst[i];\n    for (let j = 0; j < lst2.length; j++) {\n      if (lst2[j] === x) {\n        rows.push(row.concat(j));\n      }\n    }\n  }\n  rows.sort((a, b) => a[0] - b[0]);\n  rows.sort((a, b) => b[1] - a[1]);\n  return rows;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpfsva5_g_.ts(32,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334489
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    if (row.includes(x)) {\n      result.push([i, row.indexOf(x)]);\n    }\n  }\n  result.sort((a, b) => a[1] - b[1]);\n  result.sort((a, b) => b[0] - a[0]);\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp7_l0iq9x.ts(26,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334489
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < cols; j++) {\n      if (row[j] === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => a[0] - b[0]);\n  result.sort((a, b) => b[1] - a[1]);\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    [\n      0,\n      0\n    ]\n  ],\n  [\n    [\n      1,\n      0\n    ],\n    [\n      1,\n      4\n    ]\n  ],\n  [\n    [\n      2,\n      0\n    ],\n    [\n      2,\n      5\n    ]\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmp1pw6j8xv.js:40:12)\n    at Object.<anonymous> (/tmp/tmp1pw6j8xv.js:47:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ [ 0, 0 ] ], [ [ 1",
      "stdout": "",
      "timestamp": 1660334490
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [minRow, minCol] = rows.reduce(([minRow, minCol], row) => {\n    const [row, col] = row;\n    return [Math.min(minRow, row), Math.min(minCol, col)];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRow, maxCol] = rows.reduce(([maxRow, maxCol], row) => {\n    const [row, col] = row;\n    return [Math.max(maxRow, row), Math.max(maxCol, col)];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const [minRowIndex, minColIndex] = rows.reduce(([minRowIndex, minColIndex], row, i) => {\n    const [row, col] = row;\n    return [Math.min(minRowIndex, i), Math.min(minColIndex, col)];\n  }, [minRow, minCol]);\n  const [maxRowIndex, maxColIndex] = rows.reduce(([maxRowIndex, maxColIndex], row, i) => {\n    const [row, col] = row;\n    return [Math.max(maxRowIndex, i), Math.max(maxColIndex, col)];\n  }, [maxRow, maxCol]);\n  const [minRowIndex, minColIndex] = rows.reduce(([minRowIndex, minColIndex], row, i) => {\n    const [row, col] = row;\n    return [Math.min(minRowIndex, i), Math.min(minColIndex, col)];\n  }, [minRow, minCol]);\n  const [maxRowIndex, maxColIndex] = rows.reduce(([maxRowIndex, maxColIndex], row, i) => {\n    const [row, col] = row;\n    return [Math.max(maxRowIndex, i), Math.max(maxColIndex, col)];\n  }, [maxRow, maxCol]);\n  const [minRowIndex, minColIndex] = rows.reduce(([minRowIndex, minColIndex], row, i) => {\n    const [row, col] = row;\n    return [Math.min(minRowIndex, i), Math.min(minColIndex, col)];\n  }, [minRow, minCol]);\n  const [maxRowIndex, maxColIndex] = rows.reduce(([maxRowIndex, maxColIndex], row, i) => {\n    const [row, col] = row;\n    return [Math.max(maxRowIndex, i), Math.max(maxColIndex, col)];\n  }, [maxRow, maxCol]);\n  const [minRowIndex, minColIndex] = rows.reduce(([minRowIndex, minColIndex], row, i) => {\n    const [row, col] = row;\n    return [Math.min(minRowIndex, i), Math.min(minColIndex, col)\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpstk9hmi4.ts(56,1): error TS1005: ',' expected.\n../../../../tmp/tmpstk9hmi4.ts(56,9): error TS1005: ',' expected.\n../../../../tmp/tmpstk9hmi4.ts(70,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334490
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n\n  const row = [x];\n  const rows = [row];\n  const columns = [lst[0]];\n\n  for (let i = 1; i < lst.length; i++) {\n    const column = lst[i];\n    row.push(column);\n    rows.push(row);\n    columns.push(column);\n  }\n\n  const sortedRows = sortRows(rows);\n  const sortedColumns = sortColumns(columns);\n\n  return sortedRows.map((row) => sortedColumns.map((column) => [row, column]));\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpln4hvf5g.ts(27,14): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmpln4hvf5g.ts(32,22): error TS2552: Cannot find name 'sortRows'. Did you mean 'sortedRows'?\n../../../../tmp/tmpln4hvf5g.ts(33,25): error TS2552: Cannot find name 'sortColumns'. Did you mean 'sortedColumns'?\n",
      "timestamp": 1660334490
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const rows = [row];\n  const columns = [lst[0]];\n  for (let i = 1; i < lst.length; i++) {\n    const column = lst[i];\n    const [row, column] = [row, column].sort((a, b) => a - b);\n    rows.push(row);\n    columns.push(column);\n  }\n  return [...new Map(rows.map(row => [row, columns.map(column => [column, row])])).values()];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpvm89xyn1.ts(24,11): error TS2451: Cannot redeclare block-scoped variable 'column'.\n../../../../tmp/tmpvm89xyn1.ts(25,17): error TS2451: Cannot redeclare block-scoped variable 'column'.\n../../../../tmp/tmpvm89xyn1.ts(25,28): error TS2448: Block-scoped variable 'row' used before its declaration.\n../../../../tmp/tmpvm89xyn1.ts(29,3): error TS2322: Type 'number[][][][]' is not assignable to type '[number, number][]'.\n  Type 'number[][][]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334490
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const n = lst.length;\n  if (n === 0) return [];\n  if (n === 1) return [[0, lst[0].length - 1]];\n  const row = [0, lst[0].length - 1];\n  for (let i = 1; i < n; i++) {\n    const [row, col] = get_row(lst[i], x);\n    row.push(col);\n  }\n  return row;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpyt_a276e.ts(22,32): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number[][]'.\n  Type 'number' is not assignable to type 'number[]'.\n../../../../tmp/tmpyt_a276e.ts(23,14): error TS2345: Argument of type '[number, number]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmpyt_a276e.ts(25,3): error TS2322: Type 'number[]' is not assignable to type '[number, number][]'.\n  Type 'number' is not assignable to type '[number, number]'.\n",
      "timestamp": 1660334490
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.map(row => row.map(i => i + 1));\n  const cols = lst.map(row => row.map(i => i + 1));\n  const [rows, cols] = sort_rows(rows, cols);\n  const row = rows.find(row => row.includes(x));\n  const [row, col] = sort_cols(row, cols);\n  return [row, col];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpnhj8ehyv.ts(17,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpnhj8ehyv.ts(18,9): error TS2451: Cannot redeclare block-scoped variable 'cols'.\n../../../../tmp/tmpnhj8ehyv.ts(19,10): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpnhj8ehyv.ts(19,16): error TS2451: Cannot redeclare block-scoped variable 'cols'.\n../../../../tmp/tmpnhj8ehyv.ts(19,24): error TS2304: Cannot find name 'sort_rows'.\n../../../../tmp/tmpnhj8ehyv.ts(20,9): error TS2451: Cannot redeclare block-scoped variable 'row'.\n../../../../tmp/tmpnhj8ehyv.ts(21,10): error TS2451: Cannot redeclare block-scoped variable 'row'.\n../../../../tmp/tmpnhj8ehyv.ts(21,22): error TS2304: Cannot find name 'sort_cols'.\n",
      "timestamp": 1660334490
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < cols; j++) {\n      if (row[j] === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    if (a[0] > b[0]) {\n      return 1;\n    }\n    if (a[0] < b[0]) {\n      return -1;\n    }\n    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[1] > b[1]) {\n      return 1;\n    }\n    if (a[1] < b[1]) {\n      return -1;\n    }\n    return 0;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    [\n      0,\n      0\n    ]\n  ],\n  [\n    [\n      1,\n      0\n    ],\n    [\n      1,\n      4\n    ]\n  ],\n  [\n    [\n      2,\n      0\n    ],\n    [\n      2,\n      5\n    ]\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmpyhxvnooz.js:53:12)\n    at Object.<anonymous> (/tmp/tmpyhxvnooz.js:60:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ [ 0, 0 ] ], [ [ 1",
      "stdout": "",
      "timestamp": 1660334490
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const [rows, cols] = lst.length;\n  if (rows === 0) {\n    return [];\n  }\n  const [row_max, col_max] = lst[0].length;\n  if (x === row_max) {\n    return lst;\n  }\n  const rows: number[][] = [];\n  for (let i = 0; i < rows; i++) {\n    const row: number[] = [];\n    for (let j = 0; j < cols; j++) {\n      if (i === x) {\n        row.push([i, j]);\n      }\n      if (j === col_max) {\n        row.push([i, col_max - 1]);\n      }\n    }\n    rows.push(row);\n  }\n  return rows;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpkbki6_xj.ts(17,9): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmpkbki6_xj.ts(17,10): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpkbki6_xj.ts(21,9): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmpkbki6_xj.ts(23,5): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n../../../../tmp/tmpkbki6_xj.ts(25,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpkbki6_xj.ts(30,18): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmpkbki6_xj.ts(33,18): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n",
      "timestamp": 1660334490
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const n = lst.length;\n  if (n < 1) {\n    return [];\n  }\n  if (x < 0) {\n    return [];\n  }\n  if (x >= n) {\n    return [];\n  }\n  const row = [x];\n  const col = [x];\n  for (let i = 0; i < n; i++) {\n    if (lst[i][x] === x) {\n      row.push(i);\n      col.push(i);\n    }\n  }\n  row.sort((a, b) => a - b);\n  col.sort((a, b) => b - a);\n  return [row, col];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpvk4m_h17.ts(37,11): error TS2322: Type 'number[]' is not assignable to type '[number, number]'.\n  Target requires 2 element(s) but source may have fewer.\n../../../../tmp/tmpvk4m_h17.ts(37,16): error TS2322: Type 'number[]' is not assignable to type '[number, number]'.\n",
      "timestamp": 1660334490
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [row, col] = lst[0].length;\n  const result: number[][] = [];\n  for (let i = 0; i < row; i++) {\n    const rowResult: number[] = [];\n    for (let j = 0; j < col; j++) {\n      rowResult.push([i, j]);\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    const aRow = a[0];\n    const aCol = a[1];\n    const bRow = b[0];\n    const bCol = b[1];\n    if (aRow === bRow) {\n      return aCol - bCol;\n    }\n    return aRow - bRow;\n  });\n  result.sort((a, b) => {\n    const aRow = a[0];\n    const aCol = a[1];\n    const bRow = b[0];\n    const bCol = b[1];\n    if (aCol === bCol) {\n      return aRow - bRow;\n    }\n    return aCol - bCol;\n  });\n  return result.find(r => r[0] === x);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp2art6w6o.ts(20,9): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmp2art6w6o.ts(25,22): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmp2art6w6o.ts(49,3): error TS2322: Type 'number[]' is not assignable to type '[number, number][]'.\n  Type 'number' is not assignable to type '[number, number]'.\n",
      "timestamp": 1660334490
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const row = rows[rows.length - 1];\n  const colIndex = cols.indexOf(cols.indexOf(row));\n  if (colIndex === -1) {\n    return [];\n  }\n  const rowIndex = rows.indexOf(row);\n  const rowCoords = [rowIndex, colIndex];\n  rows[rowIndex] = [];\n  cols.splice(colIndex, 1);\n  const newRows = rows.map((row) => row.slice());\n  const newCols = cols.map((col) => col.slice());\n  newRows[rowIndex][colIndex] = x;\n  return [...newRows, ...newCols];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpgmaafngj.ts(28,3): error TS2322: Type 'undefined[]' is not assignable to type 'number'.\n../../../../tmp/tmpgmaafngj.ts(30,41): error TS2339: Property 'slice' does not exist on type 'number'.\n../../../../tmp/tmpgmaafngj.ts(31,41): error TS2339: Property 'slice' does not exist on type 'number'.\n",
      "timestamp": 1660334490
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [row, col] = get_row_and_col(rows, cols, x);\n  return [\n    [row, col],\n    ...get_row(rows.slice(0, row), x),\n    ...get_row(rows.slice(row), x),\n  ];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp7xfvk_04.ts(21,22): error TS2304: Cannot find name 'get_row_and_col'.\n../../../../tmp/tmp7xfvk_04.ts(24,16): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number[][]'.\n  Type 'number' is not assignable to type 'number[]'.\n../../../../tmp/tmp7xfvk_04.ts(25,16): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number[][]'.\n",
      "timestamp": 1660334490
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    if (row.includes(x)) {\n      rows.push([i, row.indexOf(x)]);\n    }\n  }\n  rows.sort((a, b) => a[1] - b[1]);\n  rows.sort((a, b) => b[1] - a[1]);\n  return rows;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp_a3f562y.ts(26,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334490
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < cols; j++) {\n      if (row[j] === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    const aRow = a[0] as number;\n    const bRow = b[0] as number;\n    if (aRow === bRow) {\n      return a[1] - b[1];\n    }\n    return aRow - bRow;\n  });\n  result.sort((a, b) => {\n    const aCol = a[1] as number;\n    const bCol = b[1] as number;\n    if (aCol === bCol) {\n      return a[0] - b[0];\n    }\n    return aCol - bCol;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    [\n      0,\n      0\n    ]\n  ],\n  [\n    [\n      1,\n      0\n    ],\n    [\n      1,\n      4\n    ]\n  ],\n  [\n    [\n      2,\n      0\n    ],\n    [\n      2,\n      5\n    ]\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmp0g_ew4x_.js:54:12)\n    at Object.<anonymous> (/tmp/tmp0g_ew4x_.js:61:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ [ 0, 0 ] ], [ [ 1",
      "stdout": "",
      "timestamp": 1660334490
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < cols; j++) {\n      if (row[j] === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    if (a[0] > b[0]) {\n      return 1;\n    }\n    if (a[0] < b[0]) {\n      return -1;\n    }\n    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[1] > b[1]) {\n      return 1;\n    }\n    if (a[1] < b[1]) {\n      return -1;\n    }\n    return 0;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    [\n      0,\n      0\n    ]\n  ],\n  [\n    [\n      1,\n      0\n    ],\n    [\n      1,\n      4\n    ]\n  ],\n  [\n    [\n      2,\n      0\n    ],\n    [\n      2,\n      5\n    ]\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmpyhxvnooz.js:53:12)\n    at Object.<anonymous> (/tmp/tmpyhxvnooz.js:60:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ [ 0, 0 ] ], [ [ 1",
      "stdout": "",
      "timestamp": 1660334490
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const coords: number[][] = [];\n  for (let row = 0; row < rows; row++) {\n    const rowCoords: number[] = [];\n    for (let col = 0; col < cols; col++) {\n      rowCoords.push({ row: row, col: col });\n    }\n    coords.push(rowCoords);\n  }\n  coords.sort((a, b) => {\n    if (a.row < b.row) {\n      return -1;\n    }\n    if (a.row > b.row) {\n      return 1;\n    }\n    if (a.col < b.col) {\n      return -1;\n    }\n    if (a.col > b.col) {\n      return 1;\n    }\n    return 0;\n  });\n  const rowIndex = coords.findIndex(c => c.row === x);\n  const rowCoords = coords[rowIndex];\n  const rowCoordsIndex = rowCoords.findIndex(c => c.col === x);\n  const rowCoordsIndex = rowCoordsIndex === -1 ? rowCoordsIndex : rowCoordsIndex - 1;\n  const rowCoordsRow = rowCoords[rowCoordsIndex].row;\n  const rowCoordsCol = rowCoords[rowCoordsIndex].col;\n  const rowCoordsRowIndex = rowCoords.findIndex(c => c.row === rowCoordsRow);\n  const rowCoordsRowIndex = rowCoordsRowIndex === -1 ? rowCoordsRowIndex : rowCoordsRowIndex - 1;\n  const rowCoordsRowIndex = rowCoordsRowIndex === -1 ? rowCoordsRow : rowCoordsRow;\n  const rowCoordsColIndex = rowCoords.findIndex(c => c.col === rowCoordsCol);\n  const rowCoordsColIndex = rowCoordsColIndex === -1 ? rowCoordsColIndex : rowCoordsColIndex - 1;\n  const rowCoordsColIndex = rowCoordsColIndex === -1 ? rowCoordsCol : rowCoordsCol;\n  const rowCoordsRowIndex = rowCoordsRowIndex === -1 ? rowCoordsRow : rowCoordsRowIndex;\n  const rowCoordsColIndex = rowCoordsColIndex === -1 ? rowCoordsCol : rowCoordsColIndex;\n  const rowCoordsRow = rowCoords[rowCoordsRowIndex].row;\n  const rowCoordsCol = rowCoords[rowCoordsColIndex].col;\n  const rowCoordsRowIndex = rowCoords.findIndex(c => c.row === rowCoordsRow);\n  const rowCoordsRowIndex = rowCoordsRowIndex\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpt9ntb37q.ts(77,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334490
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n\n  const row = [x];\n  const rows = [row];\n  const columns = [lst[0]];\n  const coords = [[0, 0]];\n\n  while (lst.length > 0) {\n    const row = lst.pop();\n    row.forEach((x, i) => {\n      const column = columns[i];\n      column.push(x);\n    });\n    rows.push(row);\n    columns.push([]);\n    coords.push([]);\n  }\n\n  coords.sort((a, b) => {\n    const aRow = a[0];\n    const bRow = b[0];\n    if (aRow < bRow) {\n      return -1;\n    }\n    if (aRow > bRow) {\n      return 1;\n    }\n    return 0;\n  });\n\n  coords.sort((a, b) => {\n    const aCol = a[1];\n    const bCol = b[1];\n    if (aCol < bCol) {\n      return -1;\n    }\n    if (aCol > bCol) {\n      return 1;\n    }\n    return 0;\n  });\n\n  return coords.map(coord => [coord[0], coord[1]]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "Exception",
      "stderr": "/tmp/tmpo8bj0f4w.js:28\n            column.push(x);\n                   ^\n\nTypeError: Cannot read properties of undefined (reading 'push')\n    at /tmp/tmpo8bj0f4w.js:28:20\n    at Array.forEach (<anonymous>)\n    at get_row (/tmp/tmpo8bj0f4w.js:26:13)\n    at test (/tmp/tmpo8bj0f4w.js:61:22)\n    at Object.<anonymous> (/tmp/tmpo8bj0f4w.js:68:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660334490
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const row = get_row_by_index(rows, x);\n  const col = get_col_by_index(cols, row);\n  return [row, col];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmphroyhase.ts(21,15): error TS2304: Cannot find name 'get_row_by_index'.\n../../../../tmp/tmphroyhase.ts(22,15): error TS2304: Cannot find name 'get_col_by_index'.\n",
      "timestamp": 1660334490
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [row, col] = get_row_and_col(rows, cols, x);\n  return [\n    [0, row],\n    [col, cols - 1],\n  ].sort((a, b) => a[0] - b[0]).sort((a, b) => b[1] - a[1]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmphpf9jk0m.ts(21,22): error TS2304: Cannot find name 'get_row_and_col'.\n../../../../tmp/tmphpf9jk0m.ts(22,3): error TS2322: Type 'any[][]' is not assignable to type '[number, number][]'.\n  Type 'any[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n../../../../tmp/tmphpf9jk0m.ts(24,11): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n",
      "timestamp": 1660334490
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.map(row => row.map(i => i + 1));\n  const cols = rows.map(row => row.map(i => i + 1));\n  const result = [];\n  for (let i = 0; i < rows.length; i++) {\n    for (let j = 0; j < cols[i].length; j++) {\n      if (cols[i][j] === x) {\n        result.push([i, j, 1]);\n      }\n    }\n  }\n  result.sort((a, b) => {\n    if (a[0] < b[0]) return -1;\n    if (a[0] > b[0]) return 1;\n    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[1] < b[1]) return -1;\n    if (a[1] > b[1]) return 1;\n    return 0;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmpo77dmgz8.js:46:12)\n    at Object.<anonymous> (/tmp/tmpo77dmgz8.js:53:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ [ 0, 0 ], [ 1, 4 ], [ 1, 0 ], [ 2, 5 ], [ 2, 0 ] ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660334491
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result = [];\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const rowIndexMap = new Map<number, number>();\n  const colIndexMap = new Map<number, number>();\n  for (let row = 0; row < rows; row++) {\n    const rowIndex = rowIndexMap.get(row) || row;\n    const colIndexMapRow = colIndexMap.get(row) || 0;\n    const colIndexMapCol = colIndexMap.get(colIndexMapRow) || 0;\n    const rowIndex = rowIndexMap.get(colIndexMapRow) || row;\n    const colIndexMapCol = colIndexMap.get(col) || colIndexMapCol;\n    const rowIndexMap = rowIndexMap.set(row, rowIndexMap.get(rowIndex) || 0);\n    const colIndexMap = colIndexMap.set(colIndexMapRow, colIndexMapCol);\n    if (lst[rowIndex][colIndexMapCol] === x) {\n      result.push([rowIndex, colIndexMapCol]);\n    }\n  }\n  return result.sort((a, b) => b[0] - a[0]).sort((a, b) => b[1] - a[1]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmplg2x1qps.ts(23,11): error TS2451: Cannot redeclare block-scoped variable 'rowIndex'.\n../../../../tmp/tmplg2x1qps.ts(23,22): error TS2448: Block-scoped variable 'rowIndexMap' used before its declaration.\n../../../../tmp/tmplg2x1qps.ts(24,28): error TS2448: Block-scoped variable 'colIndexMap' used before its declaration.\n../../../../tmp/tmplg2x1qps.ts(25,11): error TS2451: Cannot redeclare block-scoped variable 'colIndexMapCol'.\n../../../../tmp/tmplg2x1qps.ts(25,28): error TS2448: Block-scoped variable 'colIndexMap' used before its declaration.\n../../../../tmp/tmplg2x1qps.ts(26,11): error TS2451: Cannot redeclare block-scoped variable 'rowIndex'.\n../../../../tmp/tmplg2x1qps.ts(26,22): error TS2448: Block-scoped variable 'rowIndexMap' used before its declaration.\n../../../../tmp/tmplg2x1qps.ts(27,11): error TS2451: Cannot redeclare block-scoped variable 'colIndexMapCol'.\n../../../../tmp/tmplg2x1qps.ts(27,28): error TS2448: Block-scoped variable 'colIndexMap' used before its declaration.\n../../",
      "timestamp": 1660334490
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].indexOf(x) !== -1) {\n      result.push([i, lst[i].indexOf(x)]);\n    }\n  }\n  result.sort((a, b) => a[1] - b[1]);\n  result.sort((a, b) => b[0] - a[0]);\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp6posvj9z.ts(25,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334492
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.map(row => row.map(i => i + x));\n  const rows = rows.map(row => row.sort((a, b) => a - b).reverse());\n  const cols = rows.map(row => row.sort((a, b) => b - a));\n  return [...rows, ...cols];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmprtcoyuml.ts(17,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmprtcoyuml.ts(18,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmprtcoyuml.ts(20,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334492
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  const rows = lst.length;\n  const cols = lst[0].length;\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult: number[] = [];\n    for (let j = 0; j < cols; j++) {\n      const element = row[j];\n      if (element === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    if (a[0] === b[0]) {\n      return a[1] - b[1];\n    }\n    return a[0] - b[0];\n  });\n  result.sort((a, b) => {\n    if (a[1] === b[1]) {\n      return a[0] - b[0];\n    }\n    return a[1] - b[1];\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmplk3ypnr8.ts(26,24): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmplk3ypnr8.ts(43,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334493
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.map(row => row.slice(0, x));\n  const cols = lst.map(row => row.slice(x, lst.length));\n  return [...new Array(rows.length).keys()].map(i =>\n    [i, ...cols.map(col => col[i])]\n  );\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp0dyezcub.ts(19,3): error TS2322: Type '[number, ...number[]][]' is not assignable to type '[number, number][]'.\n  Type '[number, ...number[]]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334493
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [minRow, minCol] = rows.reduce(([minRow, minCol], row) => {\n    const [row, col] = row;\n    return [Math.min(minRow, row), Math.min(minCol, col)];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const maxRow = Math.max(...rows.map(row => row.length));\n  const maxCol = Math.max(...cols.map(col => col.length));\n  const rowRange = maxRow - minRow + 1;\n  const colRange = maxCol - minCol + 1;\n  const result = [];\n  for (let row = minRow; row <= maxRow; row++) {\n    const rowResult = [];\n    for (let col = minCol; col <= maxCol; col++) {\n      if (row === minRow && col === minCol) {\n        rowResult.push([row, col]);\n      } else if (row === minRow && col < minCol) {\n        rowResult.push([row, col]);\n      } else if (row === minRow && col > minCol) {\n        rowResult.push([row, col]);\n      } else if (row < minRow && col === minCol) {\n        rowResult.push([row, col]);\n      } else if (row < minRow && col < minCol) {\n        rowResult.push([row, col]);\n      } else if (row < minRow && col > minCol) {\n        rowResult.push([row, col]);\n      } else if (row === minRow && col === minCol) {\n        rowResult.push([row, col]);\n      } else if (row === minRow && col < minCol) {\n        rowResult.push([row, col]);\n      } else if (row === minRow && col > minCol) {\n        rowResult.push([row, col]);\n      } else if (row < minRow && col === minCol) {\n        rowResult.push([row, col]);\n      } else if (row < minRow && col < minCol) {\n        rowResult.push([row, col]);\n      } else if (row < minRow && col > minCol) {\n        rowResult.push([row, col]);\n      } else if (row === minRow && col === minCol) {\n        rowResult.push([row, col]);\n      } else if (row === minRow && col < minCol) {\n        rowResult.push([row, col]);\n      } else if (row === minRow && col > minCol) {\n        rowResult.push([row, col]);\n      } else if (row < minRow && col === minCol) {\n        rowResult.push([row, col]);\n      } else if (row < minRow && col < minCol) {\n        rowResult.push([row, col]);\n      } else if (row < minRow && \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpwibhy3ih.ts(68,9): error TS1005: ')' expected.\n../../../../tmp/tmpwibhy3ih.ts(82,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334493
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows: number[][] = [];\n  const columns: number[] = [];\n  const row: number[] = [];\n  const column: number[] = [];\n  let row_index = 0;\n  let column_index = 0;\n  let row_indexes: number[] = [];\n  let column_indexes: number[] = [];\n  let row_indexes_sorted: number[] = [];\n  let column_indexes_sorted: number[] = [];\n  let row_length = 0;\n  let column_length = 0;\n  let row_length_sorted = 0;\n  let column_length_sorted = 0;\n  let row_length_sorted_index = 0;\n  let column_length_sorted_index = 0;\n  let row_indexes_sorted_index = 0;\n  let column_indexes_sorted_index = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length < x) {\n      continue;\n    }\n    row.push(lst[i][0]);\n    column_indexes.push(lst[i][1]);\n    column_indexes_sorted.push(column_indexes[column_indexes_sorted_index]);\n    column_indexes_sorted_index++;\n    row_length++;\n    if (row_indexes[row_indexes_sorted_index] === undefined) {\n      row_indexes.push(row_index);\n      row_indexes_sorted.push(row_indexes[row_indexes_sorted_index]);\n      row_indexes_sorted_index++;\n    }\n  }\n  row_indexes_sorted.sort();\n  column_indexes_sorted.sort();\n  for (let i = 0; i < row_indexes_sorted.length; i++) {\n    for (let j = 0; j < column_indexes_sorted.length; j++) {\n      if (row_indexes_sorted[i] === column_indexes_sorted[j]) {\n        row.push(column_indexes[j]);\n      }\n    }\n    rows.push(row);\n    row_index = 0;\n    column_index = 0;\n    row_indexes = [];\n    column_indexes = [];\n    row_indexes_sorted = [];\n    column_indexes_sorted = [];\n    row_length = 0;\n    column_length = 0;\n    row_length_sorted = 0;\n    column_length_sorted = 0;\n    row_length_sorted_index = 0;\n    column_length_sorted_index = 0;\n    row_indexes_sorted_index = 0;\n    column_indexes_sorted_index = 0;\n  }\n  return rows;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpw1w1hhlw.ts(74,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334493
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < cols; j++) {\n      if (row[j] === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => a[0] - b[0]);\n  result.sort((a, b) => b[1] - a[1]);\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    [\n      0,\n      0\n    ]\n  ],\n  [\n    [\n      1,\n      0\n    ],\n    [\n      1,\n      4\n    ]\n  ],\n  [\n    [\n      2,\n      0\n    ],\n    [\n      2,\n      5\n    ]\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmpm0hxusnm.js:37:12)\n    at Object.<anonymous> (/tmp/tmpm0hxusnm.js:44:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ [ 0, 0 ] ], [ [ 1",
      "stdout": "",
      "timestamp": 1660334494
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n\n  const row: number[] = [];\n  const columns: number[] = [];\n\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    const columns = row.slice();\n\n    for (let j = 0; j < columns.length; j++) {\n      columns[j] = columns[j] - i;\n    }\n\n    row.push(...columns);\n  }\n\n  const rowIndex = row.indexOf(x);\n  const columnIndex = row.indexOf(Math.max(...row));\n\n  return [rowIndex, columnIndex];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpf0o3gkxd.ts(38,11): error TS2322: Type 'number' is not assignable to type '[number, number]'.\n../../../../tmp/tmpf0o3gkxd.ts(38,21): error TS2322: Type 'number' is not assignable to type '[number, number]'.\n",
      "timestamp": 1660334493
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.map(row => row.map(i => i + 1));\n  const rows = rows.map(row => row.sort((a, b) => b - a));\n  const rows = rows.map(row => row.sort((a, b) => b - a));\n  const rows = rows.map(row => row.filter(i => i >= x));\n  return rows.map(row => [row, row.indexOf(x)]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpid7l_6cb.ts(17,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpid7l_6cb.ts(18,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpid7l_6cb.ts(19,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpid7l_6cb.ts(20,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpid7l_6cb.ts(21,3): error TS2322: Type '[number[], number][]' is not assignable to type '[number, number][]'.\n  Type '[number[], number]' is not assignable to type '[number, number]'.\n    Type at position 0 in source is not compatible with type at position 0 in target.\n      Type 'number[]' is not assignable to type 'number'.\n",
      "timestamp": 1660334494
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const row: number[][] = [];\n  const row_index: number[] = [];\n  const col_index: number[] = [];\n  let row_indexes: number[] = [];\n  let col_indexes: number[] = [];\n  let row_indexes_sorted: number[] = [];\n  let col_indexes_sorted: number[] = [];\n  let row_indexes_sorted_reverse: number[] = [];\n  let col_indexes_sorted_reverse: number[] = [];\n  let row_indexes_reverse: number[] = [];\n  let col_indexes_reverse: number[] = [];\n  let row_indexes_reverse_index: number[] = [];\n  let col_indexes_reverse_index: number[] = [];\n  let row_indexes_reverse_indexes: number[] = [];\n  let col_indexes_reverse_indexes: number[] = [];\n  let row_indexes_reverse_indexes_sorted: number[] = [];\n  let col_indexes_reverse_indexes_sorted: number[] = [];\n  let row_indexes_reverse_indexes_sorted_reverse: number[] = [];\n  let col_indexes_reverse_indexes_sorted_reverse: number[] = [];\n  let row_indexes_reverse_indexes_reverse: number[] = [];\n  let col_indexes_reverse_indexes_reverse: number[] = [];\n  let row_indexes_reverse_indexes_reverse_index: number[] = [];\n  let col_indexes_reverse_indexes_reverse_index: number[] = [];\n  let row_indexes_reverse_indexes_reverse_indexes: number[] = [];\n  let col_indexes_reverse_indexes_reverse_indexes: number[] = [];\n  let row_indexes_reverse_indexes_reverse_indexes_sorted: number[] = [];\n  let col_indexes_reverse_indexes_reverse_indexes_sorted: number[] = [];\n  let row_indexes_reverse_indexes_reverse_indexes_sorted_reverse: number[] = [];\n  let col_indexes_reverse_indexes_reverse_indexes_sorted_reverse: number[] = [];\n  let row_indexes_reverse_indexes_reverse_indexes_reverse: number[] = [];\n  let col_indexes_reverse_indexes_reverse_indexes_reverse: number[] = [];\n  let row_indexes_reverse_indexes_reverse_indexes_reverse_index: number[] = [];\n  let col_indexes_reverse_indexes_reverse_indexes_reverse_index: number[] = [];\n  let row_indexes_reverse_indexes_reverse_indexes_reverse_indexes: number[] = [];\n  let col_indexes_reverse_indexes_reverse_indexes_reverse_indexes: number[] = [];\n  let row_indexes_reverse_indexes_reverse_indexes_reverse_indexes_sorted: number[] = [];\n  let col_indexes_reverse_indexes_reverse_indexes_reverse_indexes_sorted: number[] = [];\n  let row_indexes_reverse_indexes_reverse_indexes_reverse_indexes_sorted_reverse: number[]\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpxw7eiuds.ts(69,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334494
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const row = get_row_by_index(rows, x);\n  const col = get_col_by_index(cols, x);\n  return [\n    [row, col],\n    ...get_row(rows.slice(1), col),\n    ...get_row(rows.slice(0, rows.length - 1), col),\n  ];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp6ar_rbtf.ts(21,15): error TS2304: Cannot find name 'get_row_by_index'.\n../../../../tmp/tmp6ar_rbtf.ts(22,15): error TS2304: Cannot find name 'get_col_by_index'.\n../../../../tmp/tmp6ar_rbtf.ts(25,16): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number[][]'.\n  Type 'number' is not assignable to type 'number[]'.\n../../../../tmp/tmp6ar_rbtf.ts(26,16): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number[][]'.\n",
      "timestamp": 1660334493
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const row = rows.findIndex((row) => row === x);\n  if (row === -1) {\n    return [];\n  }\n  const [column] = cols.findIndex((col) => col === x);\n  if (column === -1) {\n    return [];\n  }\n  const coords = [row, column];\n  coords.sort((a, b) => a - b);\n  coords.sort((a, b) => b - a);\n  return coords.map((i) => [i, i]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmptu5am4y8.ts(25,9): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n",
      "timestamp": 1660334493
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    if (row.includes(x)) {\n      result.push([i, row.indexOf(x)]);\n    }\n  }\n  result.sort((a, b) => a[1] - b[1]);\n  result.sort((a, b) => b[0] - a[0]);\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp7_l0iq9x.ts(26,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334489
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [minRow, minCol] = rows.reduce(([minRow, minCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.min(row, minRow),\n      Math.min(col, minCol),\n    ];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRow, maxCol] = rows.reduce(([maxRow, maxCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.max(row, maxRow),\n      Math.max(col, maxCol),\n    ];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const [minRowIndex, minColIndex] = rows.reduce(([minRowIndex, minColIndex], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.min(i, minRowIndex),\n      Math.min(i, minColIndex),\n    ];\n  }, [minRow, minCol]);\n  const [maxRowIndex, maxColIndex] = rows.reduce(([maxRowIndex, maxColIndex], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.max(i, maxRowIndex),\n      Math.max(i, maxColIndex),\n    ];\n  }, [maxRow, maxCol]);\n  const [minRowIndex, minColIndex] = rows.reduce(([minRowIndex, minColIndex], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.min(i, minRowIndex),\n      Math.min(i, minColIndex),\n    ];\n  }, [minRow, minCol]);\n  const [maxRowIndex, maxColIndex] = rows.reduce(([maxRowIndex, maxColIndex], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.max(i, maxRowIndex),\n      Math.max(i, maxColIndex),\n    ];\n  }, [maxRow, maxCol]);\n  const [minRowIndex, minColIndex] = rows.reduce(([minRowIndex, minColIndex], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.min(i, minRowIndex),\n      Math.min(i, minColIndex),\n    ];\n  }, [minRow, minCol]);\n  const [maxRowIndex, maxColIndex] = rows.reduce(([maxRowIndex, maxColIndex], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.max(i, maxRowIndex),\n      Math.max(i, maxCol\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp9qeo9olo.ts(75,1): error TS1005: ',' expected.\n../../../../tmp/tmp9qeo9olo.ts(75,9): error TS1005: ',' expected.\n../../../../tmp/tmp9qeo9olo.ts(89,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334494
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const result = [row];\n  for (let i = 0; i < lst.length; i++) {\n    const lstRow = lst[i];\n    for (let j = 0; j < lstRow.length; j++) {\n      if (lstRow[j] === x) {\n        result.push([i, j]);\n      }\n    }\n  }\n  result.sort((a, b) => a[0] - b[0]);\n  result.sort((a, b) => a[1] - b[1], (a, b) => b[0] - a[0]);\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpm5ii8k5d.ts(31,38): error TS2554: Expected 0-1 arguments, but got 2.\n../../../../tmp/tmpm5ii8k5d.ts(32,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334494
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result = [];\n  const rows = lst.map(row => row.filter(x => x === x));\n  const rowsWithX = rows.map(row => row.filter(x => x === x));\n  const rowsWithXAndY = rowsWithX.map(row => row.map(y => [y, y]));\n  const rowsWithXAndYAndZ = rowsWithXAndY.map(row => row.map(z => [z[0], z[1]]));\n  const rowsWithXAndYAndZAndW = rowsWithXAndYAndZ.map(row => row.map(w => [w[0], w[1]]));\n  const rowsWithXAndYAndZAndWAndX = rowsWithXAndYAndZAndW.map(row => row.map(x => [x, x]));\n  const rowsWithXAndYAndZAndWAndXAndY = rowsWithXAndYAndZAndWAndX.map(row => row.map(y => [y, y]));\n  const rowsWithXAndYAndZAndWAndXAndYAndZ = rowsWithXAndYAndZAndWAndXAndY.map(row => row.map(z => [z[0], z[1]]));\n  const rowsWithXAndYAndZAndWAndXAndYAndZAndW = rowsWithXAndYAndZAndWAndXAndYAndZ.map(row => row.map(w => [w[0], w[1]]));\n  const rowsWithXAndYAndZAndWAndXAndYAndZAndWAndX = rowsWithXAndYAndZAndWAndXAndYAndZAndW.map(row => row.map(x => [x, x]));\n  const rowsWithXAndYAndZAndWAndXAndYAndZAndWAndXAndY = rowsWithXAndYAndZAndWAndXAndYAndZAndWAndX.map(row => row.map(y => [y, y]));\n  const rowsWithXAndYAndZAndWAndXAndYAndZAndWAndXAndYAndZ = rowsWithXAndYAndZAndWAndXAndYAndZAndWAndXAndY.map(row => row.map(z => [z[0], z[1]]));\n  const rowsWithXAndYAndZAndWAndXAndYAndZAndWAndXAndYAndZAndW = rowsWithXAndYAndZAndWAndXAndYAndZAndWAndXAndYAndZ.map(row => row.map(w => [w[0], w[1]]));\n  const rowsWithXAndY\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpb66l3p_j.ts(46,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334494
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const row: number[][] = [];\n  const column: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].indexOf(x) !== -1) {\n      row.push(i);\n      column.push(lst[i].indexOf(x));\n    }\n  }\n  row.sort((a, b) => a - b);\n  column.sort((a, b) => b - a);\n  return row.map((r, i) => [r, column[i]]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp0e16itry.ts(21,16): error TS2345: Argument of type 'number' is not assignable to parameter of type 'number[]'.\n../../../../tmp/tmp0e16itry.ts(25,22): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmp0e16itry.ts(25,26): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmp0e16itry.ts(27,3): error TS2322: Type '[number[], number][]' is not assignable to type '[number, number][]'.\n  Type '[number[], number]' is not assignable to type '[number, number]'.\n    Type at position 0 in source is not compatible with type at position 0 in target.\n      Type 'number[]' is not assignable to type 'number'.\n",
      "timestamp": 1660334494
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n\n  const row = [x];\n  const rows = [row];\n  const columns = [lst[0]];\n  const columnIndex = 0;\n  let rowIndex = 0;\n\n  while (rowIndex < lst.length) {\n    const nextRow = [];\n    const nextColumns = [];\n\n    for (let i = 0; i < lst[rowIndex].length; i++) {\n      if (lst[rowIndex][i] === x) {\n        nextRow.push(i);\n        nextColumns.push(columnIndex);\n      }\n    }\n\n    rows.push(nextRow);\n    columns.push(nextColumns);\n\n    rowIndex++;\n    columnIndex++;\n  }\n\n  rows.sort((a, b) => a[0] - b[0]);\n  columns.sort((a, b) => b[1] - a[1]);\n\n  return rows.map(row => [row, columns[row][1]]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmph9k400jd.ts(42,5): error TS2588: Cannot assign to 'columnIndex' because it is a constant.\n../../../../tmp/tmph9k400jd.ts(48,3): error TS2322: Type '[number[], any][]' is not assignable to type '[number, number][]'.\n  Type '[number[], any]' is not assignable to type '[number, number]'.\n    Type at position 0 in source is not compatible with type at position 0 in target.\n      Type 'number[]' is not assignable to type 'number'.\n../../../../tmp/tmph9k400jd.ts(48,40): error TS2538: Type 'number[]' cannot be used as an index type.\n",
      "timestamp": 1660334494
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const rows = [row];\n  for (let i = 0; i < lst.length; i++) {\n    const lstRow = lst[i];\n    for (let j = 0; j < lstRow.length; j++) {\n      if (lstRow[j] === x) {\n        row.push(j);\n        rows.push(row);\n      }\n    }\n  }\n  rows.sort((a, b) => a[0] - b[0]);\n  rows.sort((a, b) => b[1] - a[1]);\n  return rows.map(row => row.map(i => [i, lst[i]]));\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp2e8uczly.ts(33,3): error TS2322: Type '(number | number[])[][][]' is not assignable to type '[number, number][]'.\n  Type '(number | number[])[][]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334494
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [row, col] = lst[0].length;\n  const rows = [...Array(row)].map(() => []);\n  for (let i = 0; i < row; i++) {\n    rows[i].push(0);\n  }\n  for (let i = 0; i < lst.length; i++) {\n    const [row, col] = lst[i].length;\n    for (let j = 0; j < row; j++) {\n      if (lst[i][j] === x) {\n        rows[row].push([i, j]);\n      }\n    }\n  }\n  rows.sort((a, b) => {\n    const aRow = a.map(x => x[0]);\n    const bRow = b.map(x => x[0]);\n    if (aRow.length < bRow.length) {\n      return 1;\n    }\n    if (aRow.length > bRow.length) {\n      return -1;\n    }\n    return 0;\n  });\n  rows.sort((a, b) => {\n    const aCol = a.map(x => x[1]);\n    const bCol = b.map(x => x[1]);\n    if (aCol.length < bCol.length) {\n      return 1;\n    }\n    if (aCol.length > bCol.length) {\n      return -1;\n    }\n    return 0;\n  });\n  return rows;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpl2386smj.ts(20,9): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmpl2386smj.ts(26,11): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmpl2386smj.ts(55,3): error TS2322: Type 'any[][]' is not assignable to type '[number, number][]'.\n  Type 'any[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334494
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [minRow, minCol] = rows.reduce(([minRow, minCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.min(minRow, row),\n      Math.min(minCol, col),\n    ];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRow, maxCol] = rows.reduce(([maxRow, maxCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.max(maxRow, row),\n      Math.max(maxCol, col),\n    ];\n  }, [0, Number.MAX_SAFE_INTEGER]);\n  const [minRowIndex, minColIndex] = rows.reduce(([minRowIndex, minColIndex], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.min(minRowIndex, i),\n      Math.min(minColIndex, col),\n    ];\n  }, [minRow, minCol]);\n  const [maxRowIndex, maxColIndex] = rows.reduce(([maxRowIndex, maxColIndex], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.max(maxRowIndex, i),\n      Math.max(maxColIndex, col),\n    ];\n  }, [maxRow, maxCol]);\n  const [minRowIndex, minColIndex] = rows.reduce(([minRowIndex, minColIndex], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.min(minRowIndex, i),\n      Math.min(minColIndex, col),\n    ];\n  }, [minRow, minCol]);\n  const [maxRowIndex, maxColIndex] = rows.reduce(([maxRowIndex, maxColIndex], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.max(maxRowIndex, i),\n      Math.max(maxColIndex, col),\n    ];\n  }, [maxRow, maxCol]);\n  const [minRowIndex, minColIndex] = rows.reduce(([minRowIndex, minColIndex], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.min(minRowIndex, i),\n      Math.min(minColIndex, col),\n    ];\n  }, [minRow, minCol]);\n  const [maxRowIndex, maxColIndex] = rows.reduce(([maxRowIndex, maxColIndex], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.max(maxRowIndex, i),\n      Math.max(maxColIndex, col),\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpe7agq54a.ts(75,9): error TS1005: ',' expected.\n../../../../tmp/tmpe7agq54a.ts(89,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334494
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const coords: number[][] = [];\n  for (let row = 0; row < rows; row++) {\n    const rowCoords: number[] = [];\n    for (let col = 0; col < cols; col++) {\n      rowCoords.push(getCoord(row, col, lst));\n    }\n    coords.push(rowCoords);\n  }\n  return coords.find((coord: number[]) => coord[0] === x);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp_vyzqb12.ts(23,22): error TS2304: Cannot find name 'getCoord'.\n../../../../tmp/tmp_vyzqb12.ts(27,3): error TS2322: Type 'number[]' is not assignable to type '[number, number][]'.\n  Type 'number' is not assignable to type '[number, number]'.\n",
      "timestamp": 1660334494
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    if (row.includes(x)) {\n      result.push([i, row.indexOf(x)]);\n    }\n  }\n  result.sort((a, b) => {\n    if (a[1] < b[1]) {\n      return -1;\n    }\n    if (a[1] > b[1]) {\n      return 1;\n    }\n    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[0] < b[0]) {\n      return -1;\n    }\n    if (a[0] > b[0]) {\n      return 1;\n    }\n    return 0;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpnl3d_wpq.ts(42,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334494
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const result = [];\n  for (let i = 0; i < lst.length; i++) {\n    const column = lst[i][0];\n    if (column === x) {\n      result.push([row, column]);\n    }\n  }\n  result.sort((a, b) => a[0] - b[0]);\n  result.sort((a, b) => b[1] - a[1]);\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    [\n      1\n    ],\n    1\n  ],\n  [\n    [\n      1\n    ],\n    1\n  ],\n  [\n    [\n      1\n    ],\n    1\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmpadpp4n4e.js:35:12)\n    at Object.<anonymous> (/tmp/tmpadpp4n4e.js:42:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ [ 1 ], 1 ], [ [ 1 ], 1 ], [ [ 1 ], 1 ] ],\n  expected: [ [ 0, 0 ], [ 1, 4 ], [ 1, 0 ",
      "stdout": "",
      "timestamp": 1660334494
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const n = lst.length;\n  if (n === 0) return [];\n  const m = lst[0].length;\n  if (m === 0) return [];\n  const ret = [];\n  for (let i = 0; i < n; i++) {\n    const row = lst[i];\n    const row_x = row[x];\n    const row_y = row[x - 1];\n    if (row_x === row_y) {\n      ret.push([i, x]);\n    } else {\n      ret.push([i, x - 1]);\n    }\n  }\n  ret.sort((a, b) => a[0] - b[0]);\n  ret.sort((a, b) => b[1] - a[1]);\n  return ret;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    0\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmpql9f44jk.js:42:12)\n    at Object.<anonymous> (/tmp/tmpql9f44jk.js:49:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ 0, 0 ], [ 1, 0 ], [ 2, 0 ] ],\n  expected: [ [ 0, 0 ], [ 1, 4 ], [ 1, 0 ], [ 2, 5 ], [ 2, 0 ] ],\n  operator: 'deepEqual'\n}\n\nNo",
      "stdout": "",
      "timestamp": 1660334496
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const rows = [row];\n  const columns = [lst[0]];\n  for (let i = 1; i < lst.length; i++) {\n    const column = lst[i];\n    for (let j = 0; j < column.length; j++) {\n      rows.push(column);\n      columns.push(column);\n    }\n  }\n  rows.sort((a, b) => a[0] - b[0]);\n  columns.sort((a, b) => b[1] - a[1]);\n  return rows.map((row) => row.map((col) => col[0]));\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpy5r5c4sm.ts(32,3): error TS2322: Type 'any[][]' is not assignable to type '[number, number][]'.\n  Type 'any[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334496
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const row = [x];\n  const result = [];\n  for (let i = 0; i < rows; i++) {\n    const rowResult = [];\n    for (let j = 0; j < cols; j++) {\n      rowResult.push([i, j, lst[i][j]]);\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    const aRow = a[0];\n    const bRow = b[0];\n    if (aRow === bRow) {\n      return a[1] - b[1];\n    }\n    return aRow - bRow;\n  });\n  result.sort((a, b) => {\n    const aCol = a[1];\n    const bCol = b[1];\n    if (aCol === bCol) {\n      return a[0] - b[0];\n    }\n    return aCol - bCol;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    [\n      0,\n      0,\n      1\n    ],\n    [\n      0,\n      1,\n      2\n    ],\n    [\n      0,\n      2,\n      3\n    ],\n    [\n      0,\n      3,\n      4\n    ],\n    [\n      0,\n      4,\n      5\n    ],\n    [\n      0,\n      5,\n      6\n    ]\n  ],\n  [\n    [\n      1,\n      0,\n      1\n    ],\n    [\n      1,\n      1,\n      2\n    ],\n    [\n      1,\n      2,\n      3\n    ],\n    [\n      1,\n      3,\n      4\n    ],\n    [\n      1,\n      4,\n      1\n    ],\n    [\n      1,\n      5,\n      6\n    ]\n  ],\n  [\n    [\n      2,\n    ...\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmpss01h3lv.js:52:12)\n    at Object.<anonymous> (/tmp/tmpss01h3lv.js:59:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Mo",
      "stdout": "",
      "timestamp": 1660334496
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const row: number[][] = [];\n  const col: number[] = [];\n  let row_index = 0;\n  let col_index = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].indexOf(x) !== -1) {\n      row.push(row_index);\n      col.push(col_index);\n      row_index++;\n      col_index++;\n    } else {\n      row_index++;\n    }\n  }\n  row.push(row_index);\n  col.push(col_index);\n  row.sort((a, b) => a - b);\n  col.sort((a, b) => b - a);\n  return row.map((r, i) => [r, col[i]]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp6z87xs3w.ts(23,16): error TS2345: Argument of type 'number' is not assignable to parameter of type 'number[]'.\n../../../../tmp/tmp6z87xs3w.ts(31,12): error TS2345: Argument of type 'number' is not assignable to parameter of type 'number[]'.\n../../../../tmp/tmp6z87xs3w.ts(33,22): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmp6z87xs3w.ts(33,26): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmp6z87xs3w.ts(35,3): error TS2322: Type '[number[], number][]' is not assignable to type '[number, number][]'.\n  Type '[number[], number]' is not assignable to type '[number, number]'.\n    Type at position 0 in source is not compatible with type at position 0 in target.\n      Type 'number[]' is not assignable to type 'number'.\n",
      "timestamp": 1660334496
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < cols; j++) {\n      rowResult.push([i, j]);\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    if (a[0] > b[0]) return 1;\n    if (a[0] < b[0]) return -1;\n    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[1] > b[1]) return 1;\n    if (a[1] < b[1]) return -1;\n    return 0;\n  });\n  return result.filter((r) => r[0] === x);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmpfnqs9y10.js:47:12)\n    at Object.<anonymous> (/tmp/tmpfnqs9y10.js:54:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ [ 0, 0 ], [ 1, 4 ], [ 1, 0 ], [ 2, 5 ], [ 2, 0 ] ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660334497
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < cols; j++) {\n      if (row[j] === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    const aRow = a[0];\n    const bRow = b[0];\n    if (aRow > bRow) {\n      return 1;\n    }\n    if (aRow < bRow) {\n      return -1;\n    }\n    return 0;\n  });\n  result.sort((a, b) => {\n    const aCol = a[1];\n    const bCol = b[1];\n    if (aCol > bCol) {\n      return 1;\n    }\n    if (aCol < bCol) {\n      return -1;\n    }\n    return 0;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    [\n      0,\n      0\n    ]\n  ],\n  [\n    [\n      1,\n      0\n    ],\n    [\n      1,\n      4\n    ]\n  ],\n  [\n    [\n      2,\n      0\n    ],\n    [\n      2,\n      5\n    ]\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmp0k9svv8u.js:57:12)\n    at Object.<anonymous> (/tmp/tmp0k9svv8u.js:64:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ [ 0, 0 ] ], [ [ 1",
      "stdout": "",
      "timestamp": 1660334497
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const rows = [row];\n  for (let i = 0; i < lst.length; i++) {\n    const lstRow = lst[i];\n    for (let j = 0; j < lstRow.length; j++) {\n      if (lstRow[j] === x) {\n        rows.push(row.concat(j));\n      }\n    }\n  }\n  return rows.sort((a, b) => b[0] - a[0]).sort((a, b) => b[1] - a[1]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpcux6zfd9.ts(30,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334497
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    if (row.indexOf(x) !== -1) {\n      rows.push([i, row.indexOf(x)]);\n    }\n  }\n  rows.sort((a, b) => a[1] - b[1]);\n  rows.sort((a, b) => b[0] - a[0]);\n  return rows;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp95gpqrju.ts(26,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334497
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  const rows = lst.length;\n  const cols = lst[0].length;\n  for (let row = 0; row < rows; row++) {\n    const row_coords: number[] = [];\n    for (let col = 0; col < cols; col++) {\n      if (lst[row][col] === x) {\n        row_coords.push([row, col]);\n      }\n    }\n    result.push(row_coords);\n  }\n  result.sort((a, b) => {\n    if (a[0] > b[0]) return 1;\n    if (a[0] < b[0]) return -1;\n    return 0;\n  });\n  for (let row = 0; row < rows; row++) {\n    result.sort((a, b) => {\n      if (a[a[0]] > b[a[0]]) return 1;\n      if (a[a[0]] < b[a[0]]) return -1;\n      return 0;\n    });\n  }\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpdosh0j7z.ts(24,25): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmpdosh0j7z.ts(41,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334497
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows: number[][] = [];\n  const columns: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    if (row.includes(x)) {\n      rows.push(i);\n      columns.push(row.indexOf(x));\n    }\n  }\n  rows.sort((a, b) => a - b);\n  columns.sort((a, b) => b - a);\n  return rows.map((r) => [r, columns[r]]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpsf_4dl3y.ts(22,17): error TS2345: Argument of type 'number' is not assignable to parameter of type 'number[]'.\n../../../../tmp/tmpsf_4dl3y.ts(26,23): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmpsf_4dl3y.ts(26,27): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmpsf_4dl3y.ts(28,3): error TS2322: Type '[number[], any][]' is not assignable to type '[number, number][]'.\n  Type '[number[], any]' is not assignable to type '[number, number]'.\n    Type at position 0 in source is not compatible with type at position 0 in target.\n      Type 'number[]' is not assignable to type 'number'.\n../../../../tmp/tmpsf_4dl3y.ts(28,38): error TS2538: Type 'number[]' cannot be used as an index type.\n",
      "timestamp": 1660334497
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const coords: number[][] = [];\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowCoords: number[] = [];\n    for (let j = 0; j < cols; j++) {\n      rowCoords.push(row[j]);\n    }\n    coords.push(rowCoords);\n  }\n  coords.sort((a, b) => a[0] - b[0]);\n  coords.sort((a, b) => b[1] - a[1]);\n  const result: number[][] = [];\n  for (let i = 0; i < coords.length; i++) {\n    const coord = coords[i];\n    if (coord[0] === x) {\n      result.push([i, coord[1]]);\n    }\n  }\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp2s48sm5u.ts(40,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334497
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [minRow, minCol] = rows.reduce(([minRow, minCol], row) => {\n    const [minRowRow] = row;\n    return [\n      Math.min(minRow, minRowRow),\n      Math.min(minCol, row.length),\n    ];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRow, maxCol] = rows.reduce(([maxRow, maxCol], row) => {\n    const [maxRowRow] = row;\n    return [\n      Math.max(maxRow, maxRowRow),\n      Math.max(maxCol, row.length),\n    ];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const [minRowCol, maxRowCol] = cols.reduce(([minRowCol, maxRowCol], col) => {\n    const [minRowColCol] = col;\n    return [\n      Math.min(minRowCol, minRowColCol),\n      Math.max(maxRowCol, minRowColCol),\n    ];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRowCol, minRowCol] = cols.reduce(([maxRowCol, minRowCol], col) => {\n    const [maxRowColCol] = col;\n    return [\n      Math.max(maxRowCol, maxRowColCol),\n      Math.min(minRowCol, maxRowColCol),\n    ];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const [minRowColCol, maxRowColCol] = cols.reduce(([minRowColCol, maxRowColCol], col) => {\n    const [minRowColColCol] = col;\n    return [\n      Math.min(minRowColCol, minRowColColCol),\n      Math.max(maxRowColCol, minRowColColCol),\n    ];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [minRowColColCol, maxRowColColCol] = cols.reduce(([minRowColColCol, maxRowColColCol], col) => {\n    const [minRowColColColCol] = col;\n    return [\n      Math.min(minRowColColCol, minRowColColColCol),\n      Math.max(maxRowColColCol, minRowColColColCol),\n    ];\n  }, [Number.MAX_SAFE_INTEGER, \ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpjrer1bzh.ts(63,9): error TS1005: ',' expected.\n../../../../tmp/tmpjrer1bzh.ts(77,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334497
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [row, col] = lst[0].length;\n  const result = [];\n  for (let i = 0; i < row; i++) {\n    const rowCoord = [i, 0];\n    for (let j = 0; j < col; j++) {\n      if (lst[i][j] === x) {\n        result.push(rowCoord);\n      }\n    }\n  }\n  result.sort((a, b) => a[0] - b[0]);\n  result.sort((a, b) => b[1] - a[1]);\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpx3sbm8cf.ts(20,9): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n",
      "timestamp": 1660334497
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const rows = [row];\n  const columns = [lst[0]];\n  for (let i = 1; i < lst.length; i++) {\n    const column = lst[i];\n    row.push(column);\n    rows.push(row);\n    columns.push(column);\n  }\n  rows.sort((a, b) => a[0] - b[0]);\n  columns.sort((a, b) => b[1] - a[1]);\n  return rows.map(row => columns.map(col => [col, row[0]]));\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp3gmohlec.ts(25,14): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmp3gmohlec.ts(31,3): error TS2322: Type '(number | number[])[][][]' is not assignable to type '[number, number][]'.\n  Type '(number | number[])[][]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334497
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const rows = [row];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    const rows = [...rows, ...row];\n  }\n  const sorted = rows.sort((a, b) => b[0] - a[0]);\n  const sorted = sorted.sort((a, b) => b[1] - a[1]);\n  return sorted.map(([x, y]) => [x, y]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpkk_idmdh.ts(24,22): error TS2448: Block-scoped variable 'rows' used before its declaration.\n../../../../tmp/tmpkk_idmdh.ts(26,9): error TS2451: Cannot redeclare block-scoped variable 'sorted'.\n../../../../tmp/tmpkk_idmdh.ts(27,9): error TS2451: Cannot redeclare block-scoped variable 'sorted'.\n",
      "timestamp": 1660334497
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [row, col] = get_row_and_col(rows, cols, x);\n  return [\n    [row, col],\n    ...get_row(rows.slice(0, row), x - row),\n    ...get_row(rows.slice(row), x - col),\n  ];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp1w_jgacl.ts(21,22): error TS2304: Cannot find name 'get_row_and_col'.\n../../../../tmp/tmp1w_jgacl.ts(24,16): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number[][]'.\n  Type 'number' is not assignable to type 'number[]'.\n../../../../tmp/tmp1w_jgacl.ts(25,16): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number[][]'.\n",
      "timestamp": 1660334497
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [row, col] = get_row_col(rows, cols);\n  const [x, y] = get_row_col(row, col);\n  if (x === x) {\n    return [];\n  }\n  if (x === -1) {\n    return [\n      [row, col],\n    ];\n  }\n  if (y === -1) {\n    return [\n      [row, col],\n      [row, col + 1],\n    ];\n  }\n  return [\n    [row, col],\n    [row, col + 1],\n    [row, col + 2],\n  ];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmplrdnz1mt.ts(16,35): error TS2300: Duplicate identifier 'x'.\n../../../../tmp/tmplrdnz1mt.ts(21,22): error TS2304: Cannot find name 'get_row_col'.\n../../../../tmp/tmplrdnz1mt.ts(22,10): error TS2300: Duplicate identifier 'x'.\n../../../../tmp/tmplrdnz1mt.ts(22,18): error TS2304: Cannot find name 'get_row_col'.\n",
      "timestamp": 1660334497
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [row, col] = lst[0];\n  const [row_max, col_max] = row.map(x => Math.max(...x));\n  const [row_min, col_min] = row.map(x => Math.min(...x));\n  const [row_mid, col_mid] = row.map(x => Math.floor(x / 2));\n  const [row_mid2, col_mid2] = row.map(x => Math.floor(x / 2));\n  const [row_mid3, col_mid3] = row.map(x => Math.floor(x / 2));\n  const [row_mid4, col_mid4] = row.map(x => Math.floor(x / 2));\n  const [row_mid5, col_mid5] = row.map(x => Math.floor(x / 2));\n  const [row_mid6, col_mid6] = row.map(x => Math.floor(x / 2));\n  const [row_mid7, col_mid7] = row.map(x => Math.floor(x / 2));\n  const [row_mid8, col_mid8] = row.map(x => Math.floor(x / 2));\n  const [row_mid9, col_mid9] = row.map(x => Math.floor(x / 2));\n  const [row_mid10, col_mid10] = row.map(x => Math.floor(x / 2));\n  const [row_mid11, col_mid11] = row.map(x => Math.floor(x / 2));\n  const [row_mid12, col_mid12] = row.map(x => Math.floor(x / 2));\n  const [row_mid13, col_mid13] = row.map(x => Math.floor(x / 2));\n  const [row_mid14, col_mid14] = row.map(x => Math.floor(x / 2));\n  const [row_mid15, col_mid15] = row.map(x => Math.floor(x / 2));\n  const [row_mid16, col_mid16] = row.map(x => Math.floor(x / 2));\n  const [row_mid17, col_mid17] = row.map(x => Math.floor(x / 2));\n  const [row_mid18, col_mid18] = row.map(x => Math.floor(x / 2));\n  const [row_mid19, col_mid19] = row.map(x => Math.floor(x / 2));\n  const [row_mid20, col_mid20] = row.map(x => Math.floor(x / 2));\n  const [row_mid21, col_mid21] = row.map(x => Math.floor(x / 2));\n  const [row_mid22, col_mid22] = row.map(x => Math.floor(x / 2));\n  const [row_mid23, col_mid23] = row.map(x => Math.floor(x / 2));\n  const [row_mid24, col_mid24] = row.map(x => Math.floor(x / 2));\n  const [row_mid25, col_mid25] = row.map(x => Math.floor(x / 2));\n  const [row_mid26, col_mid26] = row.map(x => Math.floor(x / 2));\n  const [row_mid27, col_mid27] = row.map(x => Math.floor(x / 2));\n  const [row_mid28, col_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpwdncs57w.ts(51,1): error TS1005: ',' expected.\n../../../../tmp/tmpwdncs57w.ts(51,9): error TS1005: ',' expected.\n../../../../tmp/tmpwdncs57w.ts(65,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334497
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n\n  const [rows, cols] = lst;\n  const [minRow, minCol] = rows.reduce(([minRow, minCol], row) => {\n    if (row.length < minCol) {\n      return [row, row.length];\n    }\n    if (row.length > minCol) {\n      return [row, minCol];\n    }\n    return [row, row.length];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n\n  const [maxRow, maxCol] = rows.reduce(([maxRow, maxCol], row) => {\n    if (row.length > maxCol) {\n      return [row, row.length];\n    }\n    if (row.length < maxCol) {\n      return [row, maxCol];\n    }\n    return [row, row.length];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n\n  const [minRowIndex, minColIndex] = rows.reduce(([minRowIndex, minColIndex], row, i) => {\n    if (row.length < minColIndex) {\n      return [i, row.length];\n    }\n    if (row.length > minColIndex) {\n      return [i, minColIndex];\n    }\n    return [i, row.length];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n\n  const [maxRowIndex, maxColIndex] = rows.reduce(([maxRowIndex, maxColIndex], row, i) => {\n    if (row.length > maxColIndex) {\n      return [i, row.length];\n    }\n    if (row.length < maxColIndex) {\n      return [i, maxColIndex];\n    }\n    return [i, row.length];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n\n  const [minRowIndex, minColIndex] = rows.reduce(([minRowIndex, minColIndex], row, i) => {\n    if (row.length < minColIndex) {\n      return [i, row.length];\n    }\n    if (row.length > minColIndex) {\n      return [i, minColIndex];\n    }\n    return [i, row.length];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n\n  const [maxRowIndex, maxColIndex] = rows.reduce(([maxRowIndex, maxColIndex], row, i) => {\n    if (row.length > maxColIndex) {\n      return [i, row.length];\n    }\n    if (row.length < maxColIndex) {\n      return [i, maxColIndex];\n    }\n    return [i, row.length];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n\n  const [minRowIndex, minColIndex] = rows.reduce(([minRowIndex, minColIndex], row, i) => {\n    if (\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5wdif8it.ts(84,9): error TS1005: ')' expected.\n../../../../tmp/tmp5wdif8it.ts(98,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334497
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [row, col] = get_row_and_col(rows, cols, x);\n  return [\n    [0, row],\n    [col, cols - 1],\n  ];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp447d8aab.ts(21,22): error TS2304: Cannot find name 'get_row_and_col'.\n../../../../tmp/tmp447d8aab.ts(24,11): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n",
      "timestamp": 1660334497
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const row: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const rowValues: number[] = [];\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] === x) {\n        rowValues.push(j);\n      }\n    }\n    row.push(rowValues);\n  }\n  row.sort((a, b) => a[0] > b[0] ? 1 : -1);\n  row.sort((a, b) => b[1] > a[1] ? 1 : -1);\n  return row;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpsh9lmuka.ts(29,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334498
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < cols; j++) {\n      if (row[j] === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => a[0] - b[0]);\n  result.sort((a, b) => b[1] - a[1]);\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    [\n      0,\n      0\n    ]\n  ],\n  [\n    [\n      1,\n      0\n    ],\n    [\n      1,\n      4\n    ]\n  ],\n  [\n    [\n      2,\n      0\n    ],\n    [\n      2,\n      5\n    ]\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmpm0hxusnm.js:37:12)\n    at Object.<anonymous> (/tmp/tmpm0hxusnm.js:44:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ [ 0, 0 ] ], [ [ 1",
      "stdout": "",
      "timestamp": 1660334494
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    if (row.indexOf(x) !== -1) {\n      rows.push([i, row.indexOf(x)]);\n    }\n  }\n  rows.sort((a, b) => a[1] - b[1]);\n  for (let i = 0; i < rows.length; i++) {\n    rows[i].sort((a, b) => b[0] - a[0]);\n  }\n  return rows;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp1r82s5aq.ts(28,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334497
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.map(row => row.map(i => i + x));\n  const rows = rows.sort((a, b) => a[0] - b[0]);\n  const cols = rows.map(row => row.slice().sort((a, b) => b[1] - a[1]));\n  return rows.map(row => row.map((_, i) => cols[i].map(j => [i, j])));\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmphoujw2x0.ts(17,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmphoujw2x0.ts(18,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmphoujw2x0.ts(20,3): error TS2322: Type 'number[][][][]' is not assignable to type '[number, number][]'.\n  Type 'number[][][]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334498
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.map(row => row.map(i => i + 1));\n  const cols = rows.map(row => row.map(i => i + 1));\n  const coords = rows.map(row => row.map(i => [i, 0]));\n  const sortedCoords = coords.sort((a, b) => a[0] - b[0]);\n  const sortedRows = sortedCoords.map(coord => coord[0]);\n  const sortedCols = sortedCoords.map(coord => coord[1]);\n  const rowIndex = sortedRows.indexOf(x);\n  const colIndex = sortedCols.indexOf(x);\n  return sortedCoords.map(coord => [coord[0] + rowIndex, coord[1] + colIndex]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp8ox_ha3c.ts(20,46): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmp8ox_ha3c.ts(20,53): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmp8ox_ha3c.ts(23,39): error TS2345: Argument of type 'number' is not assignable to parameter of type 'number[]'.\n../../../../tmp/tmp8ox_ha3c.ts(24,39): error TS2345: Argument of type 'number' is not assignable to parameter of type 'number[]'.\n../../../../tmp/tmp8ox_ha3c.ts(25,37): error TS2365: Operator '+' cannot be applied to types 'number[]' and 'number'.\n../../../../tmp/tmp8ox_ha3c.ts(25,58): error TS2365: Operator '+' cannot be applied to types 'number[]' and 'number'.\n",
      "timestamp": 1660334499
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, columns] = lst;\n  const [row, col] = get_row_and_col(rows, x);\n  return [\n    ...sort_row_by_col(row, col, columns, x),\n    ...sort_row_by_col(row, col, columns, x),\n  ];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmphzvk8lte.ts(21,22): error TS2304: Cannot find name 'get_row_and_col'.\n../../../../tmp/tmphzvk8lte.ts(23,8): error TS2304: Cannot find name 'sort_row_by_col'.\n../../../../tmp/tmphzvk8lte.ts(24,8): error TS2304: Cannot find name 'sort_row_by_col'.\n",
      "timestamp": 1660334499
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [minRow, minCol] = rows.reduce(([minRow, minCol], row) => {\n    const [row, col] = row;\n    return [Math.min(row, minRow), Math.min(col, minCol)];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const maxRow = rows.length - 1;\n  const maxCol = cols.length - 1;\n  const [maxRow, maxCol] = [maxRow, maxCol];\n  const [row, col] = [minRow, minCol];\n  const [x, y] = [row, col];\n  const [minX, minY] = [minRow, minCol];\n  const [maxX, maxY] = [maxRow, maxCol];\n  const [maxX, maxY] = [maxRow, maxCol];\n  const [minX, minY] = [minRow, minCol];\n  const [maxX, maxY] = [maxRow, maxCol];\n  const [minX, minY] = [minRow, minCol];\n  const [maxX, maxY] = [maxRow, maxCol];\n  const [minX, minY] = [minRow, minCol];\n  const [maxX, maxY] = [maxRow, maxCol];\n  const [minX, minY] = [minRow, minCol];\n  const [maxX, maxY] = [maxRow, maxCol];\n  const [minX, minY] = [minRow, minCol];\n  const [maxX, maxY] = [maxRow, maxCol];\n  const [minX, minY] = [minRow, minCol];\n  const [maxX, maxY] = [maxRow, maxCol];\n  const [minX, minY] = [minRow, minCol];\n  const [maxX, maxY] = [maxRow, maxCol];\n  const [minX, minY] = [minRow, minCol];\n  const [maxX, maxY] = [maxRow, maxCol];\n  const [minX, minY] = [minRow, minCol];\n  const [maxX, maxY] = [maxRow, maxCol];\n  const [minX, minY] = [minRow, minCol];\n  const [maxX, maxY] = [maxRow, maxCol];\n  const [minX, minY] = [minRow, minCol];\n  const [maxX, maxY] = [maxRow, maxCol];\n  const [minX, minY] = [minRow, minCol];\n  const [maxX, maxY] = [maxRow, maxCol];\n  const [minX, min\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpmrh7s0hc.ts(58,1): error TS1005: ',' expected.\n../../../../tmp/tmpmrh7s0hc.ts(58,9): error TS1005: ',' expected.\n../../../../tmp/tmpmrh7s0hc.ts(72,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334499
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    if (row.includes(x)) {\n      result.push([i, row.indexOf(x)]);\n    }\n  }\n  result.sort((a, b) => b[1] - a[1]);\n  result.sort((a, b) => b[0] - a[0]);\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpuhrrp50i.ts(26,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334499
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  const row: number[] = [];\n  let col = 0;\n  let row_index = 0;\n  let col_index = 0;\n  while (row_index < lst.length) {\n    if (lst[row_index][col] === x) {\n      result.push([row_index, col_index]);\n      row_index++;\n      col_index = 0;\n      row.push(row_index);\n    } else {\n      col_index++;\n    }\n  }\n  result.sort((a, b) => b[1] - a[1]);\n  result.sort((a, b) => b[0] - a[0]);\n  result.sort((a, b) => b[1] - a[1]);\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpld3dp478.ts(35,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334500
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const row = [...lst].sort((a, b) => b[0] - a[0]);\n  const col = [...row].sort((a, b) => b[1] - a[1]);\n  const result = [];\n  for (let i = 0; i < row.length; i++) {\n    if (row[i][0] === x) {\n      for (let j = 0; j < col.length; j++) {\n        result.push([row[i][0], col[j][0]]);\n      }\n    }\n  }\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    1,\n    1\n  ],\n  [\n    1,\n    1\n  ],\n  [\n    1,\n    1\n  ],\n  [\n    1,\n    1\n  ],\n  [\n    1,\n    1\n  ],\n  [\n    1,\n    1\n  ],\n  [\n    1,\n    1\n  ],\n  [\n    1,\n    1\n  ],\n  [\n    1,\n    1\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmp008ruaq5.js:32:12)\n    at Object.<anonymous> (/tmp/tmp008ruaq5.js:39:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actua",
      "stdout": "",
      "timestamp": 1660334500
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const row = rows.findIndex((row) => row === x);\n  if (row === -1) {\n    return [];\n  }\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n  const [row_, col_] = rows.splice(row, 1);\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp7ivgb7t4.ts(83,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334501
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.map(row => row.map(i => i + 1));\n  const cols = rows[0].map(i => i + 1);\n  const result = [];\n  for (let i = 0; i < rows.length; i++) {\n    for (let j = 0; j < cols.length; j++) {\n      if (rows[i][j] === x) {\n        result.push([i, j]);\n      }\n    }\n  }\n  result.sort((a, b) => a[0] - b[0]);\n  result.sort((a, b) => a[1] - b[1]);\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmprt41p796.js:34:12)\n    at Object.<anonymous> (/tmp/tmprt41p796.js:41:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ [ 0, 0 ], [ 1, 4 ], [ 1, 0 ], [ 2, 5 ], [ 2, 0 ] ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660334500
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [row, col] = get_row_and_col(rows, cols, x);\n  return [\n    [row, col],\n    ...get_row(rows.slice(0, row), x - rows[row][col]),\n    ...get_row(rows.slice(row + 1), x - rows[row][col]),\n  ];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp_vng253t.ts(21,22): error TS2304: Cannot find name 'get_row_and_col'.\n../../../../tmp/tmp_vng253t.ts(24,16): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number[][]'.\n  Type 'number' is not assignable to type 'number[]'.\n../../../../tmp/tmp_vng253t.ts(25,16): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number[][]'.\n",
      "timestamp": 1660334500
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const row: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const columns: number[] = [];\n    for (let j = 0; j < lst[i].length; j++) {\n      columns[j] = lst[i][j];\n    }\n    row.push(columns);\n  }\n  row.sort((a, b) => a[0] - b[0]);\n  row.sort((a, b) => b[1] - a[1]);\n  return row.filter((row) => row[0] === x);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpga6dkzu8.ts(27,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334501
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const [rows, cols] = lst;\n  if (rows.length === 0) {\n    return [];\n  }\n  const [row, col] = get_row_and_col(rows, x);\n  return [\n    [row, col],\n    ...get_row(rows.slice(1), col),\n  ];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp_fnvm3dc.ts(21,22): error TS2304: Cannot find name 'get_row_and_col'.\n../../../../tmp/tmp_fnvm3dc.ts(24,16): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number[][]'.\n  Type 'number' is not assignable to type 'number[]'.\n",
      "timestamp": 1660334501
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [row, col] = get_row_and_col(rows, cols);\n  if (row === -1) {\n    return [];\n  }\n  const [x, y] = get_row_and_col(row, col);\n  if (x === -1) {\n    return [];\n  }\n  if (x === x) {\n    return [\n      [row, col],\n    ];\n  }\n  if (x > y) {\n    const [y, x] = [x, y];\n  }\n  const [x, y] = [x, y];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [row, col];\n  const [row, col] = [\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp8aukb3ot.ts(84,9): error TS1005: ',' expected.\n../../../../tmp/tmp8aukb3ot.ts(98,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334501
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.map(row => row.map(i => i + x));\n  const rows = rows.sort((a, b) => a[0] - b[0]);\n  const cols = rows.map(row => row.slice().sort((a, b) => b[0] - a[0]));\n  return [...rows, ...cols];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpo430k_1r.ts(17,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpo430k_1r.ts(18,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpo430k_1r.ts(20,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334501
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < cols; j++) {\n      rowResult.push([i, j]);\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    if (a[0] < b[0]) {\n      return -1;\n    }\n    if (a[0] > b[0]) {\n      return 1;\n    }\n    return 0;\n  });\n  const rowResult = result[result.length - 1] as [number, number][];\n  rowResult.sort((a, b) => {\n    if (a[1] < b[1]) {\n      return -1;\n    }\n    if (a[1] > b[1]) {\n      return 1;\n    }\n    return 0;\n  });\n  return rowResult;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    2,\n    0\n  ],\n  [\n    2,\n    1\n  ],\n  [\n    2,\n    2\n  ],\n  [\n    2,\n    3\n  ],\n  [\n    2,\n    4\n  ],\n  [\n    2,\n    5\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmphfx2ts61.js:55:12)\n    at Object.<anonymous> (/tmp/tmphfx2ts61.js:62:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ 2, 0 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], [ 2, 4 ], [ 2, 5 ] ],",
      "stdout": "",
      "timestamp": 1660334501
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const n = lst.length;\n  if (n === 0) return [];\n  if (n === 1) return [[0, lst[0].length - 1]];\n  const m = lst[0].length;\n  const ret = [];\n  for (let i = 0; i < n; i++) {\n    const row = lst[i];\n    const row1 = row[0];\n    const row2 = row[row1.length - 1];\n    const col1 = row1.length - 1;\n    const col2 = row2.length - 1;\n    if (row1.indexOf(x) !== -1 && row2.indexOf(x) !== -1) {\n      ret.push([i, col1]);\n      ret.push([i, col2]);\n    }\n  }\n  ret.sort((a, b) => a[0] - b[0]);\n  ret.sort((a, b) => b[1] - a[1]);\n  return ret;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp0wo3y68t.ts(25,27): error TS2339: Property 'length' does not exist on type 'number'.\n../../../../tmp/tmp0wo3y68t.ts(26,23): error TS2339: Property 'length' does not exist on type 'number'.\n../../../../tmp/tmp0wo3y68t.ts(27,23): error TS2339: Property 'length' does not exist on type 'number'.\n../../../../tmp/tmp0wo3y68t.ts(28,14): error TS2339: Property 'indexOf' does not exist on type 'number'.\n../../../../tmp/tmp0wo3y68t.ts(28,40): error TS2339: Property 'indexOf' does not exist on type 'number'.\n",
      "timestamp": 1660334501
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    if (row.includes(x)) {\n      result.push([i, row.indexOf(x)]);\n    }\n  }\n  result.sort((a, b) => {\n    if (a[0] < b[0]) return -1;\n    if (a[0] > b[0]) return 1;\n    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[1] < b[1]) return -1;\n    if (a[1] > b[1]) return 1;\n    return 0;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5qvnmasc.ts(34,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334501
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < cols; j++) {\n      if (row[j] === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    if (a[0] > b[0]) {\n      return 1;\n    }\n    if (a[0] < b[0]) {\n      return -1;\n    }\n    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[1] > b[1]) {\n      return 1;\n    }\n    if (a[1] < b[1]) {\n      return -1;\n    }\n    return 0;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    [\n      0,\n      0\n    ]\n  ],\n  [\n    [\n      1,\n      0\n    ],\n    [\n      1,\n      4\n    ]\n  ],\n  [\n    [\n      2,\n      0\n    ],\n    [\n      2,\n      5\n    ]\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmpfrhqrqdn.js:56:12)\n    at Object.<anonymous> (/tmp/tmpfrhqrqdn.js:63:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ [ 0, 0 ] ], [ [ 1",
      "stdout": "",
      "timestamp": 1660334501
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [row, col] = get_row_and_col(lst, x);\n  return row.map((_, i) => [\n    i,\n    col,\n  ]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpeszb5art.ts(20,22): error TS2304: Cannot find name 'get_row_and_col'.\n",
      "timestamp": 1660334501
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [lst[0][x]];\n  const rest = lst.slice(1);\n  return rest.map(row => [...row, x]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp_nzxs86m.ts(22,3): error TS2322: Type '[...number[], number][]' is not assignable to type '[number, number][]'.\n  Type '[...number[], number]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334501
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n\n  const row = [x];\n  const col = [lst[0].length - 1];\n  const result = [row];\n  for (let i = 1; i < lst.length; i++) {\n    const curr = lst[i];\n    for (let j = 0; j < curr[col].length; j++) {\n      if (curr[col][j] === x) {\n        result.push([row, col]);\n        break;\n      }\n    }\n    row = [];\n    col = [];\n    for (let j = 0; j < curr[col].length; j++) {\n      row.push(curr[col][j]);\n      col.push(j);\n    }\n  }\n  return result.sort((a, b) => a[0] - b[0]).sort((a, b) => b[1] - a[1]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpkkve61os.ts(26,30): error TS2538: Type 'number[]' cannot be used as an index type.\n../../../../tmp/tmpkkve61os.ts(27,16): error TS2538: Type 'number[]' cannot be used as an index type.\n../../../../tmp/tmpkkve61os.ts(28,22): error TS2322: Type 'number[]' is not assignable to type 'number'.\n../../../../tmp/tmpkkve61os.ts(28,27): error TS2322: Type 'number[]' is not assignable to type 'number'.\n../../../../tmp/tmpkkve61os.ts(32,5): error TS2588: Cannot assign to 'row' because it is a constant.\n../../../../tmp/tmpkkve61os.ts(33,5): error TS2588: Cannot assign to 'col' because it is a constant.\n../../../../tmp/tmpkkve61os.ts(34,30): error TS2538: Type 'number[]' cannot be used as an index type.\n../../../../tmp/tmpkkve61os.ts(35,21): error TS2538: Type 'number[]' cannot be used as an index type.\n../../../../tmp/tmpkkve61os.ts(39,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 ",
      "timestamp": 1660334501
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n  for (let row = 0; row < rows; row++) {\n    const row = lst[row];\n    const rowResult = [];\n    for (let col = 0; col < cols; col++) {\n      const element = row[col];\n      if (element === x) {\n        rowResult.push([row, col]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => a[0] - b[0]);\n  result.sort((a, b) => b[1] - a[1]);\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "/home/l.phipps-costin/polyglot-codegen-evaluation/node_modules/typescript/lib/tsc.js:96888\n                throw e;\n                ^\n\nRangeError: Maximum call stack size exceeded\n    at getNodeLinks (/home/l.phipps-costin/polyglot-codegen-evaluation/node_modules/typescript/lib/tsc.js:40312:30)\n    at getResolvedSymbol (/home/l.phipps-costin/polyglot-codegen-evaluation/node_modules/typescript/lib/tsc.js:57579:25)\n    at checkIdentifier (/home/l.phipps-costin/polyglot-codegen-evaluation/node_modules/typescript/lib/tsc.js:59645:26)\n    at checkExpressionWorker (/home/l.phipps-costin/polyglot-codegen-evaluation/node_modules/typescript/lib/tsc.js:66752:28)\n    at checkExpression (/home/l.phipps-costin/polyglot-codegen-evaluation/node_modules/typescript/lib/tsc.js:66707:38)\n    at checkNonNullExpression (/home/l.phipps-costin/polyglot-codegen-evaluation/node_modules/typescript/lib/tsc.js:61989:37)\n    at checkIndexedAccess (/home/l.phipps-costin/polyglot-codegen-evaluation/node_modules/typescript/lib/tsc.js:62653:",
      "stdout": "",
      "timestamp": 1660334501
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const rows = [row];\n  const row_index = 0;\n  const columns = [lst[0]];\n  const column_index = 0;\n  while (row_index < lst.length) {\n    const column = lst[row_index][column_index];\n    if (column === x) {\n      return rows;\n    }\n    rows.push(row);\n    columns.push(column);\n    row_index++;\n    column_index++;\n  }\n  return [];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpaoikdq57.ts(28,7): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n../../../../tmp/tmpaoikdq57.ts(31,18): error TS2345: Argument of type 'number' is not assignable to parameter of type 'number[]'.\n../../../../tmp/tmpaoikdq57.ts(32,5): error TS2588: Cannot assign to 'row_index' because it is a constant.\n../../../../tmp/tmpaoikdq57.ts(33,5): error TS2588: Cannot assign to 'column_index' because it is a constant.\n",
      "timestamp": 1660334501
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [row_min, row_max] = get_row_range(rows);\n  const [col_min, col_max] = get_col_range(cols);\n  const [row_min_col, row_max_col] = get_row_col_range(row_min, row_max, col_min, col_max);\n  const [row_min_row, row_max_row] = get_row_row_range(row_min, row_max, col_min, col_max);\n  const [col_min_row, col_max_row] = get_col_col_range(row_min, row_max, col_min, col_max);\n  const [row_min_row_col, row_max_row_col] = get_row_col_row_range(row_min, row_max, col_min, col_max);\n  const [row_min_col_row, row_max_col_row] = get_col_row_range(row_min, row_max, col_min, col_max);\n  const [col_min_col_row, col_max_col_row] = get_col_col_range(row_min, row_max, col_min, col_max);\n  const [row_min_row_col_row, row_max_row_col_row] = get_row_row_col_range(row_min, row_max, col_min, col_max);\n  const [col_min_row_col_row, col_max_row_col_row] = get_col_row_col_range(row_min, row_max, col_min, col_max);\n  const [row_min_row_row_col_row, row_max_row_row_col_row] = get_row_row_col_row_range(row_min, row_max, col_min, col_max);\n  const [col_min_row_row_row_col_row, col_max_row_row_col_row] = get_col_row_row_col_range(row_min, row_max, col_min, col_max);\n  const [row_min_col_col_row_row_col_row, row_max_col_row_row_col_row] = get_row_col_row_col_row_range(row_min, row_max, col_min, col_max);\n  const [col_min_col_row_row_col_row_col_row, col_max_col_row_row_col_row_col_row] = get_col_row_row_col_row_col_range(row_min, row_max, col_min, col_max);\n  const [row_min_row_row_col_row_col_row_col_row, row_max_row_row_col_row_col_row_col_row] = get_row_row_col_row_col_row_col_range(row_min, row_max, col_min, col_max);\n  const [col_min_row_row_col_row_col_row_col_row_col_row, col_max_row_row_col_row_col_row_col_row_col_row] = get_col_row_row_col_row_col_row_col_row_range(row_min, row_max, col_min, col_max);\n  const [row_min_row_row_col_row_col_row_col_row_col_row_col_row, row_max_row_row_col_row_col_row_col_row_col_row_col_row] = get_row_row_col_row_col_row_col_row_col_\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpekuqim5b.ts(52,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334501
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [row, col] = lst[0];\n  const [row_sorted, col_sorted] = sort_2d(row, col, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sorted, (x, y) => y - x);\n  const [row_sorted, col_sorted] = sort_2d(row_sorted, col_sor\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpsdprsdqb.ts(44,1): error TS1005: ',' expected.\n../../../../tmp/tmpsdprsdqb.ts(44,9): error TS1005: ',' expected.\n../../../../tmp/tmpsdprsdqb.ts(58,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334503
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < cols; j++) {\n      const col = row[j];\n      if (col === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => a[0] - b[0]);\n  result.sort((a, b) => b[1] - a[1]);\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    [\n      0,\n      0\n    ]\n  ],\n  [\n    [\n      1,\n      0\n    ],\n    [\n      1,\n      4\n    ]\n  ],\n  [\n    [\n      2,\n      0\n    ],\n    [\n      2,\n      5\n    ]\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmp7iqi_shg.js:38:12)\n    at Object.<anonymous> (/tmp/tmp7iqi_shg.js:45:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ [ 0, 0 ] ], [ [ 1",
      "stdout": "",
      "timestamp": 1660334503
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const rowIdx = rows.findIndex(row => row === x);\n  if (rowIdx === -1) {\n    return [];\n  }\n  const [row, col] = rows[rowIdx];\n  const colIdx = cols.findIndex(col => col === x);\n  if (colIdx === -1) {\n    return [];\n  }\n  return [\n    [rowIdx, colIdx],\n    [rowIdx - 1, colIdx],\n    [rowIdx, colIdx - 1],\n    [rowIdx - 1, colIdx - 1],\n  ];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpfmio0qii.ts(25,9): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n",
      "timestamp": 1660334503
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows: number[][] = [];\n  const cols: number[] = [];\n  let row = 0;\n  let col = 0;\n  let row_index = 0;\n  let col_index = 0;\n  while (row < lst.length) {\n    if (lst[row][col] === x) {\n      rows.push(lst[row_index]);\n      cols.push(col_index);\n      row_index++;\n      col_index++;\n    } else {\n      row_index++;\n    }\n    row++;\n  }\n  rows.push(lst[row_index]);\n  cols.push(col_index);\n  rows.sort((a, b) => a[0] - b[0]);\n  cols.sort((a, b) => b[1] - a[1]);\n  return rows.map(row => [row, cols]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp8sv2twqz.ts(38,3): error TS2322: Type '[number[], number[]][]' is not assignable to type '[number, number][]'.\n  Type '[number[], number[]]' is not assignable to type '[number, number]'.\n    Type at position 0 in source is not compatible with type at position 0 in target.\n      Type 'number[]' is not assignable to type 'number'.\n",
      "timestamp": 1660334503
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n\n  const row = [x];\n  const columns = [lst[0].length - 1];\n\n  for (let i = 1; i < lst.length; i++) {\n    const curr = lst[i];\n    for (let j = 0; j < columns.length; j++) {\n      if (curr[j] < columns[j]) {\n        row.push(curr[j]);\n        columns.splice(j, 1);\n        break;\n      }\n    }\n  }\n\n  row.sort((a, b) => a - b);\n  columns.sort((a, b) => b - a);\n\n  return row.map((r) => [r, columns.indexOf(r)]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    1,\n    -1\n  ],\n  [\n    1,\n    -1\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmprck9mxd_.js:39:12)\n    at Object.<anonymous> (/tmp/tmprck9mxd_.js:46:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ 1, -1 ], [ 1, -1 ] ],\n  expected: [ [ 0, 0 ], [ 1, 4 ], [ 1, 0 ], [ 2, 5 ], [ 2, 0 ] ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660334504
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows: number[][] = [];\n  const columns: number[] = [];\n  let row = 0;\n  let col = 0;\n  while (row < lst.length) {\n    if (lst[row].indexOf(x) !== -1) {\n      rows.push(row);\n      columns.push(col);\n    }\n    row++;\n    col++;\n  }\n  rows.sort((a, b) => a - b);\n  columns.sort((a, b) => b - a);\n  return rows.map(row => columns.map(col => [row, col]));\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpyvyqbe4d.ts(23,17): error TS2345: Argument of type 'number' is not assignable to parameter of type 'number[]'.\n../../../../tmp/tmpyvyqbe4d.ts(29,23): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmpyvyqbe4d.ts(29,27): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmpyvyqbe4d.ts(31,3): error TS2322: Type '(number | number[])[][][]' is not assignable to type '[number, number][]'.\n  Type '(number | number[])[][]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334504
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const row: number[][] = [];\n  const column: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    if (row.includes(x)) {\n      row.forEach((val, j) => {\n        if (j === 0) row.unshift(val);\n        else row.push(val);\n      });\n      row.sort((a, b) => a - b);\n      row.sort((a, b) => b - a);\n      row.forEach((val, j) => {\n        if (j === 0) column.unshift(val);\n        else column.push(val);\n      });\n      column.sort((a, b) => b - a);\n      column.forEach((val, j) => {\n        if (j === 0) row.unshift(val);\n        else row.push(val);\n      });\n    }\n  }\n  return row;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpvqssfeqc.ts(39,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334504
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n  for (let row = 0; row < rows; row++) {\n    const row_coords = lst[row].map((_, col) => col);\n    const row_sorted = row_coords.sort((a, b) => b - a);\n    const row_sorted = row_sorted.reverse();\n    for (let col = 0; col < cols; col++) {\n      if (row_sorted[col] === x) {\n        result.push([row, col]);\n      }\n    }\n  }\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmphtwg9oml.ts(25,11): error TS2451: Cannot redeclare block-scoped variable 'row_sorted'.\n../../../../tmp/tmphtwg9oml.ts(26,11): error TS2451: Cannot redeclare block-scoped variable 'row_sorted'.\n",
      "timestamp": 1660334504
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const row: number[][] = [];\n  let row_index = 0;\n  let col_index = 0;\n  while (row_index < lst.length) {\n    if (lst[row_index][col_index] === x) {\n      row.push([row_index, col_index]);\n      row_index++;\n      col_index++;\n    } else {\n      col_index++;\n    }\n  }\n  return row;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpwday46sk.ts(29,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334504
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const row: number[][] = [];\n  const column: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    const column = lst[i][x];\n    row.push(column);\n    column.push(row.length);\n  }\n  row.sort((a, b) => a - b);\n  column.sort((a, b) => b - a);\n  return [row, column];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpe77qkdob.ts(23,12): error TS2339: Property 'push' does not exist on type 'number'.\n../../../../tmp/tmpe77qkdob.ts(25,22): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmpe77qkdob.ts(25,26): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmpe77qkdob.ts(27,11): error TS2322: Type 'number[][]' is not assignable to type '[number, number]'.\n  Target requires 2 element(s) but source may have fewer.\n../../../../tmp/tmpe77qkdob.ts(27,16): error TS2322: Type 'number[]' is not assignable to type '[number, number]'.\n  Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334504
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [lst[0]];\n  const columns = [lst[0]];\n  for (let i = 1; i < lst.length; i++) {\n    const row = lst[i];\n    const columns = row.slice().reverse();\n    if (columns.indexOf(x) !== -1) {\n      row.push(x);\n      columns.push(x);\n    }\n    row.push(...columns);\n    columns.push(...row);\n  }\n  row.sort((a, b) => a - b);\n  columns.sort((a, b) => b - a);\n  return row.map((r, i) => [r, columns[i]]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp7_3gqpel.ts(32,22): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmp7_3gqpel.ts(32,26): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmp7_3gqpel.ts(33,26): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmp7_3gqpel.ts(33,30): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmp7_3gqpel.ts(34,3): error TS2322: Type '[number[], number[]][]' is not assignable to type '[number, number][]'.\n  Type '[number[], number[]]' is not assignable to type '[number, number]'.\n    Type at position 0 in source is not compatible with type at position 0 in target.\n      Type 'number[]' is not assignable to type 'number'.\n",
      "timestamp": 1660334504
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n\n  const row = [x];\n  const columns = [x];\n  let row_index = 0;\n  let column_index = 0;\n\n  while (row_index < lst.length) {\n    const row_value = lst[row_index][column_index];\n    if (row_value === x) {\n      return [\n        [row_index, column_index],\n        ...get_row(\n          lst.slice(0, row_index),\n          column_index === lst[row_index].length - 1 ? lst[row_index].length - 1 : column_index + 1\n        ),\n      ];\n    }\n\n    if (row_value < x) {\n      row_index += 1;\n      column_index = 0;\n    } else {\n      column_index += 1;\n    }\n\n    row.push(row_value);\n    columns.push(row_value);\n  }\n\n  return [];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    0,\n    0\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmpcfc1j6ie.js:47:12)\n    at Object.<anonymous> (/tmp/tmpcfc1j6ie.js:54:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ 0, 0 ] ],\n  expected: [ [ 0, 0 ], [ 1, 4 ], [ 1, 0 ], [ 2, 5 ], [ 2, 0 ] ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660334505
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [row, col] = get_row_col(x, rows);\n  return [\n    [0, 0],\n    [row, col],\n    [row + 1, col],\n    [row + 1, col + 1],\n    [row, col + 1],\n  ];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp725e1i22.ts(21,22): error TS2304: Cannot find name 'get_row_col'.\n",
      "timestamp": 1660334504
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows: number[][] = [];\n  const columns: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    const row_len = row.length;\n    const col_len = row[0].length;\n    for (let j = 0; j < col_len; j++) {\n      if (row[j] === x) {\n        rows.push([i, j]);\n        columns.push([j]);\n      }\n    }\n  }\n  rows.sort((a, b) => a[0] - b[0]);\n  columns.sort((a, b) => b[1] - a[1]);\n  return rows.map(row => columns.map(col => [row, col]));\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpwpbvpc9d.ts(22,28): error TS2339: Property 'length' does not exist on type 'number'.\n../../../../tmp/tmpwpbvpc9d.ts(26,22): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmpwpbvpc9d.ts(32,3): error TS2322: Type '(number | number[])[][][]' is not assignable to type '[number, number][]'.\n  Type '(number | number[])[][]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334504
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n\n  const row = [x];\n  const columns = [x];\n  const result = [];\n\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    const columns = row.slice(0);\n\n    for (let j = 0; j < columns.length; j++) {\n      if (columns[j] === x) {\n        result.push([i, j]);\n        columns.splice(j, 1);\n      }\n    }\n\n    if (columns.length === 0) {\n      result.push([i, 0]);\n    }\n  }\n\n  result.sort((a, b) => {\n    if (a[0] === b[0]) {\n      return a[1] - b[1];\n    }\n\n    return a[0] - b[0];\n  });\n\n  result.sort((a, b) => {\n    if (a[1] === b[1]) {\n      return a[0] - b[0];\n    }\n\n    return a[1] - b[1];\n  });\n\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    0\n  ],\n  [\n    1,\n    3\n  ],\n  [\n    2,\n    4\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmph11ns08h.js:53:12)\n    at Object.<anonymous> (/tmp/tmph11ns08h.js:60:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ 0, 0 ], [ 1, 0 ], [ 2, 0 ], [ 1, 3 ], [ 2, 4 ] ],\n  expected: [ [ 0, 0 ], [ 1, 4 ",
      "stdout": "",
      "timestamp": 1660334504
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const rows = lst.length;\n  const cols = lst[0].length;\n  if (rows === 0) {\n    return [];\n  }\n  if (x === 0 || x === cols) {\n    return [[0, 0]];\n  }\n  const row = [0, 0];\n  let rowIndex = 0;\n  let colIndex = 0;\n  while (rowIndex < rows) {\n    if (lst[rowIndex][colIndex] === x) {\n      row.push(rowIndex, colIndex);\n      rowIndex++;\n      colIndex++;\n    } else {\n      colIndex++;\n    }\n  }\n  return row;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmputr3ullj.ts(40,3): error TS2322: Type 'number[]' is not assignable to type '[number, number][]'.\n  Type 'number' is not assignable to type '[number, number]'.\n",
      "timestamp": 1660334504
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const rowMap = new Map<number, number>();\n  const colMap = new Map<number, number>();\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowKey = rowMap.get(row) || row;\n    rowMap.set(row, rowKey);\n    for (let j = 0; j < cols; j++) {\n      const col = lst[i][j];\n      const colKey = colMap.get(col) || col;\n      colMap.set(col, colKey);\n      if (col === x) {\n        result.push([rowKey, colKey]);\n      }\n    }\n  }\n  result.sort((a, b) => {\n    const aRow = a[0];\n    const aCol = a[1];\n    const bRow = b[0];\n    const bCol = b[1];\n    if (aRow === bRow) {\n      return aCol - bCol;\n    }\n    return aRow - bRow;\n  });\n  result.sort((a, b) => {\n    const aRow = a[0];\n    const aCol = a[1];\n    const bRow = b[0];\n    const bCol = b[1];\n    if (aCol === bCol) {\n      return aRow - bRow;\n    }\n    return aCol - bCol;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpcdl49lpw.ts(24,31): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmpcdl49lpw.ts(25,16): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmpcdl49lpw.ts(31,22): error TS2322: Type 'number | number[]' is not assignable to type 'number'.\n  Type 'number[]' is not assignable to type 'number'.\n../../../../tmp/tmpcdl49lpw.ts(55,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334504
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < cols; j++) {\n      const element = row[j];\n      if (element === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  return result.sort((a, b) => {\n    if (a[0] < b[0]) {\n      return -1;\n    }\n    if (a[0] > b[0]) {\n      return 1;\n    }\n    return 0;\n  }).sort((a, b) => {\n    if (a[1] < b[1]) {\n      return -1;\n    }\n    if (a[1] > b[1]) {\n      return 1;\n    }\n    return 0;\n  });\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    [\n      0,\n      0\n    ]\n  ],\n  [\n    [\n      1,\n      0\n    ],\n    [\n      1,\n      4\n    ]\n  ],\n  [\n    [\n      2,\n      0\n    ],\n    [\n      2,\n      5\n    ]\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmpv7d2o9jw.js:55:12)\n    at Object.<anonymous> (/tmp/tmpv7d2o9jw.js:62:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ [ 0, 0 ] ], [ [ 1",
      "stdout": "",
      "timestamp": 1660334505
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [row, col] = lst[0].length;\n  const rows = [...new Array(row)].map(() => []);\n  for (let i = 0; i < row; i++) {\n    rows[i].push(0);\n  }\n  for (let i = 0; i < lst.length; i++) {\n    const [row, col] = lst[i].length;\n    for (let j = 0; j < col; j++) {\n      if (lst[i][j] === x) {\n        rows[row].push([i, j]);\n      }\n    }\n  }\n  rows.sort((a, b) => a[0] - b[0]);\n  rows.sort((a, b) => b[1] - a[1]);\n  return rows;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp0h94985b.ts(20,9): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmp0h94985b.ts(26,11): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmp0h94985b.ts(35,3): error TS2322: Type 'any[][]' is not assignable to type '[number, number][]'.\n  Type 'any[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334486
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [row_min, row_max] = rows.map(row => Math.min(row, x));\n  const [col_min, col_max] = cols.map(col => Math.max(col, x));\n  const row_range = row_max - row_min;\n  const col_range = col_max - col_min;\n  const rows: number[][] = [];\n  for (let row = row_min; row <= row_max; row++) {\n    const cols: number[] = [];\n    for (let col = col_min; col <= col_max; col++) {\n      if (row === row_min && col === col_min) {\n        cols.push(0);\n      } else if (row === row_min && col < col_min) {\n        cols.push(col);\n      } else if (row === row_min && col > col_min) {\n        cols.push(col - 1);\n      } else if (row < row_min && col === col_min) {\n        cols.push(col + 1);\n      } else if (row > row_min && col < col_min) {\n        cols.push(col - row_range + 1);\n      } else if (row > row_min && col > col_min) {\n        cols.push(col + row_range + 1);\n      }\n    }\n    rows.push(cols);\n  }\n  return rows.sort((a, b) => a[0] - b[0]).sort((a, b) => b[1] - a[1]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpc1z_oty5.ts(20,10): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpc1z_oty5.ts(25,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpc1z_oty5.ts(43,15): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number'.\n../../../../tmp/tmpc1z_oty5.ts(45,3): error TS2322: Type 'number[]' is not assignable to type '[number, number][]'.\n  Type 'number' is not assignable to type '[number, number]'.\n",
      "timestamp": 1660334504
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const [rows, cols] = lst;\n  const [row, col] = [x - 1, x - 1];\n  const result = [];\n  for (let i = 0; i < rows.length; i++) {\n    if (rows[i] === row) {\n      result.push([i, cols[i]]);\n    }\n  }\n  result.sort((a, b) => b[0] - a[0]);\n  result.sort((a, b) => b[1] - a[1]);\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmpg2_768o2.js:32:12)\n    at Object.<anonymous> (/tmp/tmpg2_768o2.js:39:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ [ 0, 0 ], [ 1, 4 ], [ 1, 0 ], [ 2, 5 ], [ 2, 0 ] ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660334505
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const coords: number[][] = [];\n  for (let i = 0; i < rows; i++) {\n    coords[i] = [];\n    for (let j = 0; j < cols; j++) {\n      coords[i][j] = lst[i][j];\n    }\n  }\n  coords.sort((a, b) => {\n    const aRow = a[0];\n    const bRow = b[0];\n    if (aRow < bRow) {\n      return -1;\n    } else if (aRow > bRow) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  const rowCoords = coords.map(row => row[0]);\n  coords.sort((a, b) => {\n    const aCol = a[1];\n    const bCol = b[1];\n    if (aCol < bCol) {\n      return -1;\n    } else if (aCol > bCol) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  const colCoords = coords.map(col => col[1]);\n  const result = [];\n  for (let i = 0; i < rowCoords.length; i++) {\n    const rowCoord = rowCoords[i];\n    for (let j = 0; j < colCoords.length; j++) {\n      const colCoord = colCoords[j];\n      if (rowCoord === colCoord) {\n        result.push([i, j]);\n      }\n    }\n  }\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmpbjf33i03.js:69:12)\n    at Object.<anonymous> (/tmp/tmpbjf33i03.js:76:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ [ 0, 0 ], [ 1, 4 ], [ 1, 0 ], [ 2, 5 ], [ 2, 0 ] ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660334505
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [row, col] = get_row_and_col(rows, cols);\n  const index = cols.indexOf(x);\n  if (index === -1) {\n    return [];\n  }\n  const [x, y] = get_row_and_col(row, index);\n  return [x, y];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp75xklobo.ts(16,35): error TS2300: Duplicate identifier 'x'.\n../../../../tmp/tmp75xklobo.ts(21,22): error TS2304: Cannot find name 'get_row_and_col'.\n../../../../tmp/tmp75xklobo.ts(26,10): error TS2300: Duplicate identifier 'x'.\n../../../../tmp/tmp75xklobo.ts(26,18): error TS2304: Cannot find name 'get_row_and_col'.\n",
      "timestamp": 1660334505
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows: number[][] = [];\n  const columns: number[] = [];\n  let row = 0;\n  let col = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === x) {\n      rows.push(row);\n      columns.push(col);\n      row++;\n      col = 0;\n    } else {\n      col++;\n    }\n  }\n  rows.push(row);\n  columns.push(col);\n  rows.sort(function (a, b) { return a - b; });\n  columns.sort(function (a, b) { return b - a; });\n  return rows.map(function (r) { return [r, columns[r]] });\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpk4vatmnr.ts(22,9): error TS2367: This condition will always return 'false' since the types 'number[]' and 'number' have no overlap.\n../../../../tmp/tmpk4vatmnr.ts(23,17): error TS2345: Argument of type 'number' is not assignable to parameter of type 'number[]'.\n../../../../tmp/tmpk4vatmnr.ts(31,13): error TS2345: Argument of type 'number' is not assignable to parameter of type 'number[]'.\n../../../../tmp/tmpk4vatmnr.ts(33,38): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmpk4vatmnr.ts(33,42): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmpk4vatmnr.ts(35,3): error TS2322: Type '[number[], any][]' is not assignable to type '[number, number][]'.\n  Type '[number[], any]' is not assignable to type '[number, number]'.\n    Type at position 0 in source is not compatible with type at position 0 in target.\n      Type 'nu",
      "timestamp": 1660334505
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [minRow, minCol] = rows.reduce(([minRow, minCol], row) => {\n    const [minRow, minCol] = row.reduce(([minRow, minCol], item) => {\n      if (item < minRow) {\n        return [item, item];\n      } else if (item > minRow) {\n        return [minRow, item];\n      }\n      return [minRow, minCol];\n    }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n    return [Math.min(minRow, x), Math.min(minCol, x)];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRow, maxCol] = rows.reduce(([maxRow, maxCol], row) => {\n    const [maxRow, maxCol] = row.reduce(([maxRow, maxCol], item) => {\n      if (item > maxRow) {\n        return [item, item];\n      } else if (item < maxRow) {\n        return [maxRow, item];\n      }\n      return [maxRow, maxCol];\n    }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n    return [Math.max(maxRow, x), Math.max(maxCol, x)];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const [minRow, minCol] = [minRow, minCol];\n  const [maxRow, maxCol] = [maxRow, maxCol];\n  const [minRow, maxCol] = [minRow, maxCol];\n  const [minRow, minCol] = [minRow, minCol];\n  const [maxRow, minCol] = [maxRow, minCol];\n  const [maxRow, maxCol] = [maxRow, maxCol];\n  const [minRow, maxCol] = [minRow, maxCol];\n  const [minRow, maxCol] = [minRow, maxCol];\n  const [minRow, minCol] = [minRow, minCol];\n  const [maxRow, minCol] = [maxRow, minCol];\n  const [maxRow, maxCol] = [maxRow, maxCol];\n  const [minRow, maxCol] = [minRow, maxCol];\n  const [minRow, minCol] = [minRow, minCol];\n  const [maxRow, minCol] = [maxRow, minCol];\n  const [maxRow, maxCol] = [maxRow, maxCol];\n  const [minRow, maxCol] = [minRow, maxCol];\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp0fuw49ui.ts(73,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334506
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [minRow, minCol] = rows.reduce(([minRow, minCol], row) => {\n    const [row, col] = row;\n    return [Math.min(row, minRow), Math.min(col, minCol)];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRow, maxCol] = rows.reduce(([maxRow, maxCol], row) => {\n    const [row, col] = row;\n    return [Math.max(row, maxRow), Math.max(col, maxCol)];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const rowIndex = rows.findIndex(row => row === x);\n  const colIndex = cols.findIndex(col => col === x);\n  const row = rowIndex < minRow ? rowIndex : minRow;\n  const col = colIndex < minCol ? colIndex : minCol;\n  return [row, col];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpv2brg46k.ts(21,59): error TS2300: Duplicate identifier 'row'.\n../../../../tmp/tmpv2brg46k.ts(22,11): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmpv2brg46k.ts(22,12): error TS2300: Duplicate identifier 'row'.\n../../../../tmp/tmpv2brg46k.ts(25,59): error TS2300: Duplicate identifier 'row'.\n../../../../tmp/tmpv2brg46k.ts(26,11): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmpv2brg46k.ts(26,12): error TS2300: Duplicate identifier 'row'.\n../../../../tmp/tmpv2brg46k.ts(33,11): error TS2322: Type 'number' is not assignable to type '[number, number]'.\n../../../../tmp/tmpv2brg46k.ts(33,16): error TS2322: Type 'number' is not assignable to type '[number, number]'.\n",
      "timestamp": 1660334506
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [row, col] = get_row_and_col(rows, cols);\n  const [x, y] = get_row_and_col(row, col);\n  if (x === x) {\n    return [x, y];\n  }\n  return [];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmphwa9v68x.ts(16,35): error TS2300: Duplicate identifier 'x'.\n../../../../tmp/tmphwa9v68x.ts(21,22): error TS2304: Cannot find name 'get_row_and_col'.\n../../../../tmp/tmphwa9v68x.ts(22,10): error TS2300: Duplicate identifier 'x'.\n../../../../tmp/tmphwa9v68x.ts(22,18): error TS2304: Cannot find name 'get_row_and_col'.\n",
      "timestamp": 1660334506
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].indexOf(x) !== -1) {\n      result.push([i, lst[i].indexOf(x)]);\n    }\n  }\n  result.sort((a, b) => {\n    if (a[0] > b[0]) return 1;\n    if (a[0] < b[0]) return -1;\n    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[1] > b[1]) return 1;\n    if (a[1] < b[1]) return -1;\n    return 0;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpaalt4eus.ts(33,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334506
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const row: number[][] = [];\n  let row_index = 0;\n  let col_index = 0;\n  while (row_index < lst.length) {\n    const row_length = lst[row_index].length;\n    while (col_index < row_length) {\n      if (lst[row_index][col_index] === x) {\n        row.push([row_index, col_index]);\n      }\n      col_index++;\n    }\n    row_index++;\n  }\n  row.sort((a, b) => a[0] - b[0]);\n  row.sort((a, b) => b[1] - a[1]);\n  return row;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp8rhhn_yn.ts(32,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334507
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < cols; j++) {\n      if (row[j] === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  return result.sort((a, b) => a[0] - b[0]).sort((a, b) => b[1] - a[1]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    [\n      0,\n      0\n    ]\n  ],\n  [\n    [\n      1,\n      0\n    ],\n    [\n      1,\n      4\n    ]\n  ],\n  [\n    [\n      2,\n      0\n    ],\n    [\n      2,\n      5\n    ]\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmpjs7p2tvc.js:35:12)\n    at Object.<anonymous> (/tmp/tmpjs7p2tvc.js:42:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ [ 0, 0 ] ], [ [ 1",
      "stdout": "",
      "timestamp": 1660334507
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const rows = [row];\n  const columns = [lst[0]];\n  const column_indexes = [lst[0].length - 1];\n  let row_index = 0;\n  let column_index = 0;\n  while (row_index < lst.length) {\n    const column = lst[row_index][column_index];\n    if (column === x) {\n      return row;\n    }\n    if (column < x) {\n      rows.push(row);\n      columns.push(column);\n      column_indexes.push(column_index);\n      row_index++;\n      column_index = 0;\n    } else {\n      column_index++;\n    }\n  }\n  return rows;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpsusf1qbq.ts(29,7): error TS2322: Type 'number[]' is not assignable to type '[number, number][]'.\n  Type 'number' is not assignable to type '[number, number]'.\n../../../../tmp/tmpsusf1qbq.ts(33,20): error TS2345: Argument of type 'number' is not assignable to parameter of type 'number[]'.\n../../../../tmp/tmpsusf1qbq.ts(41,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334507
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const coords: number[][] = [];\n  for (let row = 0; row < rows; row++) {\n    const rowCoords: number[] = [];\n    for (let col = 0; col < cols; col++) {\n      rowCoords.push(getCoord(row, col, lst));\n    }\n    coords.push(rowCoords);\n  }\n  const sortedCoords = coords.sort((a, b) => a[0] - b[0]);\n  const sortedRows = sortedCoords.map(a => a[1]);\n  const sortedCols = sortedCoords.map(a => a[2]);\n  const result: number[][] = [];\n  for (let row = 0; row < rows; row++) {\n    const rowCoords: number[] = [];\n    for (let col = 0; col < cols; col++) {\n      if (sortedRows.includes(row) && sortedCols.includes(col)) {\n        rowCoords.push(getCoord(row, col, lst));\n      }\n    }\n    result.push(rowCoords);\n  }\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp1xt8tenm.ts(26,22): error TS2304: Cannot find name 'getCoord'.\n../../../../tmp/tmp1xt8tenm.ts(38,24): error TS2304: Cannot find name 'getCoord'.\n../../../../tmp/tmp1xt8tenm.ts(43,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334507
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.map(row => row.map(i => i + x));\n  const rows = rows.sort((a, b) => a[0] - b[0]);\n  const cols = rows.map(row => row.slice().sort((a, b) => b[0] - a[0]));\n  return [...rows, ...cols];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpo430k_1r.ts(17,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpo430k_1r.ts(18,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpo430k_1r.ts(20,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334501
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [row, col] = lst[0].length;\n  const rows = [...Array(row)].map((_, i) => i);\n  const cols = [...Array(col)].map((_, i) => i);\n  const coords = rows.map((row) => {\n    const colIndex = cols.indexOf(row);\n    if (colIndex === -1) {\n      return [0, 0];\n    }\n    return lst[0].map((_, i) => [i, colIndex]);\n  });\n  coords.sort((a, b) => a[0] - b[0]);\n  coords.sort((a, b) => b[1] - a[1]);\n  return coords.map((coord) => [coord[0], coord[1]]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpwgzgfyh8.ts(20,9): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmpwgzgfyh8.ts(30,25): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmpwgzgfyh8.ts(30,32): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmpwgzgfyh8.ts(31,25): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmpwgzgfyh8.ts(31,32): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmpwgzgfyh8.ts(32,3): error TS2322: Type '[number | number[], number | number[]][]' is not assignable to type '[number, number][]'.\n  Type '[number | number[], number | number[]]' is not assignable to type '[number, number]'.\n    Type at pos",
      "timestamp": 1660334507
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows: number[][] = [];\n  const cols: number[] = [];\n  let row = 0;\n  let col = 0;\n  let rowMax = 0;\n  let colMax = 0;\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    const rowLen = row.length;\n    if (row === x) {\n      rows.push(row);\n      cols.push(col);\n      rowMax = rowLen;\n      colMax = colLen;\n    }\n    for (let j = 0; j < rowLen; j++) {\n      if (row[j] === x) {\n        rows.push(row);\n        cols.push(col);\n        rowMax = rowLen;\n        colMax = colLen;\n      }\n    }\n  }\n  rows.sort((a, b) => a - b);\n  cols.sort((a, b) => b - a);\n  const result = [];\n  for (let i = 0; i < rows.length; i++) {\n    for (let j = 0; j < cols.length; j++) {\n      result.push([rows[i], cols[j]]);\n    }\n  }\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpwesl3ftc.ts(26,9): error TS2367: This condition will always return 'false' since the types 'number[]' and 'number' have no overlap.\n../../../../tmp/tmpwesl3ftc.ts(30,16): error TS2304: Cannot find name 'colLen'.\n../../../../tmp/tmpwesl3ftc.ts(37,18): error TS2304: Cannot find name 'colLen'.\n../../../../tmp/tmpwesl3ftc.ts(41,23): error TS2362: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n../../../../tmp/tmpwesl3ftc.ts(41,27): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.\n",
      "timestamp": 1660334507
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const result = [row];\n  for (let i = 0; i < lst.length; i++) {\n    const curr = lst[i];\n    if (curr.indexOf(row[0]) === -1) {\n      continue;\n    }\n    for (let j = 0; j < curr.length; j++) {\n      if (curr[j] === row[0]) {\n        result.push([j, i]);\n      }\n    }\n  }\n  return result.sort((a, b) => {\n    if (a[0] < b[0]) {\n      return -1;\n    }\n    if (a[0] > b[0]) {\n      return 1;\n    }\n    return 0;\n  }).sort((a, b) => {\n    if (a[1] < b[1]) {\n      return -1;\n    }\n    if (a[1] > b[1]) {\n      return 1;\n    }\n    return 0;\n  });\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpn5yd0w3r.ts(33,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334507
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    if (row.includes(x)) {\n      result.push([i, row.indexOf(x)]);\n    }\n  }\n  result.sort((a, b) => {\n    if (a[1] > b[1]) return -1;\n    if (a[1] < b[1]) return 1;\n    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[0] > b[0]) return -1;\n    if (a[0] < b[0]) return 1;\n    return 0;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp2avgy73s.ts(34,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334507
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n\n  const [rows, cols] = lst;\n  const [row, col] = get_row_col(x, rows);\n  return [\n    [row, col],\n    ...get_row(rows.slice(0, row), col),\n    ...get_row(rows.slice(row), col),\n  ];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmppvz8pkxz.ts(22,22): error TS2304: Cannot find name 'get_row_col'.\n../../../../tmp/tmppvz8pkxz.ts(25,16): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number[][]'.\n  Type 'number' is not assignable to type 'number[]'.\n../../../../tmp/tmppvz8pkxz.ts(26,16): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'number[][]'.\n",
      "timestamp": 1660334508
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows: number[][] = [];\n  const columns: number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    const rowLength = row.length;\n    if (rowLength > x) {\n      continue;\n    }\n    for (let j = 0; j < rowLength; j++) {\n      const column = row[j];\n      if (column === x) {\n        rows.push(row);\n        columns.push(column);\n      }\n    }\n  }\n  rows.sort((a, b) => a[0] - b[0]);\n  columns.sort((a, b) => b[0] - a[0]);\n  return rows.map((row, index) => ([index, columns[index]]));\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmp8apg880w.js:40:12)\n    at Object.<anonymous> (/tmp/tmp8apg880w.js:47:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: [ [ 0, 0 ], [ 1, 4 ], [ 1, 0 ], [ 2, 5 ], [ 2, 0 ] ],\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "stdout": "",
      "timestamp": 1660334508
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.map(row => row.map(i => i + x));\n  const rows = rows.map(row => row.sort((a, b) => a - b));\n  const rows = rows.map(row => row.sort((a, b) => b - a));\n  return rows.map(row => row.map(i => [i, 0]));\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpehrtjop0.ts(17,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpehrtjop0.ts(18,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpehrtjop0.ts(19,9): error TS2451: Cannot redeclare block-scoped variable 'rows'.\n../../../../tmp/tmpehrtjop0.ts(20,3): error TS2322: Type 'number[][][]' is not assignable to type '[number, number][]'.\n  Type 'number[][]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334508
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [minRow, minCol] = rows.reduce(([minRow, minCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.min(minRow, row),\n      Math.min(minCol, col),\n    ];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRow, maxCol] = rows.reduce(([maxRow, maxCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.max(maxRow, row),\n      Math.max(maxCol, col),\n    ];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const [minRowInd, minColInd] = rows.reduce(([minRowInd, minColInd], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.min(minRowInd, i),\n      Math.min(minColInd, col),\n    ];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRowInd, maxColInd] = rows.reduce(([maxRowInd, maxColInd], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.max(maxRowInd, i),\n      Math.max(maxColInd, col),\n    ];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const [minRowIndInd, minColIndInd] = rows.reduce(([minRowIndInd, minColIndInd], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.min(minRowIndInd, i),\n      Math.min(minColIndInd, col),\n    ];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRowIndInd, maxColIndInd] = rows.reduce(([maxRowIndInd, maxColIndInd], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.max(maxRowIndInd, i),\n      Math.max(maxColIndInd, col),\n    ];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const [minRowIndIndInd, minColIndIndInd] = rows.reduce(([minRowInd\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp203dxj5b.ts(64,1): error TS1005: ',' expected.\n../../../../tmp/tmp203dxj5b.ts(64,9): error TS1005: ',' expected.\n../../../../tmp/tmp203dxj5b.ts(78,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334508
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const coords: number[][] = [];\n  for (let row = 0; row < rows; row++) {\n    const rowCoords: number[] = [];\n    for (let col = 0; col < cols; col++) {\n      rowCoords.push({ row: row, col: col });\n    }\n    coords.push(rowCoords);\n  }\n  coords.sort((a, b) => {\n    if (a.row < b.row) return -1;\n    if (a.row > b.row) return 1;\n    if (a.col < b.col) return -1;\n    if (a.col > b.col) return 1;\n    return 0;\n  });\n  const rowCoords = coords[coords.length - 1];\n  const rowIndex = rowCoords.row;\n  const rowCoordsIndex = rowCoords.col;\n  const rowCoordsIndexMax = rowCoordsIndex - 1;\n  const rowCoordsIndexMin = rowCoordsIndex + 1;\n  const colIndex = rowCoordsIndexMax - x;\n  const colCoordsIndex = rowCoordsIndexMin + x;\n  const colCoordsIndexMax = colCoordsIndex - 1;\n  const colCoordsIndexMin = colCoordsIndex + 1;\n  const coord = { row: rowIndex, col: colIndex };\n  const coords = [coord];\n  for (let row = 0; row < rows; row++) {\n    const rowCoords = coords[row];\n    const rowIndex = rowCoords.row;\n    const rowCoordsIndex = rowCoords.col;\n    const rowCoordsIndexMax = rowCoordsIndex - 1;\n    const rowCoordsIndexMin = rowCoordsIndex + 1;\n    for (let col = 0; col < cols; col++) {\n      const colCoords = coords[rowIndex][col];\n      const colIndex = colCoords.col;\n      const colCoordsIndex = colCoords.row;\n      const colCoordsIndexMax = colCoordsIndex - 1;\n      const colCoordsIndexMin = colCoordsIndex + 1;\n      if (colIndex === colCoordsIndexMax) {\n        coords.push({ row: rowIndex, col: colIndex + 1 });\n      } else if (colIndex === colCoordsIndexMin) {\n        coords.push({ row: rowIndex, col: colIndex - 1 });\n      } else if (rowIndex === rowCoordsIndexMax) {\n        coords.push({ row: rowIndex + 1, col: colIndex });\n      } else if (rowIndex === rowCoordsIndexMin) {\n        coords.push({ row: rowIndex - 1, col: colIndex });\n      }\n    }\n  }\n  return coords;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp2x47junk.ts(19,9): error TS2451: Cannot redeclare block-scoped variable 'coords'.\n../../../../tmp/tmp2x47junk.ts(23,22): error TS2345: Argument of type '{ row: number; col: number; }' is not assignable to parameter of type 'number'.\n../../../../tmp/tmp2x47junk.ts(28,11): error TS2339: Property 'row' does not exist on type 'number[]'.\n../../../../tmp/tmp2x47junk.ts(28,19): error TS2339: Property 'row' does not exist on type 'number[]'.\n../../../../tmp/tmp2x47junk.ts(29,11): error TS2339: Property 'row' does not exist on type 'number[]'.\n../../../../tmp/tmp2x47junk.ts(29,19): error TS2339: Property 'row' does not exist on type 'number[]'.\n../../../../tmp/tmp2x47junk.ts(30,11): error TS2339: Property 'col' does not exist on type 'number[]'.\n../../../../tmp/tmp2x47junk.ts(30,19): error TS2339: Property 'col' does not exist on type 'number[]'.\n../../../../tmp/tmp2x47junk.ts(31,11): error TS2339: Property 'col' does not exist on type 'number[]'.\n../../../../tmp/tmp2x47junk.ts(31,19): error TS2339",
      "timestamp": 1660334508
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst[0].length;\n  const [minRow, minCol] = lst[0].map(row => row.indexOf(x));\n  const maxRow = rows - 1;\n  const maxCol = cols - 1;\n  const result = [];\n  for (let row = 0; row <= maxRow; row++) {\n    for (let col = 0; col <= maxCol; col++) {\n      if (row === minRow && col === minCol) {\n        result.push([row, col]);\n      } else if (row === minRow) {\n        result.push([row, col]);\n      } else if (col === minCol) {\n        result.push([row, col]);\n      } else if (row === maxRow && col === maxCol) {\n        result.push([row, col]);\n      } else if (row === maxRow) {\n        result.push([row, col]);\n      } else if (col === maxCol) {\n        result.push([row, col]);\n      } else if (row === minRow && col === minCol) {\n        result.push([row, col]);\n      } else if (row === minRow) {\n        result.push([row, col]);\n      } else if (col === minCol) {\n        result.push([row, col]);\n      } else if (row === maxRow && col === maxCol) {\n        result.push([row, col]);\n      } else if (row === maxRow) {\n        result.push([row, col]);\n      } else if (col === maxCol) {\n        result.push([row, col]);\n      } else if (row === minRow && col === maxCol) {\n        result.push([row, col]);\n      } else if (row === minRow) {\n        result.push([row, col]);\n      } else if (col === maxCol) {\n        result.push([row, col]);\n      }\n    }\n  }\n  return result.sort((a, b) => b[0] - a[0]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpj7nshxcp.ts(20,9): error TS2488: Type 'number' must have a '[Symbol.iterator]()' method that returns an iterator.\n../../../../tmp/tmpj7nshxcp.ts(21,50): error TS2339: Property 'indexOf' does not exist on type 'number'.\n",
      "timestamp": 1660334508
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [minRow, minCol] = rows.reduce(([minRow, minCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.min(minRow, row),\n      Math.min(minCol, col),\n    ];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRow, maxCol] = rows.reduce(([maxRow, maxCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.max(maxRow, row),\n      Math.max(maxCol, col),\n    ];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const [minRowIndex, minColIndex] = rows.reduce(([minRowIndex, minColIndex], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.min(minRowIndex, i),\n      Math.min(minColIndex, col),\n    ];\n  }, [minRow, minCol]);\n  const [maxRowIndex, maxColIndex] = rows.reduce(([maxRowIndex, maxColIndex], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.max(maxRowIndex, i),\n      Math.max(maxColIndex, col),\n    ];\n  }, [maxRow, maxCol]);\n  const [minRowIndex, minColIndex] = rows.reduce(([minRowIndex, minColIndex], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.min(minRowIndex, i),\n      Math.min(minColIndex, col),\n    ];\n  }, [minRow, minCol]);\n  const [maxRowIndex, maxColIndex] = rows.reduce(([maxRowIndex, maxColIndex], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.max(maxRowIndex, i),\n      Math.max(maxColIndex, col),\n    ];\n  }, [maxRow, maxCol]);\n  const [minRowIndex, minColIndex] = rows.reduce(([minRowIndex, minColIndex], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.min(minRowIndex, i),\n      Math.min(minColIndex, col),\n    ];\n  }, [minRow, minCol]);\n  const [maxRowIndex, maxColIndex] = rows.reduce(([maxRowIndex, maxColIndex], row, i) => {\n    const [row, col] = row;\n    return [\n      Math.max(maxRowIndex, i),\n      Math.\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpzc9i_x60.ts(74,12): error TS1003: Identifier expected.\n../../../../tmp/tmpzc9i_x60.ts(75,1): error TS1005: ',' expected.\n../../../../tmp/tmpzc9i_x60.ts(75,9): error TS1005: ',' expected.\n../../../../tmp/tmpzc9i_x60.ts(89,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334508
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n\n  const row = [x];\n  const rows = [row];\n  const columns = [lst[0]];\n\n  for (let i = 1; i < lst.length; i++) {\n    const column = lst[i];\n    const columnIndex = columns.indexOf(column);\n    if (columnIndex === -1) {\n      columns.push(column);\n      rows.push([]);\n    }\n    rows[rows.length - 1].push(columnIndex);\n  }\n\n  rows.sort((a, b) => {\n    return a[0] - b[0];\n  });\n\n  columns.sort((a, b) => {\n    return b[1] - a[1];\n  });\n\n  const result = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    for (let j = 0; j < row.length; j++) {\n      const column = columns[j];\n      result.push([i, column]);\n    }\n  }\n\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    0,\n    [\n      1,\n      2,\n      3,\n      4,\n      5,\n      6\n    ]\n  ],\n  [\n    1,\n    [\n      1,\n      2,\n      3,\n      4,\n      5,\n      6\n    ]\n  ],\n  [\n    2,\n    [\n      1,\n      2,\n      3,\n      4,\n      5,\n      6\n    ]\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmp0q0rqpe9.js:51:12)\n    at Object.<anonymous> (/tmp/tmp0q0rqpe9.js:58:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMe",
      "stdout": "",
      "timestamp": 1660334508
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n  for (let row = 0; row < rows; row++) {\n    const rowResult = [];\n    for (let col = 0; col < cols; col++) {\n      if (lst[row][col] === x) {\n        rowResult.push([row, col]);\n      }\n    }\n    result.push(rowResult);\n  }\n  return result.sort((a, b) => b[1] - a[1]).sort((a, b) => b[0] - a[0]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    [\n      0,\n      0\n    ]\n  ],\n  [\n    [\n      1,\n      0\n    ],\n    [\n      1,\n      4\n    ]\n  ],\n  [\n    [\n      2,\n      0\n    ],\n    [\n      2,\n      5\n    ]\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmptquf28jv.js:34:12)\n    at Object.<anonymous> (/tmp/tmptquf28jv.js:41:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ [ 0, 0 ] ], [ [ 1",
      "stdout": "",
      "timestamp": 1660334508
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [minRow, minCol] = rows.reduce(([minRow, minCol], row) => {\n    const [row, col] = row;\n    return [Math.min(row, minRow), Math.min(col, minCol)];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRow, maxCol] = rows.reduce(([maxRow, maxCol], row) => {\n    const [row, col] = row;\n    return [Math.max(row, maxRow), Math.max(col, maxCol)];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const [row, col] = Math.min(Math.max(x, minRow), maxRow), Math.min(Math.max(x, minCol), maxCol);\n  return rows.map((row) => [Math.min(row, rows), Math.min(col, cols)]);\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpg1q6usq3.ts(29,65): error TS1005: ',' expected.\n../../../../tmp/tmpg1q6usq3.ts(29,69): error TS1005: ',' expected.\n",
      "timestamp": 1660334508
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const n = lst.length;\n  const m = lst[0].length;\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    const row = lst[i];\n    const rowLen = row.length;\n    for (let j = 0; j < m; j++) {\n      if (row[j] === x) {\n        result.push([i, j]); // row, column\n      }\n    }\n  }\n  result.sort((a, b) => a[0] - b[0]);\n  result.sort((a, b) => b[1] - a[1]);\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    2,\n    5\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    0\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmpbn2sizw3.js:36:12)\n    at Object.<anonymous> (/tmp/tmpbn2sizw3.js:43:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ 2, 5 ], [ 1, 4 ], [ 0, 0 ], [ 1, 0 ], [ 2, 0 ] ],\n  expected: [ [ 0, 0 ], [ 1, 4 ",
      "stdout": "",
      "timestamp": 1660334508
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  const rows = lst.length;\n  const cols = lst[0].length;\n  for (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < cols; j++) {\n      if (row[j] === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    if (a[0] > b[0]) {\n      return 1;\n    }\n    if (a[0] < b[0]) {\n      return -1;\n    }\n    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[1] > b[1]) {\n      return 1;\n    }\n    if (a[1] < b[1]) {\n      return -1;\n    }\n    return 0;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpy0j20wx6.ts(48,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334487
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [row, col] = lst[0].length;\n  const [minRow, minCol] = lst.reduce(([minRow, minCol], rowArr) => {\n    const [minRow, minCol] = rowArr.length;\n    return [Math.min(minRow, minCol), Math.max(minRow, minCol)];\n  }, [row, col]);\n  const [maxRow, maxCol] = lst.reduce(([maxRow, maxCol], rowArr) => {\n    const [maxRow, maxCol] = rowArr.length;\n    return [Math.max(maxRow, maxCol), Math.min(maxRow, maxCol)];\n  }, [row, col]);\n  const [minRow, minCol] = [minRow, minCol];\n  const [maxRow, maxCol] = [maxRow, maxCol];\n  const [minRow, maxCol] = [minRow, maxCol];\n  const [minRow, minCol] = [minRow, minCol];\n  const [maxRow, minCol] = [maxRow, minCol];\n  const [maxRow, maxCol] = [maxRow, maxCol];\n  const [minRow, maxCol] = [minRow, maxCol];\n  const [minRow, minCol] = [minRow, minCol];\n  const [maxRow, minCol] = [maxRow, minCol];\n  const [maxRow, maxCol] = [maxRow, maxCol];\n  const [minRow, maxCol] = [minRow, maxCol];\n  const [minRow, minCol] = [minRow, minCol];\n  const [maxRow, minCol] = [maxRow, minCol];\n  const [maxRow, maxCol] = [maxRow, maxCol];\n  const [minRow, maxCol] = [minRow, maxCol];\n  const [minRow, minCol] = [minRow, minCol];\n  const [maxRow, minCol] = [maxRow, minCol];\n  const [maxRow, maxCol] = [maxRow, maxCol];\n  const [minRow, maxCol] = [minRow, maxCol];\n  const [minRow, minCol] = [minRow, minCol];\n  const [maxRow, minCol] = [maxRow, minCol];\n  const [maxRow, maxCol] = [maxRow, maxCol];\n  const [minRow, maxCol] = [minRow, maxCol];\n  const [minRow, minCol] = [minRow, minCol];\n  const [maxRow, minCol] = [maxRow, minCol];\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmptd6tz_03.ts(68,8): error TS1005: '}' expected.\n",
      "timestamp": 1660334509
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const n = lst.length;\n  const m = lst[0].length;\n  const coords: number[][] = [];\n  for (let i = 0; i < n; i++) {\n    const row = [];\n    for (let j = 0; j < m; j++) {\n      if (lst[i][j] === x) {\n        row.push([i, j]);\n      }\n    }\n    coords.push(row);\n  }\n  coords.sort((a, b) => {\n    const aRow = a[0][0];\n    const bRow = b[0][0];\n    if (aRow > bRow) return 1;\n    if (aRow < bRow) return -1;\n    return 0;\n  });\n  coords.sort((a, b) => {\n    const aCol = a[0][1];\n    const bCol = b[0][1];\n    if (aCol > bCol) return 1;\n    if (aCol < bCol) return -1;\n    return 0;\n  });\n  return coords;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpoqmqomgf.ts(43,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334509
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    if (row.includes(x)) {\n      result.push([i, row.indexOf(x)]);\n    }\n  }\n  result.sort((a, b) => {\n    if (a[0] < b[0]) return -1;\n    if (a[0] > b[0]) return 1;\n    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[1] < b[1]) return -1;\n    if (a[1] > b[1]) return 1;\n    return 0;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp5qvnmasc.ts(34,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334501
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const rows = lst.length;\n  const cols = lst[0].length;\n  const coords: number[][] = [];\n  for (let row = 0; row < rows; row++) {\n    const rowCoords: number[] = [];\n    for (let col = 0; col < cols; col++) {\n      rowCoords.push(lst[row][col]);\n    }\n    coords.push(rowCoords);\n  }\n  coords.sort((a, b) => a[0] - b[0]);\n  for (let row = 0; row < rows; row++) {\n    coords[row].sort((a, b) => b[1] - a[1]);\n  }\n  const result: number[][] = [];\n  for (let row = 0; row < rows; row++) {\n    const rowCoords: number[] = [];\n    for (let col = 0; col < cols; col++) {\n      rowCoords.push(coords[row][col]);\n    }\n    result.push(rowCoords);\n  }\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmpens5q_cc.ts(39,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334509
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [row, col] = get_row_col(rows, cols);\n  const [x, y] = get_row_col(row, col);\n  if (x === x) {\n    return [x, y];\n  }\n  return [];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp64wjdw8f.ts(16,35): error TS2300: Duplicate identifier 'x'.\n../../../../tmp/tmp64wjdw8f.ts(21,22): error TS2304: Cannot find name 'get_row_col'.\n../../../../tmp/tmp64wjdw8f.ts(22,10): error TS2300: Duplicate identifier 'x'.\n../../../../tmp/tmp64wjdw8f.ts(22,18): error TS2304: Cannot find name 'get_row_col'.\n",
      "timestamp": 1660334509
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [row, col] = get_row_and_col(rows, cols);\n  const [x, y] = get_row_and_col(row, col);\n  if (x === x) {\n    return [\n      [row, col],\n    ];\n  }\n  if (y === y) {\n    return [\n      [row, col],\n      [row, col - 1],\n    ];\n  }\n  return [];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp76z08vpa.ts(16,35): error TS2300: Duplicate identifier 'x'.\n../../../../tmp/tmp76z08vpa.ts(21,22): error TS2304: Cannot find name 'get_row_and_col'.\n../../../../tmp/tmp76z08vpa.ts(22,10): error TS2300: Duplicate identifier 'x'.\n../../../../tmp/tmp76z08vpa.ts(22,18): error TS2304: Cannot find name 'get_row_and_col'.\n",
      "timestamp": 1660334509
    },
    {
      "exit_code": 1,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const n = lst.length;\n  const m = lst[0].length;\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    const row = lst[i];\n    const rowLen = row.length;\n    for (let j = 0; j < m; j++) {\n      if (row[j] === x) {\n        result.push([i, j]);\n      }\n    }\n  }\n  result.sort((a, b) => {\n    if (a[0] < b[0]) return -1;\n    if (a[0] > b[0]) return 1;\n    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[1] < b[1]) return -1;\n    if (a[1] > b[1]) return 1;\n    return 0;\n  });\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "AssertionError",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    2,\n    5\n  ]\n]\n\nshould loosely deep-equal\n\n[\n  [\n    0,\n    0\n  ],\n  [\n    1,\n    4\n  ],\n  [\n    1,\n    0\n  ],\n  [\n    2,\n    5\n  ],\n  [\n    2,\n    0\n  ]\n]\n    at test (/tmp/tmp6o6wvrhn.js:48:12)\n    at Object.<anonymous> (/tmp/tmp6o6wvrhn.js:55:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ [ 0, 0 ], [ 1, 0 ], [ 2, 0 ], [ 1, 4 ], [ 2, 5 ] ],\n  expected: [ [ 0, 0 ], [ 1, 4 ",
      "stdout": "",
      "timestamp": 1660334509
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  const result: number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    if (row.indexOf(x) !== -1) {\n      result.push([i, row.indexOf(x)]);\n    }\n  }\n  result.sort((a, b) => a[1] - b[1]);\n  result.sort((a, b) => b[0] - a[0]);\n  return result;\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp6c7twgul.ts(26,3): error TS2322: Type 'number[][]' is not assignable to type '[number, number][]'.\n  Type 'number[]' is not assignable to type '[number, number]'.\n    Target requires 2 element(s) but source may have fewer.\n",
      "timestamp": 1660334483
    },
    {
      "exit_code": 2,
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([], 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst: number[][], x: number): [number, number][] {\n  if (lst.length === 0) {\n    return [];\n  }\n\n  const [rows, cols] = lst;\n  const [row, col] = get_row_and_col(rows, cols, x);\n\n  return [\n    ...sort_coordinates(row, cols, cols, cols, cols),\n    ...sort_coordinates(row, cols, cols, cols, cols),\n  ];\n}\n\ndeclare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();",
      "status": "SyntaxError",
      "stderr": "",
      "stdout": "../../../../tmp/tmp0pok92ue.ts(22,22): error TS2304: Cannot find name 'get_row_and_col'.\n../../../../tmp/tmp0pok92ue.ts(25,8): error TS2304: Cannot find name 'sort_coordinates'.\n../../../../tmp/tmp0pok92ue.ts(26,8): error TS2304: Cannot find name 'sort_coordinates'.\n",
      "timestamp": 1660334509
    }
  ]
}