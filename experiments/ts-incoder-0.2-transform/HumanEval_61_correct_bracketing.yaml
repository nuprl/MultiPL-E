name: HumanEval_61_correct_bracketing
language: ts
prompt: "//brackets is a string of \"(\" and \")\".\n// return True if every opening\
  \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
  )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
  (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunction correct_bracketing(brackets:\
  \ string): boolean {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = correct_bracketing;\n  assert.deepEqual(candidate(\"\
  ()\"),true);\n  assert.deepEqual(candidate(\"(()())\"),true);\n  assert.deepEqual(candidate(\"\
  ()()(()())()\"),true);\n  assert.deepEqual(candidate(\"()()((()()())())(()()(()))\"\
  ),true);\n  assert.deepEqual(candidate(\"((()())))\"),false);\n  assert.deepEqual(candidate(\"\
  )(()\"),false);\n  assert.deepEqual(candidate(\"(\"),false);\n  assert.deepEqual(candidate(\"\
  ((((\"),false);\n  assert.deepEqual(candidate(\")\"),false);\n  assert.deepEqual(candidate(\"\
  (()\"),false);\n  assert.deepEqual(candidate(\"()()(()())())(()\"),false);\n  assert.deepEqual(candidate(\"\
  ()()(()())()))()\"),false);\n}\n\ntest();"
completions: ["\tlet opening_brackets = brackets.split(\"\");\n\tlet closing_brackets\
    \ = brackets.split(\"\").reverse();\n\tlet opening_brackets_set = opening_brackets.reduce((set,\
    \ opening_bracket) => {\n\t\tset.add(opening_bracket);\n\t\treturn set;\n\t},\
    \ new Set<string>());\n\tlet closing_brackets_set = closing_brackets.reduce((set,\
    \ closing_bracket) => {\n\t\tset.add(closing_bracket);\n\t\treturn set;\n\t},\
    \ new Set<string>());\n\treturn opening_brackets_set.size == closing_brackets_set.size;\n\
    }\n", "  const stack: string[] = [];\n  for (let i = 0; i < brackets.length; ++i)\
    \ {\n    const bracket = brackets[i];\n    if (bracket === \"(\") {\n      stack.push(bracket);\n\
    \    } else if (bracket === \")\") {\n      if (stack.length === 0) {\n      \
    \  return false;\n      }\n      const opening = stack.pop();\n      if (opening\
    \ !== bracket) {\n        return false;\n      }\n    } else {\n      return false;\n\
    \    }\n  }\n  if (stack.length > 0) {\n    return false;\n  }\n  return true;\n\
    }\n", "\tlet open_brackets = brackets.split(\"\");\n\tlet closed_brackets = \"\
    \";\n\tfor (let i = 0; i < open_brackets.length; i++) {\n\t\tlet open_bracket\
    \ = open_brackets[i];\n\t\tlet closed_bracket = open_bracket;\n\t\tfor (let j\
    \ = i + 1; j < open_brackets.length; j++) {\n\t\t\tclosed_bracket += open_brackets[j];\n\
    \t\t\tif (closed_brackets.indexOf(closed_bracket) == -1) {\n\t\t\t\tclosed_brackets\
    \ += closed_bracket;\n\t\t\t}\n\t\t}\n\t\tif (closed_brackets.indexOf(closed_bracket)\
    \ == -1) {\n\t\t\tclosed_brackets += closed_bracket;\n\t\t}\n\t}\n\treturn closed_brackets.length\
    \ == brackets.length;\n}\n", "\tlet opening_brackets: number[] = [];\n\tlet closing_brackets:\
    \ number[] = [];\n\tfor (let i = 0; i < brackets.length; i++) {\n\t\tlet bracket\
    \ = brackets[i];\n\t\tif (bracket === \"(\") {\n\t\t\topening_brackets.push(i);\n\
    \t\t} else if (bracket === \")\") {\n\t\t\tclosing_brackets.push(i);\n\t\t}\n\t\
    }\n\tif (opening_brackets.length !== closing_brackets.length) {\n\t\treturn false;\n\
    \t}\n\tfor (let i = 0; i < opening_brackets.length; i++) {\n\t\tlet opening_bracket\
    \ = opening_brackets[i];\n\t\tlet closing_bracket = closing_brackets[i];\n\t\t\
    if (opening_bracket === closing_bracket) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (opening_bracket\
    \ > closing_bracket) {\n\t\t\tlet temp = opening_bracket;\n\t\t\topening_bracket\
    \ = closing_bracket;\n\t\t\tclosing_bracket = temp;\n\t\t}\n\t\tlet opening_chars\
    \ = brackets.slice(0, opening_bracket);\n\t\tlet closing_chars = brackets.slice(opening_bracket,\
    \ closing_bracket);\n\t\tif (opening_chars.join(\"\") !== closing_chars.join(\"\
    \")) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", "\tlet opening\
    \ = brackets.substr(0, 1);\n\tlet closing = brackets.substr(brackets.length -\
    \ 1, 1);\n\treturn opening === closing;\n}\n", "\tlet stack: string[] = [];\n\t\
    let opening_brackets: string[] = [];\n\tlet closing_brackets: string[] = [];\n\
    \tfor (let i = 0; i < brackets.length; i++) {\n\t\tlet bracket = brackets[i];\n\
    \t\tif (bracket.match(/[\\(\\)]/)) {\n\t\t\tstack.push(bracket);\n\t\t\topening_brackets.push(bracket);\n\
    \t\t} else if (bracket.match(/[\\[\\]]/)) {\n\t\t\tif (stack.length > 0) {\n\t\
    \t\t\tclosing_brackets.push(stack.pop());\n\t\t\t}\n\t\t} else {\n\t\t\tif (stack.length\
    \ > 0) {\n\t\t\t\tclosing_brackets.push(stack.pop());\n\t\t\t}\n\t\t}\n\t}\n\t\
    if (stack.length > 0) {\n\t\tclosing_brackets.push(stack.pop());\n\t}\n\treturn\
    \ (opening_brackets.length === closing_brackets.length);\n}\n", "\tlet stack:\
    \ string[] = [];\n\tfor (let i = 0; i < brackets.length; i++) {\n\t\tlet bracket\
    \ = brackets[i];\n\t\tif (bracket == \"(\") {\n\t\t\tstack.push(bracket);\n\t\t\
    } else if (bracket == \")\") {\n\t\t\tif (stack.length == 0) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\tlet opening = stack.pop();\n\t\t\tif (opening != bracket)\
    \ {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif (stack.length != 0) {\n\t\
    \treturn false;\n\t}\n\treturn true;\n}\n", "  const opening_brackets = brackets.split('(');\n\
    \  const closing_brackets = brackets.split(')');\n  for (let i = 0; i < opening_brackets.length;\
    \ i++) {\n    if (closing_brackets.length < opening_brackets[i]) {\n      return\
    \ false;\n    }\n  }\n  return true;\n}\n", "\tlet opening_brackets = brackets.split(\"\
    \");\n\tlet closing_brackets = brackets.split(\"\").reverse();\n\tlet opening_brackets_count\
    \ = opening_brackets.length;\n\tlet closing_brackets_count = closing_brackets.length;\n\
    \n\tfor (let i = 0; i < opening_brackets_count; i++) {\n\t\tlet opening_bracket\
    \ = opening_brackets[i];\n\t\tlet closing_bracket = closing_brackets[i];\n\n\t\
    \tif (opening_bracket != closing_bracket) {\n\t\t\treturn false;\n\t\t}\n\t}\n\
    \n\treturn true;\n}\n", "\tlet opening_brackets: number[] = [];\n\tlet closing_brackets:\
    \ number[] = [];\n\tfor (let i = 0; i < brackets.length; i++) {\n\t\tlet bracket\
    \ = brackets[i];\n\t\tif (bracket.includes(\"(\")) {\n\t\t\topening_brackets.push(i);\n\
    \t\t} else if (bracket.includes(\")\")) {\n\t\t\tclosing_brackets.push(i);\n\t\
    \t}\n\t}\n\treturn (\n\t\topening_brackets.length === closing_brackets.length\
    \ &&\n\t\topening_brackets.every((open, index) => {\n\t\t\treturn closing_brackets[index]\
    \ === open;\n\t\t})\n\t);\n}\n", "\tlet opening_brackets = brackets.split('(');\n\
    \tlet closing_brackets = brackets.split(')');\n\tlet opening_brackets_length =\
    \ opening_brackets.length;\n\tlet closing_brackets_length = closing_brackets.length;\n\
    \tfor (let i = 0; i < opening_brackets_length; i++) {\n\t\tlet opening_bracket\
    \ = opening_brackets[i];\n\t\tlet closing_bracket = closing_brackets[i];\n\t\t\
    if (opening_bracket !== closing_bracket) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\
    return true;\n}\n", "\tlet open_brackets = brackets.split(\"(\");\n\tlet closed_brackets\
    \ = brackets.split(\")\");\n\tlet open_brackets_length = open_brackets.length;\n\
    \tlet closed_brackets_length = closed_brackets.length;\n\tlet i = 0;\n\tlet j\
    \ = 0;\n\twhile (i < open_brackets_length && j < closed_brackets_length) {\n\t\
    \tif (open_brackets[i] === closed_brackets[j]) {\n\t\t\ti++;\n\t\t\tj++;\n\t\t\
    } else {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn (i === open_brackets_length)\
    \ && (j === closed_brackets_length);\n}\n", "\tlet opening_brackets = brackets.split(\"\
    \");\n\tlet closing_brackets = brackets.split(\"\").reverse();\n\tlet opening_brackets_count\
    \ = opening_brackets.length;\n\tlet closing_brackets_count = closing_brackets.length;\n\
    \tfor (let i = 0; i < opening_brackets_count; i++) {\n\t\tlet opening_bracket\
    \ = opening_brackets[i];\n\t\tlet closing_bracket = closing_brackets[i];\n\t\t\
    if (opening_bracket === closing_bracket) {\n\t\t\topening_brackets_count -= 1;\n\
    \t\t\tclosing_brackets_count -= 1;\n\t\t}\n\t}\n\treturn opening_brackets_count\
    \ === closing_brackets_count;\n}\n", "\tlet opening_brackets: number[] = [];\n\
    \tlet closing_brackets: number[] = [];\n\tfor (let i = 0; i < brackets.length;\
    \ ++i) {\n\t\tlet bracket = brackets[i];\n\t\tif (bracket.match(/[()]/)) {\n\t\
    \t\topening_brackets.push(i);\n\t\t} else if (bracket.match(/[)]/)) {\n\t\t\t\
    closing_brackets.push(i);\n\t\t}\n\t}\n\tfor (let i = 0; i < opening_brackets.length;\
    \ ++i) {\n\t\tlet opening_bracket = opening_brackets[i];\n\t\tlet closing_bracket\
    \ = closing_brackets[i];\n\t\tif (opening_bracket === closing_bracket) {\n\t\t\
    \treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", "  if (brackets.length ===\
    \ 0) {\n    return false;\n  }\n  const stack: string[] = [];\n  for (let i =\
    \ 0; i < brackets.length; i += 1) {\n    const bracket = brackets[i];\n    if\
    \ (bracket === '(') {\n      stack.push(bracket);\n    } else if (bracket ===\
    \ ')') {\n      if (stack.length === 0) {\n        return false;\n      }\n  \
    \    const openingBracket = stack.pop();\n      if (openingBracket !== '(') {\n\
    \        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n\
    \  return true;\n}\n", "  const stack: string[] = [];\n  for (let i = 0; i < brackets.length;\
    \ ++i) {\n    const bracket = brackets[i];\n    if (bracket == \"(\") {\n    \
    \  stack.push(bracket);\n    } else if (bracket == \")\") {\n      if (stack.length\
    \ == 0) {\n        return false;\n      }\n      const opening = stack.pop();\n\
    \      if (opening != bracket) {\n        return false;\n      }\n    }\n  }\n\
    \  if (stack.length != 0) {\n    return false;\n  }\n  return true;\n}\n", "\t\
    let opening_brackets = brackets.split(\"\");\n\tlet closing_brackets = brackets.split(\"\
    \").reverse();\n\tlet opening_brackets_count = opening_brackets.length;\n\tlet\
    \ closing_brackets_count = closing_brackets.length;\n\tfor (let i = 0; i < opening_brackets_count;\
    \ i++) {\n\t\tlet opening_bracket = opening_brackets[i];\n\t\tlet closing_bracket\
    \ = closing_brackets[i];\n\t\tif (opening_bracket != closing_bracket) {\n\t\t\t\
    return false;\n\t\t}\n\t}\n\treturn true;\n}\n", "  let opening_brackets = brackets.split(\"\
    \");\n  let closing_brackets = brackets.split(\"\").reverse();\n  let opening_brackets_count\
    \ = opening_brackets.length;\n  let closing_brackets_count = closing_brackets.length;\n\
    \  let opening_brackets_index = 0;\n  let closing_brackets_index = 0;\n  while\
    \ (opening_brackets_index < opening_brackets_count && closing_brackets_index <\
    \ closing_brackets_count) {\n    if (opening_brackets[opening_brackets_index]\
    \ == closing_brackets[closing_brackets_index]) {\n      opening_brackets_index++;\n\
    \      closing_brackets_index++;\n    } else {\n      return false;\n    }\n \
    \ }\n  return opening_brackets_index == opening_brackets_count;\n}\n", "\tlet\
    \ opening_brackets: number[] = [];\n\tlet closing_brackets: number[] = [];\n\t\
    for (let i = 0; i < brackets.length; ++i) {\n\t\tlet bracket = brackets[i];\n\t\
    \tif (bracket == \"(\") {\n\t\t\topening_brackets.push(i);\n\t\t} else if (bracket\
    \ == \")\") {\n\t\t\tclosing_brackets.push(i);\n\t\t}\n\t}\n\tfor (let i = 0;\
    \ i < opening_brackets.length; ++i) {\n\t\tlet opening_bracket = opening_brackets[i];\n\
    \t\tlet closing_bracket = closing_brackets[i];\n\t\tif (closing_bracket < opening_bracket)\
    \ {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n", "\tlet opening_brackets:\
    \ number[] = [];\n\tlet closing_brackets: number[] = [];\n\tfor (let i = 0; i\
    \ < brackets.length; i++) {\n\t\tlet bracket = brackets[i];\n\t\tif (bracket ==\
    \ \"(\") {\n\t\t\topening_brackets.push(i);\n\t\t} else if (bracket == \")\")\
    \ {\n\t\t\tclosing_brackets.push(i);\n\t\t}\n\t}\n\tif (opening_brackets.length\
    \ != closing_brackets.length) {\n\t\treturn false;\n\t}\n\tfor (let i = 0; i <\
    \ opening_brackets.length; i++) {\n\t\tlet opening_bracket = opening_brackets[i];\n\
    \t\tlet closing_bracket = closing_brackets[i];\n\t\tif (opening_bracket < closing_bracket)\
    \ {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
