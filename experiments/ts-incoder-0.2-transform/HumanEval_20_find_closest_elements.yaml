name: HumanEval_20_find_closest_elements
language: ts
prompt: "//From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n// other and return them in order (smaller number,\
  \ larger number).\n// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
  // [2.0, 2.2]\n// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n//\
  \ [2.0, 2.0]\nfunction find_closest_elements(numbers: number[]): [number, number]\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = find_closest_elements;\n  assert.deepEqual(candidate([1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2]),[3.9, 4.0]);\n  assert.deepEqual(candidate([1.0, 2.0,\
  \ 5.9, 4.0, 5.0]),[5.0, 5.9]);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0,\
  \ 5.0, 2.2]),[2.0, 2.2]);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.0]),[2.0, 2.0]);\n  assert.deepEqual(candidate([1.1, 2.2, 3.1, 4.1, 5.1]),[2.2,\
  \ 3.1]);\n}\n\ntest();"
completions: ["\tlet min: number = numbers[0];\n\tlet max: number = numbers[0];\n\t\
    for (let i = 1; i < numbers.length; i++) {\n\t\tif (numbers[i] < min) {\n\t\t\t\
    min = numbers[i];\n\t\t} else if (numbers[i] > max) {\n\t\t\tmax = numbers[i];\n\
    \t\t}\n\t}\n\treturn [min, max];\n}\n", "\tlet min: number = numbers[0];\n\tlet\
    \ max: number = numbers[0];\n\tfor (let i = 1; i < numbers.length; i++) {\n\t\t\
    min = Math.min(min, numbers[i]);\n\t\tmax = Math.max(max, numbers[i]);\n\t}\n\t\
    return [min, max];\n}\n", "\tlet min: number = numbers[0];\n\tlet max: number\
    \ = numbers[0];\n\tfor (let i = 1; i < numbers.length; i++) {\n\t\tif (numbers[i]\
    \ < min) {\n\t\t\tmin = numbers[i];\n\t\t} else if (numbers[i] > max) {\n\t\t\t\
    max = numbers[i];\n\t\t}\n\t}\n\treturn [min, max];\n}\n", "\tlet min: number\
    \ = numbers[0];\n\tlet max: number = numbers[0];\n\tfor (let i = 1; i < numbers.length;\
    \ i++) {\n\t\tif (numbers[i] < min) {\n\t\t\tmin = numbers[i];\n\t\t} else if\
    \ (numbers[i] > max) {\n\t\t\tmax = numbers[i];\n\t\t}\n\t}\n\treturn [min, max];\n\
    }\n", "\tlet min: number = numbers[0];\n\tlet max: number = numbers[0];\n\tfor\
    \ (let i = 1; i < numbers.length; i++) {\n\t\tif (numbers[i] < min) {\n\t\t\t\
    min = numbers[i];\n\t\t}\n\t\tif (numbers[i] > max) {\n\t\t\tmax = numbers[i];\n\
    \t\t}\n\t}\n\treturn [min, max];\n}\n", "\tlet min: number = numbers[0];\n\tlet\
    \ max: number = numbers[0];\n\tfor (let i = 1; i < numbers.length; i++) {\n\t\t\
    min = Math.min(min, numbers[i]);\n\t\tmax = Math.max(max, numbers[i]);\n\t}\n\t\
    return [min, max];\n}\n", "\tlet min: number = numbers[0];\n\tlet max: number\
    \ = numbers[0];\n\tfor (let i = 1; i < numbers.length; i++) {\n\t\tif (numbers[i]\
    \ < min) {\n\t\t\tmin = numbers[i];\n\t\t} else if (numbers[i] > max) {\n\t\t\t\
    max = numbers[i];\n\t\t}\n\t}\n\treturn [min, max];\n}\n", "\tlet min1 = numbers[0];\n\
    \tlet min2 = numbers[0];\n\tfor (let i = 1; i < numbers.length; i++) {\n\t\tlet\
    \ d = Math.abs(min1 - numbers[i]);\n\t\tif (d < Math.abs(min2 - numbers[i])) {\n\
    \t\t\tmin2 = min1;\n\t\t\tmin1 = numbers[i];\n\t\t} else {\n\t\t\tmin2 = numbers[i];\n\
    \t\t}\n\t}\n\treturn [min1, min2];\n}\n", "\tlet min: number = numbers[0];\n\t\
    let max: number = numbers[0];\n\tfor (let i = 1; i < numbers.length; i++) {\n\t\
    \tmin = Math.min(min, numbers[i]);\n\t\tmax = Math.max(max, numbers[i]);\n\t}\n\
    \treturn [min, max];\n}\n", "\tlet min: number = numbers[0];\n\tlet max: number\
    \ = numbers[0];\n\tfor (let i = 1; i < numbers.length; i++) {\n\t\tif (numbers[i]\
    \ < min) {\n\t\t\tmin = numbers[i];\n\t\t}\n\t\tif (numbers[i] > max) {\n\t\t\t\
    max = numbers[i];\n\t\t}\n\t}\n\treturn [min, max];\n}\n", "\tlet min: number\
    \ = numbers[0];\n\tlet max: number = numbers[0];\n\tfor (let i = 1; i < numbers.length;\
    \ i++) {\n\t\tif (numbers[i] < min) {\n\t\t\tmin = numbers[i];\n\t\t} else if\
    \ (numbers[i] > max) {\n\t\t\tmax = numbers[i];\n\t\t}\n\t}\n\treturn [min, max];\n\
    }\n", "\tlet min: number = numbers[0];\n\tlet max: number = numbers[0];\n\tfor\
    \ (let i = 1; i < numbers.length; i++) {\n\t\tif (numbers[i] < min) {\n\t\t\t\
    min = numbers[i];\n\t\t}\n\t\tif (numbers[i] > max) {\n\t\t\tmax = numbers[i];\n\
    \t\t}\n\t}\n\treturn [min, max];\n}\n", "\tlet min_dist = Number.MAX_VALUE;\n\t\
    let min_dist_index = -1;\n\tlet max_dist_index = -1;\n\tfor (let i = 0; i < numbers.length\
    \ - 1; i++) {\n\t\tlet dist = numbers[i + 1] - numbers[i];\n\t\tif (dist < min_dist)\
    \ {\n\t\t\tmin_dist = dist;\n\t\t\tmin_dist_index = i;\n\t\t}\n\t\tif (dist >\
    \ max_dist) {\n\t\t\tmax_dist = dist;\n\t\t\tmax_dist_index = i;\n\t\t}\n\t}\n\
    \treturn [numbers[min_dist_index], numbers[max_dist_index]];\n}\n", "\tlet min:\
    \ number = numbers[0];\n\tlet max: number = numbers[0];\n\tfor (let i = 1; i <\
    \ numbers.length; i++) {\n\t\tmin = Math.min(min, numbers[i]);\n\t\tmax = Math.max(max,\
    \ numbers[i]);\n\t}\n\treturn [min, max];\n}\n", "  let min_dist = Number.MAX_VALUE;\n\
    \  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for (let i\
    \ = 1; i < numbers.length; i++) {\n    const dist = abs(numbers[i] - min_number);\n\
    \    if (dist < min_dist) {\n      min_number = numbers[i];\n      min_dist =\
    \ dist;\n    } else if (dist > max_dist) {\n      max_number = numbers[i];\n \
    \     max_dist = dist;\n    }\n  }\n  return [min_number, max_number];\n}\n",
  "\tlet smallest = numbers[0];\n\tlet largest = numbers[0];\n\tfor (let i = 1; i\
    \ < numbers.length; i++) {\n\t\tif (numbers[i] < smallest) {\n\t\t\tsmallest =\
    \ numbers[i];\n\t\t}\n\t\tif (numbers[i] > largest) {\n\t\t\tlargest = numbers[i];\n\
    \t\t}\n\t}\n\treturn [smallest, largest];\n}\n", "\tlet min: number = numbers[0];\n\
    \tlet max: number = numbers[0];\n\tfor (let i = 1; i < numbers.length; i++) {\n\
    \t\tif (numbers[i] < min) {\n\t\t\tmin = numbers[i];\n\t\t} else if (numbers[i]\
    \ > max) {\n\t\t\tmax = numbers[i];\n\t\t}\n\t}\n\treturn [min, max];\n}\n", "\t\
    let min1 = numbers[0];\n\tlet min2 = numbers[0];\n\tfor (let i = 1; i < numbers.length;\
    \ i++) {\n\t\tlet curr = numbers[i];\n\t\tif (Math.abs(curr - min1) < Math.abs(min2\
    \ - curr)) {\n\t\t\tmin2 = min1;\n\t\t\tmin1 = curr;\n\t\t} else if (Math.abs(curr\
    \ - min2) < Math.abs(min1 - curr)) {\n\t\t\tmin2 = curr;\n\t\t}\n\t}\n\treturn\
    \ [min1, min2];\n}\n", "\tlet min: number = numbers[0];\n\tlet max: number = numbers[0];\n\
    \tfor (let i = 1; i < numbers.length; i++) {\n\t\tif (numbers[i] < min) {\n\t\t\
    \tmin = numbers[i];\n\t\t}\n\t\tif (numbers[i] > max) {\n\t\t\tmax = numbers[i];\n\
    \t\t}\n\t}\n\treturn [min, max];\n}\n", "\tlet min: number = numbers[0];\n\tlet\
    \ max: number = numbers[0];\n\tfor (let i = 1; i < numbers.length; i++) {\n\t\t\
    if (numbers[i] < min) {\n\t\t\tmin = numbers[i];\n\t\t}\n\t\tif (numbers[i] >\
    \ max) {\n\t\t\tmax = numbers[i];\n\t\t}\n\t}\n\treturn [min, max];\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
