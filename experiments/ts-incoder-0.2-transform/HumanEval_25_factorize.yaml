name: HumanEval_25_factorize
language: ts
prompt: "//Return list of prime factors of given integer in the order from smallest\
  \ to largest.\n// Each of the factors should be listed number of times corresponding\
  \ to how many times it appeares in factorization.\n// Input number should be equal\
  \ to the product of all factors\n// >>> factorize(8)\n// [2, 2, 2]\n// >>> factorize(25)\n\
  // [5, 5]\n// >>> factorize(70)\n// [2, 5, 7]\nfunction factorize(n: number): number[]\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = factorize;\n  assert.deepEqual(candidate(2),[2]);\n\
  \  assert.deepEqual(candidate(4),[2, 2]);\n  assert.deepEqual(candidate(8),[2, 2,\
  \ 2]);\n  assert.deepEqual(candidate(57),[3, 19]);\n  assert.deepEqual(candidate(3249),[3,\
  \ 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3, 3, 3, 19, 19, 19]);\n \
  \ assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n  assert.deepEqual(candidate(18),[2,\
  \ 3, 3]);\n}\n\ntest();"
completions: ["  const factors: number[] = [];\n  for (let i = 2; i <= Math.sqrt(n);\
    \ i++) {\n    if (n % i === 0) {\n      factors.push(i as number);\n      while\
    \ (n % i === 0) {\n        n /= i;\n        factors.push(i as number);\n     \
    \ }\n    }\n  }\n  return factors;\n}\n", "    let factors = [];\n    for (let\
    \ i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            factors.push(i);\n\
    \            while (n % i === 0) {\n                n /= i;\n            }\n \
    \       }\n    }\n    if (n > 1) {\n        factors.push(n);\n    }\n    return\
    \ factors;\n}\n", "  const factors: number[] = [];\n  const primeFactors: number[]\
    \ = [];\n  let factor = 1;\n  let primeFactor = 1;\n  let isPrime = true;\n  let\
    \ isFactor = false;\n  let isPrimeFactor = false;\n  let isPrimePrimeFactor =\
    \ false;\n  let isPrimePrimePrimeFactor = false;\n  let isPrimePrimePrimePrimeFactor\
    \ = false;\n  let isPrimePrimePrimePrimePrimeFactor = false;\n  let isPrimePrimePrimePrimePrimePrimeFactor\
    \ = false;\n  let isPrimePrimePrimePrimePrimePrimePrimeFactor = false;\n  let\
    \ isPrimePrimePrimePrimePrimePrimePrimePrimeFactor = false;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimeFactor\
    \ = false;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor = false;\n\
    \  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor = false;\n \
    \ let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor = false;\n\
    \  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor = false;\n\
    \  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor =\
    \ false;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor\
    \ = false;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor\
    \ = false;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor\
    \ = false;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor\
    \ = false;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor\
    \ = false;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimeFactor\
    \ = false;\n  let isPrimePrimePrimePrimePrimePrimePrimePrimePri", "  const factors:\
    \ number[] = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i ===\
    \ 0) {\n      factors.push(i as number);\n      while (n % i === 0) {\n      \
    \  n /= i;\n        factors.push(i as number);\n      }\n    }\n  }\n  return\
    \ factors;\n}\n", "  let factors: number[] = [];\n  let i = 2;\n  while (i <=\
    \ n) {\n    if (n % i === 0) {\n      factors.push(i);\n      n = n / i;\n   \
    \ } else {\n      i++;\n    }\n  }\n  return factors;\n}\n", "  const factors:\
    \ number[] = [];\n  let i = 2;\n  while (n % i === 0) {\n    factors.push(i);\n\
    \    n /= i;\n    i++;\n  }\n  if (n > 1) {\n    factors.push(n);\n  }\n  return\
    \ factors;\n}\n", "  const factors: number[] = [];\n  const factorsMap: Map<number,\
    \ number> = new Map();\n  for (let i = 1; i <= n; i++) {\n    const factor: number\
    \ = i;\n    while (n % factor === 0) {\n      n /= factor;\n      factors.push(factor);\n\
    \      factorsMap.set(factor, factorsMap.get(factor) + 1);\n    }\n  }\n  for\
    \ (let [factor, count] of factorsMap) {\n    factors.push(factor);\n    factors.push(count);\n\
    \  }\n  return factors;\n}\n", "  if (n < 2) return [];\n  let factors: number[]\
    \ = [];\n  let i = 2;\n  while (i <= n) {\n    while (n % i === 0) {\n      factors.push(i);\n\
    \      n /= i;\n    }\n    i++;\n  }\n  return factors;\n}\n", "  const factors:\
    \ number[] = [];\n  let factor = 1;\n  while (n > 1) {\n    if (n % factor ===\
    \ 0) {\n      n /= factor;\n      factors.push(factor);\n    } else {\n      factor\
    \ *= factor;\n    }\n  }\n  return factors;\n}\n", "  const factors: number[]\
    \ = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      factors.push(i);\n\
    \      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n    \
    \  }\n    }\n    i++;\n  }\n  return factors;\n}\n", "  const factors: number[]\
    \ = [];\n  let factor = 1;\n  while (n > 1) {\n    if (n % factor === 0) {\n \
    \     factors.push(factor);\n      n /= factor;\n    } else {\n      factor *=\
    \ factor;\n    }\n  }\n  return factors;\n}\n", "  const factors: number[] = [];\n\
    \  let i = 2;\n  while (true) {\n    if (n % i === 0) {\n      factors.push(i);\n\
    \      while (n % i === 0) {\n        n /= i;\n      }\n    } else {\n      break;\n\
    \    }\n    i++;\n  }\n  return factors;\n}\n", "    const factors: number[] =\
    \ [];\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0)\
    \ {\n            while (n % i === 0) {\n                n /= i;\n            \
    \    factors.push(i);\n            }\n        }\n    }\n    return factors;\n\
    }\n", "    let factors = [];\n    let i = 2;\n    while (i <= n) {\n        while\
    \ (n % i === 0) {\n            factors.push(i);\n            n = n / i;\n    \
    \    }\n        i++;\n    }\n    return factors;\n}\n", "  const factors: number[]\
    \ = [];\n  const primes: number[] = [];\n  let factor: number[] = [];\n  let i:\
    \ number;\n  let j: number;\n  let k: number;\n  let prime: number[] = [];\n \
    \ let primeFactors: number[] = [];\n  let primeFactorsCount: number[] = [];\n\
    \  let factorsCount: number[] = [];\n  let factorsCountMax: number[] = [];\n \
    \ let factorsCountMaxIndex: number[] = [];\n  let factorsCountMaxIndexIndex: number[]\
    \ = [];\n  let factorsCountMaxIndexIndex2: number[] = [];\n  let factorsCountMaxIndexIndex3:\
    \ number[] = [];\n  let factorsCountMaxIndexIndex4: number[] = [];\n  let factorsCountMaxIndexIndex5:\
    \ number[] = [];\n  let factorsCountMaxIndexIndex6: number[] = [];\n  let factorsCountMaxIndexIndex7:\
    \ number[] = [];\n  let factorsCountMaxIndexIndex8: number[] = [];\n  let factorsCountMaxIndexIndex9:\
    \ number[] = [];\n  let factorsCountMaxIndexIndex10: number[] = [];\n  let factorsCountMaxIndexIndex11:\
    \ number[] = [];\n  let factorsCountMaxIndexIndex12: number[] = [];\n  let factorsCountMaxIndexIndex13:\
    \ number[] = [];\n  let factorsCountMaxIndexIndex14: number[] = [];\n  let factorsCountMaxIndexIndex15:\
    \ number[] = [];\n  let factorsCountMaxIndexIndex16: number[] = [];\n  let factorsCountMaxIndexIndex17:\
    \ number[] = [];\n  let factorsCountMaxIndexIndex18: number[] = [];\n  let factorsCountMaxIndexIndex19:\
    \ number[] = [];\n  let factorsCountMaxIndexIndex20: number[] = [];\n  let factorsCountMaxIndexIndex21:\
    \ number[] = [];\n  let factorsCountMaxIndexIndex22: number[] = [];\n  let factorsCountMaxIndexIndex23:\
    \ number[] = [];\n  let factorsCountMaxIndexIndex24: number[] = [];\n  let factorsCountMaxIndexIndex25:\
    \ number[] = [];\n  let factorsCountMaxIndexIndex26: number[] = [];\n  let factorsCountMaxIndexIndex27:\
    \ number[] = [];\n  let factorsCountMaxIndexIndex28: number[] = [];\n  let factorsCountMaxIndexIndex29:\
    \ number[] = [];\n  let factorsCountMaxIndexIndex30: number[] = [];\n  let factorsCountMaxIndexIndex31:\
    \ number[] = [];\n  let factorsCountMaxIndexIndex32: number[] = [];\n  let factorsCountMaxIndexIndex33:\
    \ number[] = [];\n", "  if (n < 2) return [];\n  let factors = [];\n  let i =\
    \ 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      factors.push(i);\n   \
    \   n /= i;\n    } else {\n      i++;\n    }\n  }\n  return factors;\n}\n", " \
    \ const factors: number[] = [];\n  let i = 2;\n  while (i <= n) {\n    if (n %\
    \ i === 0) {\n      factors.push(i);\n      n = n / i;\n    } else {\n      i++;\n\
    \    }\n  }\n  return factors;\n}\n", "  let factors: number[] = [];\n  for (let\
    \ i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i\
    \ as number);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i\
    \ as number);\n      }\n    }\n  }\n  return factors;\n}\n", "  const factors:\
    \ number[] = [];\n  const primeFactors: number[] = [];\n  for (let i = 2; i <=\
    \ Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      primeFactors.push(i);\n\
    \      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n    \
    \  }\n    }\n  }\n  return primeFactors.concat(factors);\n}\n", "    let factors:\
    \ number[] = [];\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n\
    \ % i === 0) {\n            factors.push(i);\n            while (n % i === 0)\
    \ {\n                n /= i;\n                factors.push(i);\n            }\n\
    \        }\n    }\n    if (n > 1) {\n        factors.push(n);\n    }\n    return\
    \ factors;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
