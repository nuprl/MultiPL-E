name: HumanEval_12_longest
language: ts
prompt: "//Out of list of strings, return the longest one. Return the first one in\
  \ case of multiple\n// strings of the same length. Return None in case the input\
  \ list is empty.\n// >>> longest([])\n// undefined\n// >>> longest([\"a\", \"b\"\
  , \"c\"])\n// \"a\"\n// >>> longest([\"a\", \"bb\", \"ccc\"])\n// \"ccc\"\nfunction\
  \ longest(strings: string[]): string | undefined {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = longest;\n  assert.deepEqual(candidate([]),undefined);\n\
  \  assert.deepEqual(candidate([\"x\", \"y\", \"z\"]),\"x\");\n  assert.deepEqual(candidate([\"\
  x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]),\"zzzz\");\n}\n\ntest();"
completions: ["  if (strings.length === 0) {\n    return undefined;\n  }\n  return\
    \ strings[0].length > strings[1].length ? strings[0] : strings[1];\n}\n", "  if\
    \ (strings.length === 0) {\n    return undefined;\n  }\n  return strings.sort((a,\
    \ b) => b.length - a.length)[0] || undefined;\n}\n", "  if (strings.length ===\
    \ 0) {\n    return undefined;\n  }\n  return strings.sort((a, b) => b.length -\
    \ a.length)[0] || undefined;\n}\n", "  if (strings.length === 0) {\n    return\
    \ undefined;\n  }\n  return strings.sort((a, b) => b.length - a.length)[0] ||\
    \ undefined;\n}\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n\
    \  return strings.reduce(\n    (prev, curr) =>\n      prev.length > curr.length\
    \ ? prev : curr,\n    strings[0]\n  );\n}\n", "  if (strings.length === 0) {\n\
    \    return undefined;\n  }\n  return strings[0].length > strings[1].length ?\
    \ strings[0] : strings[1];\n}\n", "  if (strings.length === 0) {\n    return undefined;\n\
    \  }\n  return strings.reduce(\n    (longest, str) =>\n      str.length > longest.length\
    \ ? str : longest,\n    strings[0]\n  );\n}\n", "  if (strings.length === 0) {\n\
    \    return undefined;\n  }\n  return strings.sort((a, b) => b.length - a.length)[0]\
    \ || undefined;\n}\n", "  if (strings.length === 0) {\n    return undefined;\n\
    \  }\n  return strings.reduce((prev, curr) => {\n    const length = prev === undefined\
    \ ? curr : prev.length;\n    return length > curr.length ? prev : curr;\n  });\n\
    }\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n  return strings[0].length\
    \ > strings[1].length ? strings[0] : strings[1];\n}\n", "  if (strings.length\
    \ === 0) {\n    return undefined;\n  }\n  return strings.sort((a, b) => b.length\
    \ - a.length)[0] || undefined;\n}\n", "  if (strings.length === 0) {\n    return\
    \ undefined;\n  }\n  return strings.reduce((prev, curr) => {\n    return prev.length\
    \ > curr.length ? prev : curr;\n  });\n}\n", "  if (strings.length === 0) {\n\
    \    return undefined;\n  }\n  return strings.reduce(\n    (longest, str) =>\n\
    \      str.length > longest.length ? str : longest,\n    strings[0]\n  );\n}\n",
  "  if (strings.length === 0) {\n    return undefined;\n  }\n  return strings.reduce((longest,\
    \ str) => {\n    return str.length > longest.length ? str : longest;\n  });\n\
    }\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n  return strings.reduce((prev,\
    \ curr) => {\n    return prev.length > curr.length ? prev : curr;\n  });\n}\n",
  "  if (strings.length === 0) {\n    return undefined;\n  }\n  return strings.reduce((prev,\
    \ cur) => {\n    if (prev === undefined || prev.length < cur.length) {\n     \
    \ return cur;\n    }\n    return prev;\n  });\n}\n", "  if (strings.length ===\
    \ 0) {\n    return undefined;\n  }\n  return strings.reduce(\n    (longest, str)\
    \ =>\n      str.length > longest.length ? str : longest,\n    strings[0]\n  );\n\
    }\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n\n  return strings.reduce((longest,\
    \ str) => {\n    const length = str.length;\n    return length > longest ? length\
    \ : longest;\n  }, 0);\n}\n", "  if (strings.length === 0) {\n    return undefined;\n\
    \  }\n  return strings.reduce((prev, cur) => prev.length > cur.length ? prev :\
    \ cur);\n}\n", "  if (strings.length === 0) {\n    return undefined;\n  }\n  return\
    \ strings.reduce((longest, str) => {\n    return str.length > longest ? str :\
    \ longest;\n  });\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
