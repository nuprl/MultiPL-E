name: HumanEval_136_largest_smallest_integers
language: ts
prompt: "//Create a function that returns a tuple (a, b), where 'a' is\n// the largest\
  \ of negative integers, and 'b' is the smallest\n// of positive integers in a list.\n\
  // If there is no negative or positive integers, return them as None.\n// Examples:\n\
  // >>> largest_smallest_integers([2, 4, 1, 3, 5, 7])\n// [undefined, 1]\n// >>>\
  \ largest_smallest_integers([])\n// [undefined, undefined]\n// >>> largest_smallest_integers([0])\n\
  // [undefined, undefined]\nfunction largest_smallest_integers(lst: number[]): [number\
  \ | undefined, number | undefined] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = largest_smallest_integers;\n  assert.deepEqual(candidate([2,\
  \ 4, 1, 3, 5, 7]),[undefined, 1]);\n  assert.deepEqual(candidate([2, 4, 1, 3, 5,\
  \ 7, 0]),[undefined, 1]);\n  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, -2]),[-2,\
  \ 1]);\n  assert.deepEqual(candidate([4, 5, 3, 6, 2, 7, -7]),[-7, 2]);\n  assert.deepEqual(candidate([7,\
  \ 3, 8, 4, 9, 2, 5, -9]),[-9, 2]);\n  assert.deepEqual(candidate([]),[undefined,\
  \ undefined]);\n  assert.deepEqual(candidate([0]),[undefined, undefined]);\n  assert.deepEqual(candidate([-1,\
  \ -3, -5, -6]),[-1, undefined]);\n  assert.deepEqual(candidate([-1, -3, -5, -6,\
  \ 0]),[-1, undefined]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, 1]),[-3,\
  \ 1]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, -100, 1]),[-3, 1]);\n}\n\n\
  test();"
completions: ["  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n     \
    \ largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n\
    \    }\n  }\n  return [largest, smallest];\n}\n", "  let largest = Number.MAX_SAFE_INTEGER;\n\
    \  let smallest = Number.MIN_SAFE_INTEGER;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n    if\
    \ (lst[i] > largest) {\n      largest = lst[i];\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest\
    \ = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ num = lst[i];\n    if (num < smallest) {\n      smallest = num;\n    }\n   \
    \ if (num > largest) {\n      largest = num;\n    }\n  }\n  return [largest, smallest];\n\
    }\n", "  const largest = Number.MIN_SAFE_INTEGER;\n  const smallest = Number.MAX_SAFE_INTEGER;\n\
    \  for (const num of lst) {\n    if (num > largest) {\n      largest = num;\n\
    \    }\n    if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n  let\
    \ smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i]\
    \ < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n\
    }\n", "  const smallest = lst.reduce((a, b) => a < b ? a : b);\n  const largest\
    \ = lst.reduce((a, b) => a > b ? a : b);\n  return [smallest, largest];\n}\n",
  "  if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n  const [smallest,\
    \ largest] = lst.reduce(\n    (acc: [number | undefined, number | undefined],\
    \ num: number) => {\n      if (num < 0) {\n        return [undefined, num];\n\
    \      } else if (num > 0) {\n        return [num, undefined];\n      }\n    \
    \  return acc;\n    },\n    [undefined, undefined],\n  );\n  return [smallest,\
    \ largest];\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest\
    \ = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length; i++) {\n    if\
    \ (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest)\
    \ {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n}\n",
  "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n     \
    \ largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n\
    \    }\n  }\n  return [largest, smallest];\n}\n", "  const largest = Number.NEGATIVE_INFINITY;\n\
    \  const smallest = Number.POSITIVE_INFINITY;\n  for (const num of lst) {\n  \
    \  if (num < smallest) {\n      smallest = num;\n    } else if (num > largest)\
    \ {\n      largest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", " \
    \ let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n     \
    \ largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n\
    \    }\n  }\n  return [largest, smallest];\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n\
    \  let smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if\
    \ (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  const positive = lst.filter(x => x > 0);\n  const negative\
    \ = lst.filter(x => x < 0);\n  if (positive.length > 0) {\n    return [Math.max(...negative),\
    \ Math.min(...positive)];\n  }\n  if (negative.length > 0) {\n    return [undefined,\
    \ Math.max(...negative)];\n  }\n  return [undefined, undefined];\n}\n", "  let\
    \ largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n     \
    \ largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n\
    \    }\n  }\n  return [largest, smallest];\n}\n", "  const largest = Number.NEGATIVE_INFINITY;\n\
    \  const smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const num = lst[i];\n    if (num < smallest) {\n      smallest =\
    \ num;\n    }\n    if (num > largest) {\n      largest = num;\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  const positives = lst.filter(x => x >= 0);\n\
    \  const negatives = lst.filter(x => x < 0);\n  if (positives.length > 0) {\n\
    \    const max = positives.reduce((a, b) => Math.max(a, b));\n    return [max,\
    \ positives[0]];\n  } else if (negatives.length > 0) {\n    const min = negatives.reduce((a,\
    \ b) => Math.min(a, b));\n    return [min, negatives[0]];\n  } else {\n    return\
    \ [undefined, undefined];\n  }\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n\
    \  let smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if\
    \ (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  const largest = Number.NEGATIVE_INFINITY;\n  const smallest\
    \ = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ num = lst[i];\n    if (num < smallest) {\n      smallest = num;\n    } else\
    \ if (num > largest) {\n      largest = num;\n    }\n  }\n  return [largest, smallest];\n\
    }\n", "  const largest = Number.NEGATIVE_INFINITY\n  const smallest = Number.POSITIVE_INFINITY\n\
    \  for (const num of lst) {\n    if (num < smallest) {\n      smallest = num\n\
    \    }\n    if (num > largest) {\n      largest = num\n    }\n  }\n  return [largest,\
    \ smallest]\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest =\
    \ Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ num = lst[i];\n    if (num < smallest) {\n      smallest = num;\n    }\n   \
    \ if (num > largest) {\n      largest = num;\n    }\n  }\n  return [largest, smallest];\n\
    }\n", "  let largest = Number.MAX_SAFE_INTEGER;\n  let smallest = Number.MIN_SAFE_INTEGER;\n\
    \  for (const num of lst) {\n    if (num > largest) {\n      largest = num;\n\
    \    } else if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  const positive = lst.filter(x => x > 0);\n  const\
    \ negative = lst.filter(x => x < 0);\n  if (positive.length > 0) {\n    return\
    \ [Math.max(...negative), Math.min(...positive)];\n  }\n  if (negative.length\
    \ > 0) {\n    return [undefined, Math.max(...negative)];\n  }\n  return [undefined,\
    \ undefined];\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest\
    \ = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length; i++) {\n    if\
    \ (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest)\
    \ {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n}\n",
  "  const positives = lst.filter(n => n >= 0);\n  const negatives = lst.filter(n\
    \ => n < 0);\n  if (positives.length === 0) {\n    return [undefined, undefined];\n\
    \  }\n  if (negatives.length === 0) {\n    return [positives[0], undefined];\n\
    \  }\n  const largestPositive = Math.max(...positives);\n  const smallestNegative\
    \ = Math.min(...negatives);\n  return [largestPositive, smallestNegative];\n}\n",
  "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n     \
    \ largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n\
    \    }\n  }\n  return [largest, smallest];\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n\
    \  let smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if\
    \ (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest\
    \ = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++) {\n    if\
    \ (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest)\
    \ {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n}\n",
  "  const largest = Number.MIN_SAFE_INTEGER;\n  const smallest = Number.MAX_SAFE_INTEGER;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n     \
    \ smallest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  let largest\
    \ = undefined;\n  let smallest = undefined;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] < 0) {\n      if (largest === undefined) {\n        largest\
    \ = lst[i];\n      } else if (largest < lst[i]) {\n        largest = lst[i];\n\
    \      }\n    } else if (lst[i] > 0) {\n      if (smallest === undefined) {\n\
    \        smallest = lst[i];\n      } else if (smallest > lst[i]) {\n        smallest\
    \ = lst[i];\n      }\n    }\n  }\n  return [largest, smallest];\n}\n", "  const\
    \ max = Math.max(...lst);\n  const min = Math.min(...lst);\n  return [max, min];\n\
    }\n", "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n     \
    \ largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n\
    \    }\n  }\n  return [largest, smallest];\n}\n", "  const positive = lst.filter(n\
    \ => n >= 0);\n  const negative = lst.filter(n => n < 0);\n  if (negative.length\
    \ > 0) {\n    return [negative[0], positive[0]];\n  }\n  if (positive.length >\
    \ 0) {\n    return [positive[0], undefined];\n  }\n  return [undefined, undefined];\n\
    }\n", "  const largest = Number.NEGATIVE_INFINITY;\n  const smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n    \
    \  largest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  const min_val\
    \ = Math.min.apply(null, lst);\n  const max_val = Math.max.apply(null, lst);\n\
    \  return [min_val, max_val];\n}\n", "  let max_negative = Number.NEGATIVE_INFINITY;\n\
    \  let min_positive = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const num = lst[i];\n    if (num < 0) {\n      max_negative = Math.max(max_negative,\
    \ num);\n    } else {\n      min_positive = Math.min(min_positive, num);\n   \
    \ }\n  }\n  return [max_negative, min_positive];\n}\n", "  const largest = Number.NEGATIVE_INFINITY;\n\
    \  const smallest = Number.POSITIVE_INFINITY;\n  for (const num of lst) {\n  \
    \  if (num < smallest) {\n      smallest = num;\n    } else if (num > largest)\
    \ {\n      largest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", " \
    \ if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n  const [smallest,\
    \ largest] = lst;\n  if (smallest > largest) {\n    return [smallest, largest];\n\
    \  }\n  const [smallest2, largest2] = largest_smallest_integers(lst.slice(1));\n\
    \  if (smallest > smallest2) {\n    return [smallest, smallest2];\n  }\n  if (largest\
    \ < largest2) {\n    return [largest, largest2];\n  }\n  return [smallest2, largest2];\n\
    }\n", "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n     \
    \ smallest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  const positive\
    \ = lst.filter(x => x >= 0);\n  const negative = lst.filter(x => x < 0);\n  if\
    \ (positive.length > 0) {\n    const max = positive.reduce((max, x) => Math.max(max,\
    \ x), -Infinity);\n    return [max, positive[0]];\n  }\n  if (negative.length\
    \ > 0) {\n    const min = negative.reduce((min, x) => Math.min(min, x), Infinity);\n\
    \    return [negative[0], min];\n  }\n  return [undefined, undefined];\n}\n",
  "  const largest = Number.MIN_SAFE_INTEGER;\n  const smallest = Number.MAX_SAFE_INTEGER;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n     \
    \ smallest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  const smallest\
    \ = lst.reduce((a, b) => a < b ? a : b);\n  const largest = lst.reduce((a, b)\
    \ => a > b ? a : b);\n  return [smallest, largest];\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n\
    \  let smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if\
    \ (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  let max_negative = Number.NEGATIVE_INFINITY;\n  let min_positive\
    \ = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ num = lst[i];\n    if (num < 0) {\n      max_negative = Math.max(max_negative,\
    \ num);\n    } else if (num > 0) {\n      min_positive = Math.min(min_positive,\
    \ num);\n    } else {\n      return [max_negative, min_positive];\n    }\n  }\n\
    \  return [max_negative, min_positive];\n}\n", "  const [smallest, largest] =\
    \ lst.reduce(\n    ([smallest, largest], num) => {\n      if (num < smallest)\
    \ {\n        return [num, smallest]\n      } else if (num > largest) {\n     \
    \   return [smallest, num]\n      } else {\n        return [smallest, largest]\n\
    \      }\n    },\n    [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY]\n \
    \ )\n  return [smallest, largest]\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n\
    \  let smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if\
    \ (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  const largest = Number.NEGATIVE_INFINITY;\n  const smallest\
    \ = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ num = lst[i];\n    if (num > largest) {\n      largest = num;\n    } else if\
    \ (num < smallest) {\n      smallest = num;\n    }\n  }\n  return [largest, smallest];\n\
    }\n", "  const positive = lst.filter(n => n >= 0);\n  const negative = lst.filter(n\
    \ => n < 0);\n  if (positive.length > 0) {\n    return [Math.max(...negative),\
    \ Math.min(...positive)];\n  }\n  if (negative.length > 0) {\n    return [undefined,\
    \ Math.max(...negative)];\n  }\n  return [undefined, undefined];\n}\n", "  const\
    \ positive = lst.filter(n => n >= 0);\n  const negative = lst.filter(n => n <\
    \ 0);\n  if (positive.length > 0) {\n    return [Math.max(...negative), Math.min(...positive)];\n\
    \  }\n  if (negative.length > 0) {\n    return [undefined, Math.max(...negative)];\n\
    \  }\n  return [undefined, undefined];\n}\n", "  if (lst.length === 0) {\n   \
    \ return [undefined, undefined];\n  }\n  const [smallest, largest] = lst.reduce(\n\
    \    (acc, val) =>\n      val < 0 ? [Math.max(val, acc[0]), val] : [Math.min(val,\
    \ acc[1]), val],\n    [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY],\n\
    \  );\n  return [smallest, largest];\n}\n", "  const largest = Number.NEGATIVE_INFINITY;\n\
    \  const smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const n = lst[i];\n    if (n < smallest) {\n      smallest = n;\n\
    \    }\n    if (n > largest) {\n      largest = n;\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  const smallest = -Infinity;\n  const largest = Infinity;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n    \
    \  largest = num;\n    }\n  }\n  return [smallest, largest];\n}\n", "  let largest\
    \ = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n  for\
    \ (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
    \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n \
    \   }\n  }\n  return [largest, smallest];\n}\n", "  const positives = lst.filter(n\
    \ => n > 0);\n  const negatives = lst.filter(n => n < 0);\n  if (positives.length\
    \ > 0) {\n    return positives.reduce((a, b) => a > b ? a : b);\n  }\n  if (negatives.length\
    \ > 0) {\n    return negatives.reduce((a, b) => a < b ? a : b);\n  }\n  return\
    \ [undefined, undefined];\n}\n", "  if (lst.length === 0) {\n    return [undefined,\
    \ undefined];\n  }\n  const [smallest, largest] = lst.reduce(\n    ([smallest,\
    \ largest], num) => {\n      if (num < 0) {\n        return [smallest, num];\n\
    \      } else if (num > largest) {\n        return [num, largest];\n      } else\
    \ {\n        return [smallest, num];\n      }\n    },\n    [Number.NEGATIVE_INFINITY,\
    \ Number.POSITIVE_INFINITY]\n  );\n  return [smallest, largest];\n}\n", "  const\
    \ positive: number[] = [];\n  const negative: number[] = [];\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] >= 0) {\n      positive.push(lst[i]);\n\
    \    } else {\n      negative.push(lst[i]);\n    }\n  }\n  if (positive.length\
    \ > 0) {\n    return [Math.max(...negative), Math.min(...positive)];\n  }\n  if\
    \ (negative.length > 0) {\n    return [undefined, Math.max(...negative)];\n  }\n\
    \  return [undefined, undefined];\n}\n", "  const smallest = lst.reduce((a, b)\
    \ => a < b ? a : b);\n  const largest = lst.reduce((a, b) => a > b ? a : b);\n\
    \  return [smallest, largest];\n}\n", "  const [smallest, largest] = lst.reduce(\n\
    \    ([smallest, largest], num) => {\n      if (num < smallest) {\n        return\
    \ [num, smallest]\n      } else if (num > largest) {\n        return [smallest,\
    \ num]\n      } else {\n        return [smallest, largest]\n      }\n    },\n\
    \    [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY]\n  )\n  return [smallest,\
    \ largest]\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest =\
    \ Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length; i++) {\n    if\
    \ (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest)\
    \ {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n}\n",
  "  const [smallest, largest] = lst.reduce(\n    (acc, val) => {\n      if (val >\
    \ acc[0]) {\n        acc = [val, val];\n      } else if (val < acc[0]) {\n   \
    \     acc = [acc[1], val];\n      }\n      return acc;\n    },\n    [Number.MAX_SAFE_INTEGER,\
    \ Number.MIN_SAFE_INTEGER]\n  );\n  return [smallest, largest];\n}\n", "  const\
    \ largest = Number.NEGATIVE_INFINITY;\n  const smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n    \
    \  largest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  const smallest\
    \ = -Infinity;\n  const largest = Infinity;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const num = lst[i];\n    if (num < smallest) {\n      smallest =\
    \ num;\n    }\n    if (num > largest) {\n      largest = num;\n    }\n  }\n  return\
    \ [smallest, largest];\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n  let\
    \ smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i]\
    \ < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n\
    }\n", "  const largest = Number.NEGATIVE_INFINITY;\n  const smallest = Number.POSITIVE_INFINITY;\n\
    \  for (const num of lst) {\n    if (num > largest) {\n      largest = num;\n\
    \    }\n    if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n  let\
    \ smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    const num = lst[i];\n    if (num < 0) {\n      largest = num;\n    }\
    \ else if (num > 0) {\n      smallest = num;\n    }\n  }\n  return [largest, smallest];\n\
    }\n", "  const largest = Number.MIN_SAFE_INTEGER;\n  const smallest = Number.MAX_SAFE_INTEGER;\n\
    \  for (const num of lst) {\n    if (num > largest) {\n      largest = num;\n\
    \    } else if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n  let\
    \ smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    const num = lst[i];\n    if (num > largest) {\n      largest = num;\n\
    \    }\n    if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n  let\
    \ smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    const num = lst[i];\n    if (num < smallest) {\n      smallest = num;\n\
    \    } else if (num > largest) {\n      largest = num;\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  const largest = Number.MIN_SAFE_INTEGER;\n  const smallest\
    \ = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ num = lst[i];\n    if (num < smallest) {\n      smallest = num;\n    }\n   \
    \ if (num > largest) {\n      largest = num;\n    }\n  }\n  return [largest, smallest];\n\
    }\n", "  const smallest = lst.reduce((a, b) => a < b ? a : b);\n  const largest\
    \ = lst.reduce((a, b) => a > b ? a : b);\n  return [smallest, largest];\n}\n",
  "  let largest = Number.MAX_SAFE_INTEGER;\n  let smallest = Number.MIN_SAFE_INTEGER;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n     \
    \ largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n\
    \    }\n  }\n  return [largest, smallest];\n}\n", "  const [smallest, largest]\
    \ = lst.reduce(([smallest, largest], num) => {\n    if (num < 0) {\n      smallest\
    \ = num;\n    } else if (num > largest) {\n      largest = num;\n    }\n    return\
    \ [smallest, largest];\n  }, [undefined, undefined]);\n  return [smallest, largest];\n\
    }\n", "  const largest = Number.NEGATIVE_INFINITY;\n  const smallest = Number.POSITIVE_INFINITY;\n\
    \  for (const num of lst) {\n    if (num > largest) {\n      largest = num;\n\
    \    } else if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  const positive = lst.filter(n => n >= 0);\n \
    \ const negative = lst.filter(n => n < 0);\n  if (positive.length > 0) {\n   \
    \ return [Math.max(...negative), Math.min(...positive)];\n  }\n  if (negative.length\
    \ > 0) {\n    return [undefined, Math.max(...negative)];\n  }\n  return [undefined,\
    \ undefined];\n}\n", "  const largest = Number.MIN_SAFE_INTEGER;\n  const smallest\
    \ = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ num = lst[i];\n    if (num < smallest) {\n      smallest = num;\n    }\n   \
    \ if (num > largest) {\n      largest = num;\n    }\n  }\n  return [largest, smallest];\n\
    }\n", "  const [smallest, largest] = lst.reduce(\n    (acc, val) =>\n      val\
    \ < 0 ? [...acc, val] : [...acc, undefined],\n    [undefined, undefined]\n  );\n\
    \  return [smallest, largest];\n}\n", "  const min: number = Number.MAX_SAFE_INTEGER;\n\
    \  const max: number = Number.MIN_SAFE_INTEGER;\n  for (const num of lst) {\n\
    \    if (num < min) {\n      min = num;\n    }\n    if (num > max) {\n      max\
    \ = num;\n    }\n  }\n  return [min, max];\n}\n", "  const smallest = lst[0]\n\
    \  const largest = lst[0]\n  for (const num of lst) {\n    if (num < smallest)\
    \ {\n      smallest = num\n    }\n    if (num > largest) {\n      largest = num\n\
    \    }\n  }\n  return [smallest, largest]\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n\
    \  let smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const num = lst[i];\n    if (num > largest) {\n      largest = num;\n\
    \    }\n    if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  const smallest = lst.sort((a, b) => a - b)[0]\n\
    \  const largest = lst.sort((a, b) => b - a)[0]\n  return [smallest, largest]\n\
    }\n", "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n     \
    \ smallest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  if (lst.length\
    \ === 0) {\n    return [undefined, undefined];\n  }\n  const largest = lst[0];\n\
    \  const smallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if\
    \ (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest)\
    \ {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n}\n",
  "  let smallest = -Infinity;\n  let largest = Infinity;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const num = lst[i];\n    if (num < 0) {\n      if (smallest ===\
    \ -Infinity) {\n        smallest = num;\n      } else {\n        largest = num;\n\
    \      }\n    } else {\n      if (smallest === Infinity) {\n        smallest =\
    \ num;\n      } else {\n        largest = num;\n      }\n    }\n  }\n  return\
    \ [smallest, largest];\n}\n", "  let smallest = -Infinity;\n  let largest = Infinity;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n    \
    \  largest = num;\n    }\n  }\n  return [smallest, largest];\n}\n", "  let largest\
    \ = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n  for\
    \ (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
    \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n \
    \   }\n  }\n  return [largest, smallest];\n}\n", "  let largest = Number.MAX_SAFE_INTEGER;\n\
    \  let smallest = Number.MIN_SAFE_INTEGER;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if\
    \ (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest\
    \ = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length; i++) {\n    if\
    \ (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest)\
    \ {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n}\n",
  "  let smallest = -Infinity;\n  let largest = Infinity;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const num = lst[i];\n    if (num > largest) {\n      largest = num;\n\
    \    }\n    if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return\
    \ [smallest, largest];\n}\n", "  const min = Math.min(...lst);\n  const max =\
    \ Math.max(...lst);\n  return [max, min];\n}\n", "  const smallest = lst.reduce((a,\
    \ b) => Math.min(a, b), -Infinity);\n  const largest = lst.reduce((a, b) => Math.max(a,\
    \ b), Infinity);\n  return [smallest, largest];\n}\n", "  const positive = lst.filter(n\
    \ => n >= 0);\n  const negative = lst.filter(n => n < 0);\n  if (positive.length\
    \ > 0) {\n    return [Math.max(...negative), Math.min(...positive)];\n  }\n  if\
    \ (negative.length > 0) {\n    return [undefined, Math.max(...negative)];\n  }\n\
    \  return [undefined, undefined];\n}\n", "  if (lst.length === 0) {\n    return\
    \ [undefined, undefined];\n  }\n  const largest = lst[0];\n  const smallest =\
    \ lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > largest)\
    \ {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest\
    \ = lst[i];\n    }\n  }\n  return [largest, smallest];\n}\n", "  let largest =\
    \ -Infinity;\n  let smallest = Infinity;\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i]\
    \ < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n\
    }\n", "  let largest = -Infinity;\n  let smallest = Infinity;\n  for (let i =\
    \ 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num > largest) {\n\
    \      largest = num;\n    }\n    if (num < smallest) {\n      smallest = num;\n\
    \    }\n  }\n  return [largest, smallest];\n}\n", "  const [smallest, largest]\
    \ = lst.reduce(\n    (acc, val) => {\n      if (val < 0) return [undefined, val];\n\
    \      if (val > 0) return [val, undefined];\n      return acc;\n    },\n    [undefined,\
    \ undefined]\n  );\n  return [smallest, largest];\n}\n", "  const positives =\
    \ lst.filter(x => x >= 0);\n  const negatives = lst.filter(x => x < 0);\n  if\
    \ (positives.length === 0) {\n    return [undefined, undefined];\n  }\n  if (negatives.length\
    \ === 0) {\n    return [positives[0], undefined];\n  }\n  return [Math.max(...negatives),\
    \ Math.min(...positives)];\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n\
    \  let smallest = Number.MAX_SAFE_INTEGER;\n  for (const num of lst) {\n    if\
    \ (num > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n\
    \      smallest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  let\
    \ largest = Number.MAX_SAFE_INTEGER;\n  let smallest = Number.MIN_SAFE_INTEGER;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < 0) {\n      smallest\
    \ = lst[i];\n    } else if (lst[i] > 0) {\n      largest = lst[i];\n    }\n  }\n\
    \  return [largest, smallest];\n}\n", "  const positive = lst.filter(n => n >=\
    \ 0);\n  const negative = lst.filter(n => n < 0);\n  if (positive.length > 0 &&\
    \ negative.length > 0) {\n    return [Math.max(...negative), Math.min(...positive)];\n\
    \  }\n  if (positive.length > 0) {\n    return [Math.max(...positive)];\n  }\n\
    \  if (negative.length > 0) {\n    return [Math.min(...negative)];\n  }\n  return\
    \ [undefined, undefined];\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n \
    \ let smallest = Number.MAX_SAFE_INTEGER;\n  for (const num of lst) {\n    if\
    \ (num > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n\
    \      smallest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  if\
    \ (lst.length === 0) {\n    return [undefined, undefined];\n  }\n  const smallest\
    \ = lst[0];\n  const largest = lst[0];\n  for (let i = 1; i < lst.length; i++)\
    \ {\n    const current = lst[i];\n    if (current < smallest) {\n      smallest\
    \ = current;\n    } else if (current > largest) {\n      largest = current;\n\
    \    }\n  }\n  return [smallest, largest];\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n\
    \  let smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if\
    \ (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  let smallest = -Infinity;\n  let largest = Infinity;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ > largest) {\n      largest = num;\n    } else if (num < smallest) {\n     \
    \ smallest = num;\n    }\n  }\n  return [smallest, largest];\n}\n", "  let smallest\
    \ = -Infinity;\n  let largest = Infinity;\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    const num = lst[i];\n    if (num > largest) {\n      largest = num;\n\
    \    }\n    if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return\
    \ [smallest, largest];\n}\n", "  const min_val = lst[0];\n  const max_val = lst[0];\n\
    \  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < min_val) {\n     \
    \ min_val = lst[i];\n    } else if (lst[i] > max_val) {\n      max_val = lst[i];\n\
    \    }\n  }\n  return [max_val, min_val];\n}\n", "  const max = -Infinity;\n \
    \ const min = Infinity;\n  for (let i = 0; i < lst.length; i++) {\n    const n\
    \ = lst[i];\n    if (n < min) {\n      min = n;\n    }\n    if (n > max) {\n \
    \     max = n;\n    }\n  }\n  return [max, min];\n}\n", "  let smallest = -Infinity;\n\
    \  let largest = Infinity;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n\
    \      smallest = lst[i];\n    }\n  }\n  return [smallest, largest];\n}\n", " \
    \ const [smallest, largest] = lst.reduce(\n    (acc, val) => {\n      if (val\
    \ < acc[0]) {\n        return [val, acc[0]]\n      } else if (val > acc[1]) {\n\
    \        return [acc[1], val]\n      }\n      return acc\n    },\n    [Number.NEGATIVE_INFINITY,\
    \ Number.POSITIVE_INFINITY]\n  )\n  return [smallest, largest]\n}\n", "  const\
    \ positive = lst.filter(x => x > 0);\n  const negative = lst.filter(x => x < 0);\n\
    \  if (positive.length > 0) {\n    return [Math.max(...negative), Math.min(...positive)];\n\
    \  }\n  if (negative.length > 0) {\n    return [undefined, Math.max(...negative)];\n\
    \  }\n  return [undefined, undefined];\n}\n", "  let largest = -Infinity;\n  let\
    \ smallest = Infinity;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n\
    \      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n}\n", " \
    \ let min: number | undefined = undefined;\n  let max: number | undefined = undefined;\n\
    \  for (const num of lst) {\n    if (num < 0) {\n      min = num;\n    } else\
    \ if (num > 0) {\n      max = num;\n    }\n  }\n  return [min, max];\n}\n", " \
    \ let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
    \  for (const num of lst) {\n    if (num < 0) {\n      smallest = num;\n    }\
    \ else if (num > largest) {\n      largest = num;\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest\
    \ = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ num = lst[i];\n    if (num < smallest) {\n      smallest = num;\n    }\n   \
    \ if (num > largest) {\n      largest = num;\n    }\n  }\n  return [largest, smallest];\n\
    }\n", "  let smallest = -Infinity;\n  let largest = Infinity;\n  for (let i =\
    \ 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num < smallest)\
    \ {\n      smallest = num;\n    }\n    if (num > largest) {\n      largest = num;\n\
    \    }\n  }\n  return [smallest, largest];\n}\n", "  let smallest = -Infinity;\n\
    \  let largest = Infinity;\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ num = lst[i];\n    if (num < smallest) {\n      smallest = num;\n    }\n   \
    \ if (num > largest) {\n      largest = num;\n    }\n  }\n  if (smallest === -Infinity)\
    \ {\n    return [undefined, undefined];\n  }\n  if (largest === Infinity) {\n\
    \    return [undefined, undefined];\n  }\n  return [smallest, largest];\n}\n",
  "  const largest = Number.NEGATIVE_INFINITY;\n  const smallest = Number.POSITIVE_INFINITY;\n\
    \  for (const num of lst) {\n    if (num > largest) {\n      largest = num;\n\
    \    }\n    if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  const smallest = Number.MAX_SAFE_INTEGER;\n \
    \ const largest = -Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const num = lst[i];\n    if (num > largest) {\n      largest = num;\n\
    \    }\n    if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return\
    \ [smallest, largest];\n}\n", "  if (lst.length === 0) {\n    return [undefined,\
    \ undefined];\n  }\n  const [smallest, largest] = lst.reduce(([smallest, largest],\
    \ num) => {\n    if (num < 0) {\n      return [smallest, num];\n    }\n    if\
    \ (num > largest) {\n      return [num, largest];\n    }\n    return [smallest,\
    \ num];\n  }, [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY]);\n  return\
    \ [smallest, largest];\n}\n", "  const largest = Number.NEGATIVE_INFINITY;\n \
    \ const smallest = Number.POSITIVE_INFINITY;\n  for (const num of lst) {\n   \
    \ if (num > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n\
    \      smallest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  const\
    \ positive = lst.filter(x => x >= 0);\n  const negative = lst.filter(x => x <\
    \ 0);\n  if (positive.length > 0) {\n    return [Math.max(...negative), Math.min(...positive)];\n\
    \  }\n  if (negative.length > 0) {\n    return [undefined, Math.max(...negative)];\n\
    \  }\n  return [undefined, undefined];\n}\n", "  let smallest = -Infinity;\n \
    \ let largest = Infinity;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]\
    \ > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n\
    \      smallest = lst[i];\n    }\n  }\n  return [smallest, largest];\n}\n", " \
    \ const largest = Number.NEGATIVE_INFINITY;\n  const smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n    \
    \  largest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  const max\
    \ = -Infinity;\n  const min = Infinity;\n  for (const num of lst) {\n    if (num\
    \ < min) {\n      min = num;\n    }\n    if (num > max) {\n      max = num;\n\
    \    }\n  }\n  return [max, min];\n}\n", "  const largest = Number.MIN_SAFE_INTEGER;\n\
    \  const smallest = Number.MAX_SAFE_INTEGER;\n  for (const num of lst) {\n   \
    \ if (num < smallest) {\n      smallest = num;\n    }\n    if (num > largest)\
    \ {\n      largest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", " \
    \ const positive = lst.filter(n => n >= 0);\n  const negative = lst.filter(n =>\
    \ n < 0);\n  if (positive.length > 0) {\n    const max = positive.reduce((a, b)\
    \ => Math.max(a, b));\n    return [max, positive[0]];\n  }\n  if (negative.length\
    \ > 0) {\n    const min = negative.reduce((a, b) => Math.min(a, b));\n    return\
    \ [min, negative[0]];\n  }\n  return [undefined, undefined];\n}\n", "  const smallest\
    \ = lst.reduce((a, b) => a < b ? a : b);\n  const largest = lst.reduce((a, b)\
    \ => a > b ? a : b);\n  return [smallest, largest];\n}\n", "  const [smallest,\
    \ largest] = lst.reduce(\n    (minMax, [num, i]) => {\n      if (num < smallest)\
    \ {\n        return [smallest, num];\n      } else if (num > largest) {\n    \
    \    return [num, largest];\n      }\n      return minMax;\n    },\n    [Number.NEGATIVE_INFINITY,\
    \ Number.POSITIVE_INFINITY]\n  );\n  return [smallest, largest];\n}\n", "  let\
    \ max_negative = Number.NEGATIVE_INFINITY;\n  let min_positive = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ < 0) {\n      max_negative = Math.max(max_negative, num);\n    } else if (num\
    \ > 0) {\n      min_positive = Math.min(min_positive, num);\n    } else {\n  \
    \    return [max_negative, min_positive];\n    }\n  }\n  return [max_negative,\
    \ min_positive];\n}\n", "  let max_num = -Infinity;\n  let min_num = Infinity;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max_num) {\n     \
    \ max_num = lst[i];\n    }\n    if (lst[i] < min_num) {\n      min_num = lst[i];\n\
    \    }\n  }\n  return [max_num, min_num];\n}\n", "  const largest = Number.NEGATIVE_INFINITY;\n\
    \  const smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const num = lst[i];\n    if (num < smallest) {\n      smallest =\
    \ num;\n    }\n    if (num > largest) {\n      largest = num;\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  let largest = undefined;\n  let smallest = undefined;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n     \
    \ largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n\
    \    }\n  }\n  return [smallest, largest];\n}\n", "  const largest = Number.MIN_SAFE_INTEGER;\n\
    \  const smallest = Number.MAX_SAFE_INTEGER;\n  for (const num of lst) {\n   \
    \ if (num < smallest) {\n      smallest = num;\n    }\n    if (num > largest)\
    \ {\n      largest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", " \
    \ let largest = undefined;\n  let smallest = undefined;\n  for (let i = 0; i <\
    \ lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n \
    \   }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  let smallest = -Infinity;\n  let largest = Infinity;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n     \
    \ largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n\
    \    }\n  }\n  return [smallest, largest];\n}\n", "  const [smallest, largest]\
    \ = lst.reduce(\n    (acc: [number | undefined, number | undefined], num: number)\
    \ => {\n      if (num > acc[0]) {\n        acc[0] = num;\n      }\n      if (num\
    \ < acc[1]) {\n        acc[1] = num;\n      }\n      return acc;\n    },\n   \
    \ [undefined, undefined],\n  );\n  return [smallest, largest];\n}\n", "  const\
    \ largest = Number.NEGATIVE_INFINITY;\n  const smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ > largest) {\n      largest = num;\n    } else if (num < smallest) {\n     \
    \ smallest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  const min:\
    \ number = Number.MAX_SAFE_INTEGER;\n  const max: number = Number.MIN_SAFE_INTEGER;\n\
    \  for (const num of lst) {\n    if (num < min) {\n      min = num;\n    }\n \
    \   if (num > max) {\n      max = num;\n    }\n  }\n  return [min, max];\n}\n",
  "  if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n  const min_val\
    \ = lst[0];\n  const max_val = lst[0];\n  for (let i = 1; i < lst.length; i++)\
    \ {\n    const val = lst[i];\n    if (val < min_val) {\n      min_val = val;\n\
    \    } else if (val > max_val) {\n      max_val = val;\n    }\n  }\n  return [max_val,\
    \ min_val];\n}\n", "  const largest = Number.NEGATIVE_INFINITY\n  const smallest\
    \ = Number.POSITIVE_INFINITY\n  for (const num of lst) {\n    if (num < smallest)\
    \ {\n      smallest = num\n    }\n    if (num > largest) {\n      largest = num\n\
    \    }\n  }\n  return [largest, smallest]\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n\
    \  let smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const num = lst[i];\n    if (num < smallest) {\n      smallest =\
    \ num;\n    }\n    if (num > largest) {\n      largest = num;\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  const positives = lst.filter(n => n >= 0);\n\
    \  const negatives = lst.filter(n => n < 0);\n  if (positives.length === 0) {\n\
    \    return [undefined, undefined];\n  }\n  if (negatives.length === 0) {\n  \
    \  return [positives[0], undefined];\n  }\n  const maxNegative = Math.max(...negatives);\n\
    \  const minPositive = Math.min(...positives);\n  return [maxNegative, minPositive];\n\
    }\n", "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n     \
    \ largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n\
    \    }\n  }\n  return [largest, smallest];\n}\n", "  const largest = Number.NEGATIVE_INFINITY;\n\
    \  const smallest = Number.POSITIVE_INFINITY;\n  for (const num of lst) {\n  \
    \  if (num > largest) {\n      largest = num;\n    } else if (num < smallest)\
    \ {\n      smallest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", " \
    \ const [smallest, largest] = lst.reduce(\n    ([smallest, largest], num) => {\n\
    \      if (num < smallest) {\n        return [num, smallest]\n      } else if\
    \ (num > largest) {\n        return [smallest, num]\n      }\n      return [smallest,\
    \ largest]\n    },\n    [undefined, undefined]\n  )\n  return [smallest, largest]\n\
    }\n", "  const [minInt, maxInt] = [Infinity, -Infinity];\n  for (let i = 0; i\
    \ < lst.length; i++) {\n    const num = lst[i];\n    if (num < minInt) {\n   \
    \   minInt = num;\n    } else if (num > maxInt) {\n      maxInt = num;\n    }\n\
    \  }\n  return [minInt, maxInt];\n}\n", "  const positive = lst.filter(n => n\
    \ >= 0);\n  const negative = lst.filter(n => n < 0);\n  if (positive.length >\
    \ 0 && negative.length > 0) {\n    return [Math.max(...negative), Math.min(...positive)];\n\
    \  }\n  if (positive.length > 0) {\n    return [Math.max(...positive)];\n  }\n\
    \  if (negative.length > 0) {\n    return [Math.min(...negative)];\n  }\n  return\
    \ [undefined, undefined];\n}\n", "  const positive: number[] = [];\n  const negative:\
    \ number[] = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] >=\
    \ 0) {\n      positive.push(lst[i]);\n    } else {\n      negative.push(lst[i]);\n\
    \    }\n  }\n  if (positive.length > 0) {\n    return [Math.max(...negative),\
    \ Math.min(...positive)];\n  }\n  if (negative.length > 0) {\n    return [undefined,\
    \ Math.max(...negative)];\n  }\n  return [undefined, undefined];\n}\n", "  let\
    \ largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n    \
    \  largest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  let largest\
    \ = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n  for\
    \ (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest\
    \ = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n \
    \   }\n  }\n  return [largest, smallest];\n}\n", "  let largest = Number.MAX_SAFE_INTEGER;\n\
    \  let smallest = Number.MIN_SAFE_INTEGER;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const num = lst[i];\n    if (num > largest) {\n      largest = num;\n\
    \    }\n    if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  const largest = Number.NEGATIVE_INFINITY;\n \
    \ const smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const n = lst[i];\n    if (n < smallest) {\n      smallest = n;\n\
    \    } else if (n > largest) {\n      largest = n;\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest\
    \ = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ num = lst[i];\n    if (num < smallest) {\n      smallest = num;\n    }\n   \
    \ if (num > largest) {\n      largest = num;\n    }\n  }\n  return [largest, smallest];\n\
    }\n", "  const largest = Number.NEGATIVE_INFINITY;\n  const smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n    \
    \  largest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  const largest\
    \ = Number.NEGATIVE_INFINITY\n  const smallest = Number.POSITIVE_INFINITY\n  for\
    \ (const num of lst) {\n    if (num > largest) {\n      largest = num\n    } else\
    \ if (num < smallest) {\n      smallest = num\n    }\n  }\n  return [largest,\
    \ smallest]\n}\n", "  let smallest = -Infinity;\n  let largest = Infinity;\n \
    \ for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n     \
    \ smallest = num;\n    }\n  }\n  return [smallest, largest];\n}\n", "  const smallest\
    \ = -Infinity;\n  const largest = Infinity;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const num = lst[i];\n    if (num < smallest) {\n      smallest =\
    \ num;\n    }\n    if (num > largest) {\n      largest = num;\n    }\n  }\n  return\
    \ [smallest, largest];\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n  let\
    \ smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    const num = lst[i];\n    if (num > largest) {\n      largest = num;\n\
    \    } else if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n  let\
    \ smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    const num = lst[i];\n    if (num > largest) {\n      largest = num;\n\
    \    }\n    if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  let smallest = -Infinity;\n  let largest = Infinity;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n     \
    \ largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n\
    \    }\n  }\n  return [smallest, largest];\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n\
    \  let smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if\
    \ (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  if (lst.length === 0) {\n    return [undefined, undefined];\n\
    \  }\n  const [smallest, largest] = lst.reduce(\n    (acc, val) =>\n      val\
    \ < acc[0] ? [val, acc[0]] : [acc[0], val],\n    [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER],\n\
    \  );\n  return [smallest, largest];\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n\
    \  let smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if\
    \ (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  const largest = Number.MIN_SAFE_INTEGER;\n  const smallest\
    \ = Number.MAX_SAFE_INTEGER;\n  for (const num of lst) {\n    if (num < smallest)\
    \ {\n      smallest = num;\n    }\n    if (num > largest) {\n      largest = num;\n\
    \    }\n  }\n  return [largest, smallest];\n}\n", "  const smallest = lst.reduce((a,\
    \ b) => a < b ? a : b);\n  const largest = lst.reduce((a, b) => a > b ? a : b);\n\
    \  return [smallest, largest];\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n\
    \  let smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if\
    \ (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest\
    \ = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ num = lst[i];\n    if (num < 0) {\n      largest = num;\n    } else if (num\
    \ > 0) {\n      smallest = num;\n    }\n  }\n  return [largest, smallest];\n}\n",
  "  const min: number = Number.MAX_SAFE_INTEGER;\n  const max: number = Number.MIN_SAFE_INTEGER;\n\
    \  for (const num of lst) {\n    if (num < min) {\n      min = num;\n    }\n \
    \   if (num > max) {\n      max = num;\n    }\n  }\n  return [min, max];\n}\n",
  "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n     \
    \ largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n\
    \    }\n  }\n  return [largest, smallest];\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n\
    \  let smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const num = lst[i];\n    if (num > largest) {\n      largest = num;\n\
    \    }\n    if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  if (lst.length === 0) {\n    return [undefined,\
    \ undefined];\n  }\n  let largest = Number.NEGATIVE_INFINITY;\n  let smallest\
    \ = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ num = lst[i];\n    if (num < 0) {\n      smallest = num;\n    } else if (num\
    \ > largest) {\n      largest = num;\n    }\n  }\n  return [largest, smallest];\n\
    }\n", "  let largest = Number.MAX_SAFE_INTEGER;\n  let smallest = Number.MIN_SAFE_INTEGER;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ < 0) {\n      smallest = num;\n    } else if (num > largest) {\n      largest\
    \ = num;\n    }\n  }\n  return [smallest, largest];\n}\n", "  if (lst.length ===\
    \ 0) {\n    return [undefined, undefined];\n  }\n  const smallest = lst[0];\n\
    \  const largest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    const\
    \ current = lst[i];\n    if (current < smallest) {\n      smallest = current;\n\
    \    }\n    if (current > largest) {\n      largest = current;\n    }\n  }\n \
    \ return [smallest, largest];\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n\
    \  let smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if\
    \ (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  let max_negative = Number.NEGATIVE_INFINITY;\n  let min_positive\
    \ = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ num = lst[i];\n    if (num < 0) {\n      max_negative = Math.max(max_negative,\
    \ num);\n    } else {\n      min_positive = Math.min(min_positive, num);\n   \
    \ }\n  }\n  return [max_negative, min_positive];\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n\
    \  let smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if\
    \ (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest\
    \ = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ num = lst[i];\n    if (num < 0) {\n      largest = num;\n    } else if (num\
    \ > 0) {\n      smallest = num;\n    }\n  }\n  return [largest, smallest];\n}\n",
  "  let smallest = -Infinity;\n  let largest = Infinity;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const num = lst[i];\n    if (num < smallest || smallest === -Infinity)\
    \ {\n      smallest = num;\n    }\n    if (num > largest || largest === Infinity)\
    \ {\n      largest = num;\n    }\n  }\n  return [smallest, largest];\n}\n", " \
    \ if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n  const largest\
    \ = lst[0];\n  const smallest = lst[0];\n  for (let i = 1; i < lst.length; i++)\
    \ {\n    const num = lst[i];\n    if (num > largest) {\n      largest = num;\n\
    \    } else if (num < smallest) {\n      smallest = num;\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  const largest = Number.MIN_SAFE_INTEGER;\n  const\
    \ smallest = Number.MAX_SAFE_INTEGER;\n  for (const num of lst) {\n    if (num\
    \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n    \
    \  largest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  let smallest\
    \ = -Infinity;\n  let largest = Infinity;\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    const num = lst[i];\n    if (num < smallest) {\n      smallest = num;\n\
    \    }\n    if (num > largest) {\n      largest = num;\n    }\n  }\n  return [smallest,\
    \ largest];\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest\
    \ = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length; i++) {\n    if\
    \ (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i] < smallest)\
    \ {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n}\n",
  "  if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n  const max\
    \ = -Infinity;\n  const min = Infinity;\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    const num = lst[i];\n    if (num < 0) {\n      max = num;\n    } else\
    \ if (num > 0) {\n      min = num;\n    } else {\n      return [max, min];\n \
    \   }\n  }\n  return [max, min];\n}\n", "  let min: number | undefined = undefined;\n\
    \  let max: number | undefined = undefined;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] < 0) {\n      if (min === undefined) {\n        min =\
    \ lst[i];\n      } else {\n        min = Math.min(min, lst[i]);\n      }\n   \
    \ } else {\n      if (max === undefined) {\n        max = lst[i];\n      } else\
    \ {\n        max = Math.max(max, lst[i]);\n      }\n    }\n  }\n  return [min,\
    \ max];\n}\n", "  const largest = Number.MIN_SAFE_INTEGER;\n  const smallest =\
    \ Number.MAX_SAFE_INTEGER;\n  for (const num of lst) {\n    if (num > largest)\
    \ {\n      largest = num;\n    }\n    if (num < smallest) {\n      smallest =\
    \ num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  if (lst.length ===\
    \ 0) {\n    return [undefined, undefined];\n  }\n  const [smallest, largest] =\
    \ lst.reduce(\n    (minMax, [v, i]) => {\n      if (v < smallest) {\n        return\
    \ [smallest, v];\n      } else if (v > largest) {\n        return [v, largest];\n\
    \      }\n      return minMax;\n    },\n    [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY]\n\
    \  );\n  return [smallest, largest];\n}\n", "  let largest = Number.NEGATIVE_INFINITY;\n\
    \  let smallest = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const num = lst[i];\n    if (num < smallest) {\n      smallest =\
    \ num;\n    }\n    if (num > largest) {\n      largest = num;\n    }\n  }\n  return\
    \ [largest, smallest];\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n  let\
    \ smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n    if (lst[i]\
    \ < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [largest, smallest];\n\
    }\n", "  const smallest = lst.reduce((a, b) => a < b ? a : b);\n  const largest\
    \ = lst.reduce((a, b) => a > b ? a : b);\n  return [smallest, largest];\n}\n",
  "  const positive = lst.filter(x => x >= 0);\n  const negative = lst.filter(x =>\
    \ x < 0);\n  if (negative.length > 0) {\n    return [Math.max(...negative), Math.min(...positive)];\n\
    \  }\n  if (positive.length > 0) {\n    return [Math.max(...positive), undefined];\n\
    \  }\n  return [undefined, undefined];\n}\n", "  const [smallest, largest] = lst.reduce(\n\
    \    (acc: [number | undefined, number | undefined], num: number) => {\n     \
    \ if (num < smallest) {\n        acc[0] = num\n        acc[1] = smallest\n   \
    \   } else if (num > largest) {\n        acc[0] = largest\n        acc[1] = num\n\
    \      } else {\n        acc[0] = num\n        acc[1] = num\n      }\n      return\
    \ acc\n    },\n    [undefined, undefined]\n  )\n  return [smallest, largest]\n\
    }\n", "  let smallest = -Infinity;\n  let largest = Infinity;\n  for (let i =\
    \ 0; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n\
    \    }\n    if (lst[i] > largest) {\n      largest = lst[i];\n    }\n  }\n  return\
    \ [smallest, largest];\n}\n", "  let smallest = -Infinity;\n  let largest = Infinity;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n    \
    \  largest = num;\n    }\n  }\n  return [smallest, largest];\n}\n", "  const min:\
    \ number | undefined = Number.MAX_SAFE_INTEGER;\n  const max: number | undefined\
    \ = Number.MIN_SAFE_INTEGER;\n  for (const num of lst) {\n    if (num < min) min\
    \ = num;\n    if (num > max) max = num;\n  }\n  return [min, max];\n}\n", "  let\
    \ largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n    \
    \  largest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  const largest\
    \ = Number.NEGATIVE_INFINITY;\n  const smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (num\
    \ < smallest) {\n      smallest = num;\n    }\n    if (num > largest) {\n    \
    \  largest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  const positive\
    \ = lst.filter(n => n >= 0);\n  const negative = lst.filter(n => n < 0);\n  if\
    \ (negative.length > 0) {\n    return [negative[0], positive[0]];\n  }\n  if (positive.length\
    \ > 0) {\n    return [positive[0], negative[0]];\n  }\n  return [undefined, undefined];\n\
    }\n", "  let largest = Number.NEGATIVE_INFINITY;\n  let smallest = Number.POSITIVE_INFINITY;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n     \
    \ largest = lst[i];\n    }\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n\
    \    }\n  }\n  return [largest, smallest];\n}\n", "  let smallest = -Infinity;\n\
    \  let largest = Infinity;\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ num = lst[i];\n    if (num < smallest || smallest === -Infinity) {\n      smallest\
    \ = num;\n    }\n    if (num > largest || largest === Infinity) {\n      largest\
    \ = num;\n    }\n  }\n  return [smallest, largest];\n}\n", "  let largest = Number.MIN_SAFE_INTEGER;\n\
    \  let smallest = Number.MAX_SAFE_INTEGER;\n  for (const num of lst) {\n    if\
    \ (num > largest) {\n      largest = num;\n    }\n    if (num < smallest) {\n\
    \      smallest = num;\n    }\n  }\n  return [largest, smallest];\n}\n", "  let\
    \ smallest = -Infinity;\n  let largest = Infinity;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    const num = lst[i];\n    if (num < smallest || smallest === -Infinity)\
    \ {\n      smallest = num;\n    }\n    if (num > largest || largest === Infinity)\
    \ {\n      largest = num;\n    }\n  }\n  return [smallest, largest];\n}\n", " \
    \ const largest = Number.NEGATIVE_INFINITY;\n  const smallest = Number.POSITIVE_INFINITY;\n\
    \  for (const num of lst) {\n    if (num < smallest) {\n      smallest = num;\n\
    \    }\n    if (num > largest) {\n      largest = num;\n    }\n  }\n  return [largest,\
    \ smallest];\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
