name: HumanEval_87_get_row
language: ts
prompt: "//You are given a 2 dimensional data, as a nested lists,\n// which is similar\
  \ to matrix, however, unlike matrices,\n// each row may contain a different number\
  \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
  \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a\
  \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by\
  \ rows in ascending order.\n// Also, sort coordinates of the row by columns in descending\
  \ order.\n// Examples:\n// >>> get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
  \ [1, 2, 3, 4, 5, 1]], 1)\n// [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n// >>> get_row([],\
  \ 1)\n// []\n// >>> get_row([[], [1], [1, 2, 3]], 3)\n// [[2, 2]]\nfunction get_row(lst:\
  \ number[][], x: number): [number, number][] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = get_row;\n  assert.deepEqual(candidate([[1, 2, 3,\
  \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 4], [1, 0],\
  \ [2, 5], [2, 0]]);\n  assert.deepEqual(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3,\
  \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
  \ 4, 5, 6]], 2),[[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]);\n  assert.deepEqual(candidate([[1,\
  \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
  \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1),[[0, 0], [1, 0], [2,\
  \ 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]]);\n\
  \  assert.deepEqual(candidate([], 1),[]);\n  assert.deepEqual(candidate([[1]], 2),[]);\n\
  \  assert.deepEqual(candidate([[], [1], [1, 2, 3]], 3),[[2, 2]]);\n}\n\ntest();"
completions: ["  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n\
    \  const rows = [row];\n  const columns = [lst[0]];\n  for (let i = 1; i < lst.length;\
    \ i++) {\n    const column = lst[i];\n    for (let j = 0; j < column.length; j++)\
    \ {\n      rows.push(column);\n      columns.push(column);\n    }\n  }\n  rows.sort((a,\
    \ b) => a[0] - b[0]);\n  columns.sort((a, b) => b[1] - a[1]);\n  return rows.map(row\
    \ => row.map(i => [i, columns[i - 1]]));\n}\n", "  if (lst.length === 0) {\n \
    \   return [];\n  }\n\n  const [rows, cols] = lst;\n  const [row, col] = get_row_col(rows,\
    \ cols);\n  const [x, y] = get_row_col(row, col);\n\n  if (x === x) {\n    return\
    \ [];\n  }\n\n  const [y1, y2] = get_row_col(row, col + 1);\n  const [x1, x2]\
    \ = get_row_col(row, col - 1);\n\n  if (x === x1) {\n    return [\n      [x, y1],\n\
    \      [x, y2],\n    ];\n  }\n\n  if (x === x2) {\n    return [\n      [x, y1],\n\
    \      [y, y2],\n    ];\n  }\n\n  return [];\n}\n", "  if (lst.length === 0) {\n\
    \    return [];\n  }\n  const [row, col] = lst[0].length;\n  const rows = [...Array(row)].map(()\
    \ => []);\n  for (let i = 0; i < row; i++) {\n    rows[i].push(0);\n  }\n  for\
    \ (let i = 0; i < lst.length; i++) {\n    const [row, col] = lst[i].length;\n\
    \    for (let j = 0; j < col; j++) {\n      if (lst[i][j] === x) {\n        rows[row].push([i,\
    \ j]);\n      }\n    }\n  }\n  rows.sort((a, b) => a[0] - b[0]);\n  rows.sort((a,\
    \ b) => b[1] - a[1]);\n  return rows;\n}\n", "  if (lst.length === 0) {\n    return\
    \ [];\n  }\n  const [row, col] = lst[0].length;\n  const rows = [...Array(row)].map(()\
    \ => []);\n  for (let i = 0; i < row; i++) {\n    rows[i].push(0);\n  }\n  for\
    \ (let i = 0; i < lst.length; i++) {\n    const [row, col] = lst[i].length;\n\
    \    for (let j = 0; j < col; j++) {\n      rows[row][col] = lst[i][j];\n    }\n\
    \  }\n  rows.sort((a, b) => a[0] - b[0]);\n  rows.sort((a, b) => b[1] - a[1]);\n\
    \  return rows.map(row => row.map(col => [col, row]));\n}\n", "  if (lst.length\
    \ === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const [minRow,\
    \ minCol] = rows.reduce(([minRow, minCol], row) => {\n    const [minRowVal, minColVal]\
    \ = row.reduce(([minRowVal, minColVal], val) => {\n      if (val === x) {\n  \
    \      return [minRowVal, minColVal];\n      }\n      if (val < minRowVal) {\n\
    \        return [val, val];\n      }\n      return [minRowVal, val];\n    }, [Number.MAX_SAFE_INTEGER,\
    \ Number.MAX_SAFE_INTEGER]);\n    return [Math.min(minRow, minRowVal), Math.min(minCol,\
    \ minColVal)];\n  }, [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const\
    \ [maxRow, maxCol] = rows.reduce(([maxRow, maxCol], row) => {\n    const [maxRowVal,\
    \ maxColVal] = row.reduce(([maxRowVal, maxColVal], val) => {\n      if (val ===\
    \ x) {\n        return [maxRowVal, maxColVal];\n      }\n      if (val > maxRowVal)\
    \ {\n        return [val, val];\n      }\n      return [maxRowVal, val];\n   \
    \ }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n    return [Math.max(maxRow,\
    \ maxRowVal), Math.max(maxCol, maxColVal)];\n  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n\
    \  const rows: number[][] = [];\n  for (let row = minRow; row <= maxRow; row++)\
    \ {\n    const rowCoords: number[] = [];\n    for (let col = minCol; col <= maxCol;\
    \ col++) {\n      rowCoords.push([row, col]);\n    }\n    rows.push(rowCoords);\n\
    \  }\n  rows.sort((row1, row2) => row1[0] - row2[0]);\n  rows.sort((row1, row2)\
    \ => row1[1] - row2[1]);\n  return rows;\n}\n", "  if (lst.length === 0) {\n \
    \   return [];\n  }\n  const [rows, columns] = lst;\n  const rowIndex = rows.findIndex((row)\
    \ => row === x);\n  const columnIndex = columns.findIndex((column) => column ===\
    \ x);\n  if (rowIndex === -1) {\n    return [];\n  }\n  const [row, column] =\
    \ [rowIndex, columnIndex];\n  const sortedRows = rows.sort((a, b) => a - b);\n\
    \  const sortedColumns = columns.sort((a, b) => b - a);\n  const coordinates =\
    \ [\n    [row, sortedColumns[rowIndex]],\n    [row, sortedColumns[rowIndex + 1]],\n\
    \  ];\n  return coordinates.sort((a, b) => b[0] - a[0]);\n}\n", "  const result:\
    \ number[][] = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row =\
    \ lst[i];\n    if (row.includes(x)) {\n      result.push([i, row.indexOf(x)]);\n\
    \    }\n  }\n  result.sort((a, b) => {\n    if (a[1] < b[1]) return -1;\n    if\
    \ (a[1] > b[1]) return 1;\n    return 0;\n  });\n  result.sort((a, b) => {\n \
    \   if (a[0] < b[0]) return -1;\n    if (a[0] > b[0]) return 1;\n    return 0;\n\
    \  });\n  return result;\n}\n", "  if (lst.length === 0) {\n    return [];\n \
    \ }\n\n  const row = [x];\n  const columns = [lst[0].length - 1];\n  const coordinates\
    \ = [row];\n\n  for (let i = 1; i < lst.length; i++) {\n    const column = lst[i].length\
    \ - 1;\n    const coordinate = [row, column];\n\n    if (column > columns[columns.length\
    \ - 1]) {\n      columns.push(column);\n      coordinates.push(coordinate);\n\
    \    }\n\n    row.push(lst[i][column]);\n  }\n\n  coordinates.sort((a, b) => a[0]\
    \ - b[0]);\n  coordinates.sort((a, b) => b[1] - a[1]);\n\n  return coordinates;\n\
    }\n", "  if (lst.length === 0) {\n    return [];\n  }\n  const [row, col] = lst[0];\n\
    \  const [row_sorted, col_sorted] = sort_2d(row, col);\n  const [row_sorted_reversed,\
    \ col_sorted_reversed] = sort_2d(row_sorted, col_sorted);\n  const [row_sorted_reversed_reversed,\
    \ col_sorted_reversed_reversed] = sort_2d(row_sorted_reversed, col_sorted_reversed);\n\
    \  const [row_sorted_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed]\
    \ = sort_2d(row_sorted_reversed_reversed, col_sorted_reversed_reversed);\n  const\
    \ [row_sorted_reversed_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed_reversed]\
    \ = sort_2d(row_sorted_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed);\n\
    \  const [row_sorted_reversed_reversed_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed_reversed_reversed]\
    \ = sort_2d(row_sorted_reversed_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed_reversed);\n\
    \  const [row_sorted_reversed_reversed_reversed_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed_reversed_reversed_reversed]\
    \ = sort_2d(row_sorted_reversed_reversed_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed_reversed_reversed);\n\
    \  const [row_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed,\
    \ col_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed] =\
    \ sort_2d(row_sorted_reversed_reversed_reversed_reversed_reversed_reversed, col_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed);\n\
    \  const [row_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed,\
    \ col_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed]\
    \ = sort_2d(row_sorted_reversed_reversed_reversed_reversed_reversed_reversed,\
    \ col_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed);\n\
    \  const [row_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed,\
    \ col_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed]\
    \ = sort_2d(row_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed,\
    \ col_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed);\n\
    \  const [row_sorted_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed,\
    \ col_sorted_reversed_reversed_reverse", "  if (lst.length === 0) {\n    return\
    \ [];\n  }\n  const [rows, cols] = lst;\n  const [minRow, minCol] = rows.reduce(([minRow,\
    \ minCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.min(row,\
    \ minRow),\n      Math.min(col, minCol),\n    ];\n  }, [Number.MAX_SAFE_INTEGER,\
    \ Number.MAX_SAFE_INTEGER]);\n  const [maxRow, maxCol] = rows.reduce(([maxRow,\
    \ maxCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.max(row,\
    \ maxRow),\n      Math.max(col, maxCol),\n    ];\n  }, [Number.MIN_SAFE_INTEGER,\
    \ Number.MIN_SAFE_INTEGER]);\n  const [x, y] = x;\n  const [minRow, minCol] =\
    \ rows.reduce(([minRow, minCol], row) => {\n    const [row, col] = row;\n    return\
    \ [\n      Math.min(row, minRow),\n      Math.min(col, minCol),\n    ];\n  },\
    \ [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]);\n  const [maxRow, maxCol]\
    \ = rows.reduce(([maxRow, maxCol], row) => {\n    const [row, col] = row;\n  \
    \  return [\n      Math.max(row, maxRow),\n      Math.max(col, maxCol),\n    ];\n\
    \  }, [Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);\n  const [minX, minY]\
    \ = minCol === x ? [minRow, x] : [x, minCol];\n  const [maxX, maxY] = maxCol ===\
    \ x ? [maxRow, x] : [x, maxCol];\n  const [minRow, minCol] = rows.reduce(([minRow,\
    \ minCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.min(row,\
    \ minRow),\n      Math.min(col, minCol),\n    ];\n  }, [Number.MAX_SAFE_INTEGER,\
    \ Number.MAX_SAFE_INTEGER]);\n  const [maxRow, maxCol] = rows.reduce(([maxRow,\
    \ maxCol], row) => {\n    const [row, col] = row;\n    return [\n      Math.max(row,\
    \ maxRow),\n      Math.max(col, maxCol),\n    ];\n  }, [Number.MIN_SAFE_INTEGER,\
    \ Number.MIN_SAFE_INTEGER]);\n  const [minX, minY] = minCol === x ? [minRow, x]\
    \ : [x, minCol];\n  const [maxX, maxY] = maxCol === x ? [maxRow, x] : [x, max",
  "  if (lst.length === 0) {\n    return [];\n  }\n\n  const row = [x];\n  const columns\
    \ = [lst[0].length - 1];\n\n  for (let i = 1; i < lst.length; i++) {\n    const\
    \ curr = lst[i];\n    const [row, column] = [row, curr[row - 1] + columns];\n\
    \    columns.push(curr[column]);\n  }\n\n  row.sort((a, b) => a - b);\n  columns.sort((a,\
    \ b) => b - a);\n\n  return row.map((r) => [r, columns[r - 1]]);\n}\n", "  if\
    \ (lst.length === 0) {\n    return [];\n  }\n  const [rows, cols] = lst;\n  const\
    \ [row, col] = get_row_and_col(rows, cols, x);\n  return [\n    ...row.map(([x,\
    \ y]) => [x, y + 1]),\n    ...col.map(([x, y]) => [x + 1, y])\n  ];\n}\n", " \
    \ if (lst.length === 0) {\n    return [];\n  }\n  const rows = lst.length;\n \
    \ const cols = lst[0].length;\n  const coords: number[][] = [];\n  for (let row\
    \ = 0; row < rows; row++) {\n    const row_coords: number[] = [];\n    for (let\
    \ col = 0; col < cols; col++) {\n      if (lst[row][col] === x) {\n        row_coords.push([row,\
    \ col]);\n      }\n    }\n    coords.push(row_coords);\n  }\n  coords.sort((a,\
    \ b) => a[0] - b[0]);\n  coords.sort((a, b) => b[1] - a[1]);\n  return coords;\n\
    }\n", "  const result: number[][] = [];\n  const rows = lst.length;\n  const cols\
    \ = lst[0].length;\n  const rowMap = new Map<number, number>();\n  const colMap\
    \ = new Map<number, number>();\n  for (let i = 0; i < rows; i++) {\n    const\
    \ row = lst[i];\n    const rowKey = rowMap.get(row) || 0;\n    rowMap.set(row,\
    \ rowKey + 1);\n    for (let j = 0; j < cols; j++) {\n      const col = lst[i][j];\n\
    \      const colKey = colMap.get(col) || 0;\n      colMap.set(col, colKey + 1);\n\
    \      if (col === x) {\n        result.push([rowKey + 1, colKey + 1]);\n    \
    \  }\n    }\n  }\n  return result.sort((a, b) => b[0] - a[0]).sort((a, b) => b[1]\
    \ - a[1]);\n}\n", "  if (lst.length === 0) {\n    return [];\n  }\n  const row\
    \ = [x];\n  const result = [row];\n  for (let i = 0; i < lst.length; i++) {\n\
    \    const lstRow = lst[i];\n    const lstRowLen = lstRow.length;\n    for (let\
    \ j = 0; j < lstRowLen; j++) {\n      if (lstRow[j] === x) {\n        result.push([i,\
    \ j]);\n      }\n    }\n  }\n  result.sort((a, b) => {\n    if (a[0] > b[0]) {\n\
    \      return 1;\n    }\n    if (a[0] < b[0]) {\n      return -1;\n    }\n   \
    \ return 0;\n  });\n  result.sort((a, b) => {\n    if (a[1] > b[1]) {\n      return\
    \ 1;\n    }\n    if (a[1] < b[1]) {\n      return -1;\n    }\n    return 0;\n\
    \  });\n  return result;\n}\n", "  const result: number[][] = [];\n  for (let\
    \ i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    if (row.indexOf(x)\
    \ !== -1) {\n      result.push([i, row.indexOf(x)]);\n    }\n  }\n  result.sort((a,\
    \ b) => a[1] - b[1]);\n  result.sort((a, b) => b[0] - a[0]);\n  return result;\n\
    }\n", "  if (lst.length === 0) {\n    return [];\n  }\n  const row = [x];\n  const\
    \ rows = [row];\n  const columns = [lst[0]];\n  for (let i = 1; i < lst.length;\
    \ i++) {\n    const column = lst[i];\n    for (let j = 0; j < column.length; j++)\
    \ {\n      row.push(column[j]);\n      columns.push(column);\n    }\n    rows.push(row);\n\
    \    row = [column];\n  }\n  rows.sort((a, b) => a[0] - b[0]);\n  columns.sort((a,\
    \ b) => b.length - a[0]);\n  return rows.map(row => row.map(col => [col, col.length]));\n\
    }\n", "  if (lst.length === 0) {\n    return [];\n  }\n  const [row, col] = lst[0];\n\
    \  const rowLen = row.length;\n  const colLen = col.length;\n  const result =\
    \ [];\n  for (let i = 0; i < rowLen; i++) {\n    const rowItem = row[i];\n   \
    \ const colItem = col[i];\n    if (rowItem === x) {\n      result.push([i, colItem]);\n\
    \    }\n  }\n  return result.sort((a, b) => b[1] - a[1]).sort((a, b) => b[0] -\
    \ a[0]);\n}\n", "  if (lst.length === 0) {\n    return [];\n  }\n  const row =\
    \ [x];\n  const columns = [lst[0]];\n  for (let i = 1; i < lst.length; i++) {\n\
    \    if (lst[i].indexOf(row[0]) === -1) {\n      row.push(lst[i][0]);\n      columns.push(lst[i]);\n\
    \    }\n  }\n  columns.sort((a, b) => b[0] - a[0]);\n  columns.sort((a, b) =>\
    \ b.length - a[1]);\n  return columns.map(col => [row, col]);\n}\n", "  const\
    \ rows = lst.length;\n  const cols = lst[0].length;\n  const result = [];\n  for\
    \ (let i = 0; i < rows; i++) {\n    const row = lst[i];\n    const rowResult =\
    \ [];\n    for (let j = 0; j < cols; j++) {\n      const element = row[j];\n \
    \     if (element === x) {\n        rowResult.push([i, j]);\n      }\n    }\n\
    \    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    if (a[0] < b[0])\
    \ {\n      return -1;\n    }\n    if (a[0] > b[0]) {\n      return 1;\n    }\n\
    \    return 0;\n  });\n  result.sort((a, b) => {\n    if (a[1] < b[1]) {\n   \
    \   return -1;\n    }\n    if (a[1] > b[1]) {\n      return 1;\n    }\n    return\
    \ 0;\n  });\n  return result;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
