language: go_test.go
name: HumanEval_87_get_row
results:
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, val := range row {\n            if val == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdwyzaqzm_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdwyzaqzm_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, value := range row {\n            if value == x {\n                result\
    \ = append(result, []interface{}{i, j})\n            }\n        }\n    }\n   \
    \ return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprczvzesr_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprczvzesr_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmprczvzesr_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprczvzesr_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmprczvzesr_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for y, row := range lst {\n        for x1,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{y, x1})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx_4ztazm_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx_4ztazm_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx_4ztazm_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx_4ztazm_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx_4ztazm_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ item := range row {\n            if item == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsn1nsb62_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsn1nsb62_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsn1nsb62_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsn1nsb62_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsn1nsb62_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ item := range row {\n            if item == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsn1nsb62_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsn1nsb62_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsn1nsb62_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsn1nsb62_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsn1nsb62_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, col := range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoiyjdb39_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpoiyjdb39_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpoiyjdb39_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ v := range row {\n            if v == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyf5dyviw_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpyf5dyviw_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpyf5dyviw_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ item := range row {\n            if item == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsn1nsb62_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsn1nsb62_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsn1nsb62_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsn1nsb62_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsn1nsb62_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ v := range row {\n            if v == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyf5dyviw_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpyf5dyviw_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpyf5dyviw_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, elem := range row {\n            if elem == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpubme_1el_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpubme_1el_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpubme_1el_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpubme_1el_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpubme_1el_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, val := range row {\n            if val == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdwyzaqzm_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdwyzaqzm_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, v := range row {\n            if v == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1r328eog_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1r328eog_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1r328eog_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1r328eog_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp1r328eog_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, num := range row {\n            if num == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpupf7vclk_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpupf7vclk_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpupf7vclk_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpupf7vclk_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpupf7vclk_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ el := range row {\n            if el == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmuhutrqt_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmuhutrqt_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmuhutrqt_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmuhutrqt_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpmuhutrqt_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, col := range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoiyjdb39_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpoiyjdb39_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpoiyjdb39_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ elem := range row {\n            if elem == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ud1pwnj_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6ud1pwnj_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp6ud1pwnj_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6ud1pwnj_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp6ud1pwnj_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, val := range row {\n            if val == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdwyzaqzm_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdwyzaqzm_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, v := range row {\n            if v == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1r328eog_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1r328eog_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1r328eog_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1r328eog_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp1r328eog_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ el := range row {\n            if el == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmuhutrqt_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmuhutrqt_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmuhutrqt_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmuhutrqt_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpmuhutrqt_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, col := range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoiyjdb39_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpoiyjdb39_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpoiyjdb39_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ v := range row {\n            if v == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyf5dyviw_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpyf5dyviw_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpyf5dyviw_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, col := range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoiyjdb39_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpoiyjdb39_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpoiyjdb39_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, col := range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoiyjdb39_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpoiyjdb39_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpoiyjdb39_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, col := range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoiyjdb39_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpoiyjdb39_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpoiyjdb39_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, elem := range row {\n            if elem == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpubme_1el_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpubme_1el_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpubme_1el_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpubme_1el_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpubme_1el_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, elem := range row {\n            if elem == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpubme_1el_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpubme_1el_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpubme_1el_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpubme_1el_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpubme_1el_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, col := range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoiyjdb39_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpoiyjdb39_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpoiyjdb39_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, col := range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoiyjdb39_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpoiyjdb39_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpoiyjdb39_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, elem := range row {\n            if elem == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpubme_1el_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpubme_1el_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpubme_1el_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpubme_1el_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpubme_1el_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, col := range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoiyjdb39_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpoiyjdb39_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpoiyjdb39_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ el := range row {\n            if el == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmuhutrqt_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmuhutrqt_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmuhutrqt_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmuhutrqt_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpmuhutrqt_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, col := range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoiyjdb39_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpoiyjdb39_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpoiyjdb39_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, col := range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoiyjdb39_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpoiyjdb39_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpoiyjdb39_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, value := range row {\n            if value == x {\n                result\
    \ = append(result, []interface{}{i, j})\n            }\n        }\n    }\n   \
    \ return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprczvzesr_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprczvzesr_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmprczvzesr_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprczvzesr_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmprczvzesr_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, v := range row {\n            if v == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1r328eog_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1r328eog_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1r328eog_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1r328eog_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp1r328eog_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, col := range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoiyjdb39_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpoiyjdb39_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpoiyjdb39_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, val := range row {\n            if val == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdwyzaqzm_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdwyzaqzm_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, val := range row {\n            if val == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdwyzaqzm_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdwyzaqzm_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    res := make([][]interface{}, 0)\n    for i, row := range lst {\n    \
    \    for j, el := range row {\n            if el == x {\n                res =\
    \ append(res, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphn7u5uee_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmphn7u5uee_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmphn7u5uee_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmphn7u5uee_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmphn7u5uee_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // your code here\n    return nil\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxec2ipb8_test.go:29:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxec2ipb8_test.go:30:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxec2ipb8_test.go:31:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxec2ipb8_test.go:34:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpxec2ipb8_test.go:34:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ v := range row {\n            if v == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyf5dyviw_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpyf5dyviw_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpyf5dyviw_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, v := range row {\n            if v == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1r328eog_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1r328eog_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1r328eog_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1r328eog_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp1r328eog_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, val := range row {\n            if val == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdwyzaqzm_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdwyzaqzm_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ v := range row {\n            if v == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyf5dyviw_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpyf5dyviw_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpyf5dyviw_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ el := range row {\n            if el == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmuhutrqt_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmuhutrqt_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmuhutrqt_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmuhutrqt_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpmuhutrqt_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ el := range row {\n            if el == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmuhutrqt_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmuhutrqt_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmuhutrqt_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmuhutrqt_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpmuhutrqt_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, v := range row {\n            if v == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1r328eog_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1r328eog_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1r328eog_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1r328eog_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp1r328eog_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    res := make([][]interface{}, 0)\n    for i, row := range lst {\n    \
    \    for j, col := range row {\n            if col == x {\n                res\
    \ = append(res, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptxnnoqpl_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmptxnnoqpl_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmptxnnoqpl_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmptxnnoqpl_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmptxnnoqpl_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, val := range row {\n            if val == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdwyzaqzm_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdwyzaqzm_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, val := range row {\n            if val == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdwyzaqzm_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdwyzaqzm_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, elem := range row {\n            if elem == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpubme_1el_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpubme_1el_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpubme_1el_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpubme_1el_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpubme_1el_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ v := range row {\n            if v == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyf5dyviw_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpyf5dyviw_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpyf5dyviw_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ v := range row {\n            if v == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyf5dyviw_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpyf5dyviw_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpyf5dyviw_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, value := range row {\n            if value == x {\n                result\
    \ = append(result, []interface{}{i, j})\n            }\n        }\n    }\n   \
    \ return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprczvzesr_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprczvzesr_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmprczvzesr_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprczvzesr_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmprczvzesr_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, col := range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoiyjdb39_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpoiyjdb39_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpoiyjdb39_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ elem := range row {\n            if elem == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ud1pwnj_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6ud1pwnj_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp6ud1pwnj_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6ud1pwnj_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp6ud1pwnj_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, col := range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoiyjdb39_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpoiyjdb39_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpoiyjdb39_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ v := range row {\n            if v == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyf5dyviw_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpyf5dyviw_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpyf5dyviw_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, val := range row {\n            if val == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdwyzaqzm_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdwyzaqzm_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, val := range row {\n            if val == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdwyzaqzm_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdwyzaqzm_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, col := range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoiyjdb39_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpoiyjdb39_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpoiyjdb39_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, col := range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoiyjdb39_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpoiyjdb39_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpoiyjdb39_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ v := range row {\n            if v == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyf5dyviw_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpyf5dyviw_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpyf5dyviw_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ item := range row {\n            if item == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsn1nsb62_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsn1nsb62_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsn1nsb62_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsn1nsb62_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsn1nsb62_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, col := range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoiyjdb39_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpoiyjdb39_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpoiyjdb39_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpoiyjdb39_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ elem := range row {\n            if elem == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ud1pwnj_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6ud1pwnj_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp6ud1pwnj_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6ud1pwnj_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp6ud1pwnj_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, val := range row {\n            if val == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdwyzaqzm_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpdwyzaqzm_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpdwyzaqzm_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    res := make([][]interface{}, 0)\n    for i, row := range lst {\n    \
    \    for j, val := range row {\n            if val == x {\n                res\
    \ = append(res, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_nf2ka5g_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp_nf2ka5g_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp_nf2ka5g_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp_nf2ka5g_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp_nf2ka5g_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ v := range row {\n            if v == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyf5dyviw_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpyf5dyviw_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyf5dyviw_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpyf5dyviw_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, v := range row {\n            if v == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1r328eog_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1r328eog_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1r328eog_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1r328eog_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp1r328eog_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ el := range row {\n            if el == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmuhutrqt_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmuhutrqt_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmuhutrqt_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmuhutrqt_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpmuhutrqt_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, value := range row {\n            if value == x {\n                result\
    \ = append(result, []interface{}{i, j})\n            }\n        }\n    }\n   \
    \ return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprczvzesr_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprczvzesr_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmprczvzesr_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprczvzesr_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmprczvzesr_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zg8vu0e_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7zg8vu0e_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7zg8vu0e_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    // your code here\n    var res [][]interface{}\n    for i, row := range\
    \ lst {\n        for j, col := range row {\n            if col == x {\n      \
    \          res = append(res, []interface{}{i, j})\n            }\n        }\n\
    \    }\n    return res\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate :=\
    \ get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnrokm9wr_test.go:37:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnrokm9wr_test.go:38:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnrokm9wr_test.go:39:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnrokm9wr_test.go:42:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnrokm9wr_test.go:42:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, v := range row {\n            if v == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1r328eog_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1r328eog_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1r328eog_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1r328eog_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp1r328eog_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var res [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpklt0xg2u_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpklt0xg2u_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpklt0xg2u_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpklt0xg2u_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\nfunc get_row(lst [][]int, x int) [][]interface{}\
    \ {\n    var result [][]interface{}\n    for i, row := range lst {\n        for\
    \ j, item := range row {\n            if item == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx1f7gn9j_test.go:36:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:37:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:38:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx1f7gn9j_test.go:41:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx1f7gn9j_test.go:41:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
