language: go_test.go
name: HumanEval_79_decimal_to_binary
results:
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ TODO: implement\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpt7akm8wu_test.go:35: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpt7akm8wu_test.go:35: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpt7akm8wu_test.go:35: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpt7akm8wu_test.go:35: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ result string\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%d%s\"\
    , decimal % 2, result)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", result)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpzz17p6fn_test.go:39: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkbo3_do__test.go:35: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpkbo3_do__test.go:35: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkbo3_do__test.go:35: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpkbo3_do__test.go:35: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ result string\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%d%s\"\
    , decimal % 2, result)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", result)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpzz17p6fn_test.go:39: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ binary string\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%d%s\"\
    , decimal % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmprg9h405m_test.go:39: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ binary string\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%d%s\"\
    , decimal % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmprg9h405m_test.go:39: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal == 0 {\n        return \"db0db\"\n    }\n    var result string\n   \
    \ for decimal > 0 {\n        result = fmt.Sprintf(\"%d%s\", decimal % 2, result)\n\
    \        decimal /= 2\n    }\n    return fmt.Sprintf(\"db%sdb\", result)\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ TODO: implement me\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp0gpia6e1_test.go:35: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp0gpia6e1_test.go:35: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp0gpia6e1_test.go:35: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp0gpia6e1_test.go:35: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binary\
    \ := \"\"\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%d%s\", decimal\
    \ % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"db%sdb\"\
    , binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp3n6da8uh_test.go:39: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkbo3_do__test.go:35: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpkbo3_do__test.go:35: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ binary string\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%d%s\"\
    , decimal % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmprg9h405m_test.go:39: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ binary string\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%d%s\"\
    , decimal % 2, binary)\n        decimal /= 2\n    }\n    return \"db\" + binary\
    \ + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpaafrobea_test.go:39: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ result string = \"db\"\n    for decimal > 0 {\n        result = fmt.Sprintf(\"\
    %s%d\", result, decimal % 2)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    %sdb\", result)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpysa2afgt_test.go:39: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpysa2afgt_test.go:39:\
    \ expected 'db100000db', got 'db000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpysa2afgt_test.go:39: expected 'db1100111db', got 'db1110011db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal == 0 {\n        return \"db0db\"\n    }\n    var binary string\n   \
    \ for decimal > 0 {\n        binary = fmt.Sprintf(\"%d%s\", decimal % 2, binary)\n\
    \        decimal /= 2\n    }\n    return fmt.Sprintf(\"db%sdb\", binary)\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkbo3_do__test.go:35: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpkbo3_do__test.go:35: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal == 0 {\n        return \"db0db\"\n    }\n\n    result := \"db\"\n  \
    \  for decimal > 0 {\n        if decimal % 2 == 0 {\n            result = \"0\"\
    \ + result\n        } else {\n            result = \"1\" + result\n        }\n\
    \        decimal /= 2\n    }\n    return result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp64_ve6b8_test.go:47: expected 'db100000db', got '100000dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp64_ve6b8_test.go:47:\
    \ expected 'db1100111db', got '1100111dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmp64_ve6b8_test.go:47: expected 'db1111db', got '1111dbdb'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ binary string\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%d%s\"\
    , decimal % 2, binary)\n        decimal /= 2\n    }\n    return \"db\" + binary\
    \ + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpaafrobea_test.go:39: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ binary string\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%d%s\"\
    , decimal % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmprg9h405m_test.go:39: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkbo3_do__test.go:35: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpkbo3_do__test.go:35: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ TODO: implement\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpt7akm8wu_test.go:35: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpt7akm8wu_test.go:35: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpt7akm8wu_test.go:35: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpt7akm8wu_test.go:35: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal == 0 {\n        return \"db0db\"\n    }\n\n    binary := \"\"\n    for\
    \ decimal > 0 {\n        binary = fmt.Sprintf(\"%d%s\", decimal % 2, binary)\n\
    \        decimal /= 2\n    }\n\n    return fmt.Sprintf(\"db%sdb\", binary)\n}\n\
    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkbo3_do__test.go:35: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpkbo3_do__test.go:35: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ binary string\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%d%s\"\
    , decimal % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmprg9h405m_test.go:39: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkbo3_do__test.go:35: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpkbo3_do__test.go:35: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkbo3_do__test.go:35: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpkbo3_do__test.go:35: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ binary string = \"db\"\n    for decimal > 0 {\n        binary += string(decimal\
    \ % 2 + 48)\n        decimal /= 2\n    }\n    binary += \"db\"\n    return binary\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpw8nof2k3_test.go:17:19: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ TODO: implement\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpt7akm8wu_test.go:35: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpt7akm8wu_test.go:35: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpt7akm8wu_test.go:35: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpt7akm8wu_test.go:35: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkbo3_do__test.go:35: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpkbo3_do__test.go:35: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    binary\
    \ := \"\"\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%d%s\", decimal\
    \ % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"db%sdb\"\
    , binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp3n6da8uh_test.go:39: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal == 0 {\n        return \"db0db\"\n    }\n\n    var binary string\n \
    \   for decimal > 0 {\n        binary = fmt.Sprintf(\"%d%s\", decimal % 2, binary)\n\
    \        decimal /= 2\n    }\n\n    return fmt.Sprintf(\"db%sdb\", binary)\n}\n\
    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkbo3_do__test.go:35: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpkbo3_do__test.go:35: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ result string\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%d%s\"\
    , decimal % 2, result)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", result)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpzz17p6fn_test.go:39: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"%b\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp62makddo_test.go:34: expected 'db0db', got '0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp62makddo_test.go:34:\
    \ expected 'db100000db', got '100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp62makddo_test.go:34: expected 'db1100111db', got '1100111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp62makddo_test.go:34:\
    \ expected 'db1111db', got '1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ Your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp9_pmuici_test.go:35: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp9_pmuici_test.go:35: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp9_pmuici_test.go:35: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp9_pmuici_test.go:35: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ result string\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%d%s\"\
    , decimal % 2, result)\n        decimal /= 2\n    }\n    return \"db\" + result\
    \ + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpje045et7_test.go:39: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    if\
    \ decimal == 0 {\n        return \"db0db\"\n    }\n\n    binary := \"db\"\n  \
    \  for decimal > 0 {\n        binary += fmt.Sprintf(\"%d\", decimal % 2)\n   \
    \     decimal /= 2\n    }\n    binary += \"db\"\n\n    return binary\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpnky7r7se_test.go:45: expected 'db100000db', got 'db000001db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpnky7r7se_test.go:45:\
    \ expected 'db1100111db', got 'db1110011db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ result string\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%d%s\"\
    , decimal % 2, result)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", result)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpzz17p6fn_test.go:39: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkbo3_do__test.go:35: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpkbo3_do__test.go:35: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%db\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpfujemggl_test.go:34: expected 'db0db', got 'db0b'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpfujemggl_test.go:34:\
    \ expected 'db100000db', got 'db32b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpfujemggl_test.go:34: expected 'db1100111db', got 'db103b'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpfujemggl_test.go:34:\
    \ expected 'db1111db', got 'db15b'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkbo3_do__test.go:35: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpkbo3_do__test.go:35: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ result string\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%v%v\"\
    , decimal % 2, result)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%vdb\", result)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpy53j_rab_test.go:39: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ result string\n    for decimal > 0 {\n        result = fmt.Sprintf(\"%d%s\"\
    , decimal % 2, result)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", result)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpzz17p6fn_test.go:39: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ binary string\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%d%s\"\
    , decimal % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmprg9h405m_test.go:39: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    //\
    \ your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkbo3_do__test.go:35: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpkbo3_do__test.go:35: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpkbo3_do__test.go:35: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    var\
    \ binary string\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%d%s\"\
    , decimal % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmprg9h405m_test.go:39: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074297
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\nfunc decimal_to_binary(decimal int) string {\n    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074297
