language: go_test.go
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, v := range lst {\n        s\
    \ += v\n    }\n    return match_parens_str(s)\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4zvp77p1_test.go:22:12: undefined: match_parens_str

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, v := range lst {\n        s\
    \ += v\n    }\n    fmt.Println(s)\n    var stack []rune\n    for _, c := range\
    \ s {\n        if c == '(' {\n            stack = append(stack, c)\n        }\
    \ else {\n            if len(stack) == 0 {\n                return \"No\"\n  \
    \          }\n            stack = stack[:len(stack)-1]\n        }\n    }\n   \
    \ if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "()()\n))\n(()(())())())\n)())(()()(\n(())))(()())((\n()())\n(()(()))()\n\
    ((((((())\n)(()(()(\n)()(\n()\n)(\n--- FAIL: TestMatch_Parens (0.00s)\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmph6l0gb0r_test.go:64:\
    \ expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n\
    \        tmph6l0gb0r_test.go:64: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmph6l0gb0r_test.go:64: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp38rui49z_test.go:45: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp38rui49z_test.go:45: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp38rui49z_test.go:45: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp38rui49z_test.go:45: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp38rui49z_test.go:45: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp38rui49z_test.go:45: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    for _, s := range lst {\n        if len(s) % 2 != 0\
    \ {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpr3kgiesc_test.go:50: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpr3kgiesc_test.go:50: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpr3kgiesc_test.go:50: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmpr3kgiesc_test.go:50: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpr3kgiesc_test.go:50: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var (\n        open int\n        close int\n    )\n\
    \    for _, s := range lst {\n        for _, c := range s {\n            if c\
    \ == '(' {\n                open++\n            } else {\n                close++\n\
    \            }\n        }\n    }\n    if open == close {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmp4mut73sf_test.go:61: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, str := range lst {\n      \
    \  s += str\n    }\n    var stack []rune\n    for _, c := range s {\n        if\
    \ c == '(' {\n            stack = append(stack, c)\n        } else {\n       \
    \     if len(stack) == 0 {\n                return \"No\"\n            }\n   \
    \         stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) ==\
    \ 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp2xtmi2vc_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp2xtmi2vc_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp2xtmi2vc_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var stack []string\n    for _, s := range lst {\n  \
    \      for _, c := range s {\n            if c == '(' {\n                stack\
    \ = append(stack, \"(\")\n            } else {\n                if len(stack)\
    \ == 0 {\n                    return \"No\"\n                }\n             \
    \   stack = stack[:len(stack)-1]\n            }\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpxv5zb5_j_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpxv5zb5_j_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpxv5zb5_j_test.go:61: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var stack []rune\n    for _, str := range lst {\n  \
    \      for _, c := range str {\n            if c == '(' {\n                stack\
    \ = append(stack, c)\n            } else {\n                if len(stack) == 0\
    \ {\n                    return \"No\"\n                }\n                stack\
    \ = stack[:len(stack)-1]\n            }\n        }\n    }\n    if len(stack) ==\
    \ 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpk_p3vw9e_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpk_p3vw9e_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpk_p3vw9e_test.go:61: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var open, close int\n    for _, s := range lst {\n \
    \       for _, c := range s {\n            if c == '(' {\n                open++\n\
    \            } else {\n                close++\n            }\n        }\n   \
    \ }\n    if open == close {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpo8luunnj_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var res string\n    for _, s := range lst {\n      \
    \  res += s\n    }\n    return res\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp3n4imhuh_test.go:49: expected 'Yes', got '()()'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmp3n4imhuh_test.go:49:\
    \ expected 'No', got '))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmp3n4imhuh_test.go:49: expected 'No', got '(()(())())())'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp3n4imhuh_test.go:49: expected\
    \ 'Yes', got ')())(()()('\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n\
    \        tmp3n4imhuh_test.go:49: expected 'Yes', got '(())))(()())(('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmp3n4imhuh_test.go:49:\
    \ expected 'No', got '()())'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmp3n4imhuh_test.go:49: expected 'Yes', got '(()(()))()'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmp3n4imhuh_test.go:49: expected\
    \ 'No', got '((((((())'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmp3n4imhuh_test.go:49: expected 'No', got ')(()(()('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp3n4imhuh_test.go:49: expected\
    \ 'No', got ')()('\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n    \
    \    tmp3n4imhuh_test.go:49: expected 'Yes', got '()'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmp3n4imhuh_test.go:49: expected 'Yes', got ')('\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var l, r int\n    for _, s := range lst {\n        for\
    \ _, c := range s {\n            if c == '(' {\n                l++\n        \
    \    } else {\n                r++\n            }\n        }\n    }\n    if l\
    \ == r {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpsow55soa_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, v := range lst {\n        s\
    \ += v\n    }\n    var stack []byte\n    for _, v := range s {\n        if v ==\
    \ '(' {\n            stack = append(stack, byte(v))\n        } else {\n      \
    \      if len(stack) > 0 {\n                stack = stack[:len(stack)-1]\n   \
    \         } else {\n                return \"No\"\n            }\n        }\n\
    \    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"\
    No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpolyful5i_test.go:64: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpolyful5i_test.go:64: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpolyful5i_test.go:64: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, v := range lst {\n        s\
    \ += v\n    }\n    var stack []rune\n    for _, c := range s {\n        if c ==\
    \ '(' {\n            stack = append(stack, c)\n        } else {\n            if\
    \ len(stack) == 0 {\n                return \"No\"\n            }\n          \
    \  stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0 {\n\
    \        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpcmrlia0u_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpcmrlia0u_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpcmrlia0u_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, v := range lst {\n        s\
    \ += v\n    }\n    var stack []byte\n    for _, c := range s {\n        if c ==\
    \ '(' {\n            stack = append(stack, byte(c))\n        } else {\n      \
    \      if len(stack) == 0 {\n                return \"No\"\n            }\n  \
    \          stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) ==\
    \ 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpd0fa3f3n_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpd0fa3f3n_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpd0fa3f3n_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    var s1, s2 string = lst[0], lst[1]\n\
    \    var s1_len, s2_len int = len(s1), len(s2)\n    var s1_open, s1_close, s2_open,\
    \ s2_close int\n    var i int\n\n    for i = 0; i < s1_len; i++ {\n        if\
    \ s1[i] == '(' {\n            s1_open++\n        } else {\n            s1_close++\n\
    \        }\n    }\n\n    for i = 0; i < s2_len; i++ {\n        if s2[i] == '('\
    \ {\n            s2_open++\n        } else {\n            s2_close++\n       \
    \ }\n    }\n\n    if s1_open == s1_close && s2_open == s2_close {\n        result\
    \ = \"Yes\"\n    } else if s1_open == s1_close && s2_open != s2_close {\n    \
    \    if s2_open > s2_close {\n            s2_open -= s2_close\n            s2_close\
    \ = 0\n            if s1_open >= s2_open {\n                result = \"Yes\"\n\
    \            } else {\n                result = \"No\"\n            }\n      \
    \  } else {\n            s2_close -= s2_open\n            s2_open = 0\n      \
    \      if s1_close >= s2_close {\n                result = \"Yes\"\n         \
    \   } else {\n                result = \"No\"\n            }\n        }\n    }\
    \ else if s1_open != s1_close && s2_open == s2_close {\n        if s1_open > s1_close\
    \ {\n            s1_open -= s1_close\n            s1_close = 0\n            if\
    \ s2_open >= s1_open {\n                result = \"Yes\"\n            } else {\n\
    \                result = \"No\"\n            }\n        } else {\n          \
    \  s1_close -= s1_open\n            s1_open = 0\n            if s2_close >= s1_close\
    \ {\n                result = \"Yes\"\n            } else {\n               \n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9pj5e4pn_test.go:76:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073763
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return check_parens(s2)\n   \
    \ }\n    if len(s2) == 0 {\n        return check_parens(s1)\n    }\n    if check_parens(s1)\
    \ == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2) == \"Yes\"\
    \ {\n        return \"Yes\"\n    }\n    if check_parens(s1 + s2) == \"Yes\" {\n\
    \        return \"Yes\"\n    }\n    if check_parens(s2 + s1) == \"Yes\" {\n  \
    \      return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwfl2jyn__test.go:26:16: undefined: check_parens

    /tmp/tmpwfl2jyn__test.go:29:16: undefined: check_parens

    /tmp/tmpwfl2jyn__test.go:31:8: undefined: check_parens

    /tmp/tmpwfl2jyn__test.go:34:8: undefined: check_parens

    /tmp/tmpwfl2jyn__test.go:37:8: undefined: check_parens

    /tmp/tmpwfl2jyn__test.go:40:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // Write your code here\n    return \"\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp9xphil08_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmp9xphil08_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmp9xphil08_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmp9xphil08_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp9xphil08_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmp9xphil08_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmp9xphil08_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmp9xphil08_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmp9xphil08_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp9xphil08_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmp9xphil08_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmp9xphil08_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpv_t7fv3q_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpv_t7fv3q_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpv_t7fv3q_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpv_t7fv3q_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, s1 := range lst {\n       \
    \ s += s1\n    }\n    var count int\n    for _, c := range s {\n        if c ==\
    \ '(' {\n            count++\n        } else {\n            count--\n        }\n\
    \        if count < 0 {\n            return \"No\"\n        }\n    }\n    if count\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpcawf7eg7_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpcawf7eg7_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpcawf7eg7_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n        return check_parens(s2)\n\
    \    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n    }\n    if\
    \ check_parens(s1) == \"Yes\" && check_parens(s2) == \"Yes\" {\n        return\
    \ \"Yes\"\n    }\n    if check_parens(s1 + s2) == \"Yes\" {\n        return \"\
    Yes\"\n    }\n    if check_parens(s2 + s1) == \"Yes\" {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxe3dmivi_test.go:23:16: undefined: check_parens

    /tmp/tmpxe3dmivi_test.go:26:16: undefined: check_parens

    /tmp/tmpxe3dmivi_test.go:28:8: undefined: check_parens

    /tmp/tmpxe3dmivi_test.go:31:8: undefined: check_parens

    /tmp/tmpxe3dmivi_test.go:34:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var left, right int\n    for _, s := range lst {\n \
    \       for _, c := range s {\n            if c == '(' {\n                left++\n\
    \            } else {\n                right++\n            }\n        }\n   \
    \ }\n    if left == right {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpy4_5p4kp_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var (\n        s1, s2 string\n        i, j int\n   \
    \     c1, c2 int\n    )\n    s1 = lst[0]\n    s2 = lst[1]\n    i = 0\n    j =\
    \ 0\n    c1 = 0\n    c2 = 0\n    for i < len(s1) && j < len(s2) {\n        if\
    \ s1[i] == '(' {\n            c1++\n        } else {\n            c1--\n     \
    \   }\n        if s2[j] == '(' {\n            c2++\n        } else {\n       \
    \     c2--\n        }\n        if c1 < 0 || c2 < 0 {\n            return \"No\"\
    \n        }\n        i++\n        j++\n    }\n    if c1 != 0 || c2 != 0 {\n  \
    \      return \"No\"\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp23mqkswx_test.go:76: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp23mqkswx_test.go:76: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp23mqkswx_test.go:76: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__5\
    \ (0.00s)\n        tmp23mqkswx_test.go:76: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmp23mqkswx_test.go:76: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmp23mqkswx_test.go:76: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmp23mqkswx_test.go:76: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n        return \"Yes\"\n\
    \    }\n    if len(s2) == 0 {\n        return \"Yes\"\n    }\n    if s1[0] ==\
    \ '(' && s2[0] == ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n\
    \    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpzjc2eme2_test.go:67: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpzjc2eme2_test.go:67: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var open, close int\n    for _, s := range lst {\n \
    \       for _, c := range s {\n            if c == '(' {\n                open++\n\
    \            } else {\n                close++\n            }\n        }\n   \
    \ }\n    if open == close {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpo8luunnj_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) % 2 != 0 || len(s2) % 2 != 0 {\n\
    \        return \"No\"\n    }\n    if len(s1) == 0 && len(s2) == 0 {\n       \
    \ return \"Yes\"\n    }\n    if len(s1) == 0 {\n        return check_parens(s2)\n\
    \    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n    }\n    if\
    \ check_parens(s1) == \"Yes\" {\n        return \"Yes\"\n    }\n    if check_parens(s2)\
    \ == \"Yes\" {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqubfdkf6_test.go:29:16: undefined: check_parens

    /tmp/tmpqubfdkf6_test.go:32:16: undefined: check_parens

    /tmp/tmpqubfdkf6_test.go:34:8: undefined: check_parens

    /tmp/tmpqubfdkf6_test.go:37:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var (\n        s1, s2 string\n        i, j int\n   \
    \     res string\n    )\n    s1 = lst[0]\n    s2 = lst[1]\n    for i < len(s1)\
    \ && j < len(s2) {\n        if s1[i] == '(' && s2[j] == ')' {\n            res\
    \ += \"()\"\n            i++\n            j++\n        } else if s1[i] == '('\
    \ && s2[j] == '(' {\n            res += \"(\"\n            i++\n        } else\
    \ if s1[i] == ')' && s2[j] == ')' {\n            res += \")\"\n            j++\n\
    \        } else if s1[i] == ')' && s2[j] == '(' {\n            res += \"(\"\n\
    \            j++\n        }\n    }\n    for i < len(s1) {\n        res += string(s1[i])\n\
    \        i++\n    }\n    for j < len(s2) {\n        res += string(s2[j])\n   \
    \     j++\n    }\n    fmt.Println(res)\n    return res\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "())(\n))\n((())()))(())\n(()()()())\n(((()())(())))\n(()))\n((()))())(\n\
    ((((((())\n(()()(()\n)()(\n()\n()\n--- FAIL: TestMatch_Parens (0.00s)\n    ---\
    \ FAIL: TestMatch_Parens/test_num__0 (0.00s)\n        tmp9_dhujvt_test.go:77:\
    \ expected 'Yes', got '())('\n    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n\
    \        tmp9_dhujvt_test.go:77: expected 'No', got '))'\n    --- FAIL: TestMatch_Parens/test_num__2\
    \ (0.00s)\n        tmp9_dhujvt_test.go:77: expected 'No', got '((())()))(())'\n\
    \    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmp9_dhujvt_test.go:77:\
    \ expected 'Yes', got '(()()()())'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmp9_dhujvt_test.go:77: expected 'Yes', got '(((()())(())))'\n\
    \    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmp9_dhujvt_test.go:77:\
    \ expected 'No', got '(()))'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmp9_dhujvt_test.go:77: expected 'Yes', got '((()))())('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmp9_dhujvt_test.go:77: expected\
    \ 'No', got '((((((())'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmp9_dhujvt_test.go:77: expected 'No', got '(()()(()'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmp9_dhujvt_test.go:77: expected\
    \ 'No', got ')()('\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n    \
    \    tmp9_dhujvt_test.go:77: expected 'Yes', got '()'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmp9_dhujvt_test.go:77: expected 'Yes', got '()'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // check if it is possible to concatenate the two strings\
    \ in\n    // some order, that the resulting string will be good.\n    // A string\
    \ S is considered to be good if and only if all parentheses in S\n    // are balanced.\
    \ For example: the string '(())()' is good, while the string\n    // '())' is\
    \ not.\n    // Return 'Yes' if there's a way to make a good string, and return\
    \ 'No' otherwise.\n    // Examples:\n    // match_parens(['(())', '()()']) = 'Yes'\n\
    \    // match_parens(['(()', '()()']) = 'No'\n    // match_parens(['(())', '())('])\
    \ = 'No'\n    // match_parens(['(()))', '()()']) = 'No'\n    // match_parens(['(()))',\
    \ '()()(']) = 'No'\n    // match_parens(['(()))', '()()()']) = 'Yes'\n    // match_parens(['(()))',\
    \ '()()()()']) = 'Yes'\n    // match_parens(['(()))', '()()()()()']) = 'Yes'\n\
    \    // match_parens(['(()))', '()()()()()()']) = 'Yes'\n    // match_parens(['(()))',\
    \ '()()()()()()()']) = 'Yes'\n    // match_parens(['(()))', '()()()()()()()()'])\
    \ = 'Yes'\n    // match_parens(['(()))', '()()()()()()()()()']) = 'Yes'\n    //\
    \ match_parens(['(()))', '()()()()()()()()()()']) = 'Yes'\n    // match_parens(['(()))',\
    \ '()()()()()()()()()()()']) = 'Yes'\n    // match_parens(['(()))', '()()()()()()()()()()()()'])\
    \ = 'Yes'\n    // match_parens(['(()))', '()()()()()()()\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt4g9zv_n_test.go:41:6: expected ''('', found TestMatch_Parens

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, v := range lst {\n        s\
    \ += v\n    }\n    fmt.Println(s)\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "()()\n))\n(()(())())())\n)())(()()(\n(())))(()())((\n()())\n(()(()))()\n\
    ((((((())\n)(()(()(\n)()(\n()\n)(\n--- FAIL: TestMatch_Parens (0.00s)\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmpdtx6dkau_test.go:50:\
    \ expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmpdtx6dkau_test.go:50: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5\
    \ (0.00s)\n        tmpdtx6dkau_test.go:50: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmpdtx6dkau_test.go:50: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n      \
    \  tmpdtx6dkau_test.go:50: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpdtx6dkau_test.go:50: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, str := range lst {\n      \
    \  s += str\n    }\n    var cnt int\n    for _, c := range s {\n        if c ==\
    \ '(' {\n            cnt++\n        } else {\n            cnt--\n        }\n \
    \       if cnt < 0 {\n            return \"No\"\n        }\n    }\n    if cnt\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp_t36p2nq_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp_t36p2nq_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp_t36p2nq_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var open, close int\n    for _, s := range lst {\n \
    \       for _, c := range s {\n            if c == '(' {\n                open++\n\
    \            } else {\n                close++\n            }\n        }\n   \
    \ }\n    if open == close {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpo8luunnj_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) % 2 != 0 || len(s2) % 2 != 0 {\n\
    \        return \"No\"\n    }\n    if len(s1) == 0 && len(s2) == 0 {\n       \
    \ return \"Yes\"\n    }\n    if len(s1) == 0 {\n        return match_parens([]string{s2[1:],\
    \ s2[:len(s2)-1]})\n    }\n    if len(s2) == 0 {\n        return match_parens([]string{s1[1:],\
    \ s1[:len(s1)-1]})\n    }\n    if s1[0] == '(' && s2[0] == ')' {\n        return\
    \ match_parens([]string{s1[1:], s2[1:]})\n    }\n    if s1[0] == ')' && s2[0]\
    \ == '(' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n   \
    \ if s1[len(s1)-1] == '(' && s2[len(s2)-1] == ')' {\n        return match_parens([]string{s1[:len(s1)-1],\
    \ s2[:len(s2)-1]})\n    }\n    if s1[len(s1)-1] == ')' && s2[len(s2)-1] == '('\
    \ {\n        return match_parens([]string{s1[:len(s1)-1], s2[:len(s2)-1]})\n \
    \   }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpv9b6_4g5_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpv9b6_4g5_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpv9b6_4g5_test.go:73: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpv9b6_4g5_test.go:73: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpv9b6_4g5_test.go:73: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpv9b6_4g5_test.go:73: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var open, close int\n    for _, s := range lst {\n \
    \       for _, c := range s {\n            if c == '(' {\n                open++\n\
    \            } else {\n                close++\n            }\n        }\n   \
    \ }\n    if open == close {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpo8luunnj_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n        return \"Yes\"\n\
    \    }\n    if len(s2) == 0 {\n        return \"Yes\"\n    }\n    if s1[0] ==\
    \ '(' && s2[0] == ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n\
    \    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpzjc2eme2_test.go:67: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpzjc2eme2_test.go:67: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var result string\n    if len(lst) == 0 {\n        return\
    \ \"No\"\n    }\n    for _, s := range lst {\n        if len(s) == 0 {\n     \
    \       continue\n        }\n        if len(result) == 0 {\n            result\
    \ = s\n            continue\n        }\n        if result[len(result)-1] == '('\
    \ && s[0] == ')' {\n            result = result[:len(result)-1] + s\n        \
    \    continue\n        }\n        if result[0] == ')' && s[len(s)-1] == '(' {\n\
    \            result = s + result\n            continue\n        }\n        return\
    \ \"No\"\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpb26bcpth_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpb26bcpth_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n      \
    \  tmpb26bcpth_test.go:67: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpb26bcpth_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var lst_len int = len(lst)\n    if lst_len == 0 {\n\
    \        return \"No\"\n    }\n    var str1, str2 string = lst[0], lst[1]\n  \
    \  var str1_len, str2_len int = len(str1), len(str2)\n    var str1_open, str1_close,\
    \ str2_open, str2_close int = 0, 0, 0, 0\n    for i := 0; i < str1_len; i++ {\n\
    \        if str1[i] == '(' {\n            str1_open++\n        } else {\n    \
    \        str1_close++\n        }\n    }\n    for i := 0; i < str2_len; i++ {\n\
    \        if str2[i] == '(' {\n            str2_open++\n        } else {\n    \
    \        str2_close++\n        }\n    }\n    if str1_open == str1_close && str2_open\
    \ == str2_close {\n        return \"Yes\"\n    }\n    if str1_open == str1_close\
    \ && str2_open != str2_close {\n        return \"No\"\n    }\n    if str1_open\
    \ != str1_close && str2_open == str2_close {\n        return \"No\"\n    }\n \
    \   if str1_open > str1_close {\n        if str2_open > str2_close {\n       \
    \     if str1_open - str1_close == str2_open - str2_close {\n                return\
    \ \"Yes\"\n            }\n        } else {\n            if str1_open - str1_close\
    \ == str2_close - str2_open {\n                return \"Yes\"\n            }\n\
    \        }\n    } else {\n        if str2_open > str2_close {\n            if\
    \ str1_close - str1_open == str2_open - str2_close {\n                return \"\
    Yes\"\n            }\n        } else {\n            if str1_close - str1_open\
    \ == str2_close - str2_open {\n                return \"Yes\"\n            }\n\
    \        }\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmplg6472sq_test.go:96: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmplg6472sq_test.go:96: expected\
    \ 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpv_t7fv3q_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpv_t7fv3q_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpv_t7fv3q_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpv_t7fv3q_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, s1 := range lst {\n       \
    \ s += s1\n    }\n    var stack []byte\n    for _, c := range s {\n        if\
    \ c == '(' {\n            stack = append(stack, byte(c))\n        } else {\n \
    \           if len(stack) == 0 {\n                return \"No\"\n            }\n\
    \            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpkjzdfccq_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpkjzdfccq_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpkjzdfccq_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var (\n        s1, s2 string\n        i, j int\n   \
    \     n1, n2 int\n    )\n    s1 = lst[0]\n    s2 = lst[1]\n    n1 = len(s1)\n\
    \    n2 = len(s2)\n    for i = 0; i < n1; i++ {\n        if s1[i] == '(' {\n \
    \           for j = 0; j < n2; j++ {\n                if s2[j] == ')' {\n    \
    \                s1 = s1[:i] + s1[i+1:]\n                    s2 = s2[:j] + s2[j+1:]\n\
    \                    n1--\n                    n2--\n                    i--\n\
    \                    break\n                }\n            }\n        }\n    }\n\
    \    if n1 == 0 && n2 == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpfnq0q80x_test.go:71: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpfnq0q80x_test.go:71: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpfnq0q80x_test.go:71: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpfnq0q80x_test.go:71: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpfnq0q80x_test.go:71: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var (\n        s1, s2 string\n        i, j int\n   \
    \     l1, l2 int\n        res string\n    )\n    s1 = lst[0]\n    s2 = lst[1]\n\
    \    l1 = len(s1)\n    l2 = len(s2)\n    i = 0\n    j = 0\n    for i < l1 && j\
    \ < l2 {\n        if s1[i] == '(' && s2[j] == ')' {\n            i++\n       \
    \     j++\n        } else if s1[i] == ')' && s2[j] == '(' {\n            i++\n\
    \            j++\n        } else if s1[i] == '(' && s2[j] == '(' {\n         \
    \   i++\n        } else if s1[i] == ')' && s2[j] == ')' {\n            j++\n \
    \       } else {\n            return \"No\"\n        }\n    }\n    if i < l1 {\n\
    \        res = s1[i:]\n    } else if j < l2 {\n        res = s2[j:]\n    } else\
    \ {\n        return \"Yes\"\n    }\n    if len(res) % 2 == 1 {\n        return\
    \ \"No\"\n    }\n    for i = 0; i < len(res); i++ {\n        if res[i] == '('\
    \ {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpc6c2asct_test.go:87: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpc6c2asct_test.go:87: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpc6c2asct_test.go:87: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__5\
    \ (0.00s)\n        tmpc6c2asct_test.go:87: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpc6c2asct_test.go:87: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // Your code here\n    return \"\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpne66mo_q_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpne66mo_q_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpne66mo_q_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpne66mo_q_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpne66mo_q_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpne66mo_q_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpne66mo_q_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpne66mo_q_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpne66mo_q_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpne66mo_q_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpne66mo_q_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpne66mo_q_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, s1 := range lst {\n       \
    \ s += s1\n    }\n    var c int\n    for _, r := range s {\n        if r == '('\
    \ {\n            c++\n        } else {\n            c--\n        }\n        if\
    \ c < 0 {\n            return \"No\"\n        }\n    }\n    if c == 0 {\n    \
    \    return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmppouqq5oc_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmppouqq5oc_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmppouqq5oc_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var left, right int\n    for _, s := range lst {\n \
    \       for _, c := range s {\n            if c == '(' {\n                left++\n\
    \            } else {\n                right++\n            }\n        }\n   \
    \ }\n    if left == right {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpy4_5p4kp_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    fmt.Println(lst)\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "[()( )]\n[) )]\n[(()(()) ())())]\n[)()) (()()(]\n[(()))) (()())((]\n[()\
    \ ())]\n[(()( ()))()]\n[(((( ((())]\n[)(() (()(]\n[)( )(]\n[( )]\n[) (]\n--- FAIL:\
    \ TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1 (0.00s)\n\
    \        tmpeb6nrlxq_test.go:46: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__2\
    \ (0.00s)\n        tmpeb6nrlxq_test.go:46: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpeb6nrlxq_test.go:46: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n      \
    \  tmpeb6nrlxq_test.go:46: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpeb6nrlxq_test.go:46: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpeb6nrlxq_test.go:46: expected\
    \ 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 && len(s2) > 0 {\n        return \"No\"\n\
    \    }\n    if len(s1) > 0 && len(s2) == 0 {\n        return \"No\"\n    }\n \
    \   if s1[0] == '(' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpns4ru8ma_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpns4ru8ma_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpns4ru8ma_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpns4ru8ma_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n        return \"Yes\"\n\
    \    }\n    if len(s2) == 0 {\n        return \"Yes\"\n    }\n    if s1[0] ==\
    \ '(' && s2[0] == ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n\
    \    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpzjc2eme2_test.go:67: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpzjc2eme2_test.go:67: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n        return \"Yes\"\n\
    \    }\n    if len(s2) == 0 {\n        return \"Yes\"\n    }\n    if s1[0] ==\
    \ '(' && s2[0] == ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n\
    \    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpzjc2eme2_test.go:67: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpzjc2eme2_test.go:67: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    s := lst[0] + lst[1]\n    stack := []byte{}\n    for\
    \ i := 0; i < len(s); i++ {\n        if s[i] == '(' {\n            stack = append(stack,\
    \ s[i])\n        } else {\n            if len(stack) == 0 {\n                return\
    \ \"No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n\
    \    }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"\
    No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpd4y7ky6x_test.go:60: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpd4y7ky6x_test.go:60: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpd4y7ky6x_test.go:60: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var stack []string\n    var result string\n    for _,\
    \ s := range lst {\n        for _, c := range s {\n            if c == '(' {\n\
    \                stack = append(stack, \"(\")\n            } else {\n        \
    \        if len(stack) == 0 {\n                    return \"No\"\n           \
    \     }\n                stack = stack[:len(stack)-1]\n            }\n       \
    \ }\n    }\n    if len(stack) == 0 {\n        result = \"Yes\"\n    } else {\n\
    \        result = \"No\"\n    }\n    return result\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmplml567gd_test.go:64: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmplml567gd_test.go:64: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmplml567gd_test.go:64: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var left, right int\n    for _, s := range lst {\n \
    \       for _, c := range s {\n            if c == '(' {\n                left++\n\
    \            } else {\n                right++\n            }\n        }\n   \
    \ }\n    if left == right {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpy4_5p4kp_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var stack []string\n    for _, s := range lst {\n  \
    \      for _, c := range s {\n            if c == '(' {\n                stack\
    \ = append(stack, \"(\")\n            } else {\n                if len(stack)\
    \ == 0 {\n                    return \"No\"\n                }\n             \
    \   stack = stack[:len(stack)-1]\n            }\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpxv5zb5_j_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpxv5zb5_j_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpxv5zb5_j_test.go:61: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, v := range lst {\n        s\
    \ += v\n    }\n    var stack []byte\n    for _, c := range s {\n        if c ==\
    \ '(' {\n            stack = append(stack, byte(c))\n        } else {\n      \
    \      if len(stack) == 0 {\n                return \"No\"\n            }\n  \
    \          stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) ==\
    \ 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpd0fa3f3n_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpd0fa3f3n_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpd0fa3f3n_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, str := range lst {\n      \
    \  s += str\n    }\n    var stack []rune\n    for _, c := range s {\n        if\
    \ c == '(' {\n            stack = append(stack, c)\n        } else {\n       \
    \     if len(stack) == 0 {\n                return \"No\"\n            }\n   \
    \         stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) ==\
    \ 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp2xtmi2vc_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp2xtmi2vc_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp2xtmi2vc_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var l, r int\n    for _, s := range lst {\n        for\
    \ _, c := range s {\n            if c == '(' {\n                l++\n        \
    \    } else {\n                r++\n            }\n        }\n    }\n    if l\
    \ == r {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpsow55soa_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpfunt_l1f_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpfunt_l1f_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpfunt_l1f_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpfunt_l1f_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpfunt_l1f_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpfunt_l1f_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpfunt_l1f_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpfunt_l1f_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpfunt_l1f_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpfunt_l1f_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpfunt_l1f_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpfunt_l1f_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpv_t7fv3q_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpv_t7fv3q_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpv_t7fv3q_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpv_t7fv3q_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var (\n        s1, s2 string\n        s3 string\n  \
    \      s4 string\n        s5 string\n        s6 string\n        s7 string\n  \
    \      s8 string\n        s9 string\n        s10 string\n        s11 string\n\
    \        s12 string\n        s13 string\n        s14 string\n        s15 string\n\
    \        s16 string\n        s17 string\n        s18 string\n        s19 string\n\
    \        s20 string\n        s21 string\n        s22 string\n        s23 string\n\
    \        s24 string\n        s25 string\n        s26 string\n        s27 string\n\
    \        s28 string\n        s29 string\n        s30 string\n        s31 string\n\
    \        s32 string\n        s33 string\n        s34 string\n        s35 string\n\
    \        s36 string\n        s37 string\n        s38 string\n        s39 string\n\
    \        s40 string\n        s41 string\n        s42 string\n        s43 string\n\
    \        s44 string\n        s45 string\n        s46 string\n        s47 string\n\
    \        s48 string\n        s49 string\n        s50 string\n        s51 string\n\
    \        s52 string\n        s53 string\n        s54 string\n        s55 string\n\
    \        s56 string\n        s57 string\n        s58 string\n        s59 string\n\
    \        s60 string\n        s61 string\n        s62 string\n        s63 string\n\
    \        s64 string\n        s65 string\n        s66 string\n        s67 string\n\
    \        s68 string\n        s69 string\n        s70 string\n        s71 string\n\
    \        s72 string\n        s73 string\n        s74 string\n        s75 string\n\
    \        s76 string\n        s77 string\n        s78 string\n        s79 string\n\
    \        s80 string\n        s81 string\n        s82 string\n        s83 string\n\
    \        s84 string\n        s85 string\n        s86 string\n        s87 string\n\
    \        s88 string\n        s89 string\n        s90 string\n        s91 string\n\
    \        s92 string\n        s93 string\n        s94 string\n        s95 string\n\
    \        s96 string\n        s97 string\n        s98 string\n        s99 string\n\
    \        s100 string\n        s101 string\n        s102 string\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptpsncdhz_test.go:120:1: expected ''IDENT'', found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, v := range lst {\n        s\
    \ += v\n    }\n    var stack []rune\n    for _, c := range s {\n        if c ==\
    \ '(' {\n            stack = append(stack, c)\n        } else {\n            if\
    \ len(stack) == 0 {\n                return \"No\"\n            }\n          \
    \  stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0 {\n\
    \        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpcmrlia0u_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpcmrlia0u_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpcmrlia0u_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var left, right int\n    for _, s := range lst {\n \
    \       for _, c := range s {\n            if c == '(' {\n                left++\n\
    \            } else {\n                right++\n            }\n        }\n   \
    \ }\n    if left == right {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpy4_5p4kp_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n        return check_parens(s2)\n\
    \    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n    }\n    if\
    \ check_parens(s1) == \"Yes\" && check_parens(s2) == \"Yes\" {\n        return\
    \ \"Yes\"\n    }\n    if check_parens(s1 + s2) == \"Yes\" {\n        return \"\
    Yes\"\n    }\n    if check_parens(s2 + s1) == \"Yes\" {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxe3dmivi_test.go:23:16: undefined: check_parens

    /tmp/tmpxe3dmivi_test.go:26:16: undefined: check_parens

    /tmp/tmpxe3dmivi_test.go:28:8: undefined: check_parens

    /tmp/tmpxe3dmivi_test.go:31:8: undefined: check_parens

    /tmp/tmpxe3dmivi_test.go:34:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var stack []rune\n    for _, s := range lst {\n    \
    \    for _, c := range s {\n            if c == '(' {\n                stack =\
    \ append(stack, c)\n            } else {\n                if len(stack) == 0 {\n\
    \                    return \"No\"\n                }\n                stack =\
    \ stack[:len(stack)-1]\n            }\n        }\n    }\n    if len(stack) ==\
    \ 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpf55w6yfz_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpf55w6yfz_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpf55w6yfz_test.go:61: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073768
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n        return \"Yes\"\n\
    \    }\n    if len(s2) == 0 {\n        return \"Yes\"\n    }\n    if s1[0] ==\
    \ '(' && s2[0] == ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n\
    \    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpzjc2eme2_test.go:67: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpzjc2eme2_test.go:67: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, str := range lst {\n      \
    \  s += str\n    }\n    return match_parens_str(s)\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_1trs6c8_test.go:22:12: undefined: match_parens_str

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073768
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var open, close int\n    for _, s := range lst {\n \
    \       for _, c := range s {\n            if c == '(' {\n                open++\n\
    \            } else {\n                close++\n            }\n        }\n   \
    \ }\n    if open == close {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpo8luunnj_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var open, close int\n    for _, s := range lst {\n \
    \       for _, c := range s {\n            if c == '(' {\n                open++\n\
    \            } else {\n                close++\n            }\n        }\n   \
    \ }\n    if open == close {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpo8luunnj_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, v := range lst {\n        s\
    \ += v\n    }\n    var c int\n    for _, v := range s {\n        if v == '(' {\n\
    \            c++\n        } else {\n            c--\n        }\n        if c <\
    \ 0 {\n            return \"No\"\n        }\n    }\n    if c == 0 {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpxo1gt792_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpxo1gt792_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpxo1gt792_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073768
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var stack []string\n    var res string\n    for _, s\
    \ := range lst {\n        for _, c := range s {\n            if c == '(' {\n \
    \               stack = append(stack, \"(\")\n            } else {\n         \
    \       if len(stack) == 0 {\n                    return \"No\"\n            \
    \    }\n                stack = stack[:len(stack)-1]\n            }\n        }\n\
    \    }\n    if len(stack) == 0 {\n        res = \"Yes\"\n    } else {\n      \
    \  res = \"No\"\n    }\n    return res\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpc5yqpzkh_test.go:64: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpc5yqpzkh_test.go:64: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpc5yqpzkh_test.go:64: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073769
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, s1 := range lst {\n       \
    \ s += s1\n    }\n    var stack []byte\n    for _, c := range s {\n        if\
    \ c == '(' {\n            stack = append(stack, byte(c))\n        } else {\n \
    \           if len(stack) == 0 {\n                return \"No\"\n            }\n\
    \            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpkjzdfccq_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpkjzdfccq_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpkjzdfccq_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, v := range lst {\n        s\
    \ += v\n    }\n    fmt.Println(s)\n    var stack []string\n    for _, v := range\
    \ s {\n        if string(v) == \"(\" {\n            stack = append(stack, string(v))\n\
    \        } else {\n            if len(stack) == 0 {\n                return \"\
    No\"\n            }\n            stack = stack[:len(stack)-1]\n        }\n   \
    \ }\n    if len(stack) == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "()()\n))\n(()(())())())\n)())(()()(\n(())))(()())((\n()())\n(()(()))()\n\
    ((((((())\n)(()(()(\n)()(\n()\n)(\n--- FAIL: TestMatch_Parens (0.00s)\n    ---\
    \ FAIL: TestMatch_Parens/test_num__3 (0.00s)\n        tmpo2hcdxde_test.go:64:\
    \ expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n\
    \        tmpo2hcdxde_test.go:64: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpo2hcdxde_test.go:64: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073769
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, str := range lst {\n      \
    \  s += str\n    }\n    var stack []rune\n    for _, c := range s {\n        if\
    \ c == '(' {\n            stack = append(stack, c)\n        } else {\n       \
    \     if len(stack) == 0 {\n                return \"No\"\n            }\n   \
    \         stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) ==\
    \ 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp2xtmi2vc_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp2xtmi2vc_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp2xtmi2vc_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, str := range lst {\n      \
    \  s += str\n    }\n    var stack []rune\n    for _, c := range s {\n        if\
    \ c == '(' {\n            stack = append(stack, c)\n        } else {\n       \
    \     if len(stack) == 0 {\n                return \"No\"\n            }\n   \
    \         stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) ==\
    \ 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp2xtmi2vc_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp2xtmi2vc_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp2xtmi2vc_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, str := range lst {\n      \
    \  s += str\n    }\n    var stack []byte\n    for _, c := range s {\n        if\
    \ c == '(' {\n            stack = append(stack, byte(c))\n        } else {\n \
    \           if len(stack) == 0 {\n                return \"No\"\n            }\n\
    \            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpb31gm3n9_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpb31gm3n9_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpb31gm3n9_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073769
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var (\n        i, j int\n        s1, s2 string\n   \
    \ )\n    s1 = lst[0]\n    s2 = lst[1]\n    for i = 0; i < len(s1); i++ {\n   \
    \     if s1[i] == '(' {\n            for j = 0; j < len(s2); j++ {\n         \
    \       if s2[j] == ')' {\n                    s1 = s1[:i] + s1[i+1:]\n      \
    \              s2 = s2[:j] + s2[j+1:]\n                    break\n           \
    \     }\n            }\n        }\n    }\n    if len(s1) == 0 && len(s2) == 0\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpsds8on8f_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpsds8on8f_test.go:65: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpsds8on8f_test.go:65: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpsds8on8f_test.go:65: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpsds8on8f_test.go:65: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073769
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n        return \"Yes\"\n\
    \    }\n    if len(s2) == 0 {\n        return \"Yes\"\n    }\n    if s1[0] ==\
    \ '(' && s2[0] == ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n\
    \    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpzjc2eme2_test.go:67: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpzjc2eme2_test.go:67: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n        return check_parens(s2)\n\
    \    }\n    if len(s2) == 0 {\n        return check_parens(s1)\n    }\n    if\
    \ check_parens(s1) == \"Yes\" && check_parens(s2) == \"Yes\" {\n        return\
    \ \"Yes\"\n    }\n    if check_parens(s1+s2) == \"Yes\" {\n        return \"Yes\"\
    \n    }\n    if check_parens(s2+s1) == \"Yes\" {\n        return \"Yes\"\n   \
    \ }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2925rinn_test.go:23:16: undefined: check_parens

    /tmp/tmp2925rinn_test.go:26:16: undefined: check_parens

    /tmp/tmp2925rinn_test.go:28:8: undefined: check_parens

    /tmp/tmp2925rinn_test.go:31:8: undefined: check_parens

    /tmp/tmp2925rinn_test.go:34:8: undefined: check_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073769
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, s1 := range lst {\n       \
    \ s += s1\n    }\n    var c int\n    for _, r := range s {\n        if r == '('\
    \ {\n            c++\n        } else {\n            c--\n        }\n        if\
    \ c < 0 {\n            return \"No\"\n        }\n    }\n    if c == 0 {\n    \
    \    return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmppouqq5oc_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmppouqq5oc_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmppouqq5oc_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var (\n        s1, s2 string\n        s3 string\n  \
    \      i, j int\n        c1, c2 int\n    )\n    s1 = lst[0]\n    s2 = lst[1]\n\
    \    i = 0\n    j = 0\n    c1 = 0\n    c2 = 0\n    for i < len(s1) && j < len(s2)\
    \ {\n        if s1[i] == '(' {\n            c1++\n        } else {\n         \
    \   c1--\n        }\n        if s2[j] == '(' {\n            c2++\n        } else\
    \ {\n            c2--\n        }\n        if c1 < 0 || c2 < 0 {\n            break\n\
    \        }\n        i++\n        j++\n    }\n    if c1 < 0 {\n        s3 = s1[i:]\
    \ + s2\n    } else if c2 < 0 {\n        s3 = s1 + s2[j:]\n    } else {\n     \
    \   s3 = s1 + s2\n    }\n    c1 = 0\n    for i = 0; i < len(s3); i++ {\n     \
    \   if s3[i] == '(' {\n            c1++\n        } else {\n            c1--\n\
    \        }\n        if c1 < 0 {\n            return \"No\"\n        }\n    }\n\
    \    if c1 == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpd0wdhcje_test.go:95: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpd0wdhcje_test.go:95: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpd0wdhcje_test.go:95: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073769
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073766
- exit_code: null
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var (\n        s1, s2 string\n        i, j int\n   \
    \     c1, c2 byte\n        ok bool\n    )\n    s1, s2 = lst[0], lst[1]\n    i,\
    \ j = 0, 0\n    for i < len(s1) && j < len(s2) {\n        c1, c2 = s1[i], s2[j]\n\
    \        if c1 == '(' {\n            i++\n        } else {\n            i--\n\
    \        }\n        if c2 == '(' {\n            j++\n        } else {\n      \
    \      j--\n        }\n        if i < 0 || j < 0 {\n            break\n      \
    \  }\n    }\n    if i < 0 {\n        i = -i\n    }\n    if j < 0 {\n        j\
    \ = -j\n    }\n    if i == 0 && j == 0 {\n        ok = true\n    } else {\n  \
    \      ok = false\n    }\n    if ok {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660073782
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, s1 := range lst {\n       \
    \ s += s1\n    }\n    var stack []int\n    for i, c := range s {\n        if c\
    \ == '(' {\n            stack = append(stack, i)\n        } else {\n         \
    \   if len(stack) == 0 {\n                return \"No\"\n            }\n     \
    \       stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp5kadghpq_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp5kadghpq_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp5kadghpq_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073769
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var stack []string\n    for _, s := range lst {\n  \
    \      for _, c := range s {\n            if c == '(' {\n                stack\
    \ = append(stack, \"(\")\n            } else {\n                if len(stack)\
    \ == 0 {\n                    return \"No\"\n                }\n             \
    \   stack = stack[:len(stack)-1]\n            }\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpxv5zb5_j_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpxv5zb5_j_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpxv5zb5_j_test.go:61: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, str := range lst {\n      \
    \  s += str\n    }\n    var count int\n    for _, c := range s {\n        if c\
    \ == '(' {\n            count++\n        } else {\n            count--\n     \
    \   }\n        if count < 0 {\n            return \"No\"\n        }\n    }\n \
    \   if count == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp9qyavrs5_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp9qyavrs5_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp9qyavrs5_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073769
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, v := range lst {\n        s\
    \ += v\n    }\n    var stack []rune\n    for _, c := range s {\n        if c ==\
    \ '(' {\n            stack = append(stack, c)\n        } else {\n            if\
    \ len(stack) == 0 {\n                return \"No\"\n            }\n          \
    \  stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0 {\n\
    \        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpcmrlia0u_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpcmrlia0u_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpcmrlia0u_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 && len(s2) != 0 {\n        return \"No\"\
    \n    }\n    if len(s1) != 0 && len(s2) == 0 {\n        return \"No\"\n    }\n\
    \    if s1[0] == '(' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmptgvda4nt_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmptgvda4nt_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmptgvda4nt_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmptgvda4nt_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073769
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var l, r int\n    for _, s := range lst {\n        for\
    \ _, c := range s {\n            if c == '(' {\n                l++\n        \
    \    } else {\n                r++\n            }\n        }\n    }\n    if l\
    \ == r {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpsow55soa_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var stack []string\n    for _, s := range lst {\n  \
    \      for _, c := range s {\n            if c == '(' {\n                stack\
    \ = append(stack, \"(\")\n            } else {\n                if len(stack)\
    \ == 0 {\n                    return \"No\"\n                }\n             \
    \   stack = stack[:len(stack)-1]\n            }\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpxv5zb5_j_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpxv5zb5_j_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpxv5zb5_j_test.go:61: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpv_t7fv3q_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpv_t7fv3q_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpv_t7fv3q_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpv_t7fv3q_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var left, right int\n    for _, s := range lst {\n \
    \       for _, c := range s {\n            if c == '(' {\n                left++\n\
    \            } else {\n                right++\n            }\n        }\n   \
    \ }\n    if left == right {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpy4_5p4kp_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, s1 := range lst {\n       \
    \ s += s1\n    }\n    var l int\n    for _, c := range s {\n        if c == '('\
    \ {\n            l++\n        } else {\n            l--\n        }\n        if\
    \ l < 0 {\n            return \"No\"\n        }\n    }\n    if l == 0 {\n    \
    \    return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp8uy0ci9j_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp8uy0ci9j_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp8uy0ci9j_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073769
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, str := range lst {\n      \
    \  s += str\n    }\n    var stack []rune\n    for _, c := range s {\n        if\
    \ c == '(' {\n            stack = append(stack, c)\n        } else {\n       \
    \     if len(stack) == 0 {\n                return \"No\"\n            }\n   \
    \         stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) >\
    \ 0 {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp8_yw_ob__test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp8_yw_ob__test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp8_yw_ob__test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073769
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var i, j int\n    var c1, c2 byte\n    var s1, s2 string\n\
    \    var stack []byte\n    var ok bool\n\n    s1 = lst[0]\n    s2 = lst[1]\n\n\
    \    for i = 0; i < len(s1); i++ {\n        c1 = s1[i]\n        if c1 == '(' {\n\
    \            stack = append(stack, c1)\n        } else {\n            if len(stack)\
    \ == 0 {\n                return \"No\"\n            }\n            c2 = stack[len(stack)-1]\n\
    \            if c2 == '(' {\n                stack = stack[:len(stack)-1]\n  \
    \          } else {\n                return \"No\"\n            }\n        }\n\
    \    }\n\n    for j = 0; j < len(s2); j++ {\n        c1 = s2[j]\n        if c1\
    \ == '(' {\n            stack = append(stack, c1)\n        } else {\n        \
    \    if len(stack) == 0 {\n                return \"No\"\n            }\n    \
    \        c2 = stack[len(stack)-1]\n            if c2 == '(' {\n              \
    \  stack = stack[:len(stack)-1]\n            } else {\n                return\
    \ \"No\"\n            }\n        }\n    }\n\n    if len(stack) == 0 {\n      \
    \  return \"Yes\"\n    }\n\n    for i = 0; i < len(stack); i++ {\n        c1 =\
    \ stack[i]\n        if c1 == '(' {\n            ok = false\n            for j\
    \ = 0; j < len(stack); j++ {\n                c2 = stack[j]\n                if\
    \ c2 == ')' {\n                    stack[i] = ')'\n                    stack[j]\
    \ = '('\n                    ok = true\n                    break\n          \
    \      }\n            }\n            if !ok {\n                return \"No\"\n\
    \            }\n        }\n    }\n\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpryzpcd8g_test.go:111: expected 'Yes', got 'No'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__4 (0.00s)\n        tmpryzpcd8g_test.go:111:\
    \ expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpryzpcd8g_test.go:111: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073769
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, str := range lst {\n      \
    \  s += str\n    }\n    return match_parens_str(s)\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_1trs6c8_test.go:22:12: undefined: match_parens_str

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073768
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, v := range lst {\n        s\
    \ += v\n    }\n    var stack []rune\n    for _, c := range s {\n        if c ==\
    \ '(' {\n            stack = append(stack, c)\n        } else {\n            if\
    \ len(stack) == 0 {\n                return \"No\"\n            }\n          \
    \  stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0 {\n\
    \        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpcmrlia0u_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpcmrlia0u_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpcmrlia0u_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var (\n        s1, s2 string\n        i, j int\n   \
    \     c1, c2 int\n    )\n    s1 = lst[0]\n    s2 = lst[1]\n    i = 0\n    j =\
    \ 0\n    c1 = 0\n    c2 = 0\n    for i < len(s1) {\n        if s1[i] == '(' {\n\
    \            c1++\n        } else {\n            c1--\n        }\n        i++\n\
    \    }\n    for j < len(s2) {\n        if s2[j] == '(' {\n            c2++\n \
    \       } else {\n            c2--\n        }\n        j++\n    }\n    if c1 ==\
    \ 0 && c2 == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc\
    \ TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n  \
    \   { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"(())))\", \"(()())((\"}), expected: \"Yes\" },\n     {\
    \ actual: candidate([]string{\"()\", \"())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\"(()(\", \"()))()\"}), expected: \"Yes\" },\n     { actual:\
    \ candidate([]string{\"((((\", \"((())\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(()\", \"(()(\"}), expected: \"No\" },\n     { actual:\
    \ candidate([]string{\")(\", \")(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"\
    (\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"\
    (\"}), expected: \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpz4jpro0k_test.go:75: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpz4jpro0k_test.go:75: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpz4jpro0k_test.go:75: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpz4jpro0k_test.go:75: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpz4jpro0k_test.go:75: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmpz4jpro0k_test.go:75: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpz4jpro0k_test.go:75: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073769
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var open, close int\n    for _, s := range lst {\n \
    \       for _, c := range s {\n            if c == '(' {\n                open++\n\
    \            } else {\n                close++\n            }\n        }\n   \
    \ }\n    if open == close {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpo8luunnj_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var stack []string\n    for _, s := range lst {\n  \
    \      for _, c := range s {\n            if c == '(' {\n                stack\
    \ = append(stack, \"(\")\n            } else {\n                if len(stack)\
    \ == 0 {\n                    return \"No\"\n                }\n             \
    \   stack = stack[:len(stack)-1]\n            }\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpxv5zb5_j_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpxv5zb5_j_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpxv5zb5_j_test.go:61: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var stack []string\n    for _, s := range lst {\n  \
    \      for _, c := range s {\n            if c == '(' {\n                stack\
    \ = append(stack, \"(\")\n            } else {\n                if len(stack)\
    \ == 0 {\n                    return \"No\"\n                }\n             \
    \   stack = stack[:len(stack)-1]\n            }\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpxv5zb5_j_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpxv5zb5_j_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpxv5zb5_j_test.go:61: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n        return \"Yes\"\n\
    \    }\n    if len(s2) == 0 {\n        return \"Yes\"\n    }\n    if s1[0] ==\
    \ '(' && s2[0] == ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n\
    \    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpzjc2eme2_test.go:67: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpzjc2eme2_test.go:67: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, str := range lst {\n      \
    \  s += str\n    }\n    var stack []rune\n    for _, c := range s {\n        if\
    \ c == '(' {\n            stack = append(stack, c)\n        } else {\n       \
    \     if len(stack) == 0 {\n                return \"No\"\n            }\n   \
    \         stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) ==\
    \ 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp2xtmi2vc_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp2xtmi2vc_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp2xtmi2vc_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, s1 := range lst {\n       \
    \ s += s1\n    }\n    var stack []rune\n    for _, r := range s {\n        if\
    \ r == '(' {\n            stack = append(stack, r)\n        } else {\n       \
    \     if len(stack) == 0 {\n                return \"No\"\n            }\n   \
    \         stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) ==\
    \ 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpz79az62e_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpz79az62e_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpz79az62e_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073769
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var (\n        s1, s2 string\n        s1len, s2len int\n\
    \        s1open, s2open int\n        s1close, s2close int\n        s1open_close,\
    \ s2open_close int\n        s1close_open, s2close_open int\n        s1open_open,\
    \ s2open_open int\n        s1close_close, s2close_close int\n        s1open_open_close,\
    \ s2open_open_close int\n        s1close_open_open, s2close_open_open int\n  \
    \      s1open_close_close, s2open_close_close int\n        s1close_close_open,\
    \ s2close_close_open int\n        s1open_open_open, s2open_open_open int\n   \
    \     s1close_close_close, s2close_close_close int\n        s1open_close_open,\
    \ s2open_close_open int\n        s1close_open_close, s2close_open_close int\n\
    \        s1open_open_close_open, s2open_open_close_open int\n        s1close_open_open_close,\
    \ s2close_open_open_close int\n        s1open_close_open_close, s2open_close_open_close\
    \ int\n        s1close_open_close_open, s2close_open_close_open int\n        s1open_open_open_close,\
    \ s2open_open_open_close int\n        s1close_close_open_open, s2close_close_open_open\
    \ int\n        s1open_close_close_open, s2open_close_close_open int\n        s1close_open_open_close,\
    \ s2close_open_open_close int\n        s1open_open_close_open_close, s2open_open_close_open_close\
    \ int\n        s1close_open_open_close_open, s2close_open_open_close_open int\n\
    \        s1open_close_open_close_open, s2open_close_open_close_open int\n    \
    \    s1close_open_close_open_close, s2\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprbr0b84w_test.go:46:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073768
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var (\n        s1, s2 string\n        s3 string\n  \
    \      i, j int\n        c1, c2 int\n    )\n    s1 = lst[0]\n    s2 = lst[1]\n\
    \    s3 = s1 + s2\n    c1 = 0\n    c2 = 0\n    for i = 0; i < len(s1); i++ {\n\
    \        if s1[i] == '(' {\n            c1++\n        } else {\n            c1--\n\
    \        }\n    }\n    for j = 0; j < len(s2); j++ {\n        if s2[j] == '('\
    \ {\n            c2++\n        } else {\n            c2--\n        }\n    }\n\
    \    if c1 == 0 && c2 == 0 {\n        return \"Yes\"\n    }\n    if c1 < 0 ||\
    \ c2 < 0 {\n        return \"No\"\n    }\n    for i = 0; i < len(s3); i++ {\n\
    \        if s3[i] == '(' {\n            c1++\n        } else {\n            c1--\n\
    \        }\n        if c1 == 0 {\n            return \"Yes\"\n        }\n    }\n\
    \    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpkgj0d7gi_test.go:86: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpkgj0d7gi_test.go:86: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpkgj0d7gi_test.go:86: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpkgj0d7gi_test.go:86: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpkgj0d7gi_test.go:86: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpkgj0d7gi_test.go:86: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10\
    \ (0.00s)\n        tmpkgj0d7gi_test.go:86: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__11 (0.00s)\n        tmpkgj0d7gi_test.go:86: expected\
    \ 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073769
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, v := range lst {\n        s\
    \ += v\n    }\n    return s\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmptspq9rn8_test.go:49: expected 'Yes', got '()()'\n    ---\
    \ FAIL: TestMatch_Parens/test_num__1 (0.00s)\n        tmptspq9rn8_test.go:49:\
    \ expected 'No', got '))'\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n\
    \        tmptspq9rn8_test.go:49: expected 'No', got '(()(())())())'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmptspq9rn8_test.go:49: expected\
    \ 'Yes', got ')())(()()('\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n\
    \        tmptspq9rn8_test.go:49: expected 'Yes', got '(())))(()())(('\n    ---\
    \ FAIL: TestMatch_Parens/test_num__5 (0.00s)\n        tmptspq9rn8_test.go:49:\
    \ expected 'No', got '()())'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n\
    \        tmptspq9rn8_test.go:49: expected 'Yes', got '(()(()))()'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmptspq9rn8_test.go:49: expected\
    \ 'No', got '((((((())'\n    --- FAIL: TestMatch_Parens/test_num__8 (0.00s)\n\
    \        tmptspq9rn8_test.go:49: expected 'No', got ')(()(()('\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmptspq9rn8_test.go:49: expected\
    \ 'No', got ')()('\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n    \
    \    tmptspq9rn8_test.go:49: expected 'Yes', got '()'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmptspq9rn8_test.go:49: expected 'Yes', got ')('\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073769
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var (\n        s1, s2 string\n        i, j int\n   \
    \     c1, c2 int\n    )\n    s1 = lst[0]\n    s2 = lst[1]\n    for i = 0; i <\
    \ len(s1); i++ {\n        if s1[i] == '(' {\n            c1++\n        } else\
    \ {\n            c1--\n        }\n    }\n    for j = 0; j < len(s2); j++ {\n \
    \       if s2[j] == '(' {\n            c2++\n        } else {\n            c2--\n\
    \        }\n    }\n    if c1 == 0 && c2 == 0 {\n        return \"Yes\"\n    }\n\
    \    if c1 < 0 || c2 < 0 {\n        return \"No\"\n    }\n    if c1 == c2 {\n\
    \        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpui27iu01_test.go:75: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpui27iu01_test.go:75: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpui27iu01_test.go:75: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpui27iu01_test.go:75: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpui27iu01_test.go:75: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n     \
    \   tmpui27iu01_test.go:75: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11\
    \ (0.00s)\n        tmpui27iu01_test.go:75: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073769
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return match_parens_helper(s2)\n\
    \    }\n    if len(s2) == 0 {\n        return match_parens_helper(s1)\n    }\n\
    \    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1i65kc56_test.go:26:16: undefined: match_parens_helper

    /tmp/tmp1i65kc56_test.go:29:16: undefined: match_parens_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073769
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, v := range lst {\n        s\
    \ += v\n    }\n    var stack []rune\n    for _, v := range s {\n        if v ==\
    \ '(' {\n            stack = append(stack, v)\n        } else {\n            if\
    \ len(stack) == 0 {\n                return \"No\"\n            }\n          \
    \  stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0 {\n\
    \        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpl5egsrzf_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpl5egsrzf_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpl5egsrzf_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073770
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var stack []string\n    for _, s := range lst {\n  \
    \      for _, c := range s {\n            if c == '(' {\n                stack\
    \ = append(stack, \"(\")\n            } else {\n                if len(stack)\
    \ == 0 {\n                    return \"No\"\n                }\n             \
    \   stack = stack[:len(stack)-1]\n            }\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpxv5zb5_j_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpxv5zb5_j_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpxv5zb5_j_test.go:61: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n        return \"Yes\"\n\
    \    }\n    if len(s2) == 0 {\n        return \"Yes\"\n    }\n    if s1[0] ==\
    \ '(' && s2[0] == ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n\
    \    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpzjc2eme2_test.go:67: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpzjc2eme2_test.go:67: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var (\n        s1, s2 string\n        s3 string\n  \
    \      i, j int\n        c1, c2, c3 int\n    )\n    s1 = lst[0]\n    s2 = lst[1]\n\
    \    s3 = s1 + s2\n    for i = 0; i < len(s1); i++ {\n        if s1[i] == '('\
    \ {\n            c1++\n        } else {\n            c1--\n        }\n    }\n\
    \    for j = 0; j < len(s2); j++ {\n        if s2[j] == '(' {\n            c2++\n\
    \        } else {\n            c2--\n        }\n    }\n    for i = 0; i < len(s3);\
    \ i++ {\n        if s3[i] == '(' {\n            c3++\n        } else {\n     \
    \       c3--\n        }\n        if c3 < 0 {\n            break\n        }\n \
    \   }\n    if c1 == 0 && c2 == 0 && c3 == 0 {\n        return \"Yes\"\n    }\n\
    \    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate :=\
    \ match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"()(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected:\
    \ \"No\" },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpbt14appo_test.go:81: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpbt14appo_test.go:81: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpbt14appo_test.go:81: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpbt14appo_test.go:81: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmpbt14appo_test.go:81: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpbt14appo_test.go:81: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073770
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var (\n        open, close int\n        s string\n \
    \   )\n    for _, s = range lst {\n        for _, c := range s {\n           \
    \ if c == '(' {\n                open++\n            } else {\n              \
    \  close++\n            }\n        }\n    }\n    if open == close {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmp13chqmjh_test.go:61: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073770
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var (\n        s1, s2 string\n        s string\n   \
    \     i, j int\n        c int\n    )\n    s1 = lst[0]\n    s2 = lst[1]\n    s\
    \ = s1 + s2\n    i = 0\n    j = len(s) - 1\n    for i < j {\n        if s[i] ==\
    \ '(' && s[j] == ')' {\n            i++\n            j--\n        } else if s[i]\
    \ == ')' && s[j] == '(' {\n            i++\n            j--\n            c++\n\
    \        } else if s[i] == '(' && s[j] == '(' {\n            i++\n           \
    \ c++\n        } else if s[i] == ')' && s[j] == ')' {\n            j--\n     \
    \       c++\n        }\n    }\n    if c % 2 == 0 {\n        return \"Yes\"\n \
    \   }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate\
    \ := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmppdxzyxxx_test.go:75: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmppdxzyxxx_test.go:75: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmppdxzyxxx_test.go:75: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__5\
    \ (0.00s)\n        tmppdxzyxxx_test.go:75: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__7 (0.00s)\n        tmppdxzyxxx_test.go:75: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmppdxzyxxx_test.go:75: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073770
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var stack []string\n    for _, s := range lst {\n  \
    \      for _, c := range s {\n            if c == '(' {\n                stack\
    \ = append(stack, \"(\")\n            } else {\n                if len(stack)\
    \ == 0 {\n                    return \"No\"\n                }\n             \
    \   stack = stack[:len(stack)-1]\n            }\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpxv5zb5_j_test.go:61: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpxv5zb5_j_test.go:61: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpxv5zb5_j_test.go:61: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 {\n        return \"Yes\"\n\
    \    }\n    if len(s2) == 0 {\n        return \"Yes\"\n    }\n    if s1[0] ==\
    \ '(' && s2[0] == ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n\
    \    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpzjc2eme2_test.go:67: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpzjc2eme2_test.go:67: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpzjc2eme2_test.go:67: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var l, r int\n    for _, s := range lst {\n        for\
    \ _, c := range s {\n            if c == '(' {\n                l++\n        \
    \    } else {\n                r++\n            }\n        }\n    }\n    if l\
    \ == r {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpsow55soa_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var open, close int\n    for _, s := range lst {\n \
    \       for _, c := range s {\n            if c == '(' {\n                open++\n\
    \            } else {\n                close++\n            }\n        }\n   \
    \ }\n    if open == close {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__9\
    \ (0.00s)\n        tmpo8luunnj_test.go:58: expected 'No', got 'Yes'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpv_t7fv3q_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmpv_t7fv3q_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmpv_t7fv3q_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmpv_t7fv3q_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 2
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, v := range lst {\n        s\
    \ += v\n    }\n    return match_parens_string(s)\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnr5rhcmo_test.go:22:12: undefined: match_parens_string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073770
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var (\n        s1, s2 string\n        i, j int\n   \
    \     ok bool\n    )\n    s1, s2 = lst[0], lst[1]\n    for i < len(s1) && j <\
    \ len(s2) {\n        if s1[i] == '(' && s2[j] == ')' {\n            i++\n    \
    \        j++\n            ok = true\n        } else if s1[i] == ')' && s2[j] ==\
    \ '(' {\n            i++\n            j++\n            ok = true\n        } else\
    \ {\n            return \"No\"\n        }\n    }\n    if ok {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp0cu38x2k_test.go:67: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp0cu38x2k_test.go:67: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n      \
    \  tmp0cu38x2k_test.go:67: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073770
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, s1 := range lst {\n       \
    \ s += s1\n    }\n    var stack []rune\n    for _, c := range s {\n        if\
    \ c == '(' {\n            stack = append(stack, c)\n        } else {\n       \
    \     if len(stack) == 0 {\n                return \"No\"\n            }\n   \
    \         stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) ==\
    \ 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpuhf_urdr_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpuhf_urdr_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpuhf_urdr_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073770
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) != 2 {\n        return \"No\"\n    }\n \
    \   s1, s2 := lst[0], lst[1]\n    if len(s1) == 0 && len(s2) == 0 {\n        return\
    \ \"Yes\"\n    }\n    if len(s1) == 0 {\n        return \"No\"\n    }\n    if\
    \ len(s2) == 0 {\n        return \"No\"\n    }\n    if s1[0] == '(' && s2[0] ==\
    \ ')' {\n        return match_parens([]string{s1[1:], s2[1:]})\n    }\n    if\
    \ s1[0] == '(' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    if s1[0] == ')' && s2[0] == ')' {\n        return match_parens([]string{s1[1:],\
    \ s2[1:]})\n    }\n    if s1[0] == ')' && s2[0] == '(' {\n        return match_parens([]string{s1[1:],\
    \ s2})\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t *testing.T) {\n\
    \  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n      \
    \  tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__6 (0.00s)\n        tmpqeiqtqcf_test.go:70: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpqeiqtqcf_test.go:70: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, str := range lst {\n      \
    \  s += str\n    }\n    var stack []rune\n    for _, c := range s {\n        if\
    \ c == '(' {\n            stack = append(stack, c)\n        } else {\n       \
    \     if len(stack) == 0 {\n                return \"No\"\n            }\n   \
    \         stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) ==\
    \ 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmp2xtmi2vc_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmp2xtmi2vc_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp2xtmi2vc_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // Your code here\n    return \"\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpne66mo_q_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpne66mo_q_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpne66mo_q_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpne66mo_q_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpne66mo_q_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpne66mo_q_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpne66mo_q_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpne66mo_q_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpne66mo_q_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpne66mo_q_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpne66mo_q_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpne66mo_q_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073767
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    // TODO - Add your code here\n    return \"\"\n}\n\n\
    func TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpvnte6mpp_test.go:46: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpvnte6mpp_test.go:46: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpvnte6mpp_test.go:46:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpvnte6mpp_test.go:46: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, v := range lst {\n        s\
    \ += v\n    }\n    var stack []rune\n    for _, c := range s {\n        if c ==\
    \ '(' {\n            stack = append(stack, c)\n        } else {\n            if\
    \ len(stack) == 0 {\n                return \"No\"\n            }\n          \
    \  stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) == 0 {\n\
    \        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpcmrlia0u_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpcmrlia0u_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpcmrlia0u_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    var s string\n    for _, s1 := range lst {\n       \
    \ s += s1\n    }\n    var stack []rune\n    for _, c := range s {\n        if\
    \ c == '(' {\n            stack = append(stack, c)\n        } else {\n       \
    \     if len(stack) == 0 {\n                return \"No\"\n            }\n   \
    \         stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) ==\
    \ 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\nfunc TestMatch_Parens(t\
    \ *testing.T) {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{\"()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"\
    )\", \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__3\
    \ (0.00s)\n        tmpuhf_urdr_test.go:63: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__4 (0.00s)\n        tmpuhf_urdr_test.go:63: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmpuhf_urdr_test.go:63: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073770
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    if len(lst) == 0 {\n        return \"Yes\"\n    }\n\
    \    if len(lst) == 1 {\n        return \"No\"\n    }\n    s1 := lst[0]\n    s2\
    \ := lst[1]\n    if len(s1) == 0 {\n        return match_parens([]string{s2})\n\
    \    }\n    if len(s2) == 0 {\n        return match_parens([]string{s1})\n   \
    \ }\n    if s1[0] == '(' {\n        if s2[0] == '(' {\n            return match_parens([]string{s1[1:],\
    \ s2})\n        } else {\n            return match_parens([]string{s1[1:], s2[1:]})\n\
    \        }\n    } else {\n        if s2[0] == '(' {\n            return match_parens([]string{s1,\
    \ s2[1:]})\n        } else {\n            return \"No\"\n        }\n    }\n}\n\
    \nfunc TestMatch_Parens(t *testing.T) {\n  candidate := match_parens\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"()(\", \")\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\")\", \")\"}), expected: \"No\" },\n\
    \     { actual: candidate([]string{\"(()(())\", \"())())\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\")())\", \"(()()(\"}), expected: \"Yes\"\
    \ },\n     { actual: candidate([]string{\"(())))\", \"(()())((\"}), expected:\
    \ \"Yes\" },\n     { actual: candidate([]string{\"()\", \"())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\"(()(\", \"()))()\"}), expected: \"\
    Yes\" },\n     { actual: candidate([]string{\"((((\", \"((())\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(()\", \"(()(\"}), expected: \"\
    No\" },\n     { actual: candidate([]string{\")(\", \")(\"}), expected: \"No\"\
    \ },\n     { actual: candidate([]string{\"(\", \")\"}), expected: \"Yes\" },\n\
    \     { actual: candidate([]string{\")\", \"(\"}), expected: \"Yes\" },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmp6baa1_ky_test.go:71: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__3 (0.00s)\n        tmp6baa1_ky_test.go:71: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__4 (0.00s)\n      \
    \  tmp6baa1_ky_test.go:71: expected 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__6\
    \ (0.00s)\n        tmp6baa1_ky_test.go:71: expected 'Yes', got 'No'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__10 (0.00s)\n        tmp6baa1_ky_test.go:71: expected\
    \ 'Yes', got 'No'\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n     \
    \   tmp6baa1_ky_test.go:71: expected 'Yes', got 'No'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660073770
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__0\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__1 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__2 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__3 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__4\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__5 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__6 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__7 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__8\
    \ (0.00s)\n        tmpm7d8fayg_test.go:45: expected 'No', got ''\n    --- FAIL:\
    \ TestMatch_Parens/test_num__9 (0.00s)\n        tmpm7d8fayg_test.go:45: expected\
    \ 'No', got ''\n    --- FAIL: TestMatch_Parens/test_num__10 (0.00s)\n        tmpm7d8fayg_test.go:45:\
    \ expected 'Yes', got ''\n    --- FAIL: TestMatch_Parens/test_num__11 (0.00s)\n\
    \        tmpm7d8fayg_test.go:45: expected 'Yes', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073766
- exit_code: 1
  program: "package match_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given a list of two strings, both strings consist of open\n//\
    \ parentheses '(' or close parentheses ')' only.\n// Your job is to check if it\
    \ is possible to concatenate the two strings in\n// some order, that the resulting\
    \ string will be good.\n// A string S is considered to be good if and only if\
    \ all parentheses in S\n// are balanced. For example: the string '(())()' is good,\
    \ while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n// Examples:\nfunc match_parens(lst\
    \ []string) string {\n    return \"Yes\"\n}\n\nfunc TestMatch_Parens(t *testing.T)\
    \ {\n  candidate := match_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    ()(\", \")\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\")\"\
    , \")\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(())\"\
    , \"())())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")())\"\
    , \"(()()(\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"(())))\"\
    , \"(()())((\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"()\"\
    , \"())\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(()(\",\
    \ \"()))()\"}), expected: \"Yes\" },\n     { actual: candidate([]string{\"((((\"\
    , \"((())\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(()\"\
    , \"(()(\"}), expected: \"No\" },\n     { actual: candidate([]string{\")(\", \"\
    )(\"}), expected: \"No\" },\n     { actual: candidate([]string{\"(\", \")\"}),\
    \ expected: \"Yes\" },\n     { actual: candidate([]string{\")\", \"(\"}), expected:\
    \ \"Yes\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMatch_Parens (0.00s)\n    --- FAIL: TestMatch_Parens/test_num__1\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__2 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__5 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__7\
    \ (0.00s)\n        tmpi62k186y_test.go:45: expected 'No', got 'Yes'\n    --- FAIL:\
    \ TestMatch_Parens/test_num__8 (0.00s)\n        tmpi62k186y_test.go:45: expected\
    \ 'No', got 'Yes'\n    --- FAIL: TestMatch_Parens/test_num__9 (0.00s)\n      \
    \  tmpi62k186y_test.go:45: expected 'No', got 'Yes'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073765
