language: go_test.go
name: HumanEval_159_eat
results:
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ need > remaining {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075105
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if remaining < need {\n        result = append(result, number\
    \ + remaining)\n        result = append(result, 0)\n    } else {\n        result\
    \ = append(result, number + need)\n        result = append(result, remaining -\
    \ need)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number >= need {\n        return []int{number, remaining}\n    }\n    if remaining\
    \ >= need - number {\n        return []int{need, remaining - (need - number)}\n\
    \    }\n    return []int{number + remaining, 0}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpb0zzj0z__test.go:54: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpb0zzj0z__test.go:54:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpb0zzj0z__test.go:54: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpb0zzj0z__test.go:54: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{0, 0}\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp7nfgy_bs_test.go:49: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp7nfgy_bs_test.go:49:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp7nfgy_bs_test.go:49: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp7nfgy_bs_test.go:49: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp7nfgy_bs_test.go:49: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp7nfgy_bs_test.go:49:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ need > remaining {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ need > remaining {\n        return []int{number + remaining, 0}\n    } else\
    \ {\n        return []int{number + need, remaining - need}\n    }\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075105
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ need <= remaining {\n        return []int{number + need, remaining - need}\n\
    \    }\n    return []int{number + remaining, 0}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ need > remaining {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   } else {\n        return []int{need, number + remaining - need}\n    }\n}\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp29t5g596_test.go:52: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp29t5g596_test.go:52:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp29t5g596_test.go:52: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp29t5g596_test.go:52: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + remaining < need {\n        result = append(result,\
    \ number + remaining)\n        result = append(result, 0)\n    } else {\n    \
    \    result = append(result, need)\n        result = append(result, number + remaining\
    \ - need)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpvuyq9bym_test.go:56: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpvuyq9bym_test.go:56:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpvuyq9bym_test.go:56: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpvuyq9bym_test.go:56: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   } else {\n        return []int{need, number + remaining - need}\n    }\n}\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp29t5g596_test.go:52: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp29t5g596_test.go:52:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp29t5g596_test.go:52: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp29t5g596_test.go:52: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + remaining < need {\n        result = append(result,\
    \ number + remaining)\n        result = append(result, 0)\n    } else {\n    \
    \    result = append(result, need)\n        result = append(result, number + remaining\
    \ - need)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpvuyq9bym_test.go:56: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpvuyq9bym_test.go:56:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpvuyq9bym_test.go:56: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpvuyq9bym_test.go:56: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   } else {\n        return []int{need, number + remaining - need}\n    }\n}\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp29t5g596_test.go:52: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp29t5g596_test.go:52:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp29t5g596_test.go:52: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp29t5g596_test.go:52: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   } else {\n        return []int{need, number + remaining - need}\n    }\n}\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp29t5g596_test.go:52: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp29t5g596_test.go:52:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp29t5g596_test.go:52: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp29t5g596_test.go:52: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   } else {\n        return []int{need, number + remaining - need}\n    }\n}\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp29t5g596_test.go:52: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp29t5g596_test.go:52:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp29t5g596_test.go:52: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp29t5g596_test.go:52: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    return\
    \ []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__3 (0.00s)\n\
    \        tmpbg9prxtz_test.go:48: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=13)\
    \ %!s(int=-6)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpbg9prxtz_test.go:48:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=9) %!s(int=-4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number >= need {\n        return []int{number, remaining}\n    }\n    if remaining\
    \ < need - number {\n        return []int{number + remaining, 0}\n    }\n    return\
    \ []int{need, remaining - (need - number)}\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpu14zxtt9_test.go:54: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpu14zxtt9_test.go:54:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpu14zxtt9_test.go:54: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpu14zxtt9_test.go:54: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   } else {\n        return []int{need, number + remaining - need}\n    }\n}\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp29t5g596_test.go:52: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp29t5g596_test.go:52:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp29t5g596_test.go:52: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp29t5g596_test.go:52: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   } else {\n        return []int{need, number + remaining - need}\n    }\n}\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp29t5g596_test.go:52: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp29t5g596_test.go:52:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp29t5g596_test.go:52: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp29t5g596_test.go:52: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + remaining < need {\n        result = append(result,\
    \ number + remaining)\n        result = append(result, 0)\n    } else {\n    \
    \    result = append(result, need)\n        result = append(result, number + remaining\
    \ - need)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpvuyq9bym_test.go:56: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpvuyq9bym_test.go:56:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpvuyq9bym_test.go:56: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpvuyq9bym_test.go:56: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ (number + remaining) < need {\n        return []int{number + remaining, 0}\n\
    \    }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp19tkqah1_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp19tkqah1_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp19tkqah1_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp19tkqah1_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number >= need {\n        return []int{number, remaining}\n    }\n    if remaining\
    \ < need - number {\n        return []int{number + remaining, 0}\n    }\n    return\
    \ []int{need, remaining - (need - number)}\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpu14zxtt9_test.go:54: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpu14zxtt9_test.go:54:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpu14zxtt9_test.go:54: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpu14zxtt9_test.go:54: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   } else {\n        return []int{need, number + remaining - need}\n    }\n}\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp29t5g596_test.go:52: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp29t5g596_test.go:52:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp29t5g596_test.go:52: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp29t5g596_test.go:52: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\ntype TestCase \n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkqji16ff_test.go:33:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075104
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    if number + remaining < need {\n        return []int{number\
    \ + remaining, 0}\n    }\n    return []int{need, number + remaining - need}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpopupe_mw_test.go:52: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpopupe_mw_test.go:52:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpopupe_mw_test.go:52: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpopupe_mw_test.go:52: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + remaining < need {\n        result = append(result,\
    \ number + remaining)\n        result = append(result, 0)\n    } else {\n    \
    \    result = append(result, need)\n        result = append(result, number + remaining\
    \ - need)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpvuyq9bym_test.go:56: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpvuyq9bym_test.go:56:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpvuyq9bym_test.go:56: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpvuyq9bym_test.go:56: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   } else {\n        return []int{need, number + remaining - need}\n    }\n}\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp29t5g596_test.go:52: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp29t5g596_test.go:52:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp29t5g596_test.go:52: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp29t5g596_test.go:52: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   } else {\n        return []int{need, number + remaining - need}\n    }\n}\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp29t5g596_test.go:52: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp29t5g596_test.go:52:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp29t5g596_test.go:52: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp29t5g596_test.go:52: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + remaining < need {\n        result = append(result,\
    \ number + remaining)\n        result = append(result, 0)\n    } else {\n    \
    \    result = append(result, need)\n        result = append(result, number + remaining\
    \ - need)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpvuyq9bym_test.go:56: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpvuyq9bym_test.go:56:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpvuyq9bym_test.go:56: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpvuyq9bym_test.go:56: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ remaining < need {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number >= need {\n        return []int{number, remaining}\n    }\n    if remaining\
    \ < need - number {\n        return []int{number + remaining, 0}\n    }\n    return\
    \ []int{need, remaining - (need - number)}\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpu14zxtt9_test.go:54: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpu14zxtt9_test.go:54:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpu14zxtt9_test.go:54: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpu14zxtt9_test.go:54: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ need > remaining {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number >= need {\n        return []int{number, remaining}\n    }\n    if remaining\
    \ >= need - number {\n        return []int{need, remaining - (need - number)}\n\
    \    }\n    return []int{number + remaining, 0}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpb0zzj0z__test.go:54: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpb0zzj0z__test.go:54:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpb0zzj0z__test.go:54: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpb0zzj0z__test.go:54: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number + remaining < need {\n        result = append(result,\
    \ number + remaining)\n        result = append(result, 0)\n    } else {\n    \
    \    result = append(result, need)\n        result = append(result, number + remaining\
    \ - need)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpvuyq9bym_test.go:56: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpvuyq9bym_test.go:56:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpvuyq9bym_test.go:56: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpvuyq9bym_test.go:56: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ your code here\n    return []int{}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_s4ky9ms_test.go:49: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_s4ky9ms_test.go:49: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number >= need {\n        return []int{number, remaining}\n    }\n    if remaining\
    \ < need - number {\n        return []int{number + remaining, 0}\n    }\n    return\
    \ []int{need, remaining - (need - number)}\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpu14zxtt9_test.go:54: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpu14zxtt9_test.go:54:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpu14zxtt9_test.go:54: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpu14zxtt9_test.go:54: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number + remaining < need {\n        return []int{number + remaining, 0}\n \
    \   }\n    return []int{need, number + remaining - need}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1h44u83i_test.go:51: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1h44u83i_test.go:51:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1h44u83i_test.go:51: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp1h44u83i_test.go:51: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075105
- exit_code: 0
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ need > remaining {\n        return []int{number + remaining, 0}\n    }\n   \
    \ return []int{number + need, remaining - need}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075105
