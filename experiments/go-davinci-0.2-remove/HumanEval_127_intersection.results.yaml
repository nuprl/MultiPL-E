language: go_test.go
name: HumanEval_127_intersection
results:
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    for i := 2; i < end; i++ {\n        if end % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpdt45tj2u_test.go:82: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpvaapmjj2_test.go:77: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start > end {\n        return \"NO\"\n    }\n    if isPrime(end - start)\
    \ {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4j30dsao_test.go:49:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if end1 < start2 || end2 < start1\
    \ {\n        return \"NO\"\n    }\n    if start1 > start2 {\n        start1 =\
    \ start2\n    }\n    if end1 < end2 {\n        end1 = end2\n    }\n    if start1\
    \ == end1 {\n        return \"YES\"\n    }\n    if start1 == 1 {\n        return\
    \ \"NO\"\n    }\n    for i := 2; i < start1; i++ {\n        if start1 % i == 0\
    \ {\n            return \"NO\"\n        }\n    }\n    for i := 2; i < end1; i++\
    \ {\n        if end1 % i == 0 {\n            return \"NO\"\n        }\n    }\n\
    \    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp21fwzdw1_test.go:80: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmp21fwzdw1_test.go:80: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if end1 < start2 || end2 < start1\
    \ {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    var primes = []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,\
    \ 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n    for _, prime := range primes {\n\
    \        if prime == end - start {\n            return \"YES\"\n        }\n  \
    \  }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpruvvpsq4_test.go:75: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__4 (0.00s)\n        tmpruvvpsq4_test.go:75: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmpruvvpsq4_test.go:75: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpvaapmjj2_test.go:77: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < end; i++ {\n        if end % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpd37kpc15_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpd37kpc15_test.go:74: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpd37kpc15_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpd37kpc15_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpd37kpc15_test.go:74: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < start; i++ {\n        if end % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpefxttfpa_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpefxttfpa_test.go:74: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpefxttfpa_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpefxttfpa_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpefxttfpa_test.go:74: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpvaapmjj2_test.go:77: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if end1 < start2 || end2 < start1\
    \ {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpvj4h_0_j_test.go:77: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpvj4h_0_j_test.go:77: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpvj4h_0_j_test.go:77: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpvj4h_0_j_test.go:77: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    for i := 2; i < end; i++ {\n        if end % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpdt45tj2u_test.go:82: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 2 || end == 2 {\n        return \"YES\"\n    }\n    if start\
    \ % 2 == 0 || end % 2 == 0 {\n        return \"NO\"\n    }\n    for i := 3; i\
    \ < end; i += 2 {\n        if start % i == 0 || end % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpekgp49qs_test.go:80: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmpekgp49qs_test.go:80: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpekgp49qs_test.go:80: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpekgp49qs_test.go:80: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpekgp49qs_test.go:80: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if end - start == 0 {\n        return \"NO\"\n \
    \   }\n    if end - start == 1 {\n        return \"YES\"\n    }\n    if end -\
    \ start == 2 {\n        return \"NO\"\n    }\n    for i := 2; i <= end - start;\
    \ i++ {\n        if (end - start) % i == 0 {\n            return \"NO\"\n    \
    \    }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmp600vexd2_test.go:80: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmp600vexd2_test.go:80: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmp600vexd2_test.go:80: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp600vexd2_test.go:80: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    for i := 2; i < end; i++ {\n        if end % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpdt45tj2u_test.go:82: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < start; i++ {\n        if start % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    for i := 2; i < end; i++ {\n        if end % i\
    \ == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpane6go9s_test.go:79: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpane6go9s_test.go:79: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpane6go9s_test.go:79: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpane6go9s_test.go:79: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpane6go9s_test.go:79: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpvaapmjj2_test.go:77: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if end1 < start2 || end2 < start1\
    \ {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < end; i++ {\n        if start % i == 0 && end % i == 0 {\n\
    \            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpnx17ic2f_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpnx17ic2f_test.go:74: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpnx17ic2f_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpnx17ic2f_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpnx17ic2f_test.go:74: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var start, end int\n    if interval1[0].(int) >\
    \ interval2[0].(int) {\n        start = interval1[0].(int)\n    } else {\n   \
    \     start = interval2[0].(int)\n    }\n    if interval1[1].(int) < interval2[1].(int)\
    \ {\n        end = interval1[1].(int)\n    } else {\n        end = interval2[1].(int)\n\
    \    }\n    if start > end {\n        return \"NO\"\n    }\n    if isPrime(end\
    \ - start + 1) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpspfvvx5d_test.go:36:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if end1 < start2 || end2 < start1\
    \ {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 2 {\n        return \"YES\"\n    }\n    if start % 2 == 0 {\n\
    \        return \"NO\"\n    }\n    for i := 3; i < end; i += 2 {\n        if start\
    \ % i == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpr_86ndjl_test.go:80: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmpr_86ndjl_test.go:80: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpr_86ndjl_test.go:80: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpr_86ndjl_test.go:80: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpr_86ndjl_test.go:80: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n    start := interval1[0].(int)\n\
    \    if interval2[0].(int) > start {\n        start = interval2[0].(int)\n   \
    \ }\n    end := interval1[1].(int)\n    if interval2[1].(int) < end {\n      \
    \  end = interval2[1].(int)\n    }\n    if start == end {\n        return \"YES\"\
    \n    }\n    for i := 2; i < start; i++ {\n        if end % i == 0 {\n       \
    \     return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp38t0v4ux_test.go:64: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp38t0v4ux_test.go:64: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp38t0v4ux_test.go:64: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp38t0v4ux_test.go:64: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmp38t0v4ux_test.go:64: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    if start1 < start2 {\n        start1\
    \ = start2\n    }\n    if end1 > end2 {\n        end1 = end2\n    }\n    if start1\
    \ == end1 {\n        return \"YES\"\n    }\n    if start1 == 2 || start1 == 3\
    \ || start1 == 5 || start1 == 7 {\n        return \"YES\"\n    }\n    if start1\
    \ % 2 == 0 || start1 % 3 == 0 || start1 % 5 == 0 || start1 % 7 == 0 {\n      \
    \  return \"NO\"\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpi203kccu_test.go:73: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmpi203kccu_test.go:73: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmpi203kccu_test.go:73: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpi203kccu_test.go:73: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpi203kccu_test.go:73: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmpi203kccu_test.go:73: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpvaapmjj2_test.go:77: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int)\
    \ > interval2[0].(int) {\n        interval1, interval2 = interval2, interval1\n\
    \    }\n    if interval1[1].(int) < interval2[1].(int) {\n        interval2[0]\
    \ = interval1[1]\n    } else {\n        interval2[0] = interval2[1]\n    }\n \
    \   if interval2[0].(int) - interval1[0].(int) == 1 {\n        return \"YES\"\n\
    \    }\n    for i := 2; i < interval2[0].(int); i++ {\n        if interval2[0].(int)\
    \ % i == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmphhjxllun_test.go:64: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmphhjxllun_test.go:64: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmphhjxllun_test.go:64: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmphhjxllun_test.go:64: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmphhjxllun_test.go:64: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    for i := 2; i < end; i++ {\n        if end % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpdt45tj2u_test.go:82: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpvaapmjj2_test.go:77: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    for i := 2; i < end; i++ {\n        if end % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpdt45tj2u_test.go:82: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp8eiqxw8d_test.go:45: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmp8eiqxw8d_test.go:45: expected\
    \ 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if end1\
    \ < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    start := start1\n\
    \    if start2 > start1 {\n        start = start2\n    }\n    end := end1\n  \
    \  if end2 < end1 {\n        end = end2\n    }\n    if start == end {\n      \
    \  return \"YES\"\n    }\n    for i := start + 1; i < end; i++ {\n        if end\
    \ % i == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp_zd8pne2_test.go:68: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp_zd8pne2_test.go:68: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmp_zd8pne2_test.go:68: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp_zd8pne2_test.go:68: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmp_zd8pne2_test.go:68: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmp_zd8pne2_test.go:68: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if end1 < start2 || end2 < start1\
    \ {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    for i := 2; i < end; i++ {\n        if end % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpb_h30x_0_test.go:82: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpb_h30x_0_test.go:82: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpb_h30x_0_test.go:82: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpb_h30x_0_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start < start2\
    \ {\n        start = start2\n    }\n    end := end1\n    if end > end2 {\n   \
    \     end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < start; i++ {\n        if start % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    for i := 2; i < end; i++ {\n        if end % i\
    \ == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpeuogugu9_test.go:79: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpeuogugu9_test.go:79: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpeuogugu9_test.go:79: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpeuogugu9_test.go:79: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpeuogugu9_test.go:79: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpvaapmjj2_test.go:77: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    for i := 2; i < end; i++ {\n        if end % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpdt45tj2u_test.go:82: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    if start1 < start2 {\n        start1\
    \ = start2\n    }\n    if end1 > end2 {\n        end1 = end2\n    }\n    if start1\
    \ == end1 {\n        return \"YES\"\n    }\n    if start1 == 1 {\n        return\
    \ \"NO\"\n    }\n    for i := 2; i < start1; i++ {\n        if start1 % i == 0\
    \ {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpotziwbqb_test.go:75: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpotziwbqb_test.go:75: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpotziwbqb_test.go:75: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpotziwbqb_test.go:75: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if end1 < start2 || end2 < start1\
    \ {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < start; i++ {\n        if start % i == 0 && end % i == 0 {\n\
    \            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp4didayth_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp4didayth_test.go:74: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp4didayth_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp4didayth_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmp4didayth_test.go:74: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 0
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if end - start < 2 {\n        return \"NO\"\n  \
    \  }\n    for i := 2; i < end - start; i++ {\n        if (end - start) % i ==\
    \ 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < start; i++ {\n        if end % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpefxttfpa_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpefxttfpa_test.go:74: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpefxttfpa_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpefxttfpa_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpefxttfpa_test.go:74: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var start, end int\n    if interval1[0].(int) >\
    \ interval2[0].(int) {\n        start = interval1[0].(int)\n    } else {\n   \
    \     start = interval2[0].(int)\n    }\n    if interval1[1].(int) < interval2[1].(int)\
    \ {\n        end = interval1[1].(int)\n    } else {\n        end = interval2[1].(int)\n\
    \    }\n    if start > end {\n        return \"NO\"\n    }\n    if isPrime(end\
    \ - start + 1) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpspfvvx5d_test.go:36:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpvaapmjj2_test.go:77: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var start, end int\n    if interval1[0].(int) >\
    \ interval2[0].(int) {\n        start = interval1[0].(int)\n    } else {\n   \
    \     start = interval2[0].(int)\n    }\n    if interval1[1].(int) < interval2[1].(int)\
    \ {\n        end = interval1[1].(int)\n    } else {\n        end = interval2[1].(int)\n\
    \    }\n    if start > end {\n        return \"NO\"\n    }\n    if isPrime(end\
    \ - start + 1) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpspfvvx5d_test.go:36:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start < end {\n        for i := start; i < end; i++ {\n            if\
    \ i % 2 == 0 {\n                return \"NO\"\n            }\n        }\n    \
    \    return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp5kk8bzbw_test.go:77: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmp5kk8bzbw_test.go:77: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmp5kk8bzbw_test.go:77: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp5kk8bzbw_test.go:77: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmp5kk8bzbw_test.go:77: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmp5kk8bzbw_test.go:77: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if end1\
    \ < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    if start1 < start2\
    \ {\n        start1 = start2\n    }\n    if end1 > end2 {\n        end1 = end2\n\
    \    }\n    if end1 - start1 == 1 {\n        return \"YES\"\n    }\n    if end1\
    \ - start1 == 2 {\n        return \"NO\"\n    }\n    for i := 2; i <= end1 - start1;\
    \ i++ {\n        if (end1 - start1) % i == 0 {\n            return \"NO\"\n  \
    \      }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpxwuduyfo_test.go:69: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpxwuduyfo_test.go:69: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n      \
    \  tmpxwuduyfo_test.go:69: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3\
    \ (0.00s)\n        tmpxwuduyfo_test.go:69: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__4 (0.00s)\n        tmpxwuduyfo_test.go:69: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n      \
    \  tmpxwuduyfo_test.go:69: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpxwuduyfo_test.go:69: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    for i := 2; i < end; i++ {\n        if end % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpdt45tj2u_test.go:82: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < start; i++ {\n        if end % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpefxttfpa_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpefxttfpa_test.go:74: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpefxttfpa_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpefxttfpa_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpefxttfpa_test.go:74: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    for i := 2; i < end; i++ {\n        if end % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpdt45tj2u_test.go:82: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start > end {\n        return \"NO\"\n    }\n    if end - start == 1 {\n\
    \        return \"YES\"\n    }\n    if end - start == 2 {\n        return \"NO\"\
    \n    }\n    for i := 2; i < end - start; i++ {\n        if (end - start) % i\
    \ == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpuqzg3d5a_test.go:83: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpuqzg3d5a_test.go:83: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n      \
    \  tmpuqzg3d5a_test.go:83: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3\
    \ (0.00s)\n        tmpuqzg3d5a_test.go:83: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__4 (0.00s)\n        tmpuqzg3d5a_test.go:83: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n      \
    \  tmpuqzg3d5a_test.go:83: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpuqzg3d5a_test.go:83: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if end1 < start2 || end2 < start1\
    \ {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < start; i++ {\n        if start % i == 0 && end % i == 0 {\n\
    \            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp4didayth_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp4didayth_test.go:74: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp4didayth_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp4didayth_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmp4didayth_test.go:74: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var start, end int\n    if interval1[0].(int) >\
    \ interval2[0].(int) {\n        start = interval1[0].(int)\n    } else {\n   \
    \     start = interval2[0].(int)\n    }\n    if interval1[1].(int) < interval2[1].(int)\
    \ {\n        end = interval1[1].(int)\n    } else {\n        end = interval2[1].(int)\n\
    \    }\n    if start > end {\n        return \"NO\"\n    }\n    if isPrime(end\
    \ - start + 1) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpspfvvx5d_test.go:36:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < start; i++ {\n        if start % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    for i := 2; i < end; i++ {\n        if end % i\
    \ == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpane6go9s_test.go:79: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpane6go9s_test.go:79: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpane6go9s_test.go:79: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpane6go9s_test.go:79: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpane6go9s_test.go:79: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if end1 < start2 || end2 < start1\
    \ {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpvj4h_0_j_test.go:77: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpvj4h_0_j_test.go:77: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpvj4h_0_j_test.go:77: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpvj4h_0_j_test.go:77: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if end1 < start2 || end2 < start1\
    \ {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < start; i++ {\n        if start % i == 0 && end % i == 0 {\n\
    \            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp4didayth_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp4didayth_test.go:74: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp4didayth_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp4didayth_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmp4didayth_test.go:74: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if end1 < start2 || end2 < start1\
    \ {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < start; i++ {\n        if start % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    for i := 2; i < end; i++ {\n        if end % i\
    \ == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpvpjprxqk_test.go:79: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpvpjprxqk_test.go:79: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpvpjprxqk_test.go:79: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpvpjprxqk_test.go:79: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpvpjprxqk_test.go:79: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    length := end - start\n    if length < 2 {\n   \
    \     return \"YES\"\n    }\n    for i := 2; i < length; i++ {\n        if length\
    \ % i == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp_m3n95n2_test.go:75: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp_m3n95n2_test.go:75: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp_m3n95n2_test.go:75: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp_m3n95n2_test.go:75: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmp_m3n95n2_test.go:75: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpvaapmjj2_test.go:77: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < start; i++ {\n        if start % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    for i := 2; i < end; i++ {\n        if end % i\
    \ == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpane6go9s_test.go:79: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpane6go9s_test.go:79: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpane6go9s_test.go:79: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpane6go9s_test.go:79: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpane6go9s_test.go:79: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    for i := 2; i < end; i++ {\n        if end % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpdt45tj2u_test.go:82: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 2 {\n        return \"YES\"\n    }\n    if start == 3 {\n   \
    \     return \"YES\"\n    }\n    if start == 5 {\n        return \"YES\"\n   \
    \ }\n    if start == 7 {\n        return \"YES\"\n    }\n    if start == 11 {\n\
    \        return \"YES\"\n    }\n    if start == 13 {\n        return \"YES\"\n\
    \    }\n    if start == 17 {\n        return \"YES\"\n    }\n    if start == 19\
    \ {\n        return \"YES\"\n    }\n    if start == 23 {\n        return \"YES\"\
    \n    }\n    if start == 29 {\n        return \"YES\"\n    }\n    if start ==\
    \ 31 {\n        return \"YES\"\n    }\n    if start == 37 {\n        return \"\
    YES\"\n    }\n    if start == 41 {\n        return \"YES\"\n    }\n    if start\
    \ == 43 {\n        return \"YES\"\n    }\n    if start == 47 {\n        return\
    \ \"YES\"\n    }\n    if start == 53 {\n        return \"YES\"\n    }\n    if\
    \ start == 59 {\n        return \"YES\"\n    }\n    if start == 61 {\n       \
    \ return \"YES\"\n    }\n    if start == 67 {\n        return \"YES\"\n    }\n\
    \    if start == 71 {\n        return \"YES\"\n    }\n   \nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw61d_7oa_test.go:107:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    if start1 <= start2 {\n        if\
    \ end1 <= end2 {\n            return isPrime(start2 - end1)\n        } else {\n\
    \            return isPrime(start2 - end2)\n        }\n    } else {\n        if\
    \ end1 <= end2 {\n            return isPrime(start1 - end1)\n        } else {\n\
    \            return isPrime(start1 - end2)\n        }\n    }\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1s81xmy9_test.go:37:20: undefined: isPrime

    /tmp/tmp1s81xmy9_test.go:39:20: undefined: isPrime

    /tmp/tmp1s81xmy9_test.go:43:20: undefined: isPrime

    /tmp/tmp1s81xmy9_test.go:45:20: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if end1 < start2 || end2 < start1\
    \ {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < start; i++ {\n        if start % i == 0 && end % i == 0 {\n\
    \            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp4didayth_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp4didayth_test.go:74: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp4didayth_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp4didayth_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmp4didayth_test.go:74: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < end; i++ {\n        if end % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpd37kpc15_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpd37kpc15_test.go:74: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpd37kpc15_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpd37kpc15_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpd37kpc15_test.go:74: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    length := end - start\n    if length == 1 {\n        return \"NO\"\n    }\n\
    \    for i := 2; i < length; i++ {\n        if length % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpdjhcfw5q_test.go:78: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__4 (0.00s)\n        tmpdjhcfw5q_test.go:78: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmpdjhcfw5q_test.go:78: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    for i := 2; i < end; i++ {\n        if end % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpdt45tj2u_test.go:82: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var start, end int\n    if interval1[0].(int) >\
    \ interval2[0].(int) {\n        start = interval1[0].(int)\n    } else {\n   \
    \     start = interval2[0].(int)\n    }\n    if interval1[1].(int) < interval2[1].(int)\
    \ {\n        end = interval1[1].(int)\n    } else {\n        end = interval2[1].(int)\n\
    \    }\n    if start > end {\n        return \"NO\"\n    }\n    if isPrime(end\
    \ - start + 1) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpspfvvx5d_test.go:36:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 2 {\n        return \"YES\"\n    }\n    if start == 3 {\n   \
    \     return \"YES\"\n    }\n    if start == 5 {\n        return \"YES\"\n   \
    \ }\n    if start == 7 {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpzmx3ylr__test.go:81: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmpzmx3ylr__test.go:81: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmpzmx3ylr__test.go:81: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpzmx3ylr__test.go:81: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpzmx3ylr__test.go:81: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < start; i++ {\n        if end % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpefxttfpa_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpefxttfpa_test.go:74: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpefxttfpa_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpefxttfpa_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpefxttfpa_test.go:74: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    var start, end int\n    if interval1[0].(int) >\
    \ interval2[0].(int) {\n        start = interval1[0].(int)\n    } else {\n   \
    \     start = interval2[0].(int)\n    }\n    if interval1[1].(int) < interval2[1].(int)\
    \ {\n        end = interval1[1].(int)\n    } else {\n        end = interval2[1].(int)\n\
    \    }\n    if start > end {\n        return \"NO\"\n    }\n    if isPrime(end\
    \ - start + 1) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpspfvvx5d_test.go:36:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < end; i++ {\n        if end % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpd37kpc15_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpd37kpc15_test.go:74: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpd37kpc15_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpd37kpc15_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpd37kpc15_test.go:74: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    for i := 2; i < end; i++ {\n        if end % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpdt45tj2u_test.go:82: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpvaapmjj2_test.go:77: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    for i := 2; i < end; i++ {\n        if end % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpdt45tj2u_test.go:82: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < start; i++ {\n        if start % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    for i := 2; i < end; i++ {\n        if end % i\
    \ == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpane6go9s_test.go:79: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpane6go9s_test.go:79: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpane6go9s_test.go:79: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpane6go9s_test.go:79: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpane6go9s_test.go:79: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 2 || end == 2 {\n        return \"YES\"\n    }\n    if start\
    \ % 2 == 0 || end % 2 == 0 {\n        return \"NO\"\n    }\n    for i := 3; i\
    \ < end; i += 2 {\n        if start % i == 0 || end % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpekgp49qs_test.go:80: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmpekgp49qs_test.go:80: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpekgp49qs_test.go:80: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpekgp49qs_test.go:80: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpekgp49qs_test.go:80: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < start; i++ {\n        if end % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpefxttfpa_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpefxttfpa_test.go:74: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpefxttfpa_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpefxttfpa_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpefxttfpa_test.go:74: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start < start2\
    \ {\n        start = start2\n    }\n    end := end1\n    if end > end2 {\n   \
    \     end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    length := end - start\n    if length == 1 {\n        return \"NO\"\n    }\n\
    \    for i := 2; i < length; i++ {\n        if length % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmphj8hgy0n_test.go:78: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__4 (0.00s)\n        tmphj8hgy0n_test.go:78: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmphj8hgy0n_test.go:78: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    for i := 2; i < end; i++ {\n        if end % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpdt45tj2u_test.go:82: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if isPrime(end - start) {\n        return \"YES\"\n    }\n    return \"NO\"\
    \n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnerxuxez_test.go:46:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    for i := 2; i < end; i++ {\n        if end % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpdt45tj2u_test.go:82: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpdt45tj2u_test.go:82: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpvaapmjj2_test.go:77: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    if start == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if start % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpvaapmjj2_test.go:77: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpvaapmjj2_test.go:77: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if end1 < start2 || end2 < start1\
    \ {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < end; i++ {\n        if start % i == 0 && end % i == 0 {\n\
    \            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpnx17ic2f_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpnx17ic2f_test.go:74: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpnx17ic2f_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpnx17ic2f_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpnx17ic2f_test.go:74: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\nfunc intersection(interval1 []interface{}, interval2\
    \ []interface{}) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp17kacp7k_test.go:46: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp17kacp7k_test.go:46: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp17kacp7k_test.go:46:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp17kacp7k_test.go:46: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075287
