language: go_test.go
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    var err error\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    if f < 0 {\n        f = -f\n\
    \    }\n    if f > float64(int(f)) {\n        result = int(f) + 1\n    } else\
    \ {\n        result = int(f)\n    }\n    if value[0] == '-' {\n        result\
    \ = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp950jh7er_test.go:21:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    f, err = strconv.ParseFloat(value,\
    \ 64)\n    if err != nil {\n        fmt.Println(err)\n    }\n    result = int(f)\n\
    \    if f - float64(result) > 0.5 {\n        result++\n    }\n    return result\n\
    }\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe7rkuxqt_test.go:21:14: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var decimal float64\n    fmt.Sscanf(value, \"%d.%f\", &result,\
    \ &decimal)\n    if decimal >= 0.5 {\n        result++\n    }\n    return result\n\
    }\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmp5whoth60_test.go:44: expected '%!s(int=-16)', got '%!s(int=-14)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp5whoth60_test.go:44:\
    \ expected '%!s(int=15)', got '%!s(int=16)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ Write your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpidxmzr75_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpidxmzr75_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpidxmzr75_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpidxmzr75_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign int\n    if value[0] == '-' {\n        sign = -1\n\
    \    } else {\n        sign = 1\n    }\n    for i := 0; i < len(value); i++ {\n\
    \        if value[i] == '.' {\n            if value[i+1] >= '5' {\n          \
    \      result += 1\n            }\n            break\n        }\n        result\
    \ = result * 10 + int(value[i] - '0')\n    }\n    return result * sign\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpievy70f4_test.go:54: expected '%!s(int=-16)', got '%!s(int=-25316)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f >\
    \ 0 {\n        result = int(f + 0.5)\n    } else {\n        result = int(f - 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ Write your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpidxmzr75_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpidxmzr75_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpidxmzr75_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpidxmzr75_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign float64\n    var number float64\n    var decimal float64\n\
    \    var integer int\n    var decimal_string string\n    var decimal_length int\n\
    \    var decimal_value float64\n    var decimal_value_string string\n    var decimal_value_length\
    \ int\n    var decimal_value_integer int\n    var decimal_value_decimal float64\n\
    \    var decimal_value_decimal_string string\n    var decimal_value_decimal_length\
    \ int\n    var decimal_value_decimal_integer int\n    var decimal_value_decimal_decimal\
    \ float64\n    var decimal_value_decimal_decimal_string string\n    var decimal_value_decimal_decimal_length\
    \ int\n    var decimal_value_decimal_decimal_integer int\n    var decimal_value_decimal_decimal_decimal\
    \ float64\n    var decimal_value_decimal_decimal_decimal_string string\n    var\
    \ decimal_value_decimal_decimal_decimal_length int\n    var decimal_value_decimal_decimal_decimal_integer\
    \ int\n    var decimal_value_decimal_decimal_decimal_decimal float64\n    var\
    \ decimal_value_decimal_decimal_decimal_decimal_string string\n    var decimal_value_decimal_decimal_decimal_decimal_length\
    \ int\n    var decimal_value_decimal_decimal_decimal_decimal_integer int\n   \
    \ var decimal_value_decimal_decimal_decimal_decimal_decimal float64\n    var decimal_value_decimal_decimal_decimal_decimal_decimal_string\
    \ string\n    var decimal_value_decimal_decimal_decimal_decimal_decimal_length\
    \ int\n    var decimal_value_decimal_decimal_decimal_decimal_decimal_integer int\n\
    \    var decimal_value_decimal_decimal_decimal_decimal_decimal_decimal float64\n\
    \    var decimal_value_decimal_decimal_decimal_decimal_decimal_decimal_string\
    \ string\n    var decimal_value_decimal_decimal_decimal_decimal_decimal_decimal_length\
    \ int\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdgyvi2_i_test.go:52:6: expected ''('', found TestClosest_Integer

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ Write your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpidxmzr75_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpidxmzr75_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpidxmzr75_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpidxmzr75_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var float_value float64\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(err)\n\
    \        return 0\n    }\n    result = int(float_value)\n    if float_value -\
    \ float64(result) >= 0.5 {\n        result++\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplrlsrtum_test.go:21:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    fmt.Sscanf(value, \"%f\", &number)\n\
    \    if number < 0 {\n        result = int(number) - 1\n    } else {\n       \
    \ result = int(number) + 1\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmp0yh22f3p_test.go:46: expected '%!s(int=10)', got '%!s(int=11)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp0yh22f3p_test.go:46:\
    \ expected '%!s(int=15)', got '%!s(int=16)'\n    --- FAIL: TestClosest_Integer/test_num__4\
    \ (0.00s)\n        tmp0yh22f3p_test.go:46: expected '%!s(int=0)', got '%!s(int=1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var remainder float64\n    var remainder_abs float64\n    var\
    \ remainder_abs_next float64\n    var remainder_abs_prev float64\n    var remainder_abs_next_int\
    \ int\n    var remainder_abs_prev_int int\n    var remainder_abs_next_int_float\
    \ float64\n    var remainder_abs_prev_int_float float64\n    var remainder_abs_next_int_float_abs\
    \ float64\n    var remainder_abs_prev_int_float_abs float64\n    var remainder_abs_next_int_float_abs_diff\
    \ float64\n    var remainder_abs_prev_int_float_abs_diff float64\n    var remainder_abs_next_int_float_abs_diff_abs\
    \ float64\n    var remainder_abs_prev_int_float_abs_diff_abs float64\n    var\
    \ remainder_abs_next_int_float_abs_diff_abs_min float64\n    var remainder_abs_prev_int_float_abs_diff_abs_min\
    \ float64\n    var remainder_abs_next_int_float_abs_diff_abs_min_int int\n   \
    \ var remainder_abs_prev_int_float_abs_diff_abs_min_int int\n    var remainder_abs_next_int_float_abs_diff_abs_min_int_float\
    \ float64\n    var remainder_abs_prev_int_float_abs_diff_abs_min_int_float float64\n\
    \    var remainder_abs_next_int_float_abs_diff_abs_min_int_float_abs float64\n\
    \    var remainder_abs_prev_int_float_abs_diff_abs_min_int_float_abs float64\n\
    \    var remainder_abs_next_int_float_abs_diff_abs_min_int_float_abs_diff float64\n\
    \    var remainder_abs_prev_int_float_abs_diff_abs_min_int_float_abs_diff float64\n\
    \    var remainder_abs_next_int_float_abs_diff_abs_min_int_float_abs_diff_abs\
    \ float64\n    var remainder_abs_prev_int_float_abs_diff_abs_min_int_float_\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwprxigtx_test.go:44:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    fmt.Sscanf(value, \"%f\", &floatValue)\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ Write your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpidxmzr75_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpidxmzr75_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpidxmzr75_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpidxmzr75_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    if result, err = strconv.Atoi(value); err\
    \ != nil {\n        return 0\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp700wmhdm_test.go:20:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ Write your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpidxmzr75_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpidxmzr75_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpidxmzr75_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpidxmzr75_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ Write your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpidxmzr75_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpidxmzr75_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpidxmzr75_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpidxmzr75_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    var err error\n    if number, err =\
    \ strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n   \
    \ if number < 0 {\n        number = -number\n    }\n    result = int(number)\n\
    \    if number - float64(result) >= 0.5 {\n        result++\n    }\n    if value[0]\
    \ == '-' {\n        result = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp98ycg76b_test.go:21:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkc640a4__test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var remainder float64\n    var sign int\n    var i int\n   \
    \ var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var\
    \ o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t\
    \ int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n\
    \    var z int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n\
    \    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var ii int\n\
    \    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n\
    \    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n\
    \    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n\
    \    var yy int\n    var zz int\n    var aaa int\n    var bbb int\n    var ccc\
    \ int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n  \
    \  var hhh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll\
    \ int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n  \
    \  var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu\
    \ int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n  \
    \  var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var\
    \ dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh\
    \ int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n\
    \    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\nfunc\
    \ TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7z03hjpp_test.go:107:6: expected ''('', found TestClosest_Integer

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkc640a4__test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign int\n    var decimal int\n    var decimal_len int\n\
    \    var decimal_val int\n    var decimal_val_len int\n    var decimal_val_last\
    \ int\n    var decimal_val_last_len int\n    var decimal_val_last_half int\n \
    \   var decimal_val_last_half_len int\n    var decimal_val_last_half_last int\n\
    \    var decimal_val_last_half_last_len int\n    var decimal_val_last_half_last_half\
    \ int\n    var decimal_val_last_half_last_half_len int\n    var decimal_val_last_half_last_half_last\
    \ int\n    var decimal_val_last_half_last_half_last_len int\n    var decimal_val_last_half_last_half_last_half\
    \ int\n    var decimal_val_last_half_last_half_last_half_len int\n    var decimal_val_last_half_last_half_last_half_last\
    \ int\n    var decimal_val_last_half_last_half_last_half_last_len int\n    var\
    \ decimal_val_last_half_last_half_last_half_last_half int\n    var decimal_val_last_half_last_half_last_half_last_half_len\
    \ int\n    var decimal_val_last_half_last_half_last_half_last_half_last int\n\
    \    var decimal_val_last_half_last_half_last_half_last_half_last_len int\n  \
    \  var decimal_val_last_half_last_half_last_half_last_half_last_half int\n   \
    \ var decimal_val_last_half_last_half_last_half_last_half_last_half_len int\n\
    \    var decimal_val_last_half_last_half_last_half_last_half_last_half_last int\n\
    \    var decimal_val_last_half_last_half_last_half_last_half_last_half_last_len\
    \ int\n    var decimal_val_last_half_last_half_last_half_last_half_last_half_last_half\
    \ int\n    var\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0p41x9dt_test.go:48:1: expected ''IDENT'', found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign int\n    if value[0] == '-' {\n        sign = -1\n\
    \    } else {\n        sign = 1\n    }\n    var i int\n    for i = 0; i < len(value);\
    \ i++ {\n        if value[i] == '.' {\n            break\n        }\n    }\n \
    \   var int_part int\n    var float_part float64\n    fmt.Sscanf(value[:i], \"\
    %d\", &int_part)\n    fmt.Sscanf(value[i:], \"%f\", &float_part)\n    if float_part\
    \ >= 0.5 {\n        result = int_part + 1\n    } else {\n        result = int_part\n\
    \    }\n    return result * sign\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmp6xa8nt3p_test.go:60: expected '%!s(int=-16)', got '%!s(int=14)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    var err error\n    if number, err =\
    \ strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n    if\
    \ number < 0 {\n        number = -number\n    }\n    if number - float64(int(number))\
    \ >= 0.5 {\n        result = int(number) + 1\n    } else {\n        result = int(number)\n\
    \    }\n    if value[0] == '-' {\n        result = -result\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfxj6yu51_test.go:21:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var number float64\n    if number, err =\
    \ strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n    if\
    \ number < 0 {\n        result = int(number) - 1\n    } else {\n        result\
    \ = int(number) + 1\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbrtt0tpe_test.go:21:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue) - 1\n    } else {\n\
    \        result = int(floatValue) + 1\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps0_wz_qm_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var decimal float64\n    var integer int\n    var err error\n\
    \    if decimal, err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n\
    \    }\n    integer = int(decimal)\n    if decimal - float64(integer) >= 0.5 {\n\
    \        result = integer + 1\n    } else {\n        result = integer\n    }\n\
    \    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbew9dfke_test.go:22:23: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var i int\n    var f float64\n    var err error\n    if i, err\
    \ = strconv.Atoi(value); err == nil {\n        return i\n    }\n    if f, err\
    \ = strconv.ParseFloat(value, 64); err == nil {\n        if f < 0 {\n        \
    \    f = -f\n        }\n        result = int(f)\n        if f - float64(result)\
    \ >= 0.5 {\n            result++\n        }\n        if value[0] == '-' {\n  \
    \          result = -result\n        }\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzekaduk9_test.go:22:17: undefined: strconv

    /tmp/tmpzekaduk9_test.go:25:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if float_value < 0 {\n        float_value = -float_value\n    }\n    result\
    \ = int(float_value)\n    if float_value - float64(result) >= 0.5 {\n        result++\n\
    \    }\n    if value[0] == '-' {\n        result = -result\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpofzdpdfr_test.go:21:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(err)\n\
    \        return 0\n    }\n    result = int(floatValue)\n    if floatValue - float64(result)\
    \ >= 0.5 {\n        result++\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3zv4oma8_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    if result, err = strconv.Atoi(value); err\
    \ != nil {\n        panic(err)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe4cnk7um_test.go:20:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        return 0\n    }\n    if f < 0 {\n        f = -f\n\
    \    }\n    if f - float64(int(f)) < 0.5 {\n        result = int(f)\n    } else\
    \ {\n        result = int(f) + 1\n    }\n    if value[0] == '-' {\n        result\
    \ = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbzgso83s_test.go:21:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue) - 1\n    } else {\n\
    \        result = int(floatValue) + 1\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps0_wz_qm_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    fmt.Sscanf(value, \"%f\", &number)\n\
    \    if number < 0 {\n        result = int(number - 0.5)\n    } else {\n     \
    \   result = int(number + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ int_value int\n    var float_value float64\n    var err error\n    if int_value,\
    \ err = strconv.Atoi(value); err != nil {\n        if float_value, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n            return 0\n        }\n    }\n    if int_value\
    \ == float_value {\n        return int_value\n    }\n    if float_value > 0 {\n\
    \        return int(float_value + 0.5)\n    }\n    return int(float_value - 0.5)\n\
    }\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1wfmpffy_test.go:21:25: undefined: strconv

    /tmp/tmp1wfmpffy_test.go:22:31: undefined: strconv

    /tmp/tmp1wfmpffy_test.go:26:21: invalid operation: int_value == float_value (mismatched
    types int and float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgkxwu6ao_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var i int\n    var j int\n    var k int\n    var l int\n   \
    \ var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var\
    \ r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w\
    \ int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var bb\
    \ int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var\
    \ gg int\n    var hh int\n    var ii int\n    var jj int\n    var kk int\n   \
    \ var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n\
    \    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n\
    \    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n\
    \    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee\
    \ int\n    var fff int\n    var ggg int\n    var hhh int\n    var iii int\n  \
    \  var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn\
    \ int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n  \
    \  var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www\
    \ int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n \
    \   var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var\
    \ ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj\
    \ int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n\
    \    var oooo int\n    var pppp int\n    var qqqq int\n    var r\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4yp8r4l_test.go:106:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var value_float float64\n    var value_int int\n    var value_int_next\
    \ int\n    var value_float_next float64\n    var value_float_prev float64\n  \
    \  var value_int_prev int\n    var value_float_next_diff float64\n    var value_float_prev_diff\
    \ float64\n\n    fmt.Sscanf(value, \"%f\", &value_float)\n    value_int = int(value_float)\n\
    \    value_int_next = value_int + 1\n    value_int_prev = value_int - 1\n    value_float_next\
    \ = float64(value_int_next)\n    value_float_prev = float64(value_int_prev)\n\
    \    value_float_next_diff = value_float_next - value_float\n    value_float_prev_diff\
    \ = value_float - value_float_prev\n\n    if value_float_next_diff > value_float_prev_diff\
    \ {\n        result = value_int_prev\n    } else {\n        result = value_int_next\n\
    \    }\n\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n \
    \ candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmp8ck6dmu5_test.go:63: expected '%!s(int=10)', got '%!s(int=11)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp8ck6dmu5_test.go:63:\
    \ expected '%!s(int=15)', got '%!s(int=16)'\n    --- FAIL: TestClosest_Integer/test_num__4\
    \ (0.00s)\n        tmp8ck6dmu5_test.go:63: expected '%!s(int=0)', got '%!s(int=1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgkxwu6ao_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    f, err = strconv.ParseFloat(value,\
    \ 64)\n    if err != nil {\n        fmt.Println(err)\n    }\n    result = int(f)\n\
    \    if f - float64(result) >= 0.5 {\n        result++\n    }\n    return result\n\
    }\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppti59r1h_test.go:21:14: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ Write your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpidxmzr75_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpidxmzr75_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpidxmzr75_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpidxmzr75_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    result = int(f)\n    if f\
    \ - float64(result) >= 0.5 {\n        result++\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnthxx1u1_test.go:21:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue > 0 {\n        result = int(floatValue + 0.5)\n    } else {\n\
    \        result = int(floatValue - 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpszapmaoe_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    if f < 0 {\n        f = -f\n\
    \    }\n    if f - float64(int(f)) >= 0.5 {\n        result = int(f) + 1\n   \
    \ } else {\n        result = int(f)\n    }\n    if value[0] == '-' {\n       \
    \ result = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsd_r5q05_test.go:21:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    result = int(f)\n    if f\
    \ - float64(result) >= 0.5 {\n        result++\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnthxx1u1_test.go:21:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var value_float float64\n    var value_int int\n    var value_int_plus_one\
    \ int\n    var value_int_minus_one int\n    var value_int_plus_one_diff float64\n\
    \    var value_int_minus_one_diff float64\n\n    fmt.Sscanf(value, \"%f\", &value_float)\n\
    \    value_int = int(value_float)\n    value_int_plus_one = value_int + 1\n  \
    \  value_int_minus_one = value_int - 1\n    value_int_plus_one_diff = value_float\
    \ - float64(value_int_plus_one)\n    value_int_minus_one_diff = float64(value_int_minus_one)\
    \ - value_float\n\n    if value_int_plus_one_diff < 0 {\n        value_int_plus_one_diff\
    \ = value_int_plus_one_diff * -1\n    }\n    if value_int_minus_one_diff < 0 {\n\
    \        value_int_minus_one_diff = value_int_minus_one_diff * -1\n    }\n\n \
    \   if value_int_plus_one_diff < value_int_minus_one_diff {\n        result =\
    \ value_int_plus_one\n    } else {\n        result = value_int_minus_one\n   \
    \ }\n\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpkj7synp7_test.go:66: expected '%!s(int=10)', got '%!s(int=9)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpkj7synp7_test.go:66:\
    \ expected '%!s(int=15)', got '%!s(int=16)'\n    --- FAIL: TestClosest_Integer/test_num__4\
    \ (0.00s)\n        tmpkj7synp7_test.go:66: expected '%!s(int=0)', got '%!s(int=-1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var num float64\n    num, err = strconv.ParseFloat(value,\
    \ 64)\n    if err != nil {\n        fmt.Println(err)\n    }\n    if num < 0 {\n\
    \        result = int(num - 0.5)\n    } else {\n        result = int(num + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkzdd1lvs_test.go:21:16: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    var err error\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        return result\n    }\n    result = int(f)\n    if\
    \ f - float64(result) >= 0.5 {\n        result++\n    }\n    return result\n}\n\
    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjcpnot0t_test.go:21:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var is_negative bool\n    var is_decimal bool\n    var decimal_value\
    \ float64\n    var decimal_value_int int\n    var decimal_value_int_abs int\n\
    \    var decimal_value_int_abs_2 int\n    var decimal_value_int_abs_2_abs int\n\
    \    var decimal_value_int_abs_2_abs_2 int\n    var decimal_value_int_abs_2_abs_2_abs\
    \ int\n    var decimal_value_int_abs_2_abs_2_abs_2 int\n    var decimal_value_int_abs_2_abs_2_abs_2_abs\
    \ int\n    var decimal_value_int_abs_2_abs_2_abs_2_abs_2 int\n    var decimal_value_int_abs_2_abs_2_abs_2_abs_2_abs\
    \ int\n    var decimal_value_int_abs_2_abs_2_abs_2_abs_2_abs_2 int\n    var decimal_value_int_abs_2_abs_2_abs_2_abs_2_abs_2_abs\
    \ int\n    var decimal_value_int_abs_2_abs_2_abs_2_abs_2_abs_2_abs_2 int\n   \
    \ var decimal_value_int_abs_2_abs_2_abs_2_abs_2_abs_2_abs_2_abs int\n    var decimal_value_int_abs_2_abs_2_abs_2_abs_2_abs_2_abs_2_abs_2\
    \ int\n    var decimal_value_int_abs_2_abs_2_abs_2_abs_2_abs_2_abs_2_abs_2_abs\
    \ int\n    var decimal_value_int_abs_2_abs_2_abs_2_abs_2_abs_2_abs_2_abs_2_abs_2\
    \ int\n    var decimal_value_int_abs_2_abs_2_abs_2_abs_2_abs_2_abs_2_abs_2_abs_2_abs\
    \ int\n    var decimal_value_int_abs_2_abs_2\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb_5m3vtz_test.go:40:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var floatValue float64\n    floatValue, err\
    \ = strconv.ParseFloat(value, 64)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    }\
    \ else {\n        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\
    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo7fvsipx_test.go:21:23: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkc640a4__test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var i int\n    var j int\n    var k int\n    var l int\n   \
    \ var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var\
    \ r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w\
    \ int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var bb\
    \ int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var\
    \ gg int\n    var hh int\n    var ii int\n    var jj int\n    var kk int\n   \
    \ var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n\
    \    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n\
    \    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n\
    \    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee\
    \ int\n    var fff int\n    var ggg int\n    var hhh int\n    var iii int\n  \
    \  var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn\
    \ int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n  \
    \  var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www\
    \ int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n \
    \   var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var\
    \ ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj\
    \ int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n\
    \    var oooo int\n    var pppp int\n    var qqqq int\n    var r\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4yp8r4l_test.go:106:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ num float64\n    fmt.Sscanf(value, \"%f\", &num)\n    return int(num + 0.5)\n\
    }\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmp31m5md7o_test.go:40: expected '%!s(int=-16)', got '%!s(int=-15)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var remainder float64\n    var sign int\n\n    if value[0] ==\
    \ '-' {\n        sign = -1\n    } else {\n        sign = 1\n    }\n\n    fmt.Sscanf(value,\
    \ \"%d.%f\", &result, &remainder)\n\n    if remainder >= 0.5 {\n        result\
    \ += 1\n    }\n\n    return result * sign\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpfjc65cbd_test.go:54: expected '%!s(int=-16)', got '%!s(int=14)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpfjc65cbd_test.go:54:\
    \ expected '%!s(int=15)', got '%!s(int=16)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var value_float float64\n    var value_int int\n    var value_decimal\
    \ float64\n    var value_decimal_abs float64\n    var value_decimal_abs_int int\n\
    \    var value_decimal_abs_int_float float64\n    var value_decimal_abs_int_float_abs\
    \ float64\n    var value_decimal_abs_int_float_abs_int int\n    var value_decimal_abs_int_float_abs_int_float\
    \ float64\n    var value_decimal_abs_int_float_abs_int_float_abs float64\n   \
    \ var value_decimal_abs_int_float_abs_int_float_abs_int int\n    var value_decimal_abs_int_float_abs_int_float_abs_int_float\
    \ float64\n    var value_decimal_abs_int_float_abs_int_float_abs_int_float_abs\
    \ float64\n    var value_decimal_abs_int_float_abs_int_float_abs_int_float_abs_int\
    \ int\n    var value_decimal_abs_int_float_abs_int_float_abs_int_float_abs_int_float\
    \ float64\n    var value_decimal_abs_int_float_abs_int_float_abs_int_float_abs_int_float_abs\
    \ float64\n    var value_decimal_abs_int_float_abs_int_float_abs_int_float_abs_int_float_abs_int\
    \ int\n    var value_decimal_abs_int_float_abs_int_float_abs_int_float_abs_int_float_abs_int_float\
    \ float64\n    var value_decimal_abs_int_float_abs_int_float_abs_int_float_abs_int_float_abs_int_float_abs\
    \ float64\n    var value_decimal_abs_int_float_abs_int_float_abs_int_float_abs_int_float_abs_int_float_abs_int\
    \ int\n    var value_decimal_abs_int_float_abs_int_float_abs_int_float_abs_int_\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2t3jacv0_test.go:39:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign int\n    if value[0] == '-' {\n        sign = -1\n\
    \    } else {\n        sign = 1\n    }\n    var decimal_part float64\n    var\
    \ integer_part int\n    fmt.Sscanf(value, \"%d.%f\", &integer_part, &decimal_part)\n\
    \    if decimal_part < 0.5 {\n        result = integer_part\n    } else {\n  \
    \      result = integer_part + 1\n    }\n    return result * sign\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmp493hdg20_test.go:53: expected '%!s(int=-16)', got '%!s(int=14)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp493hdg20_test.go:53:\
    \ expected '%!s(int=15)', got '%!s(int=16)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075224
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var decimal float64\n    fmt.Sscanf(value, \"%d.%f\", &result,\
    \ &decimal)\n    if decimal >= 0.5 {\n        result += 1\n    }\n    return result\n\
    }\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmp_divhjda_test.go:44: expected '%!s(int=-16)', got '%!s(int=-14)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp_divhjda_test.go:44:\
    \ expected '%!s(int=15)', got '%!s(int=16)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075224
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign int\n    var decimal int\n    var decimal_length int\n\
    \    var decimal_value int\n    var decimal_value_length int\n    var decimal_value_length_half\
    \ int\n    var decimal_value_length_half_rounded int\n    var decimal_value_length_half_rounded_length\
    \ int\n    var decimal_value_length_half_rounded_length_half int\n    var decimal_value_length_half_rounded_length_half_rounded\
    \ int\n    var decimal_value_length_half_rounded_length_half_rounded_length int\n\
    \    var decimal_value_length_half_rounded_length_half_rounded_length_half int\n\
    \    var decimal_value_length_half_rounded_length_half_rounded_length_half_rounded\
    \ int\n    var decimal_value_length_half_rounded_length_half_rounded_length_half_rounded_length\
    \ int\n    var decimal_value_length_half_rounded_length_half_rounded_length_half_rounded_length_half\
    \ int\n    var decimal_value_length_half_rounded_length_half_rounded_length_half_rounded_length_half_rounded\
    \ int\n    var decimal_value_length_half_rounded_length_half_rounded_length_half_rounded_length_half_rounded_length\
    \ int\n    var decimal_value_length_half_rounded_length_half_rounded_length_half_rounded_length_half_rounded_length_half\
    \ int\n    var decimal_value_length_half_rounded_length_half_rounded_length_half_rounded_length_half_rounded_length_half_rounded\
    \ int\n    var decimal_value_length_half_rounded_length_half_rounded_length_half_rounded_length_half_rounded_length_half_rounded_length\
    \ int\n    var decimal_value_length_half_rounded_length_half_rounded_length_half_rounded_length_half_rounded_length_half_rounded_length_half\
    \ int\n    var decimal_value_length_half_rounded_length_half_rounded_length_half_rounded_length_half_rounded_length_half_rounded_length_half_rounded\
    \ int\n    var decimal_value_length_half_rounded_length_\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoj2g_3_k_test.go:41:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkc640a4__test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    result = int(f)\n    if f\
    \ - float64(result) >= 0.5 {\n        result++\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnthxx1u1_test.go:21:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue) - 1\n    } else {\n\
    \        result = int(floatValue) + 1\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps0_wz_qm_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkc640a4__test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    fmt.Sscanf(value, \"%f\", &number)\n\
    \    if number > 0 {\n        result = int(number + 0.5)\n    } else {\n     \
    \   result = int(number - 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075224
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkc640a4__test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    fmt.Sscanf(value, \"%f\", &number)\n\
    \    if number > 0 {\n        result = int(number + 0.5)\n    } else {\n     \
    \   result = int(number - 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075224
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if floatValue > 0 {\n        result = int(floatValue + 0.5)\n    } else {\n\
    \        result = int(floatValue - 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5h3vhr57_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result float64\n    fmt.Sscanf(value, \"%f\", &result)\n    if result < 0 {\n\
    \        result -= 0.5\n    } else {\n        result += 0.5\n    }\n    return\
    \ int(result)\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075225
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var i float64\n    var j float64\n    var k float64\n    var\
    \ l float64\n    var m float64\n    var n float64\n    var o float64\n    var\
    \ p float64\n    var q float64\n    var r float64\n    var s float64\n    var\
    \ t float64\n    var u float64\n    var v float64\n    var w float64\n    var\
    \ x float64\n    var y float64\n    var z float64\n    fmt.Sscanf(value, \"%f\"\
    , &i)\n    j = i - float64(int(i))\n    k = float64(int(i))\n    l = k + 1\n \
    \   m = k - 1\n    n = l - i\n    o = i - k\n    p = i - m\n    q = n - o\n  \
    \  r = o - p\n    s = q + r\n    t = s / 2\n    u = i - t\n    v = u - float64(int(u))\n\
    \    w = float64(int(u))\n    x = w + 1\n    y = w - 1\n    z = x - u\n    if\
    \ v == 0 {\n        result = int(u)\n    } else if v > 0 {\n        result = int(x)\n\
    \    } else if v < 0 {\n        result = int(y)\n    }\n    return result\n}\n\
    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphrylfm_n_test.go:20:9: j declared but not used

    /tmp/tmphrylfm_n_test.go:36:9: z declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075224
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkc640a4__test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var floatValue float64\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        floatValue = -floatValue\n    }\n    if floatValue\
    \ - float64(int(floatValue)) < 0.5 {\n        result = int(floatValue)\n    }\
    \ else {\n        result = int(floatValue) + 1\n    }\n    if value[0] == '-'\
    \ {\n        result = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjeai2pip_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075224
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var remainder float64\n    var negative bool\n    if value[0]\
    \ == '-' {\n        negative = true\n        value = value[1:]\n    }\n    fmt.Sscanf(value,\
    \ \"%d.%f\", &result, &remainder)\n    if remainder >= 0.5 {\n        result++\n\
    \    }\n    if negative {\n        result = -result\n    }\n    return result\n\
    }\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__3\
    \ (0.00s)\n        tmpf0jp6t7v_test.go:52: expected '%!s(int=15)', got '%!s(int=16)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075225
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgkxwu6ao_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        floatValue = -floatValue\n    }\n    if floatValue\
    \ - float64(int(floatValue)) >= 0.5 {\n        result = int(floatValue) + 1\n\
    \    } else {\n        result = int(floatValue)\n    }\n    if value[0] == '-'\
    \ {\n        result = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvk1kpawz_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075224
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    fmt.Sscanf(value, \"%f\", &number)\n\
    \    if number > 0 {\n        result = int(number + 0.5)\n    } else {\n     \
    \   result = int(number - 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075224
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var floatValue float64\n    floatValue, err\
    \ = strconv.ParseFloat(value, 64)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    }\
    \ else {\n        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\
    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo7fvsipx_test.go:21:23: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue) - 1\n    } else {\n\
    \        result = int(floatValue) + 1\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps0_wz_qm_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign int\n    var decimal int\n    var decimal_length int\n\
    \    var decimal_value int\n    var decimal_value_length int\n    var decimal_value_last_digit\
    \ int\n    var decimal_value_last_digit_int int\n    var decimal_value_last_digit_int_length\
    \ int\n    var decimal_value_last_digit_int_last_digit int\n    var decimal_value_last_digit_int_last_digit_int\
    \ int\n    var decimal_value_last_digit_int_last_digit_int_length int\n    var\
    \ decimal_value_last_digit_int_last_digit_int_last_digit int\n    var decimal_value_last_digit_int_last_digit_int_last_digit_int\
    \ int\n    var decimal_value_last_digit_int_last_digit_int_last_digit_int_length\
    \ int\n    var decimal_value_last_digit_int_last_digit_int_last_digit_int_last_digit\
    \ int\n    var decimal_value_last_digit_int_last_digit_int_last_digit_int_last_digit_int\
    \ int\n    var decimal_value_last_digit_int_last_digit_int_last_digit_int_last_digit_int_length\
    \ int\n    var decimal_value_last_digit_int_last_digit_int_last_digit_int_last_digit_int_last_digit\
    \ int\n    var decimal_value_last_digit_int_last_digit_int_last_digit_int_last_digit_int_last_digit_int\
    \ int\n    var decimal_value_last_digit_int_last_digit_int_last_digit_int_last_digit_int_last_digit_int_length\
    \ int\n    var decimal_value_last_digit_int_last_digit_int_last_digit_int_last_digit_int_last_digit_int_last_digit\
    \ int\n    var decimal_value_last_digit_int_last_digit_int_last_digit_int_last_digit_int_last_digit_int_last_digit_int\
    \ int\n    var decimal_value_last_digit_int_last_\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu0c6o8qe_test.go:41:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign int\n    var decimal int\n    var decimal_len int\n\
    \    var decimal_value int\n    var decimal_value_len int\n    var decimal_value_len_half\
    \ int\n    var decimal_value_len_half_int int\n    var decimal_value_len_half_int_str\
    \ string\n    var decimal_value_len_half_int_str_len int\n    var decimal_value_len_half_int_str_len_half\
    \ int\n    var decimal_value_len_half_int_str_len_half_int int\n    var decimal_value_len_half_int_str_len_half_int_str\
    \ string\n    var decimal_value_len_half_int_str_len_half_int_str_len int\n  \
    \  var decimal_value_len_half_int_str_len_half_int_str_len_half int\n    var decimal_value_len_half_int_str_len_half_int_str_len_half_int\
    \ int\n    var decimal_value_len_half_int_str_len_half_int_str_len_half_int_str\
    \ string\n    var decimal_value_len_half_int_str_len_half_int_str_len_half_int_str_len\
    \ int\n    var decimal_value_len_half_int_str_len_half_int_str_len_half_int_str_len_half\
    \ int\n    var decimal_value_len_half_int_str_len_half_int_str_len_half_int_str_len_half_int\
    \ int\n    var decimal_value_len_half_int_str_len_half_int_str_len_half_int_str_len_half_int_str\
    \ string\n    var decimal_value_len_half_int_str_len_half_int_str_len_half_int_str_len_half_int_str_len\
    \ int\n    var decimal_value_len_half_int_str_len_half_int_str_len_half_int_str_len_half_int_str_len_half\
    \ int\n    var decimal_value_len_half_int_str_\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2b4oxjvd_test.go:41:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075224
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if float_value > 0 {\n        result = int(float_value + 0.5)\n    } else\
    \ {\n        result = int(float_value - 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7imuqmyt_test.go:21:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075224
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result float64\n    fmt.Sscanf(value, \"%f\", &result)\n    if result < 0 {\n\
    \        result -= 0.5\n    } else {\n        result += 0.5\n    }\n    return\
    \ int(result)\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075225
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgkxwu6ao_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var i, j int\n    var sign int\n    var is_float bool\n    var\
    \ is_negative bool\n    var is_zero bool\n    var is_integer bool\n    var is_integer_negative\
    \ bool\n    var is_integer_zero bool\n    var is_integer_positive bool\n    var\
    \ is_float_negative bool\n    var is_float_zero bool\n    var is_float_positive\
    \ bool\n    var integer_value string\n    var float_value string\n    var integer_value_length\
    \ int\n    var float_value_length int\n    var integer_value_length_diff int\n\
    \    var float_value_length_diff int\n    var integer_value_length_diff_abs int\n\
    \    var float_value_length_diff_abs int\n    var integer_value_length_diff_abs_min\
    \ int\n    var float_value_length_diff_abs_min int\n    var integer_value_length_diff_abs_min_index\
    \ int\n    var float_value_length_diff_abs_min_index int\n    var integer_value_length_diff_abs_min_index_value\
    \ int\n    var float_value_length_diff_abs_min_index_value int\n    var integer_value_length_diff_abs_min_index_value_length\
    \ int\n    var float_value_length_diff_abs_min_index_value_length int\n    var\
    \ integer_value_length_diff_abs_min_index_value_length_diff int\n    var float_value_length_diff_abs_min_index_value_length_diff\
    \ int\n    var integer_value_length_diff_abs_min_index_value_length_diff_abs int\n\
    \    var float_value_length_diff_abs_min_index_value_length_diff_abs int\n   \
    \ var integer_value_length_diff_abs_min_index_value_length_diff_abs_min int\n\
    \    var float_value_length_diff_abs_min_index_value_length_diff_abs_min int\n\
    \    var integer_value_length_diff_abs_min_index_value_length_diff_abs_min_index\
    \ int\n    var float_value_length_diff\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd19fd5r3_test.go:54:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075224
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result float64\n    fmt.Sscanf(value, \"%f\", &result)\n    return int(result\
    \ + 0.5)\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmp2bj26p63_test.go:40: expected '%!s(int=-16)', got '%!s(int=-15)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075225
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign int\n    var decimal_part float64\n    var integer_part\
    \ int\n    var decimal_part_int int\n    var decimal_part_int_next int\n    var\
    \ decimal_part_int_prev int\n    var decimal_part_int_next_diff float64\n    var\
    \ decimal_part_int_prev_diff float64\n    var decimal_part_int_diff float64\n\
    \    var decimal_part_int_diff_next float64\n    var decimal_part_int_diff_prev\
    \ float64\n    var decimal_part_int_diff_next_diff float64\n    var decimal_part_int_diff_prev_diff\
    \ float64\n    var decimal_part_int_diff_diff float64\n    var decimal_part_int_diff_diff_next\
    \ float64\n    var decimal_part_int_diff_diff_prev float64\n    var decimal_part_int_diff_diff_next_diff\
    \ float64\n    var decimal_part_int_diff_diff_prev_diff float64\n    var decimal_part_int_diff_diff_diff\
    \ float64\n    var decimal_part_int_diff_diff_diff_next float64\n    var decimal_part_int_diff_diff_diff_prev\
    \ float64\n    var decimal_part_int_diff_diff_diff_next_diff float64\n    var\
    \ decimal_part_int_diff_diff_diff_prev_diff float64\n    var decimal_part_int_diff_diff_diff_diff\
    \ float64\n    var decimal_part_int_diff_diff_diff_diff_next float64\n    var\
    \ decimal_part_int_diff_diff_diff_diff_prev float64\n    var decimal_part_int_diff_diff_diff_diff_next_diff\
    \ float64\n    var decimal_part_int_diff_diff_diff_diff_prev_diff float64\n  \
    \  var decimal_part_int_diff_diff_diff_diff_diff float64\n    var decimal_part_int_diff_diff_diff_diff_diff_next\
    \ float64\n    var decimal_part_int_diff_diff_diff_diff_diff_prev float64\n  \
    \  var decimal_part_int_diff_diff_diff_diff\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi6n7adi3_test.go:50:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075224
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    result = int(f)\n    if f\
    \ - float64(result) >= 0.5 {\n        result++\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnthxx1u1_test.go:21:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var number float64\n    number, err = strconv.ParseFloat(value,\
    \ 64)\n    if err != nil {\n        fmt.Println(err)\n    }\n    if number < 0\
    \ {\n        result = int(number - 0.5)\n    } else {\n        result = int(number\
    \ + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppi5oe195_test.go:21:19: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var floatValue float64\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        floatValue = -floatValue\n    }\n    result\
    \ = int(floatValue)\n    if floatValue - float64(result) >= 0.5 {\n        result++\n\
    \    }\n    if value[0] == '-' {\n        result = -result\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph5serbj6_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var number float64\n    if number, err =\
    \ strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(err)\n    \
    \    return 0\n    }\n    if number < 0 {\n        result = int(number - 0.5)\n\
    \    } else {\n        result = int(number + 0.5)\n    }\n    return result\n\
    }\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbw9rqndc_test.go:21:22: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    fmt.Sscanf(value, \"%f\", &float_value)\n\
    \    if float_value < 0 {\n        result = int(float_value - 0.5)\n    } else\
    \ {\n        result = int(float_value + 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075225
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    fmt.Sscanf(value, \"%f\", &floatValue)\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var i int\n    var j int\n    var k int\n    var l int\n   \
    \ var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var\
    \ r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w\
    \ int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var bb\
    \ int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var\
    \ gg int\n    var hh int\n    var ii int\n    var jj int\n    var kk int\n   \
    \ var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n\
    \    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n\
    \    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n\
    \    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee\
    \ int\n    var fff int\n    var ggg int\n    var hhh int\n    var iii int\n  \
    \  var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn\
    \ int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n  \
    \  var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www\
    \ int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n \
    \   var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var\
    \ ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj\
    \ int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n\
    \    var oooo int\n    var pppp int\n    var qqqq int\n    var r\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4yp8r4l_test.go:106:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var i int\n    var j int\n    var k int\n    var l int\n   \
    \ var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var\
    \ r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w\
    \ int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var bb\
    \ int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var\
    \ gg int\n    var hh int\n    var ii int\n    var jj int\n    var kk int\n   \
    \ var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n\
    \    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n\
    \    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n\
    \    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee\
    \ int\n    var fff int\n    var ggg int\n    var hhh int\n    var iii int\n  \
    \  var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn\
    \ int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n  \
    \  var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www\
    \ int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n \
    \   var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var\
    \ ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj\
    \ int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n\
    \    var oooo int\n    var pppp int\n    var qqqq int\n    var r\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4yp8r4l_test.go:106:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign int\n    if value[0] == '-' {\n        sign = -1\n\
    \    } else {\n        sign = 1\n    }\n    var i int\n    for i = 0; i < len(value);\
    \ i++ {\n        if value[i] == '.' {\n            break\n        }\n    }\n \
    \   var int_part int\n    var float_part int\n    var float_part_len int\n   \
    \ if i == len(value) {\n        int_part = sign * atoi(value)\n        return\
    \ int_part\n    } else {\n        int_part = sign * atoi(value[:i])\n        float_part\
    \ = atoi(value[i+1:])\n        float_part_len = len(value[i+1:])\n    }\n    if\
    \ float_part == 0 {\n        return int_part\n    }\n    var tmp int\n    for\
    \ i = 0; i < float_part_len; i++ {\n        tmp = float_part / 10\n        if\
    \ tmp == 0 {\n            break\n        }\n        float_part = tmp\n    }\n\
    \    if i == float_part_len {\n        return int_part\n    }\n    if float_part\
    \ >= 5 {\n        return int_part + sign\n    } else {\n        return int_part\n\
    \    }\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyqdkz1f5_test.go:18:9: result declared but not used

    /tmp/tmpyqdkz1f5_test.go:35:27: undefined: atoi

    /tmp/tmpyqdkz1f5_test.go:38:27: undefined: atoi

    /tmp/tmpyqdkz1f5_test.go:39:22: undefined: atoi

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgkxwu6ao_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var num float64\n    fmt.Sscanf(value, \"%f\", &num)\n    if\
    \ num < 0 {\n        result = int(num - 0.5)\n    } else {\n        result = int(num\
    \ + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075226
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    fmt.Sscanf(value, \"%f\", &number)\n\
    \    if number > 0 {\n        result = int(number + 0.5)\n    } else {\n     \
    \   result = int(number - 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075224
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(err)\n\
    \        return 0\n    }\n    if floatValue < 0 {\n        result = int(floatValue\
    \ - 0.5)\n    } else {\n        result = int(floatValue + 0.5)\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkyjdkddp_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if floatValue < 0 {\n        floatValue = -floatValue\n    }\n    if floatValue\
    \ - float64(int(floatValue)) < 0.5 {\n        result = int(floatValue)\n    }\
    \ else {\n        result = int(floatValue) + 1\n    }\n    if value[0] == '-'\
    \ {\n        result = -result\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgtbyte2f_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var remainder float64\n    var remainder_abs float64\n    var\
    \ remainder_abs_next float64\n    var remainder_abs_prev float64\n    var remainder_abs_next_int\
    \ int\n    var remainder_abs_prev_int int\n    var remainder_abs_next_int_float\
    \ float64\n    var remainder_abs_prev_int_float float64\n    var remainder_abs_next_int_float_abs\
    \ float64\n    var remainder_abs_prev_int_float_abs float64\n    var remainder_abs_next_int_float_abs_diff\
    \ float64\n    var remainder_abs_prev_int_float_abs_diff float64\n    var remainder_abs_next_int_float_abs_diff_abs\
    \ float64\n    var remainder_abs_prev_int_float_abs_diff_abs float64\n    var\
    \ remainder_abs_next_int_float_abs_diff_abs_min float64\n    var remainder_abs_prev_int_float_abs_diff_abs_min\
    \ float64\n    var remainder_abs_next_int_float_abs_diff_abs_min_int int\n   \
    \ var remainder_abs_prev_int_float_abs_diff_abs_min_int int\n    var remainder_abs_next_int_float_abs_diff_abs_min_int_float\
    \ float64\n    var remainder_abs_prev_int_float_abs_diff_abs_min_int_float float64\n\
    \    var remainder_abs_next_int_float_abs_diff_abs_min_int_float_abs float64\n\
    \    var remainder_abs_prev_int_float_abs_diff_abs_min_int_float_abs float64\n\
    \    var remainder_abs_next_int_float_abs_diff_abs_min_int_float_abs_diff float64\n\
    \    var remainder_abs_prev_int_float_abs_diff_abs_min_int_float_abs_diff float64\n\
    \    var remainder_abs_next_int_float_abs_diff_abs_min_int_float_abs_diff_abs\
    \ float64\n    var remainder_abs_prev_int_float_abs_diff_abs_min_int_float_\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwprxigtx_test.go:44:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign int\n    if value[0] == '-' {\n        sign = -1\n\
    \    } else {\n        sign = 1\n    }\n    var v float64\n    fmt.Sscanf(value,\
    \ \"%f\", &v)\n    if v - float64(int(v)) >= 0.5 {\n        result = int(v) +\
    \ 1\n    } else {\n        result = int(v)\n    }\n    return result * sign\n\
    }\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpujrm_dkl_test.go:52: expected '%!s(int=-16)', got '%!s(int=15)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075226
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var f float64\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    result = int(f)\n    if f\
    \ - float64(result) >= 0.5 {\n        result++\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnthxx1u1_test.go:21:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    if value[0] == '-' {\n        result = -1\n    } else {\n  \
    \      result = 1\n    }\n    var i int\n    for i = 0; i < len(value); i++ {\n\
    \        if value[i] == '.' {\n            break\n        }\n    }\n    var integer\
    \ = value[:i]\n    var decimal = value[i+1:]\n    var integer_result int\n   \
    \ var decimal_result int\n    fmt.Sscanf(integer, \"%d\", &integer_result)\n \
    \   fmt.Sscanf(decimal, \"%d\", &decimal_result)\n    if decimal_result >= 5 {\n\
    \        integer_result += result\n    }\n    return integer_result\n}\n\nfunc\
    \ TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [3:2] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [3:2]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x51f020, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x51f020,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.closest_integer({0x529f64?, 0xf?})\n\t/tmp/tmpc1yxj_3i_test.go:31\
    \ +0x227\ncommand-line-arguments_test.TestClosest_Integer(0x0?)\n\t/tmp/tmpc1yxj_3i_test.go:49\
    \ +0x4a\ntesting.tRunner(0xc0001a0340, 0x5352b8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075226
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkc640a4__test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign int\n    if value[0] == '-' {\n        sign = -1\n\
    \    } else {\n        sign = 1\n    }\n    var fractional float64\n    fmt.Sscanf(value,\
    \ \"%d.%f\", &result, &fractional)\n    if fractional >= 0.5 {\n        result\
    \ += 1\n    }\n    return result * sign\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpi4inqjgf_test.go:50: expected '%!s(int=-16)', got '%!s(int=14)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpi4inqjgf_test.go:50:\
    \ expected '%!s(int=15)', got '%!s(int=16)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075226
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    fmt.Sscanf(value, \"%f\", &floatValue)\n\
    \    if floatValue >= 0 {\n        result = int(floatValue + 0.5)\n    } else\
    \ {\n        result = int(floatValue - 0.5)\n    }\n    return result\n}\n\nfunc\
    \ TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075226
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var is_negative bool\n    if value[0] == '-' {\n        is_negative\
    \ = true\n        value = value[1:]\n    }\n    if value[len(value)-1] == '.'\
    \ {\n        value = value[:len(value)-1]\n    }\n    if value[len(value)-1] ==\
    \ '5' {\n        value = value[:len(value)-1]\n        result, _ = strconv.Atoi(value)\n\
    \        if is_negative {\n            result--\n        } else {\n          \
    \  result++\n        }\n    } else {\n        result, _ = strconv.Atoi(value)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpirfkhvs6_test.go:29:21: undefined: strconv

    /tmp/tmpirfkhvs6_test.go:36:21: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgkxwu6ao_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    var err error\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    if f < 0 {\n        result\
    \ = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_vpd_ip1_test.go:21:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    var err error\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    result = int(f)\n    if f\
    \ - float64(result) >= 0.5 {\n        result++\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3b5l5sl1_test.go:21:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if floatValue > 0 {\n        result = int(floatValue + 0.5)\n    } else {\n\
    \        result = int(floatValue - 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5h3vhr57_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    fmt.Sscanf(value, \"%f\", &float_value)\n\
    \    if float_value > 0 {\n        result = int(float_value + 0.5)\n    } else\
    \ {\n        result = int(float_value - 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075227
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if float_value >= 0 {\n        result = int(float_value + 0.5)\n    } else\
    \ {\n        result = int(float_value - 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprcalofmo_test.go:21:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var decimal float64\n    fmt.Sscanf(value, \"%d.%f\", &result,\
    \ &decimal)\n    if decimal >= 0.5 {\n        result++\n    }\n    return result\n\
    }\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmp5whoth60_test.go:44: expected '%!s(int=-16)', got '%!s(int=-14)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp5whoth60_test.go:44:\
    \ expected '%!s(int=15)', got '%!s(int=16)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ Write your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpidxmzr75_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpidxmzr75_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpidxmzr75_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpidxmzr75_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if float_value < 0 {\n        result = int(float_value - 0.5)\n    } else\
    \ {\n        result = int(float_value + 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz8hwhg1m_test.go:21:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    fmt.Sscanf(value, \"%f\", &floatValue)\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue) - 1\n    } else {\n\
    \        result = int(floatValue) + 1\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps0_wz_qm_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign int\n    if value[0] == '-' {\n        sign = -1\n\
    \    } else {\n        sign = 1\n    }\n    var i int\n    for i = 0; i < len(value);\
    \ i++ {\n        if value[i] == '.' {\n            break\n        }\n    }\n \
    \   var left, right int\n    if i == len(value) {\n        left = 0\n        right\
    \ = 0\n    } else {\n        left = i\n        right = len(value) - i - 1\n  \
    \  }\n    var num int\n    for i = 0; i < left; i++ {\n        num = num * 10\
    \ + int(value[i] - '0')\n    }\n    var tmp int\n    for i = left + 1; i < len(value);\
    \ i++ {\n        tmp = tmp * 10 + int(value[i] - '0')\n    }\n    if tmp >= 5\
    \ {\n        num += 1\n    }\n    result = num * sign\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqj2p3s_0_test.go:31:15: right declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpq449xk04_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpq449xk04_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    fmt.Sscanf(value, \"%f\", &float_value)\n\
    \    if float_value < 0 {\n        float_value = float_value - 0.5\n    } else\
    \ {\n        float_value = float_value + 0.5\n    }\n    result = int(float_value)\n\
    \    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075227
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    var err error\n    if f, err = strconv.ParseFloat(value,\
    \ 64); err != nil {\n        panic(err)\n    }\n    if f < 0 {\n        result\
    \ = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_vpd_ip1_test.go:21:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign int\n    if value[0] == '-' {\n        sign = -1\n\
    \    } else {\n        sign = 1\n    }\n    var i int\n    for i = 0; i < len(value);\
    \ i++ {\n        if value[i] == '.' {\n            break\n        }\n    }\n \
    \   var integer_part int\n    var decimal_part int\n    var decimal_part_len int\n\
    \    if i == len(value) {\n        fmt.Sscanf(value, \"%d\", &integer_part)\n\
    \    } else {\n        fmt.Sscanf(value[:i], \"%d\", &integer_part)\n        fmt.Sscanf(value[i+1:],\
    \ \"%d\", &decimal_part)\n        decimal_part_len = len(value) - i - 1\n    }\n\
    \    if decimal_part == 0 {\n        result = integer_part\n    } else {\n   \
    \     var decimal_part_int int\n        var decimal_part_int_len int\n       \
    \ var decimal_part_int_len_half int\n        var decimal_part_int_len_half_1 int\n\
    \        var decimal_part_int_len_half_2 int\n        var decimal_part_int_len_half_3\
    \ int\n        var decimal_part_int_len_half_4 int\n        var decimal_part_int_len_half_5\
    \ int\n        var decimal_part_int_len_half_6 int\n        var decimal_part_int_len_half_7\
    \ int\n        var decimal_part_int_len_half_8 int\n        var decimal_part_int_len_half_9\
    \ int\n        var decimal_part_int_len_half_10 int\n        var decimal_part_int_len_half_11\
    \ int\n        var decimal_part_int_len_half_12 int\n        var decimal_part_int_len_half_13\
    \ int\n        var decimal_part_int_len_half_14 int\n        var decimal_part_int_len_half_15\
    \ int\n        var decimal_part_int_len_half_16 int\n        var decimal_part_int_len_half_17\
    \ int\n       \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv2clxp2a_test.go:65:6: expected ''('', found TestClosest_Integer

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    fmt.Sscanf(value, \"%f\", &floatValue)\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var i float64\n    fmt.Sscanf(value, \"%f\", &i)\n    if i <\
    \ 0 {\n        result = int(i - 0.5)\n    } else {\n        result = int(i + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075227
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkc640a4__test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    fmt.Sscanf(value, \"%f\", &floatValue)\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkc640a4__test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    fmt.Sscanf(value, \"%f\", &float_value)\n\
    \    if float_value < 0 {\n        result = int(float_value - 0.5)\n    } else\
    \ {\n        result = int(float_value + 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075225
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign int\n    var decimal int\n    var decimal_len int\n\
    \    var decimal_value int\n    var decimal_value_len int\n    var decimal_value_len_half\
    \ int\n    var decimal_value_len_half_plus_one int\n    var decimal_value_half\
    \ int\n    var decimal_value_half_plus_one int\n    var decimal_value_half_plus_two\
    \ int\n    var decimal_value_half_plus_three int\n    var decimal_value_half_plus_four\
    \ int\n    var decimal_value_half_plus_five int\n    var decimal_value_half_plus_six\
    \ int\n    var decimal_value_half_plus_seven int\n    var decimal_value_half_plus_eight\
    \ int\n    var decimal_value_half_plus_nine int\n    var decimal_value_half_plus_ten\
    \ int\n    var decimal_value_half_plus_eleven int\n    var decimal_value_half_plus_twelve\
    \ int\n    var decimal_value_half_plus_thirteen int\n    var decimal_value_half_plus_fourteen\
    \ int\n    var decimal_value_half_plus_fifteen int\n    var decimal_value_half_plus_sixteen\
    \ int\n    var decimal_value_half_plus_seventeen int\n    var decimal_value_half_plus_eighteen\
    \ int\n    var decimal_value_half_plus_nineteen int\n    var decimal_value_half_plus_twenty\
    \ int\n    var decimal_value_half_plus_twenty_one int\n    var decimal_value_half_plus_twenty_two\
    \ int\n    var decimal_value_half_plus_twenty_three int\n    var decimal_value_half_plus_twenty_four\
    \ int\n    var decimal_value_half_plus_twenty_five int\n    var decimal_value_half_plus_twenty_six\
    \ int\n    var decimal_value_half_plus_twenty_seven int\n    var decimal_value_half_plus_twenty_eight\
    \ int\n    var decimal_value_half_plus_twenty_nine int\n    var decimal_value_half_plus_thirty\
    \ int\n    var decimal_value_half_plus\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5a_sj38e_test.go:57:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var sign int\n    var is_negative bool\n    var is_decimal bool\n\
    \    var decimal_part float64\n    var decimal_part_int int\n    var decimal_part_int_next\
    \ int\n    var decimal_part_int_prev int\n    var decimal_part_int_next_diff float64\n\
    \    var decimal_part_int_prev_diff float64\n    var decimal_part_int_diff float64\n\
    \    var decimal_part_int_diff_next float64\n    var decimal_part_int_diff_prev\
    \ float64\n    var decimal_part_int_diff_next_diff float64\n    var decimal_part_int_diff_prev_diff\
    \ float64\n    var decimal_part_int_diff_next_diff_diff float64\n    var decimal_part_int_diff_prev_diff_diff\
    \ float64\n    var decimal_part_int_diff_next_diff_diff_diff float64\n    var\
    \ decimal_part_int_diff_prev_diff_diff_diff float64\n    var decimal_part_int_diff_next_diff_diff_diff_diff\
    \ float64\n    var decimal_part_int_diff_prev_diff_diff_diff_diff float64\n  \
    \  var decimal_part_int_diff_next_diff_diff_diff_diff_diff float64\n    var decimal_part_int_diff_prev_diff_diff_diff_diff_diff\
    \ float64\n    var decimal_part_int_diff_next_diff_diff_diff_diff_diff_diff float64\n\
    \    var decimal_part_int_diff_prev_diff_diff_diff_diff_diff_diff float64\n  \
    \  var decimal_part_int_diff_next_diff_diff_diff_diff_diff_diff_diff float64\n\
    \    var decimal_part_int_diff_prev_diff_diff_diff_diff_diff_diff_diff float64\n\
    \    var decimal_part_int_diff_next_diff_diff_diff_diff_diff_diff_diff_diff float64\n\
    \    var decimal_part_int_diff_prev_diff_diff_diff_diff_diff_diff_diff_diff float64\n\
    \    var decimal_part_int_diff_next\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3c7jijb4_test.go:47:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    fmt.Sscanf(value, \"%f\", &number)\n\
    \    if number < 0 {\n        result = int(number - 0.5)\n    } else {\n     \
    \   result = int(number + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075222
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var floatValue float64\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    result = int(floatValue)\n    if floatValue - float64(result) >= 0.5 {\n\
    \        result++\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzm03rhlx_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075227
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ Write your code here\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T)\
    \ {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpidxmzr75_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpidxmzr75_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpidxmzr75_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpidxmzr75_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 0
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var f float64\n    fmt.Sscanf(value, \"%f\", &f)\n    if f <\
    \ 0 {\n        result = int(f - 0.5)\n    } else {\n        result = int(f + 0.5)\n\
    \    }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    //\
    \ TODO: Implement\n    return 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n\
    \  candidate := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n\
    \     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual: candidate(\"\
    15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected: 0 },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpr6d0y_yp_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpr6d0y_yp_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpr6d0y_yp_test.go:39: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpr6d0y_yp_test.go:39:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075227
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if float_value > 0 {\n        result = int(float_value) + 1\n    } else {\n\
    \        result = int(float_value) - 1\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd_9ew4jk_test.go:21:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075227
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        fmt.Println(err)\n\
    \        return 0\n    }\n    if floatValue < 0 {\n        result = int(floatValue\
    \ - 0.5)\n    } else {\n        result = int(floatValue + 0.5)\n    }\n    return\
    \ result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkyjdkddp_test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var err error\n    var floatValue float64\n    floatValue, err\
    \ = strconv.ParseFloat(value, 64)\n    if err != nil {\n        fmt.Println(err)\n\
    \    }\n    if floatValue > 0 {\n        result = int(floatValue + 0.5)\n    }\
    \ else {\n        result = int(floatValue - 0.5)\n    }\n    return result\n}\n\
    \nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0pozbqt2_test.go:21:23: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075227
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var floatValue float64\n    var err error\n    if floatValue,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if floatValue < 0 {\n        result = int(floatValue - 0.5)\n    } else {\n\
    \        result = int(floatValue + 0.5)\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkc640a4__test.go:21:26: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var i int\n    var j int\n    var k int\n    var l int\n   \
    \ var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var\
    \ r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w\
    \ int\n    var x int\n    var y int\n    var z int\n    fmt.Sscanf(value, \"%d.%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d\"\
    , &i, &j, &k, &l, &m, &n, &o, &p, &q, &r, &s, &t, &u, &v, &w, &x, &y, &z)\n  \
    \  if i == 0 {\n        if j > 4 {\n            result = 1\n        } else {\n\
    \            result = 0\n        }\n    } else {\n        if j > 4 {\n       \
    \     result = i + 1\n        } else {\n            result = i\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate\
    \ := closest_integer\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"10\"), expected:\
    \ 10 },\n     { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpe3ouzwzk_test.go:71: expected '%!s(int=-16)', got '%!s(int=-14)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075227
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    return\
    \ 0\n}\n\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__1 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Integer/test_num__2\
    \ (0.00s)\n        tmpro73qxwr_test.go:38: expected '%!s(int=-16)', got '%!s(int=0)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmpro73qxwr_test.go:38:\
    \ expected '%!s(int=15)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        return 0\n    }\n\
    \    if float_value < 0 {\n        result = int(float_value - 0.5)\n    } else\
    \ {\n        result = int(float_value + 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6adefc7u_test.go:21:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075227
- exit_code: 2
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var float_value float64\n    var err error\n    if float_value,\
    \ err = strconv.ParseFloat(value, 64); err != nil {\n        panic(err)\n    }\n\
    \    if float_value < 0 {\n        result = int(float_value - 0.5)\n    } else\
    \ {\n        result = int(float_value + 0.5)\n    }\n    return result\n}\n\n\
    func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     { actual:\
    \ candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"), expected:\
    \ -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     { actual:\
    \ candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz8hwhg1m_test.go:21:27: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var i int\n    var j int\n    var k int\n    var l int\n   \
    \ var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var\
    \ r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w\
    \ int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var ab\
    \ int\n    var ac int\n    var ad int\n    var ae int\n    var af int\n    var\
    \ ag int\n    var ah int\n    var ai int\n    var aj int\n    var ak int\n   \
    \ var al int\n    var am int\n    var an int\n    var ao int\n    var ap int\n\
    \    var aq int\n    var ar int\n    var as int\n    var at int\n    var au int\n\
    \    var av int\n    var aw int\n    var ax int\n    var ay int\n    var az int\n\
    \    var ba int\n    var bb int\n    var bc int\n    var bd int\n    var be int\n\
    \    var bf int\n    var bg int\n    var bh int\n    var bi int\n    var bj int\n\
    \    var bk int\n    var bl int\n    var bm int\n    var bn int\n    var bo int\n\
    \    var bp int\n    var bq int\n    var br int\n    var bs int\n    var bt int\n\
    \    var bu int\n    var bv int\n    var bw int\n    var bx int\n    var by int\n\
    \    var bz int\n    var ca int\n    var cb int\n    var cc int\n    var cd int\n\
    \    var ce int\n    var cf int\n    var cg int\n    var ch int\n    var ci int\n\
    \    var cj int\n    var ck int\n    var cl int\n    var cm int\n    var cn int\n\
    \    var co int\n    var cp int\n    var cq int\n    var cr int\n    var cs int\n\
    \    var ct int\n    var cu int\n    var cv int\n    var cw int\n    var cx int\n\
    \    var cy\nfunc TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n    \
    \ { actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"\
    -15.5\"), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n\
    \     { actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq704a463_test.go:113:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075227
- exit_code: 1
  program: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Create a function that takes a value (string) representing a number\n\
    // and returns the closest integer to it. If the number is equidistant\n// from\
    \ two integers, round it away from zero.\n// Examples\n// Note:\n// Rounding away\
    \ from zero means that if the given number is equidistant\n// from two integers,\
    \ the one you should return is the one that is the\n// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value string) int {\n    var\
    \ result int\n    var number float64\n    fmt.Sscanf(value, \"%f\", &number)\n\
    \    if number < 0 {\n        result = int(number) - 1\n    } else {\n       \
    \ result = int(number) + 1\n    }\n    return result\n}\n\nfunc TestClosest_Integer(t\
    \ *testing.T) {\n  candidate := closest_integer\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"10\"), expected: 10 },\n     { actual: candidate(\"14.5\"), expected:\
    \ 15 },\n     { actual: candidate(\"-15.5\"), expected: -16 },\n     { actual:\
    \ candidate(\"15.3\"), expected: 15 },\n     { actual: candidate(\"0\"), expected:\
    \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestClosest_Integer (0.00s)\n    --- FAIL: TestClosest_Integer/test_num__0\
    \ (0.00s)\n        tmp0yh22f3p_test.go:46: expected '%!s(int=10)', got '%!s(int=11)'\n\
    \    --- FAIL: TestClosest_Integer/test_num__3 (0.00s)\n        tmp0yh22f3p_test.go:46:\
    \ expected '%!s(int=15)', got '%!s(int=16)'\n    --- FAIL: TestClosest_Integer/test_num__4\
    \ (0.00s)\n        tmp0yh22f3p_test.go:46: expected '%!s(int=0)', got '%!s(int=1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075220
