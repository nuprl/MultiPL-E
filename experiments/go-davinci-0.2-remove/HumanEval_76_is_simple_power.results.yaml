language: go_test.go
name: HumanEval_76_is_simple_power
results:
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i < x; i++ {\n \
    \       if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3qmla96r_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i < x; i++ {\n \
    \       if i == x {\n            return true\n        }\n        if i*i > x {\n\
    \            return false\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmp8o4esxsl_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmp8o4esxsl_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmp8o4esxsl_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmp8o4esxsl_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n \
    \       if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2hf04ywv_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++ {\n\
    \        if i * i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i < x; i++ {\n \
    \       if x == n * n {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmph4699rpl_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n \
    \       if n * n * i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__5\
    \ (0.00s)\n        tmph5zkgqh__test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__6 (0.00s)\n        tmph5zkgqh__test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i < x; i++ {\n \
    \       if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3qmla96r_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++ {\n\
    \        if i * i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i < x; i++ {\n \
    \       if x == n * n {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmph4699rpl_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i <= x; i++ {\n\
    \        if n * n == x {\n            return true\n        }\n        n = n *\
    \ n\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n\
    \  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x < n {\n        return false\n\
    \    }\n    return is_simple_power(x/n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__5\
    \ (0.00s)\n        tmprdulsole_test.go:44: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x == n {\n        return\
    \ true\n    }\n    if x < n {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__5\
    \ (0.00s)\n        tmpktm51d78_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x < n {\n        return false\n\
    \    }\n    return is_simple_power(x/n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__5\
    \ (0.00s)\n        tmprdulsole_test.go:44: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptusha_t__test.go:20:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++ {\n\
    \        if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb5g03q8o_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i < x; i++ {\n \
    \       if x == n * n {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmph4699rpl_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++ {\n\
    \        if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb5g03q8o_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n \
    \       if n * n == x {\n            return true\n        }\n        n = n * n\n\
    \    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptusha_t__test.go:20:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n \
    \       if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2hf04ywv_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i < x; i++ {\n \
    \       if x == n * n {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmph4699rpl_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x%n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x/n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i < x; i++ {\n \
    \       if x == n * n {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmph4699rpl_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    for i := 1; i < x; i++ {\n        if n**i == x {\n            return true\n\
    \        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpseplme_6_test.go:14:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 1; i <= x; i++ {\n        if n ** i == x {\n    \
    \        return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzml28lp8_test.go:20:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++ {\n\
    \        if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb5g03q8o_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x == n {\n        return\
    \ true\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i < x; i++ {\n \
    \       if x == n*n {\n            return true\n        }\n        n = n*n\n \
    \   }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 0 {\n        return false\n    }\n    if x == 1 {\n        return\
    \ true\n    }\n    for i := 1; i < x; i++ {\n        if n*n == x {\n         \
    \   return true\n        }\n        n *= n\n    }\n    return false\n}\n\nfunc\
    \ TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return x == 1\n    }\n    for i := 1; i < x; i++ {\n\
    \        if n * n == x {\n            return true\n        }\n        n *= n\n\
    \    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmp14izqz4m_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n \
    \       if n * n == x {\n            return true\n        }\n        n *= n\n\
    \    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.007s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x < n {\n        return false\n\
    \    }\n    for x % n == 0 {\n        x /= n\n    }\n    return x == 1\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == n {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmph2idqvn1_test.go:44: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n \
    \       if n * n == x {\n            return true\n        }\n        n *= n\n\
    \    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.007s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n \
    \       if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2hf04ywv_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    for i := 1; i < x; i++ {\n        if n * n * i == x {\n            return\
    \ true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__5\
    \ (0.00s)\n        tmptz1c21fd_test.go:43: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__6 (0.00s)\n        tmptz1c21fd_test.go:43:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmptz1c21fd_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmptz1c21fd_test.go:43:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 0 {\n        return false\n    }\n    if x == 1 {\n        return\
    \ true\n    }\n    if x == n {\n        return true\n    }\n    if x % n != 0\
    \ {\n        return false\n    }\n    return is_simple_power(x / n, n)\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 0 {\n        return false\n    }\n    if x == 1 {\n        return\
    \ true\n    }\n    if x == n {\n        return true\n    }\n    if x % n != 0\
    \ {\n        return false\n    }\n    return is_simple_power(x / n, n)\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n\n    for i := 2; i <= x; i++ {\n\
    \        if i * i == x {\n            return true\n        }\n    }\n\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073452
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return x == 1\n    }\n    if x < n {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmpf23xg_iz_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n \
    \       if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2hf04ywv_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x < n {\n        return false\n\
    \    }\n    return is_simple_power(x/n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__5\
    \ (0.00s)\n        tmprdulsole_test.go:44: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    for i := 1; i < x; i++ {\n        if n**i == x {\n            return true\n\
    \        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpseplme_6_test.go:14:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 1; i < x; i++ {\n        if n * n == x {\n      \
    \      return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmpfr9i1w99_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x == n {\n        return\
    \ true\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return x == 1\n    }\n    if x < n {\n        return\
    \ false\n    }\n    if x == n {\n        return true\n    }\n    return is_simple_power(x/n,\
    \ n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmpb5xckmgt_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == n {\n        return true\n    }\n    if x < n {\n        return false\n\
    \    }\n    return is_simple_power(x/n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmptq3xp9lh_test.go:44: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x == n {\n        return\
    \ true\n    }\n    for i := 2; i <= x; i++ {\n        if n * n == x {\n      \
    \      return true\n        }\n        n *= n\n    }\n    return false\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i < x; i++ {\n \
    \       if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3qmla96r_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return x == 1\n    }\n    if x == n {\n        return\
    \ true\n    }\n    if x < n {\n        return false\n    }\n    return is_simple_power(x/n,\
    \ n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmp3teyg99m_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i < x; i++ {\n \
    \       if x == n*n {\n            return true\n        }\n        n *= n\n  \
    \  }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073452
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x == n {\n        return\
    \ true\n    }\n    if x < n {\n        return false\n    }\n    return is_simple_power(x/n,\
    \ n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__5\
    \ (0.00s)\n        tmpj24zr7j2_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n \
    \       if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2hf04ywv_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x < n {\n        return false\n\
    \    }\n    for x % n == 0 {\n        x /= n\n    }\n    return x == 1\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x%n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x/n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n \
    \       if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2hf04ywv_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return x == 1\n    }\n    if x == n {\n        return\
    \ true\n    }\n    if x < n {\n        return false\n    }\n    return is_simple_power(x/n,\
    \ n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmp3teyg99m_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++ {\n\
    \        if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb5g03q8o_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i <= x; i++ {\n\
    \        if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt8asouc6_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 2; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc0qmxeli_test.go:20:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++ {\n\
    \        if n ** i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm02n5kv5_test.go:17:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x < n {\n        return false\n\
    \    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i < x; i++ {\n \
    \       if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3qmla96r_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i < x; i++ {\n \
    \       if x == n*n {\n            return true\n        }\n        n = n*n\n \
    \   }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n \
    \       if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2hf04ywv_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == n {\n        return true\n    }\n    if x < n {\n        return false\n\
    \    }\n    return is_simple_power(x/n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmptq3xp9lh_test.go:44: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++ {\n\
    \        if i == x {\n            return true\n        }\n        if i > x {\n\
    \            return false\n        }\n        i *= n\n    }\n    return false\n\
    }\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpj24v_epn_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpj24v_epn_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpj24v_epn_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpj24v_epn_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x < n {\n        return false\n\
    \    }\n    return is_simple_power(x/n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__5\
    \ (0.00s)\n        tmprdulsole_test.go:44: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i <= x; i++ {\n\
    \        if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt8asouc6_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == n {\n        return true\n    }\n    if x < n {\n        return false\n\
    \    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmp2z2dqj5e_test.go:44: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x < n {\n        return false\n\
    \    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    for i := 1; i <= x; i++ {\n        if n**i == x {\n            return true\n\
    \        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp371kcfm3_test.go:14:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++ {\n\
    \        if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb5g03q8o_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy8zcclnn_test.go:20:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    for i := 1; i < x; i++ {\n        if n**i == x {\n            return true\n\
    \        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpseplme_6_test.go:14:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i < x; i++ {\n \
    \       if n ** i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp81_yrh9w_test.go:17:17: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    for i := 1; i < x; i++ {\n        if n**i == x {\n            return true\n\
    \        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpseplme_6_test.go:14:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++ {\n\
    \        if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb5g03q8o_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 2; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc0qmxeli_test.go:20:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x == n {\n        return\
    \ true\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n \
    \       if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2hf04ywv_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpwrzcyuh1_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpwrzcyuh1_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpwrzcyuh1_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpwrzcyuh1_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmpwrzcyuh1_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    for i := 1; i < x; i++ {\n        if n**i == x {\n            return true\n\
    \        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpseplme_6_test.go:14:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++ {\n\
    \        if i == x {\n            return true\n        }\n        if i * i > x\
    \ {\n            return false\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmp9xjpdotl_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmp9xjpdotl_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmp9xjpdotl_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmp9xjpdotl_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++ {\n\
    \        if x == n*n {\n            return true\n        }\n        n = n*n\n\
    \    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073453
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i <= x; i++ {\n\
    \        if n*n == x {\n            return true\n        }\n        n *= n\n \
    \   }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.006s\n"
  timestamp: 1660073453
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n \
    \       if n*n == x {\n            return true\n        }\n        n *= n\n  \
    \  }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073453
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++ {\n\
    \        if i == x {\n            return true\n        }\n        if i * i > x\
    \ {\n            return false\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmp9xjpdotl_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmp9xjpdotl_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmp9xjpdotl_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmp9xjpdotl_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i < x; i++ {\n \
    \       if x % i == 0 {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmps3ygecr__test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmps3ygecr__test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmps3ygecr__test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmps3ygecr__test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073453
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++ {\n\
    \        if i == x {\n            return true\n        }\n        if i * i > x\
    \ {\n            return false\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmp9xjpdotl_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmp9xjpdotl_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmp9xjpdotl_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmp9xjpdotl_test.go:49:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x == n {\n        return\
    \ true\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++ {\n\
    \        if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb5g03q8o_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    // your code here\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__8\
    \ (0.00s)\n        tmpiydup_xu_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__9 (0.00s)\n        tmpiydup_xu_test.go:39:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    for i := 1; i <= x; i++ {\n        if n**i == x {\n            return true\n\
    \        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp371kcfm3_test.go:14:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x < n {\n        return false\n\
    \    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy8zcclnn_test.go:20:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    for i := 1; i < x; i++ {\n        if n**i == x {\n            return true\n\
    \        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpseplme_6_test.go:14:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x == n {\n        return\
    \ true\n    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    for i := 1; i < x; i++ {\n        if n**i == x {\n            return true\n\
    \        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpseplme_6_test.go:14:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    for i := 1; i < x; i++ {\n        if n**i == x {\n            return true\n\
    \        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpseplme_6_test.go:14:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x < n {\n        return false\n\
    \    }\n    if x % n != 0 {\n        return false\n    }\n    return is_simple_power(x\
    \ / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073452
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == n {\n        return true\n    }\n    if x < n {\n        return false\n\
    \    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmp2z2dqj5e_test.go:44: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return true\n    }\n    for i := 1; i <= x; i++ {\n\
    \        if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcsk9mh1v_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073453
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i < x; i++ {\n \
    \       if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3qmla96r_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 0 {\n        return false\n    }\n    for i := 1; i <= x; i++ {\n\
    \        if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5qr333e4_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073453
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 0 {\n        return false\n    }\n    if x == 1 {\n        return\
    \ true\n    }\n    for i := 1; i < x; i++ {\n        if n*n == x {\n         \
    \   return true\n        }\n        n *= n\n    }\n    return false\n}\n\nfunc\
    \ TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n \
    \       if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2hf04ywv_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n\n    for i := 2; i <= x; i++ {\n\
    \        if i == x {\n            return true\n        }\n        if i > x {\n\
    \            return false\n        }\n        i *= n\n    }\n    return false\n\
    }\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmpuj7i2oiq_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__2 (0.00s)\n        tmpuj7i2oiq_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Simple_Power/test_num__3\
    \ (0.00s)\n        tmpuj7i2oiq_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestIs_Simple_Power/test_num__4 (0.00s)\n        tmpuj7i2oiq_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660073453
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 2; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy8zcclnn_test.go:20:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i <= x; i++ {\n\
    \        if x == n*n {\n            return true\n        }\n        n = n*n\n\
    \    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073453
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n \
    \       if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2hf04ywv_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == n {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmph2idqvn1_test.go:44: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i <= x; i++ {\n\
    \        if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt8asouc6_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x < n {\n        return false\n\
    \    }\n    for x % n == 0 {\n        x /= n\n    }\n    return x == 1\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == n {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmph2idqvn1_test.go:44: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    for i := 1; i <= x; i++ {\n        if n**i == x {\n            return true\n\
    \        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp371kcfm3_test.go:14:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n \
    \       if n * n == x {\n            return true\n        }\n        n *= n\n\
    \    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate\
    \ := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16, 2), expected:\
    \ true },\n     { actual: candidate(143214, 16), expected: false },\n     { actual:\
    \ candidate(4, 2), expected: true },\n     { actual: candidate(9, 3), expected:\
    \ true },\n     { actual: candidate(16, 4), expected: true },\n     { actual:\
    \ candidate(24, 2), expected: false },\n     { actual: candidate(128, 4), expected:\
    \ false },\n     { actual: candidate(12, 6), expected: false },\n     { actual:\
    \ candidate(1, 1), expected: true },\n     { actual: candidate(1, 12), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.007s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return true\n    }\n    if x == n {\n        return\
    \ true\n    }\n    if x < n {\n        return false\n    }\n    return is_simple_power(x/n,\
    \ n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__9\
    \ (0.00s)\n        tmpc_9uz717_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073453
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 1; i <= x; i++ {\n        if n**i == x {\n      \
    \      return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdijoay7c_test.go:20:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073453
- exit_code: 1
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i < x; i++ {\n \
    \       if x == n * n {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIs_Simple_Power (0.00s)\n    --- FAIL: TestIs_Simple_Power/test_num__0\
    \ (0.00s)\n        tmph4699rpl_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x < n {\n        return false\n\
    \    }\n    for x % n == 0 {\n        x /= n\n    }\n    return x == 1\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 0 {\n        return false\n    }\n    if x == 1 {\n        return\
    \ true\n    }\n    if x == n {\n        return true\n    }\n    if x < n {\n \
    \       return false\n    }\n    if x % n != 0 {\n        return false\n    }\n\
    \    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t *testing.T)\
    \ {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(16,\
    \ 2), expected: true },\n     { actual: candidate(143214, 16), expected: false\
    \ },\n     { actual: candidate(4, 2), expected: true },\n     { actual: candidate(9,\
    \ 3), expected: true },\n     { actual: candidate(16, 4), expected: true },\n\
    \     { actual: candidate(24, 2), expected: false },\n     { actual: candidate(128,\
    \ 4), expected: false },\n     { actual: candidate(12, 6), expected: false },\n\
    \     { actual: candidate(1, 1), expected: true },\n     { actual: candidate(1,\
    \ 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073453
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n \
    \       if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2hf04ywv_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 2; i < x; i++ {\n \
    \       if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3qmla96r_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x < n {\n        return false\n\
    \    }\n    for x % n == 0 {\n        x /= n\n    }\n    return x == 1\n}\n\n\
    func TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(16, 2), expected: true },\n     { actual:\
    \ candidate(143214, 16), expected: false },\n     { actual: candidate(4, 2), expected:\
    \ true },\n     { actual: candidate(9, 3), expected: true },\n     { actual: candidate(16,\
    \ 4), expected: true },\n     { actual: candidate(24, 2), expected: false },\n\
    \     { actual: candidate(128, 4), expected: false },\n     { actual: candidate(12,\
    \ 6), expected: false },\n     { actual: candidate(1, 1), expected: true },\n\
    \     { actual: candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073450
- exit_code: 0
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    if x % n != 0 {\n        return\
    \ false\n    }\n    return is_simple_power(x / n, n)\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if n == 1 {\n        return x == 1\n    }\n    if x == 1 {\n        return\
    \ false\n    }\n    for i := 2; i < x; i++ {\n        if n**i == x {\n       \
    \     return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Simple_Power(t\
    \ *testing.T) {\n  candidate := is_simple_power\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(16, 2), expected: true },\n     { actual: candidate(143214, 16), expected:\
    \ false },\n     { actual: candidate(4, 2), expected: true },\n     { actual:\
    \ candidate(9, 3), expected: true },\n     { actual: candidate(16, 4), expected:\
    \ true },\n     { actual: candidate(24, 2), expected: false },\n     { actual:\
    \ candidate(128, 4), expected: false },\n     { actual: candidate(12, 6), expected:\
    \ false },\n     { actual: candidate(1, 1), expected: true },\n     { actual:\
    \ candidate(1, 12), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc0qmxeli_test.go:20:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package is_simple_power_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Your task is to write a function that returns true if a number x is\
    \ a simple\n// power of n and false in other cases.\n// x is a simple power of\
    \ n if n**int=x\n// For example:\nfunc is_simple_power(x int, n int) bool {\n\
    \    if x == 1 {\n        return true\n    }\n    for i := 1; i < x; i++ {\n \
    \       if n**i == x {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestIs_Simple_Power(t *testing.T) {\n  candidate := is_simple_power\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(16, 2), expected: true },\n   \
    \  { actual: candidate(143214, 16), expected: false },\n     { actual: candidate(4,\
    \ 2), expected: true },\n     { actual: candidate(9, 3), expected: true },\n \
    \    { actual: candidate(16, 4), expected: true },\n     { actual: candidate(24,\
    \ 2), expected: false },\n     { actual: candidate(128, 4), expected: false },\n\
    \     { actual: candidate(12, 6), expected: false },\n     { actual: candidate(1,\
    \ 1), expected: true },\n     { actual: candidate(1, 12), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2hf04ywv_test.go:17:15: invalid operation: cannot indirect i (variable
    of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073450
